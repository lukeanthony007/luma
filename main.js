/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/decamelize/index.js
var require_decamelize = __commonJS({
  "node_modules/decamelize/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(str, sep) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      sep = typeof sep === "undefined" ? "_" : sep;
      return str.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
    };
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports, module2) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase2 = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module2.exports = camelCase2;
    module2.exports.default = camelCase2;
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods2) {
      if (options instanceof Array) {
        methods2 = options;
        options = null;
      }
      if (!methods2) {
        methods2 = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods2.push(key);
          }
        }
      }
      for (var i = 0; i < methods2.length; i++) {
        var method = methods2[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/p-retry/index.js
var require_p_retry = __commonJS({
  "node_modules/p-retry/index.js"(exports, module2) {
    "use strict";
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari
      "Network request failed"
      // `cross-fetch`
    ];
    var AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    var pRetry4 = (input, options) => new Promise((resolve, reject) => {
      options = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options
      };
      const operation = retry.operation(options);
      operation.attempt(async (attemptNumber) => {
        try {
          resolve(await input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              await options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      });
    });
    module2.exports = pRetry4;
    module2.exports.default = pRetry4;
    module2.exports.AbortError = AbortError;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter;
    }
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-timeout/index.js"(exports, module2) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise.then(resolve, reject),
        () => {
          clearTimeout(timer);
        }
      );
    });
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError;
  }
});

// node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "node_modules/p-queue/dist/lower-bound.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function lowerBound(array, value, comparator) {
      let first = 0;
      let count = array.length;
      while (count > 0) {
        const step = count / 2 | 0;
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
          first = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first;
    }
    exports.default = lowerBound;
  }
});

// node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/p-queue/dist/priority-queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lower_bound_1 = require_lower_bound();
    var PriorityQueue = class {
      constructor() {
        this._queue = [];
      }
      enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
          priority: options.priority,
          run
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
          this._queue.push(element);
          return;
        }
        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
        this._queue.splice(index, 0, element);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
      }
      get size() {
        return this._queue.length;
      }
    };
    exports.default = PriorityQueue;
  }
});

// node_modules/p-queue/dist/index.js
var require_dist = __commonJS({
  "node_modules/p-queue/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventEmitter = require_eventemitter3();
    var p_timeout_1 = require_p_timeout();
    var priority_queue_1 = require_priority_queue();
    var empty = () => {
    };
    var timeoutError = new p_timeout_1.TimeoutError();
    var PQueue = class extends EventEmitter {
      constructor(options) {
        var _a, _b, _c, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty;
        this._resolveIdle = empty;
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
      }
      /**
      Executes all queued functions until it reaches the limit.
      */
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      /**
      Adds a sync or async task to the queue. Always returns a promise.
      */
      async add(fn, options = {}) {
        return new Promise((resolve, reject) => {
          const run = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
                if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                  reject(timeoutError);
                }
                return void 0;
              });
              resolve(await operation);
            } catch (error) {
              reject(error);
            }
            this._next();
          };
          this._queue.enqueue(run, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      /**
          Same as `.add()`, but accepts an array of sync or async functions.
      
          @returns A promise that resolves when all functions are resolved.
          */
      async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
      }
      /**
      Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
      */
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      /**
      Put queue execution on hold.
      */
      pause() {
        this._isPaused = true;
      }
      /**
      Clear the queue.
      */
      clear() {
        this._queue = new this._queueClass();
      }
      /**
          Can be called multiple times. Useful if you for example add additional items at a later time.
      
          @returns A promise that settles when the queue becomes empty.
          */
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
          The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
      
          @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
          */
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
      Size of the queue.
      */
      get size() {
        return this._queue.size;
      }
      /**
          Size of the queue, filtered by the given options.
      
          For example, this can be used to find the number of items remaining in the queue with a specific priority level.
          */
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      /**
      Number of pending promises.
      */
      get pending() {
        return this._pendingCount;
      }
      /**
      Whether the queue is currently paused.
      */
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      /**
      Set the timeout for future operations.
      */
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    };
    exports.default = PQueue;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module2.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, safeSrc: src, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
            const match = `-${identifier}`.match(r);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module2) {
    var SemVer = require_semver();
    var parse = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module2) {
    var parse = require_parse();
    var valid = (version2, options) => {
      const v = parse(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module2) {
    var parse = require_parse();
    var clean = (version2, options) => {
      const s = parse(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module2) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module2) {
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module2) {
    var parse = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module2) {
    var SemVer = require_semver();
    var compare2 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare2;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module2) {
    var compare2 = require_compare();
    var rcompare = (a, b, loose) => compare2(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module2) {
    var compare2 = require_compare();
    var compareLoose = (a, b) => compare2(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module2) {
    var compare2 = require_compare();
    var gt = (a, b, loose) => compare2(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module2) {
    var compare2 = require_compare();
    var lt = (a, b, loose) => compare2(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module2) {
    var compare2 = require_compare();
    var eq = (a, b, loose) => compare2(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module2) {
    var compare2 = require_compare();
    var neq = (a, b, loose) => compare2(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module2) {
    var compare2 = require_compare();
    var gte = (a, b, loose) => compare2(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module2) {
    var compare2 = require_compare();
    var lte = (a, b, loose) => compare2(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module2) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce2 = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce2;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports, module2) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module2) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache2 = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module2) {
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module2) {
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module2) {
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module2) {
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare2(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce2 = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce: coerce2,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles2 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles2.color.gray = styles2.color.blackBright;
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
      styles2.color.grey = styles2.color.blackBright;
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles2[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles2[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles2, "codes", {
        value: codes,
        enumerable: false
      });
      styles2.color.close = "\x1B[39m";
      styles2.bgColor.close = "\x1B[49m";
      styles2.color.ansi256 = wrapAnsi256();
      styles2.color.ansi16m = wrapAnsi16m();
      styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles2, {
        rgbToAnsi256: {
          value: (red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer = Number.parseInt(colorString, 16);
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles2;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr2[curByte++] = tmp >> 16 & 255;
        arr2[curByte++] = tmp >> 8 & 255;
        arr2[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr2[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr2[curByte++] = tmp >> 8 & 255;
        arr2[curByte++] = tmp & 255;
      }
      return arr2;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/daily-note-synth/run-daily-note-synth.ts
var import_obsidian2 = require("obsidian");

// src/daily-note-synth/utils.ts
function getNotesFromFolder(app, folderPath) {
  const vault = app.vault;
  const allFiles = vault.getMarkdownFiles();
  const files = allFiles.filter((file) => {
    const matches = file.path.startsWith(folderPath + "/");
    return matches;
  });
  if (files.length === 0) {
    console.log(`No notes found in ${folderPath}`);
  }
  return files;
}

// src/daily-note-synth/synthesize-daily-note.ts
var import_obsidian = require("obsidian");

// node_modules/@langchain/core/dist/utils/json.js
function parseJsonMarkdown(s, parser = parsePartialJson) {
  s = s.trim();
  const firstFenceIndex = s.indexOf("```");
  if (firstFenceIndex === -1) {
    return parser(s);
  }
  let contentAfterFence = s.substring(firstFenceIndex + 3);
  if (contentAfterFence.startsWith("json\n")) {
    contentAfterFence = contentAfterFence.substring(5);
  } else if (contentAfterFence.startsWith("json")) {
    contentAfterFence = contentAfterFence.substring(4);
  } else if (contentAfterFence.startsWith("\n")) {
    contentAfterFence = contentAfterFence.substring(1);
  }
  const closingFenceIndex = contentAfterFence.indexOf("```");
  let finalContent = contentAfterFence;
  if (closingFenceIndex !== -1) {
    finalContent = contentAfterFence.substring(0, closingFenceIndex);
  }
  return parser(finalContent.trim());
}
function parsePartialJson(s) {
  if (typeof s === "undefined") {
    return null;
  }
  try {
    return JSON.parse(s);
  } catch (error) {
  }
  let new_s = "";
  const stack = [];
  let isInsideString = false;
  let escaped = false;
  for (let char of s) {
    if (isInsideString) {
      if (char === '"' && !escaped) {
        isInsideString = false;
      } else if (char === "\n" && !escaped) {
        char = "\\n";
      } else if (char === "\\") {
        escaped = !escaped;
      } else {
        escaped = false;
      }
    } else {
      if (char === '"') {
        isInsideString = true;
        escaped = false;
      } else if (char === "{") {
        stack.push("}");
      } else if (char === "[") {
        stack.push("]");
      } else if (char === "}" || char === "]") {
        if (stack && stack[stack.length - 1] === char) {
          stack.pop();
        } else {
          return null;
        }
      }
    }
    new_s += char;
  }
  if (isInsideString) {
    new_s += '"';
  }
  for (let i = stack.length - 1; i >= 0; i -= 1) {
    new_s += stack[i];
  }
  try {
    return JSON.parse(new_s);
  } catch (error) {
    return null;
  }
}

// node_modules/@langchain/core/dist/load/map_keys.js
var import_decamelize = __toESM(require_decamelize(), 1);
var import_camelcase = __toESM(require_camelcase(), 1);
function keyToJson(key, map) {
  return (map == null ? void 0 : map[key]) || (0, import_decamelize.default)(key);
}
function mapKeys(fields, mapper, map) {
  const mapped = {};
  for (const key in fields) {
    if (Object.hasOwn(fields, key)) {
      mapped[mapper(key, map)] = fields[key];
    }
  }
  return mapped;
}

// node_modules/@langchain/core/dist/load/serializable.js
function shallowCopy(obj) {
  return Array.isArray(obj) ? [...obj] : { ...obj };
}
function replaceSecrets(root2, secretsMap) {
  const result = shallowCopy(root2);
  for (const [path, secretId] of Object.entries(secretsMap)) {
    const [last, ...partsReverse] = path.split(".").reverse();
    let current = result;
    for (const part of partsReverse.reverse()) {
      if (current[part] === void 0) {
        break;
      }
      current[part] = shallowCopy(current[part]);
      current = current[part];
    }
    if (current[last] !== void 0) {
      current[last] = {
        lc: 1,
        type: "secret",
        id: [secretId]
      };
    }
  }
  return result;
}
function get_lc_unique_name(serializableClass) {
  const parentClass = Object.getPrototypeOf(serializableClass);
  const lcNameIsSubclassed = typeof serializableClass.lc_name === "function" && (typeof parentClass.lc_name !== "function" || serializableClass.lc_name() !== parentClass.lc_name());
  if (lcNameIsSubclassed) {
    return serializableClass.lc_name();
  } else {
    return serializableClass.name;
  }
}
var Serializable = class {
  /**
   * The name of the serializable. Override to provide an alias or
   * to preserve the serialized module name in minified environments.
   *
   * Implemented as a static method to support loading logic.
   */
  static lc_name() {
    return this.name;
  }
  /**
   * The final serialized identifier for the module.
   */
  get lc_id() {
    return [
      ...this.lc_namespace,
      get_lc_unique_name(this.constructor)
    ];
  }
  /**
   * A map of secrets, which will be omitted from serialization.
   * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
   * Values are the secret ids, which will be used when deserializing.
   */
  get lc_secrets() {
    return void 0;
  }
  /**
   * A map of additional attributes to merge with constructor args.
   * Keys are the attribute names, e.g. "foo".
   * Values are the attribute values, which will be serialized.
   * These attributes need to be accepted by the constructor as arguments.
   */
  get lc_attributes() {
    return void 0;
  }
  /**
   * A map of aliases for constructor args.
   * Keys are the attribute names, e.g. "foo".
   * Values are the alias that will replace the key in serialization.
   * This is used to eg. make argument names match Python.
   */
  get lc_aliases() {
    return void 0;
  }
  /**
   * A manual list of keys that should be serialized.
   * If not overridden, all fields passed into the constructor will be serialized.
   */
  get lc_serializable_keys() {
    return void 0;
  }
  constructor(kwargs, ..._args) {
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "lc_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (this.lc_serializable_keys !== void 0) {
      this.lc_kwargs = Object.fromEntries(Object.entries(kwargs || {}).filter(([key]) => {
        var _a;
        return (_a = this.lc_serializable_keys) == null ? void 0 : _a.includes(key);
      }));
    } else {
      this.lc_kwargs = kwargs != null ? kwargs : {};
    }
  }
  toJSON() {
    if (!this.lc_serializable) {
      return this.toJSONNotImplemented();
    }
    if (
      // eslint-disable-next-line no-instanceof/no-instanceof
      this.lc_kwargs instanceof Serializable || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs)
    ) {
      return this.toJSONNotImplemented();
    }
    const aliases = {};
    const secrets = {};
    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
      acc[key] = key in this ? this[key] : this.lc_kwargs[key];
      return acc;
    }, {});
    for (let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {
      Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
      Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
      Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
    }
    Object.keys(secrets).forEach((keyPath) => {
      let read = this;
      let write = kwargs;
      const [last, ...partsReverse] = keyPath.split(".").reverse();
      for (const key of partsReverse.reverse()) {
        if (!(key in read) || read[key] === void 0)
          return;
        if (!(key in write) || write[key] === void 0) {
          if (typeof read[key] === "object" && read[key] != null) {
            write[key] = {};
          } else if (Array.isArray(read[key])) {
            write[key] = [];
          }
        }
        read = read[key];
        write = write[key];
      }
      if (last in read && read[last] !== void 0) {
        write[last] = write[last] || read[last];
      }
    });
    return {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: mapKeys(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, keyToJson, aliases)
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
};

// node_modules/@langchain/core/dist/messages/content_blocks.js
function isDataContentBlock(content_block) {
  return typeof content_block === "object" && content_block !== null && "type" in content_block && typeof content_block.type === "string" && "source_type" in content_block && (content_block.source_type === "url" || content_block.source_type === "base64" || content_block.source_type === "text" || content_block.source_type === "id");
}
function isURLContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "url" && "url" in content_block && typeof content_block.url === "string";
}
function isBase64ContentBlock(content_block) {
  return isDataContentBlock(content_block) && content_block.source_type === "base64" && "data" in content_block && typeof content_block.data === "string";
}
function convertToOpenAIImageBlock(content_block) {
  if (isDataContentBlock(content_block)) {
    if (content_block.source_type === "url") {
      return {
        type: "image_url",
        image_url: {
          url: content_block.url
        }
      };
    }
    if (content_block.source_type === "base64") {
      if (!content_block.mime_type) {
        throw new Error("mime_type key is required for base64 data.");
      }
      const mime_type = content_block.mime_type;
      return {
        type: "image_url",
        image_url: {
          url: `data:${mime_type};base64,${content_block.data}`
        }
      };
    }
  }
  throw new Error("Unsupported source type. Only 'url' and 'base64' are supported.");
}

// node_modules/@langchain/core/dist/messages/base.js
function mergeContent(firstContent, secondContent) {
  var _a;
  if (typeof firstContent === "string") {
    if (firstContent === "") {
      return secondContent;
    }
    if (typeof secondContent === "string") {
      return firstContent + secondContent;
    } else if (Array.isArray(secondContent) && secondContent.some((c) => isDataContentBlock(c))) {
      return [
        {
          type: "text",
          source_type: "text",
          text: firstContent
        },
        ...secondContent
      ];
    } else {
      return [{ type: "text", text: firstContent }, ...secondContent];
    }
  } else if (Array.isArray(secondContent)) {
    return (_a = _mergeLists(firstContent, secondContent)) != null ? _a : [
      ...firstContent,
      ...secondContent
    ];
  } else {
    if (secondContent === "") {
      return firstContent;
    } else if (Array.isArray(firstContent) && firstContent.some((c) => isDataContentBlock(c))) {
      return [
        ...firstContent,
        {
          type: "file",
          source_type: "text",
          text: secondContent
        }
      ];
    } else {
      return [...firstContent, { type: "text", text: secondContent }];
    }
  }
}
function stringifyWithDepthLimit(obj, depthLimit) {
  function helper(obj2, currentDepth) {
    if (typeof obj2 !== "object" || obj2 === null || obj2 === void 0) {
      return obj2;
    }
    if (currentDepth >= depthLimit) {
      if (Array.isArray(obj2)) {
        return "[Array]";
      }
      return "[Object]";
    }
    if (Array.isArray(obj2)) {
      return obj2.map((item) => helper(item, currentDepth + 1));
    }
    const result = {};
    for (const key of Object.keys(obj2)) {
      result[key] = helper(obj2[key], currentDepth + 1);
    }
    return result;
  }
  return JSON.stringify(helper(obj, 0), null, 2);
}
var BaseMessage = class extends Serializable {
  get lc_aliases() {
    return {
      additional_kwargs: "additional_kwargs",
      response_metadata: "response_metadata"
    };
  }
  /**
   * Get text content of the message.
   */
  get text() {
    if (typeof this.content === "string") {
      return this.content;
    }
    if (!Array.isArray(this.content))
      return "";
    return this.content.map((c) => {
      if (typeof c === "string")
        return c;
      if (c.type === "text")
        return c.text;
      return "";
    }).join("");
  }
  /** The type of the message. */
  getType() {
    return this._getType();
  }
  constructor(fields, kwargs) {
    if (typeof fields === "string") {
      fields = {
        content: fields,
        additional_kwargs: kwargs,
        response_metadata: {}
      };
    }
    if (!fields.additional_kwargs) {
      fields.additional_kwargs = {};
    }
    if (!fields.response_metadata) {
      fields.response_metadata = {};
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "messages"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "content", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "additional_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "response_metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = fields.name;
    this.content = fields.content;
    this.additional_kwargs = fields.additional_kwargs;
    this.response_metadata = fields.response_metadata;
    this.id = fields.id;
  }
  toDict() {
    return {
      type: this._getType(),
      data: this.toJSON().kwargs
    };
  }
  static lc_name() {
    return "BaseMessage";
  }
  // Can't be protected for silly reasons
  get _printableFields() {
    return {
      id: this.id,
      content: this.content,
      name: this.name,
      additional_kwargs: this.additional_kwargs,
      response_metadata: this.response_metadata
    };
  }
  // this private method is used to update the ID for the runtime
  // value as well as in lc_kwargs for serialisation
  _updateId(value) {
    this.id = value;
    this.lc_kwargs.id = value;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.lc_name();
  }
  // Override the default behavior of console.log
  [Symbol.for("nodejs.util.inspect.custom")](depth) {
    if (depth === null) {
      return this;
    }
    const printable = stringifyWithDepthLimit(this._printableFields, Math.max(4, depth));
    return `${this.constructor.lc_name()} ${printable}`;
  }
};
function _mergeDicts(left, right) {
  const merged = { ...left };
  for (const [key, value] of Object.entries(right)) {
    if (merged[key] == null) {
      merged[key] = value;
    } else if (value == null) {
      continue;
    } else if (typeof merged[key] !== typeof value || Array.isArray(merged[key]) !== Array.isArray(value)) {
      throw new Error(`field[${key}] already exists in the message chunk, but with a different type.`);
    } else if (typeof merged[key] === "string") {
      if (key === "type") {
        continue;
      }
      merged[key] += value;
    } else if (typeof merged[key] === "object" && !Array.isArray(merged[key])) {
      merged[key] = _mergeDicts(merged[key], value);
    } else if (Array.isArray(merged[key])) {
      merged[key] = _mergeLists(merged[key], value);
    } else if (merged[key] === value) {
      continue;
    } else {
      console.warn(`field[${key}] already exists in this message chunk and value has unsupported type.`);
    }
  }
  return merged;
}
function _mergeLists(left, right) {
  if (left === void 0 && right === void 0) {
    return void 0;
  } else if (left === void 0 || right === void 0) {
    return left || right;
  } else {
    const merged = [...left];
    for (const item of right) {
      if (typeof item === "object" && "index" in item && typeof item.index === "number") {
        const toMerge = merged.findIndex((leftItem) => leftItem.index === item.index);
        if (toMerge !== -1) {
          merged[toMerge] = _mergeDicts(merged[toMerge], item);
        } else {
          merged.push(item);
        }
      } else if (typeof item === "object" && "text" in item && item.text === "") {
        continue;
      } else {
        merged.push(item);
      }
    }
    return merged;
  }
}
var BaseMessageChunk = class extends BaseMessage {
};
function _isMessageFieldWithRole(x) {
  return typeof x.role === "string";
}
function isBaseMessage(messageLike) {
  return typeof (messageLike == null ? void 0 : messageLike._getType) === "function";
}
function isBaseMessageChunk(messageLike) {
  return isBaseMessage(messageLike) && typeof messageLike.concat === "function";
}

// node_modules/@langchain/core/dist/messages/tool.js
var ToolMessage = class extends BaseMessage {
  static lc_name() {
    return "ToolMessage";
  }
  get lc_aliases() {
    return { tool_call_id: "tool_call_id" };
  }
  constructor(fields, tool_call_id, name) {
    if (typeof fields === "string") {
      fields = { content: fields, name, tool_call_id };
    }
    super(fields);
    Object.defineProperty(this, "lc_direct_tool_output", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "status", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tool_call_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "artifact", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.tool_call_id = fields.tool_call_id;
    this.artifact = fields.artifact;
    this.status = fields.status;
  }
  _getType() {
    return "tool";
  }
  static isInstance(message) {
    return message._getType() === "tool";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_call_id: this.tool_call_id,
      artifact: this.artifact
    };
  }
};
function defaultToolCallParser(rawToolCalls) {
  const toolCalls = [];
  const invalidToolCalls = [];
  for (const toolCall of rawToolCalls) {
    if (!toolCall.function) {
      continue;
    } else {
      const functionName = toolCall.function.name;
      try {
        const functionArgs = JSON.parse(toolCall.function.arguments);
        const parsed = {
          name: functionName || "",
          args: functionArgs || {},
          id: toolCall.id
        };
        toolCalls.push(parsed);
      } catch (error) {
        invalidToolCalls.push({
          name: functionName,
          args: toolCall.function.arguments,
          id: toolCall.id,
          error: "Malformed args."
        });
      }
    }
  }
  return [toolCalls, invalidToolCalls];
}

// node_modules/@langchain/core/dist/messages/ai.js
var AIMessage = class extends BaseMessage {
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls"
    };
  }
  constructor(fields, kwargs) {
    var _a, _b, _c, _d, _e;
    let initParams;
    if (typeof fields === "string") {
      initParams = {
        content: fields,
        tool_calls: [],
        invalid_tool_calls: [],
        additional_kwargs: kwargs != null ? kwargs : {}
      };
    } else {
      initParams = fields;
      const rawToolCalls = (_a = initParams.additional_kwargs) == null ? void 0 : _a.tool_calls;
      const toolCalls = initParams.tool_calls;
      if (!(rawToolCalls == null) && rawToolCalls.length > 0 && (toolCalls === void 0 || toolCalls.length === 0)) {
        console.warn([
          "New LangChain packages are available that more efficiently handle",
          "tool calling.\n\nPlease upgrade your packages to versions that set",
          "message tool calls. e.g., `yarn add @langchain/anthropic`,",
          "yarn add @langchain/openai`, etc."
        ].join(" "));
      }
      try {
        if (!(rawToolCalls == null) && toolCalls === void 0) {
          const [toolCalls2, invalidToolCalls] = defaultToolCallParser(rawToolCalls);
          initParams.tool_calls = toolCalls2 != null ? toolCalls2 : [];
          initParams.invalid_tool_calls = invalidToolCalls != null ? invalidToolCalls : [];
        } else {
          initParams.tool_calls = (_b = initParams.tool_calls) != null ? _b : [];
          initParams.invalid_tool_calls = (_c = initParams.invalid_tool_calls) != null ? _c : [];
        }
      } catch (e) {
        initParams.tool_calls = [];
        initParams.invalid_tool_calls = [];
      }
    }
    super(initParams);
    Object.defineProperty(this, "tool_calls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "invalid_tool_calls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "usage_metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (typeof initParams !== "string") {
      this.tool_calls = (_d = initParams.tool_calls) != null ? _d : this.tool_calls;
      this.invalid_tool_calls = (_e = initParams.invalid_tool_calls) != null ? _e : this.invalid_tool_calls;
    }
    this.usage_metadata = initParams.usage_metadata;
  }
  static lc_name() {
    return "AIMessage";
  }
  _getType() {
    return "ai";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
};
function isAIMessage(x) {
  return x._getType() === "ai";
}
function isAIMessageChunk(x) {
  return x._getType() === "ai";
}
var AIMessageChunk = class extends BaseMessageChunk {
  constructor(fields) {
    var _a, _b, _c, _d, _e;
    let initParams;
    if (typeof fields === "string") {
      initParams = {
        content: fields,
        tool_calls: [],
        invalid_tool_calls: [],
        tool_call_chunks: []
      };
    } else if (fields.tool_call_chunks === void 0) {
      initParams = {
        ...fields,
        tool_calls: (_a = fields.tool_calls) != null ? _a : [],
        invalid_tool_calls: [],
        tool_call_chunks: [],
        usage_metadata: fields.usage_metadata !== void 0 ? fields.usage_metadata : void 0
      };
    } else {
      const toolCalls = [];
      const invalidToolCalls = [];
      for (const toolCallChunk of fields.tool_call_chunks) {
        let parsedArgs = {};
        try {
          parsedArgs = parsePartialJson(toolCallChunk.args || "{}");
          if (parsedArgs === null || typeof parsedArgs !== "object" || Array.isArray(parsedArgs)) {
            throw new Error("Malformed tool call chunk args.");
          }
          toolCalls.push({
            name: (_b = toolCallChunk.name) != null ? _b : "",
            args: parsedArgs,
            id: toolCallChunk.id,
            type: "tool_call"
          });
        } catch (e) {
          invalidToolCalls.push({
            name: toolCallChunk.name,
            args: toolCallChunk.args,
            id: toolCallChunk.id,
            error: "Malformed args.",
            type: "invalid_tool_call"
          });
        }
      }
      initParams = {
        ...fields,
        tool_calls: toolCalls,
        invalid_tool_calls: invalidToolCalls,
        usage_metadata: fields.usage_metadata !== void 0 ? fields.usage_metadata : void 0
      };
    }
    super(initParams);
    Object.defineProperty(this, "tool_calls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "invalid_tool_calls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "tool_call_chunks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "usage_metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.tool_call_chunks = (_c = initParams.tool_call_chunks) != null ? _c : this.tool_call_chunks;
    this.tool_calls = (_d = initParams.tool_calls) != null ? _d : this.tool_calls;
    this.invalid_tool_calls = (_e = initParams.invalid_tool_calls) != null ? _e : this.invalid_tool_calls;
    this.usage_metadata = initParams.usage_metadata;
  }
  get lc_aliases() {
    return {
      ...super.lc_aliases,
      tool_calls: "tool_calls",
      invalid_tool_calls: "invalid_tool_calls",
      tool_call_chunks: "tool_call_chunks"
    };
  }
  static lc_name() {
    return "AIMessageChunk";
  }
  _getType() {
    return "ai";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      tool_calls: this.tool_calls,
      tool_call_chunks: this.tool_call_chunks,
      invalid_tool_calls: this.invalid_tool_calls,
      usage_metadata: this.usage_metadata
    };
  }
  concat(chunk) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __;
    const combinedFields = {
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      tool_call_chunks: [],
      id: (_a = this.id) != null ? _a : chunk.id
    };
    if (this.tool_call_chunks !== void 0 || chunk.tool_call_chunks !== void 0) {
      const rawToolCalls = _mergeLists(this.tool_call_chunks, chunk.tool_call_chunks);
      if (rawToolCalls !== void 0 && rawToolCalls.length > 0) {
        combinedFields.tool_call_chunks = rawToolCalls;
      }
    }
    if (this.usage_metadata !== void 0 || chunk.usage_metadata !== void 0) {
      const inputTokenDetails = {
        ...(((_c = (_b = this.usage_metadata) == null ? void 0 : _b.input_token_details) == null ? void 0 : _c.audio) !== void 0 || ((_e = (_d = chunk.usage_metadata) == null ? void 0 : _d.input_token_details) == null ? void 0 : _e.audio) !== void 0) && {
          audio: ((_h = (_g = (_f = this.usage_metadata) == null ? void 0 : _f.input_token_details) == null ? void 0 : _g.audio) != null ? _h : 0) + ((_k = (_j = (_i = chunk.usage_metadata) == null ? void 0 : _i.input_token_details) == null ? void 0 : _j.audio) != null ? _k : 0)
        },
        ...(((_m = (_l = this.usage_metadata) == null ? void 0 : _l.input_token_details) == null ? void 0 : _m.cache_read) !== void 0 || ((_o = (_n = chunk.usage_metadata) == null ? void 0 : _n.input_token_details) == null ? void 0 : _o.cache_read) !== void 0) && {
          cache_read: ((_r = (_q = (_p = this.usage_metadata) == null ? void 0 : _p.input_token_details) == null ? void 0 : _q.cache_read) != null ? _r : 0) + ((_u = (_t = (_s = chunk.usage_metadata) == null ? void 0 : _s.input_token_details) == null ? void 0 : _t.cache_read) != null ? _u : 0)
        },
        ...(((_w = (_v = this.usage_metadata) == null ? void 0 : _v.input_token_details) == null ? void 0 : _w.cache_creation) !== void 0 || ((_y = (_x = chunk.usage_metadata) == null ? void 0 : _x.input_token_details) == null ? void 0 : _y.cache_creation) !== void 0) && {
          cache_creation: ((_B = (_A = (_z = this.usage_metadata) == null ? void 0 : _z.input_token_details) == null ? void 0 : _A.cache_creation) != null ? _B : 0) + ((_E = (_D = (_C = chunk.usage_metadata) == null ? void 0 : _C.input_token_details) == null ? void 0 : _D.cache_creation) != null ? _E : 0)
        }
      };
      const outputTokenDetails = {
        ...(((_G = (_F = this.usage_metadata) == null ? void 0 : _F.output_token_details) == null ? void 0 : _G.audio) !== void 0 || ((_I = (_H = chunk.usage_metadata) == null ? void 0 : _H.output_token_details) == null ? void 0 : _I.audio) !== void 0) && {
          audio: ((_L = (_K = (_J = this.usage_metadata) == null ? void 0 : _J.output_token_details) == null ? void 0 : _K.audio) != null ? _L : 0) + ((_O = (_N = (_M = chunk.usage_metadata) == null ? void 0 : _M.output_token_details) == null ? void 0 : _N.audio) != null ? _O : 0)
        },
        ...(((_Q = (_P = this.usage_metadata) == null ? void 0 : _P.output_token_details) == null ? void 0 : _Q.reasoning) !== void 0 || ((_S = (_R = chunk.usage_metadata) == null ? void 0 : _R.output_token_details) == null ? void 0 : _S.reasoning) !== void 0) && {
          reasoning: ((_V = (_U = (_T = this.usage_metadata) == null ? void 0 : _T.output_token_details) == null ? void 0 : _U.reasoning) != null ? _V : 0) + ((_Y = (_X = (_W = chunk.usage_metadata) == null ? void 0 : _W.output_token_details) == null ? void 0 : _X.reasoning) != null ? _Y : 0)
        }
      };
      const left = (_Z = this.usage_metadata) != null ? _Z : {
        input_tokens: 0,
        output_tokens: 0,
        total_tokens: 0
      };
      const right = (__ = chunk.usage_metadata) != null ? __ : {
        input_tokens: 0,
        output_tokens: 0,
        total_tokens: 0
      };
      const usage_metadata = {
        input_tokens: left.input_tokens + right.input_tokens,
        output_tokens: left.output_tokens + right.output_tokens,
        total_tokens: left.total_tokens + right.total_tokens,
        // Do not include `input_token_details` / `output_token_details` keys in combined fields
        // unless their values are defined.
        ...Object.keys(inputTokenDetails).length > 0 && {
          input_token_details: inputTokenDetails
        },
        ...Object.keys(outputTokenDetails).length > 0 && {
          output_token_details: outputTokenDetails
        }
      };
      combinedFields.usage_metadata = usage_metadata;
    }
    return new AIMessageChunk(combinedFields);
  }
};

// node_modules/@langchain/core/dist/messages/chat.js
var ChatMessage = class extends BaseMessage {
  static lc_name() {
    return "ChatMessage";
  }
  static _chatMessageClass() {
    return ChatMessage;
  }
  constructor(fields, role) {
    if (typeof fields === "string") {
      fields = { content: fields, role };
    }
    super(fields);
    Object.defineProperty(this, "role", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.role = fields.role;
  }
  _getType() {
    return "generic";
  }
  static isInstance(message) {
    return message._getType() === "generic";
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
};
var ChatMessageChunk = class extends BaseMessageChunk {
  static lc_name() {
    return "ChatMessageChunk";
  }
  constructor(fields, role) {
    if (typeof fields === "string") {
      fields = { content: fields, role };
    }
    super(fields);
    Object.defineProperty(this, "role", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.role = fields.role;
  }
  _getType() {
    return "generic";
  }
  concat(chunk) {
    var _a;
    return new ChatMessageChunk({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      role: this.role,
      id: (_a = this.id) != null ? _a : chunk.id
    });
  }
  get _printableFields() {
    return {
      ...super._printableFields,
      role: this.role
    };
  }
};

// node_modules/@langchain/core/dist/messages/function.js
var FunctionMessageChunk = class extends BaseMessageChunk {
  static lc_name() {
    return "FunctionMessageChunk";
  }
  _getType() {
    return "function";
  }
  concat(chunk) {
    var _a, _b;
    return new FunctionMessageChunk({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      name: (_a = this.name) != null ? _a : "",
      id: (_b = this.id) != null ? _b : chunk.id
    });
  }
};

// node_modules/@langchain/core/dist/messages/human.js
var HumanMessage = class extends BaseMessage {
  static lc_name() {
    return "HumanMessage";
  }
  _getType() {
    return "human";
  }
  constructor(fields, kwargs) {
    super(fields, kwargs);
  }
};
var HumanMessageChunk = class extends BaseMessageChunk {
  static lc_name() {
    return "HumanMessageChunk";
  }
  _getType() {
    return "human";
  }
  constructor(fields, kwargs) {
    super(fields, kwargs);
  }
  concat(chunk) {
    var _a;
    return new HumanMessageChunk({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      id: (_a = this.id) != null ? _a : chunk.id
    });
  }
};

// node_modules/@langchain/core/dist/messages/system.js
var SystemMessage = class extends BaseMessage {
  static lc_name() {
    return "SystemMessage";
  }
  _getType() {
    return "system";
  }
  constructor(fields, kwargs) {
    super(fields, kwargs);
  }
};
var SystemMessageChunk = class extends BaseMessageChunk {
  static lc_name() {
    return "SystemMessageChunk";
  }
  _getType() {
    return "system";
  }
  constructor(fields, kwargs) {
    super(fields, kwargs);
  }
  concat(chunk) {
    var _a;
    return new SystemMessageChunk({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),
      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),
      id: (_a = this.id) != null ? _a : chunk.id
    });
  }
};

// node_modules/@langchain/core/dist/errors/index.js
function addLangChainErrorFields(error, lc_error_code) {
  error.lc_error_code = lc_error_code;
  error.message = `${error.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${lc_error_code}/
`;
  return error;
}

// node_modules/@langchain/core/dist/tools/utils.js
function _isToolCall(toolCall) {
  return !!(toolCall && typeof toolCall === "object" && "type" in toolCall && toolCall.type === "tool_call");
}
var ToolInputParsingException = class extends Error {
  constructor(message, output) {
    super(message);
    Object.defineProperty(this, "output", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.output = output;
  }
};

// node_modules/@langchain/core/dist/messages/utils.js
function _coerceToolCall(toolCall) {
  if (_isToolCall(toolCall)) {
    return toolCall;
  } else if (typeof toolCall.id === "string" && toolCall.type === "function" && typeof toolCall.function === "object" && toolCall.function !== null && "arguments" in toolCall.function && typeof toolCall.function.arguments === "string" && "name" in toolCall.function && typeof toolCall.function.name === "string") {
    return {
      id: toolCall.id,
      args: JSON.parse(toolCall.function.arguments),
      name: toolCall.function.name,
      type: "tool_call"
    };
  } else {
    return toolCall;
  }
}
function isSerializedConstructor(x) {
  return typeof x === "object" && x != null && x.lc === 1 && Array.isArray(x.id) && x.kwargs != null && typeof x.kwargs === "object";
}
function _constructMessageFromParams(params) {
  let type;
  let rest;
  if (isSerializedConstructor(params)) {
    const className = params.id.at(-1);
    if (className === "HumanMessage" || className === "HumanMessageChunk") {
      type = "user";
    } else if (className === "AIMessage" || className === "AIMessageChunk") {
      type = "assistant";
    } else if (className === "SystemMessage" || className === "SystemMessageChunk") {
      type = "system";
    } else if (className === "FunctionMessage" || className === "FunctionMessageChunk") {
      type = "function";
    } else if (className === "ToolMessage" || className === "ToolMessageChunk") {
      type = "tool";
    } else {
      type = "unknown";
    }
    rest = params.kwargs;
  } else {
    const { type: extractedType, ...otherParams } = params;
    type = extractedType;
    rest = otherParams;
  }
  if (type === "human" || type === "user") {
    return new HumanMessage(rest);
  } else if (type === "ai" || type === "assistant") {
    const { tool_calls: rawToolCalls, ...other } = rest;
    if (!Array.isArray(rawToolCalls)) {
      return new AIMessage(rest);
    }
    const tool_calls = rawToolCalls.map(_coerceToolCall);
    return new AIMessage({ ...other, tool_calls });
  } else if (type === "system") {
    return new SystemMessage(rest);
  } else if (type === "developer") {
    return new SystemMessage({
      ...rest,
      additional_kwargs: {
        ...rest.additional_kwargs,
        __openai_role__: "developer"
      }
    });
  } else if (type === "tool" && "tool_call_id" in rest) {
    return new ToolMessage({
      ...rest,
      content: rest.content,
      tool_call_id: rest.tool_call_id,
      name: rest.name
    });
  } else {
    const error = addLangChainErrorFields(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(params, null, 2)}`), "MESSAGE_COERCION_FAILURE");
    throw error;
  }
}
function coerceMessageLikeToMessage(messageLike) {
  if (typeof messageLike === "string") {
    return new HumanMessage(messageLike);
  } else if (isBaseMessage(messageLike)) {
    return messageLike;
  }
  if (Array.isArray(messageLike)) {
    const [type, content] = messageLike;
    return _constructMessageFromParams({ type, content });
  } else if (_isMessageFieldWithRole(messageLike)) {
    const { role: type, ...rest } = messageLike;
    return _constructMessageFromParams({ ...rest, type });
  } else {
    return _constructMessageFromParams(messageLike);
  }
}
function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
  const string_messages = [];
  for (const m of messages) {
    let role;
    if (m._getType() === "human") {
      role = humanPrefix;
    } else if (m._getType() === "ai") {
      role = aiPrefix;
    } else if (m._getType() === "system") {
      role = "System";
    } else if (m._getType() === "function") {
      role = "Function";
    } else if (m._getType() === "tool") {
      role = "Tool";
    } else if (m._getType() === "generic") {
      role = m.role;
    } else {
      throw new Error(`Got unsupported message type: ${m._getType()}`);
    }
    const nameStr = m.name ? `${m.name}, ` : "";
    const readableContent = typeof m.content === "string" ? m.content : JSON.stringify(m.content, null, 2);
    string_messages.push(`${role}: ${nameStr}${readableContent}`);
  }
  return string_messages.join("\n");
}
function convertToChunk(message) {
  var _a;
  const type = message._getType();
  if (type === "human") {
    return new HumanMessageChunk({ ...message });
  } else if (type === "ai") {
    let aiChunkFields = {
      ...message
    };
    if ("tool_calls" in aiChunkFields) {
      aiChunkFields = {
        ...aiChunkFields,
        tool_call_chunks: (_a = aiChunkFields.tool_calls) == null ? void 0 : _a.map((tc) => ({
          ...tc,
          type: "tool_call_chunk",
          index: void 0,
          args: JSON.stringify(tc.args)
        }))
      };
    }
    return new AIMessageChunk({ ...aiChunkFields });
  } else if (type === "system") {
    return new SystemMessageChunk({ ...message });
  } else if (type === "function") {
    return new FunctionMessageChunk({ ...message });
  } else if (ChatMessage.isInstance(message)) {
    return new ChatMessageChunk({ ...message });
  } else {
    throw new Error("Unknown message type.");
  }
}

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr2, checker) => {
    for (const item of arr2) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex2 = `${regex2}(${opts.join("|")})`;
  return new RegExp(`^${regex2}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex2 = dateRegex;
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex2 = timeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data) => regex2.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@langchain/core/dist/runnables/base.js
var import_p_retry3 = __toESM(require_p_retry(), 1);

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
var i;
function unsafeStringify(arr2, offset = 0) {
  return (byteToHex[arr2[offset + 0]] + byteToHex[arr2[offset + 1]] + byteToHex[arr2[offset + 2]] + byteToHex[arr2[offset + 3]] + "-" + byteToHex[arr2[offset + 4]] + byteToHex[arr2[offset + 5]] + "-" + byteToHex[arr2[offset + 6]] + byteToHex[arr2[offset + 7]] + "-" + byteToHex[arr2[offset + 8]] + byteToHex[arr2[offset + 9]] + "-" + byteToHex[arr2[offset + 10]] + byteToHex[arr2[offset + 11]] + byteToHex[arr2[offset + 12]] + byteToHex[arr2[offset + 13]] + byteToHex[arr2[offset + 14]] + byteToHex[arr2[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/langsmith/dist/utils/async_caller.js
var import_p_retry = __toESM(require_p_retry(), 1);
var import_p_queue = __toESM(require_dist(), 1);

// node_modules/langsmith/dist/singletons/fetch.js
var DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);
var LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for("ls:fetch_implementation");
var _getFetchImplementation = (debug) => {
  return async (...args) => {
    var _a;
    if (debug || getLangSmithEnvironmentVariable("DEBUG") === "true") {
      const [url, options] = args;
      console.log(`\u2192 ${(options == null ? void 0 : options.method) || "GET"} ${url}`);
    }
    const res = await ((_a = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY]) != null ? _a : DEFAULT_FETCH_IMPLEMENTATION)(...args);
    if (debug || getLangSmithEnvironmentVariable("DEBUG") === "true") {
      console.log(`\u2190 ${res.status} ${res.statusText} ${res.url}`);
    }
    return res;
  };
};

// node_modules/langsmith/dist/utils/async_caller.js
var STATUS_NO_RETRY = [
  400,
  // Bad Request
  401,
  // Unauthorized
  403,
  // Forbidden
  404,
  // Not Found
  405,
  // Method Not Allowed
  406,
  // Not Acceptable
  407,
  // Proxy Authentication Required
  408
  // Request Timeout
];
var STATUS_IGNORE = [
  409
  // Conflict
];
var AsyncCaller = class {
  constructor(params) {
    var _a, _b;
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "debug", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxConcurrency = (_a = params.maxConcurrency) != null ? _a : Infinity;
    this.maxRetries = (_b = params.maxRetries) != null ? _b : 6;
    this.debug = params.debug;
    if ("default" in import_p_queue.default) {
      this.queue = new import_p_queue.default.default({
        concurrency: this.maxConcurrency
      });
    } else {
      this.queue = new import_p_queue.default({ concurrency: this.maxConcurrency });
    }
    this.onFailedResponseHook = params == null ? void 0 : params.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(callable, ...args) {
    const onFailedResponseHook = this.onFailedResponseHook;
    return this.queue.add(() => (0, import_p_retry.default)(() => callable(...args).catch((error) => {
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error(error);
      }
    }), {
      async onFailedAttempt(error) {
        if (error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.message.startsWith("AbortError")) {
          throw error;
        }
        if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
          throw error;
        }
        const response = error == null ? void 0 : error.response;
        const status = response == null ? void 0 : response.status;
        if (status) {
          if (STATUS_NO_RETRY.includes(+status)) {
            throw error;
          } else if (STATUS_IGNORE.includes(+status)) {
            return;
          }
          if (onFailedResponseHook) {
            await onFailedResponseHook(response);
          }
        }
      },
      // If needed we can change some of the defaults here,
      // but they're quite sensible.
      retries: this.maxRetries,
      randomize: true
    }), { throwOnTimeout: true });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(options, callable, ...args) {
    if (options.signal) {
      return Promise.race([
        this.call(callable, ...args),
        new Promise((_, reject) => {
          var _a;
          (_a = options.signal) == null ? void 0 : _a.addEventListener("abort", () => {
            reject(new Error("AbortError"));
          });
        })
      ]);
    }
    return this.call(callable, ...args);
  }
  fetch(...args) {
    return this.call(() => _getFetchImplementation(this.debug)(...args).then((res) => res.ok ? res : Promise.reject(res)));
  }
};

// node_modules/langsmith/dist/utils/messages.js
function isLangChainMessage(message) {
  return typeof (message == null ? void 0 : message._getType) === "function";
}
function convertLangChainMessageToExample(message) {
  const converted = {
    type: message._getType(),
    data: { content: message.content }
  };
  if ((message == null ? void 0 : message.additional_kwargs) && Object.keys(message.additional_kwargs).length > 0) {
    converted.data.additional_kwargs = { ...message.additional_kwargs };
  }
  return converted;
}

// node_modules/langsmith/dist/utils/_uuid.js
function assertUuid(str, which) {
  if (!validate_default(str)) {
    const msg = which !== void 0 ? `Invalid UUID for ${which}: ${str}` : `Invalid UUID: ${str}`;
    throw new Error(msg);
  }
  return str;
}

// node_modules/langsmith/dist/utils/warn.js
var warnedMessages = {};
function warnOnce(message) {
  if (!warnedMessages[message]) {
    console.warn(message);
    warnedMessages[message] = true;
  }
}

// node_modules/langsmith/dist/utils/prompts.js
var import_semver = __toESM(require_semver2(), 1);
function parsePromptIdentifier(identifier) {
  if (!identifier || identifier.split("/").length > 2 || identifier.startsWith("/") || identifier.endsWith("/") || identifier.split(":").length > 2) {
    throw new Error(`Invalid identifier format: ${identifier}`);
  }
  const [ownerNamePart, commitPart] = identifier.split(":");
  const commit = commitPart || "latest";
  if (ownerNamePart.includes("/")) {
    const [owner, name] = ownerNamePart.split("/", 2);
    if (!owner || !name) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    return [owner, name, commit];
  } else {
    if (!ownerNamePart) {
      throw new Error(`Invalid identifier format: ${identifier}`);
    }
    return ["-", ownerNamePart, commit];
  }
}

// node_modules/langsmith/dist/utils/error.js
var LangSmithConflictError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "LangSmithConflictError";
  }
};
async function raiseForStatus(response, context, consume) {
  let errorBody;
  if (response.ok) {
    if (consume) {
      errorBody = await response.text();
    }
    return;
  }
  errorBody = await response.text();
  const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Server response: ${errorBody}`;
  if (response.status === 409) {
    throw new LangSmithConflictError(fullMessage);
  }
  throw new Error(fullMessage);
}

// node_modules/langsmith/dist/utils/fast-safe-stringify/index.js
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = { result: "[Circular]" };
var arr = [];
var replacerStack = [];
var encoder = new TextEncoder();
function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function encodeString(str) {
  return encoder.encode(str);
}
function serialize(obj, replacer, spacer, options) {
  var _a;
  try {
    const str = JSON.stringify(obj, replacer, spacer);
    return encodeString(str);
  } catch (e) {
    if (!((_a = e.message) == null ? void 0 : _a.includes("Converting circular structure to JSON"))) {
      console.warn("[WARNING]: LangSmith received unserializable value.");
      return encodeString("[Unserializable]");
    }
    console.warn("[WARNING]: LangSmith received circular JSON. This will decrease tracer performance.");
    if (typeof options === "undefined") {
      options = defaultOptions();
    }
    decirc(obj, "", 0, [], void 0, 0, options);
    let res;
    try {
      if (replacerStack.length === 0) {
        res = JSON.stringify(obj, replacer, spacer);
      } else {
        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
      }
    } catch (_) {
      return encodeString("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      while (arr.length !== 0) {
        const part = arr.pop();
        if (part.length === 4) {
          Object.defineProperty(part[0], part[1], part[3]);
        } else {
          part[0][part[1]] = part[2];
        }
      }
    }
    return encodeString(res);
  }
}
function setReplace(replace, val, k, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k, { value: replace });
      arr.push([parent, k, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k, replace]);
    }
  } else {
    parent[k] = replace;
    arr.push([parent, k, val]);
  }
}
function decirc(val, k, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i;
  if (typeof val === "object" && val !== null) {
    for (i = 0; i < stack.length; i++) {
      if (stack[i] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
        return;
      }
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i = 0; i < val.length; i++) {
        decirc(val[i], i, i, stack, val, depth, options);
      }
    } else {
      var keys = Object.keys(val);
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        decirc(val[key], key, i, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer) {
  replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
    return v;
  };
  return function(key, val) {
    if (replacerStack.length > 0) {
      for (var i = 0; i < replacerStack.length; i++) {
        var part = replacerStack[i];
        if (part[1] === key && part[0] === val) {
          val = part[2];
          replacerStack.splice(i, 1);
          break;
        }
      }
    }
    return replacer.call(this, key, val);
  };
}

// node_modules/langsmith/dist/client.js
function mergeRuntimeEnvIntoRunCreate(run) {
  var _a, _b;
  const runtimeEnv = getRuntimeEnvironment();
  const envVars = getLangChainEnvVarsMetadata();
  const extra = (_a = run.extra) != null ? _a : {};
  const metadata = extra.metadata;
  run.extra = {
    ...extra,
    runtime: {
      ...runtimeEnv,
      ...extra == null ? void 0 : extra.runtime
    },
    metadata: {
      ...envVars,
      ...envVars.revision_id || run.revision_id ? { revision_id: (_b = run.revision_id) != null ? _b : envVars.revision_id } : {},
      ...metadata
    }
  };
  return run;
}
var getTracingSamplingRate = (configRate) => {
  var _a;
  const samplingRateStr = (_a = configRate == null ? void 0 : configRate.toString()) != null ? _a : getLangSmithEnvironmentVariable("TRACING_SAMPLING_RATE");
  if (samplingRateStr === void 0) {
    return void 0;
  }
  const samplingRate = parseFloat(samplingRateStr);
  if (samplingRate < 0 || samplingRate > 1) {
    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);
  }
  return samplingRate;
};
var isLocalhost = (url) => {
  const strippedUrl = url.replace("http://", "").replace("https://", "");
  const hostname = strippedUrl.split("/")[0].split(":")[0];
  return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";
};
async function toArray(iterable) {
  const result = [];
  for await (const item of iterable) {
    result.push(item);
  }
  return result;
}
function trimQuotes(str) {
  if (str === void 0) {
    return void 0;
  }
  return str.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
var handle429 = async (response) => {
  var _a;
  if ((response == null ? void 0 : response.status) === 429) {
    const retryAfter = parseInt((_a = response.headers.get("retry-after")) != null ? _a : "30", 10) * 1e3;
    if (retryAfter > 0) {
      await new Promise((resolve) => setTimeout(resolve, retryAfter));
      return true;
    }
  }
  return false;
};
function _formatFeedbackScore(score) {
  if (typeof score === "number") {
    return Number(score.toFixed(4));
  }
  return score;
}
var AutoBatchQueue = class {
  constructor() {
    Object.defineProperty(this, "items", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "sizeBytes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
  }
  peek() {
    return this.items[0];
  }
  push(item) {
    let itemPromiseResolve;
    const itemPromise = new Promise((resolve) => {
      itemPromiseResolve = resolve;
    });
    const size = serialize(item.item).length;
    this.items.push({
      action: item.action,
      payload: item.item,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      itemPromiseResolve,
      itemPromise,
      size
    });
    this.sizeBytes += size;
    return itemPromise;
  }
  pop(upToSizeBytes) {
    var _a, _b;
    if (upToSizeBytes < 1) {
      throw new Error("Number of bytes to pop off may not be less than 1.");
    }
    const popped = [];
    let poppedSizeBytes = 0;
    while (poppedSizeBytes + ((_b = (_a = this.peek()) == null ? void 0 : _a.size) != null ? _b : 0) < upToSizeBytes && this.items.length > 0) {
      const item = this.items.shift();
      if (item) {
        popped.push(item);
        poppedSizeBytes += item.size;
        this.sizeBytes -= item.size;
      }
    }
    if (popped.length === 0 && this.items.length > 0) {
      const item = this.items.shift();
      popped.push(item);
      poppedSizeBytes += item.size;
      this.sizeBytes -= item.size;
    }
    return [
      popped.map((it) => ({ action: it.action, item: it.payload })),
      () => popped.forEach((it) => it.itemPromiseResolve())
    ];
  }
};
var DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;
var SERVER_INFO_REQUEST_TIMEOUT = 2500;
var Client = class {
  constructor(config = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    Object.defineProperty(this, "apiKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "apiUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "webUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "batchIngestCaller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "timeout_ms", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_tenantId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "hideInputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hideOutputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tracingSampleRate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "filteredPostUuids", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    Object.defineProperty(this, "autoBatchTracing", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "autoBatchQueue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new AutoBatchQueue()
    });
    Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 250
    });
    Object.defineProperty(this, "batchSizeBytesLimit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "fetchOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "settings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "blockOnRootRunFinalization", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getEnvironmentVariable("LANGSMITH_TRACING_BACKGROUND") === "false"
    });
    Object.defineProperty(this, "traceBatchConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5
    });
    Object.defineProperty(this, "_serverInfo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_getServerInfoPromise", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "manualFlushMode", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "debug", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getEnvironmentVariable("LANGSMITH_DEBUG") === "true"
    });
    const defaultConfig = Client.getDefaultClientConfig();
    this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);
    this.apiUrl = (_b = trimQuotes((_a = config.apiUrl) != null ? _a : defaultConfig.apiUrl)) != null ? _b : "";
    if (this.apiUrl.endsWith("/")) {
      this.apiUrl = this.apiUrl.slice(0, -1);
    }
    this.apiKey = trimQuotes((_c = config.apiKey) != null ? _c : defaultConfig.apiKey);
    this.webUrl = trimQuotes((_d = config.webUrl) != null ? _d : defaultConfig.webUrl);
    if ((_e = this.webUrl) == null ? void 0 : _e.endsWith("/")) {
      this.webUrl = this.webUrl.slice(0, -1);
    }
    this.timeout_ms = (_f = config.timeout_ms) != null ? _f : 9e4;
    this.caller = new AsyncCaller({
      ...(_g = config.callerOptions) != null ? _g : {},
      debug: (_h = config.debug) != null ? _h : this.debug
    });
    this.traceBatchConcurrency = (_i = config.traceBatchConcurrency) != null ? _i : this.traceBatchConcurrency;
    if (this.traceBatchConcurrency < 1) {
      throw new Error("Trace batch concurrency must be positive.");
    }
    this.debug = (_j = config.debug) != null ? _j : this.debug;
    this.batchIngestCaller = new AsyncCaller({
      maxRetries: 2,
      maxConcurrency: this.traceBatchConcurrency,
      ...(_k = config.callerOptions) != null ? _k : {},
      onFailedResponseHook: handle429,
      debug: (_l = config.debug) != null ? _l : this.debug
    });
    this.hideInputs = (_n = (_m = config.hideInputs) != null ? _m : config.anonymizer) != null ? _n : defaultConfig.hideInputs;
    this.hideOutputs = (_p = (_o = config.hideOutputs) != null ? _o : config.anonymizer) != null ? _p : defaultConfig.hideOutputs;
    this.autoBatchTracing = (_q = config.autoBatchTracing) != null ? _q : this.autoBatchTracing;
    this.blockOnRootRunFinalization = (_r = config.blockOnRootRunFinalization) != null ? _r : this.blockOnRootRunFinalization;
    this.batchSizeBytesLimit = config.batchSizeBytesLimit;
    this.fetchOptions = config.fetchOptions || {};
    this.manualFlushMode = (_s = config.manualFlushMode) != null ? _s : this.manualFlushMode;
  }
  static getDefaultClientConfig() {
    var _a;
    const apiKey = getLangSmithEnvironmentVariable("API_KEY");
    const apiUrl = (_a = getLangSmithEnvironmentVariable("ENDPOINT")) != null ? _a : "https://api.smith.langchain.com";
    const hideInputs = getLangSmithEnvironmentVariable("HIDE_INPUTS") === "true";
    const hideOutputs = getLangSmithEnvironmentVariable("HIDE_OUTPUTS") === "true";
    return {
      apiUrl,
      apiKey,
      webUrl: void 0,
      hideInputs,
      hideOutputs
    };
  }
  getHostUrl() {
    if (this.webUrl) {
      return this.webUrl;
    } else if (isLocalhost(this.apiUrl)) {
      this.webUrl = "http://localhost:3000";
      return this.webUrl;
    } else if (this.apiUrl.endsWith("/api/v1")) {
      this.webUrl = this.apiUrl.replace("/api/v1", "");
      return this.webUrl;
    } else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
      this.webUrl = this.apiUrl.replace("/api", "");
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
      this.webUrl = "https://dev.smith.langchain.com";
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("eu")) {
      this.webUrl = "https://eu.smith.langchain.com";
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("beta")) {
      this.webUrl = "https://beta.smith.langchain.com";
      return this.webUrl;
    } else {
      this.webUrl = "https://smith.langchain.com";
      return this.webUrl;
    }
  }
  get headers() {
    const headers = {
      "User-Agent": `langsmith-js/${__version__}`
    };
    if (this.apiKey) {
      headers["x-api-key"] = `${this.apiKey}`;
    }
    return headers;
  }
  async processInputs(inputs) {
    if (this.hideInputs === false) {
      return inputs;
    }
    if (this.hideInputs === true) {
      return {};
    }
    if (typeof this.hideInputs === "function") {
      return this.hideInputs(inputs);
    }
    return inputs;
  }
  async processOutputs(outputs) {
    if (this.hideOutputs === false) {
      return outputs;
    }
    if (this.hideOutputs === true) {
      return {};
    }
    if (typeof this.hideOutputs === "function") {
      return this.hideOutputs(outputs);
    }
    return outputs;
  }
  async prepareRunCreateOrUpdateInputs(run) {
    const runParams = { ...run };
    if (runParams.inputs !== void 0) {
      runParams.inputs = await this.processInputs(runParams.inputs);
    }
    if (runParams.outputs !== void 0) {
      runParams.outputs = await this.processOutputs(runParams.outputs);
    }
    return runParams;
  }
  async _getResponse(path, queryParams) {
    var _a;
    const paramsString = (_a = queryParams == null ? void 0 : queryParams.toString()) != null ? _a : "";
    const url = `${this.apiUrl}${path}?${paramsString}`;
    const response = await this.caller.call(_getFetchImplementation(this.debug), url, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `Failed to fetch ${path}`);
    return response;
  }
  async _get(path, queryParams) {
    const response = await this._getResponse(path, queryParams);
    return response.json();
  }
  async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {
    let offset = Number(queryParams.get("offset")) || 0;
    const limit = Number(queryParams.get("limit")) || 100;
    while (true) {
      queryParams.set("offset", String(offset));
      queryParams.set("limit", String(limit));
      const url = `${this.apiUrl}${path}?${queryParams}`;
      const response = await this.caller.call(_getFetchImplementation(this.debug), url, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(response, `Failed to fetch ${path}`);
      const items = transform ? transform(await response.json()) : await response.json();
      if (items.length === 0) {
        break;
      }
      yield items;
      if (items.length < limit) {
        break;
      }
      offset += items.length;
    }
  }
  async *_getCursorPaginatedList(path, body = null, requestMethod = "POST", dataKey = "runs") {
    const bodyParams = body ? { ...body } : {};
    while (true) {
      const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${path}`, {
        method: requestMethod,
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions,
        body: JSON.stringify(bodyParams)
      });
      const responseBody = await response.json();
      if (!responseBody) {
        break;
      }
      if (!responseBody[dataKey]) {
        break;
      }
      yield responseBody[dataKey];
      const cursors = responseBody.cursors;
      if (!cursors) {
        break;
      }
      if (!cursors.next) {
        break;
      }
      bodyParams.cursor = cursors.next;
    }
  }
  // Allows mocking for tests
  _shouldSample() {
    if (this.tracingSampleRate === void 0) {
      return true;
    }
    return Math.random() < this.tracingSampleRate;
  }
  _filterForSampling(runs, patch = false) {
    var _a;
    if (this.tracingSampleRate === void 0) {
      return runs;
    }
    if (patch) {
      const sampled = [];
      for (const run of runs) {
        if (!this.filteredPostUuids.has(run.id)) {
          sampled.push(run);
        } else {
          this.filteredPostUuids.delete(run.id);
        }
      }
      return sampled;
    } else {
      const sampled = [];
      for (const run of runs) {
        const traceId = (_a = run.trace_id) != null ? _a : run.id;
        if (this.filteredPostUuids.has(traceId)) {
          continue;
        }
        if (run.id === traceId) {
          if (this._shouldSample()) {
            sampled.push(run);
          } else {
            this.filteredPostUuids.add(traceId);
          }
        } else {
          sampled.push(run);
        }
      }
      return sampled;
    }
  }
  async _getBatchSizeLimitBytes() {
    var _a, _b, _c;
    const serverInfo = await this._ensureServerInfo();
    return (_c = (_b = this.batchSizeBytesLimit) != null ? _b : (_a = serverInfo.batch_ingest_config) == null ? void 0 : _a.size_limit_bytes) != null ? _c : DEFAULT_BATCH_SIZE_LIMIT_BYTES;
  }
  async _getMultiPartSupport() {
    var _a, _b;
    const serverInfo = await this._ensureServerInfo();
    return (_b = (_a = serverInfo.instance_flags) == null ? void 0 : _a.dataset_examples_multipart_enabled) != null ? _b : false;
  }
  drainAutoBatchQueue(batchSizeLimit) {
    const promises = [];
    while (this.autoBatchQueue.items.length > 0) {
      const [batch, done] = this.autoBatchQueue.pop(batchSizeLimit);
      if (!batch.length) {
        done();
        break;
      }
      const batchPromise = this._processBatch(batch, done).catch(console.error);
      promises.push(batchPromise);
    }
    return Promise.all(promises);
  }
  async _processBatch(batch, done) {
    var _a;
    if (!batch.length) {
      done();
      return;
    }
    try {
      const ingestParams = {
        runCreates: batch.filter((item) => item.action === "create").map((item) => item.item),
        runUpdates: batch.filter((item) => item.action === "update").map((item) => item.item)
      };
      const serverInfo = await this._ensureServerInfo();
      if ((_a = serverInfo == null ? void 0 : serverInfo.batch_ingest_config) == null ? void 0 : _a.use_multipart_endpoint) {
        await this.multipartIngestRuns(ingestParams);
      } else {
        await this.batchIngestRuns(ingestParams);
      }
    } finally {
      done();
    }
  }
  async processRunOperation(item) {
    clearTimeout(this.autoBatchTimeout);
    this.autoBatchTimeout = void 0;
    if (item.action === "create") {
      item.item = mergeRuntimeEnvIntoRunCreate(item.item);
    }
    const itemPromise = this.autoBatchQueue.push(item);
    if (this.manualFlushMode) {
      return itemPromise;
    }
    const sizeLimitBytes = await this._getBatchSizeLimitBytes();
    if (this.autoBatchQueue.sizeBytes > sizeLimitBytes) {
      void this.drainAutoBatchQueue(sizeLimitBytes);
    }
    if (this.autoBatchQueue.items.length > 0) {
      this.autoBatchTimeout = setTimeout(() => {
        this.autoBatchTimeout = void 0;
        void this.drainAutoBatchQueue(sizeLimitBytes);
      }, this.autoBatchAggregationDelayMs);
    }
    return itemPromise;
  }
  async _getServerInfo() {
    const response = await _getFetchImplementation(this.debug)(`${this.apiUrl}/info`, {
      method: "GET",
      headers: { Accept: "application/json" },
      signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "get server info");
    const json = await response.json();
    if (this.debug) {
      console.log("\n=== LangSmith Server Configuration ===\n" + JSON.stringify(json, null, 2) + "\n");
    }
    return json;
  }
  async _ensureServerInfo() {
    if (this._getServerInfoPromise === void 0) {
      this._getServerInfoPromise = (async () => {
        var _a;
        if (this._serverInfo === void 0) {
          try {
            this._serverInfo = await this._getServerInfo();
          } catch (e) {
            console.warn(`[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to batch operations and default limits.`);
          }
        }
        return (_a = this._serverInfo) != null ? _a : {};
      })();
    }
    return this._getServerInfoPromise.then((serverInfo) => {
      if (this._serverInfo === void 0) {
        this._getServerInfoPromise = void 0;
      }
      return serverInfo;
    });
  }
  async _getSettings() {
    if (!this.settings) {
      this.settings = this._get("/settings");
    }
    return await this.settings;
  }
  /**
   * Flushes current queued traces.
   */
  async flush() {
    const sizeLimitBytes = await this._getBatchSizeLimitBytes();
    await this.drainAutoBatchQueue(sizeLimitBytes);
  }
  async createRun(run) {
    var _a;
    if (!this._filterForSampling([run]).length) {
      return;
    }
    const headers = { ...this.headers, "Content-Type": "application/json" };
    const session_name = run.project_name;
    delete run.project_name;
    const runCreate = await this.prepareRunCreateOrUpdateInputs({
      session_name,
      ...run,
      start_time: (_a = run.start_time) != null ? _a : Date.now()
    });
    if (this.autoBatchTracing && runCreate.trace_id !== void 0 && runCreate.dotted_order !== void 0) {
      void this.processRunOperation({
        action: "create",
        item: runCreate
      }).catch(console.error);
      return;
    }
    const mergedRunCreateParam = mergeRuntimeEnvIntoRunCreate(runCreate);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs`, {
      method: "POST",
      headers,
      body: serialize(mergedRunCreateParam),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create run", true);
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async batchIngestRuns({ runCreates, runUpdates }) {
    var _a, _b;
    if (runCreates === void 0 && runUpdates === void 0) {
      return;
    }
    let preparedCreateParams = await Promise.all((_a = runCreates == null ? void 0 : runCreates.map((create) => this.prepareRunCreateOrUpdateInputs(create))) != null ? _a : []);
    let preparedUpdateParams = await Promise.all((_b = runUpdates == null ? void 0 : runUpdates.map((update) => this.prepareRunCreateOrUpdateInputs(update))) != null ? _b : []);
    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
      const createById = preparedCreateParams.reduce((params, run) => {
        if (!run.id) {
          return params;
        }
        params[run.id] = run;
        return params;
      }, {});
      const standaloneUpdates = [];
      for (const updateParam of preparedUpdateParams) {
        if (updateParam.id !== void 0 && createById[updateParam.id]) {
          createById[updateParam.id] = {
            ...createById[updateParam.id],
            ...updateParam
          };
        } else {
          standaloneUpdates.push(updateParam);
        }
      }
      preparedCreateParams = Object.values(createById);
      preparedUpdateParams = standaloneUpdates;
    }
    const rawBatch = {
      post: preparedCreateParams,
      patch: preparedUpdateParams
    };
    if (!rawBatch.post.length && !rawBatch.patch.length) {
      return;
    }
    const batchChunks = {
      post: [],
      patch: []
    };
    for (const k of ["post", "patch"]) {
      const key = k;
      const batchItems = rawBatch[key].reverse();
      let batchItem = batchItems.pop();
      while (batchItem !== void 0) {
        batchChunks[key].push(batchItem);
        batchItem = batchItems.pop();
      }
    }
    if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {
      await this._postBatchIngestRuns(serialize(batchChunks));
    }
  }
  async _postBatchIngestRuns(body) {
    const headers = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    const response = await this.batchIngestCaller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/batch`, {
      method: "POST",
      headers,
      body,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "batch create run", true);
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async multipartIngestRuns({ runCreates, runUpdates }) {
    if (runCreates === void 0 && runUpdates === void 0) {
      return;
    }
    const allAttachments = {};
    let preparedCreateParams = [];
    for (const create of runCreates != null ? runCreates : []) {
      const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);
      if (preparedCreate.id !== void 0 && preparedCreate.attachments !== void 0) {
        allAttachments[preparedCreate.id] = preparedCreate.attachments;
      }
      delete preparedCreate.attachments;
      preparedCreateParams.push(preparedCreate);
    }
    let preparedUpdateParams = [];
    for (const update of runUpdates != null ? runUpdates : []) {
      preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));
    }
    const invalidRunCreate = preparedCreateParams.find((runCreate) => {
      return runCreate.trace_id === void 0 || runCreate.dotted_order === void 0;
    });
    if (invalidRunCreate !== void 0) {
      throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run`);
    }
    const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {
      return runUpdate.trace_id === void 0 || runUpdate.dotted_order === void 0;
    });
    if (invalidRunUpdate !== void 0) {
      throw new Error(`Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run`);
    }
    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
      const createById = preparedCreateParams.reduce((params, run) => {
        if (!run.id) {
          return params;
        }
        params[run.id] = run;
        return params;
      }, {});
      const standaloneUpdates = [];
      for (const updateParam of preparedUpdateParams) {
        if (updateParam.id !== void 0 && createById[updateParam.id]) {
          createById[updateParam.id] = {
            ...createById[updateParam.id],
            ...updateParam
          };
        } else {
          standaloneUpdates.push(updateParam);
        }
      }
      preparedCreateParams = Object.values(createById);
      preparedUpdateParams = standaloneUpdates;
    }
    if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {
      return;
    }
    const accumulatedContext = [];
    const accumulatedParts = [];
    for (const [method, payloads] of [
      ["post", preparedCreateParams],
      ["patch", preparedUpdateParams]
    ]) {
      for (const originalPayload of payloads) {
        const { inputs, outputs, events, attachments, ...payload } = originalPayload;
        const fields = { inputs, outputs, events };
        const stringifiedPayload = serialize(payload);
        accumulatedParts.push({
          name: `${method}.${payload.id}`,
          payload: new Blob([stringifiedPayload], {
            type: `application/json; length=${stringifiedPayload.length}`
            // encoding=gzip
          })
        });
        for (const [key, value] of Object.entries(fields)) {
          if (value === void 0) {
            continue;
          }
          const stringifiedValue = serialize(value);
          accumulatedParts.push({
            name: `${method}.${payload.id}.${key}`,
            payload: new Blob([stringifiedValue], {
              type: `application/json; length=${stringifiedValue.length}`
            })
          });
        }
        if (payload.id !== void 0) {
          const attachments2 = allAttachments[payload.id];
          if (attachments2) {
            delete allAttachments[payload.id];
            for (const [name, attachment] of Object.entries(attachments2)) {
              let contentType;
              let content;
              if (Array.isArray(attachment)) {
                [contentType, content] = attachment;
              } else {
                contentType = attachment.mimeType;
                content = attachment.data;
              }
              if (name.includes(".")) {
                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);
                continue;
              }
              accumulatedParts.push({
                name: `attachment.${payload.id}.${name}`,
                payload: new Blob([content], {
                  type: `${contentType}; length=${content.byteLength}`
                })
              });
            }
          }
        }
        accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);
      }
    }
    await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join("; "));
  }
  async _sendMultipartRequest(parts, context) {
    try {
      const boundary = "----LangSmithFormBoundary" + Math.random().toString(36).slice(2);
      const chunks = [];
      for (const part of parts) {
        chunks.push(new Blob([`--${boundary}\r
`]));
        chunks.push(new Blob([
          `Content-Disposition: form-data; name="${part.name}"\r
`,
          `Content-Type: ${part.payload.type}\r
\r
`
        ]));
        chunks.push(part.payload);
        chunks.push(new Blob(["\r\n"]));
      }
      chunks.push(new Blob([`--${boundary}--\r
`]));
      const body = new Blob(chunks);
      const arrayBuffer = await body.arrayBuffer();
      const res = await this.batchIngestCaller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/multipart`, {
        method: "POST",
        headers: {
          ...this.headers,
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        },
        body: arrayBuffer,
        signal: AbortSignal.timeout(this.timeout_ms),
        ...this.fetchOptions
      });
      await raiseForStatus(res, "ingest multipart runs", true);
    } catch (e) {
      console.warn(`${e.message.trim()}

Context: ${context}`);
    }
  }
  async updateRun(runId, run) {
    assertUuid(runId);
    if (run.inputs) {
      run.inputs = await this.processInputs(run.inputs);
    }
    if (run.outputs) {
      run.outputs = await this.processOutputs(run.outputs);
    }
    const data = { ...run, id: runId };
    if (!this._filterForSampling([data], true).length) {
      return;
    }
    if (this.autoBatchTracing && data.trace_id !== void 0 && data.dotted_order !== void 0) {
      if (run.end_time !== void 0 && data.parent_run_id === void 0 && this.blockOnRootRunFinalization && !this.manualFlushMode) {
        await this.processRunOperation({ action: "update", item: data }).catch(console.error);
        return;
      } else {
        void this.processRunOperation({ action: "update", item: data }).catch(console.error);
      }
      return;
    }
    const headers = { ...this.headers, "Content-Type": "application/json" };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}`, {
      method: "PATCH",
      headers,
      body: serialize(run),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update run", true);
  }
  async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {
    assertUuid(runId);
    let run = await this._get(`/runs/${runId}`);
    if (loadChildRuns && run.child_run_ids) {
      run = await this._loadChildRuns(run);
    }
    return run;
  }
  async getRunUrl({ runId, run, projectOpts }) {
    if (run !== void 0) {
      let sessionId;
      if (run.session_id) {
        sessionId = run.session_id;
      } else if (projectOpts == null ? void 0 : projectOpts.projectName) {
        sessionId = (await this.readProject({ projectName: projectOpts == null ? void 0 : projectOpts.projectName })).id;
      } else if (projectOpts == null ? void 0 : projectOpts.projectId) {
        sessionId = projectOpts == null ? void 0 : projectOpts.projectId;
      } else {
        const project = await this.readProject({
          projectName: getLangSmithEnvironmentVariable("PROJECT") || "default"
        });
        sessionId = project.id;
      }
      const tenantId = await this._getTenantId();
      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;
    } else if (runId !== void 0) {
      const run_ = await this.readRun(runId);
      if (!run_.app_path) {
        throw new Error(`Run ${runId} has no app_path`);
      }
      const baseUrl = this.getHostUrl();
      return `${baseUrl}${run_.app_path}`;
    } else {
      throw new Error("Must provide either runId or run");
    }
  }
  async _loadChildRuns(run) {
    const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));
    const treemap = {};
    const runs = {};
    childRuns.sort((a, b) => {
      var _a, _b;
      return ((_a = a == null ? void 0 : a.dotted_order) != null ? _a : "").localeCompare((_b = b == null ? void 0 : b.dotted_order) != null ? _b : "");
    });
    for (const childRun of childRuns) {
      if (childRun.parent_run_id === null || childRun.parent_run_id === void 0) {
        throw new Error(`Child run ${childRun.id} has no parent`);
      }
      if (!(childRun.parent_run_id in treemap)) {
        treemap[childRun.parent_run_id] = [];
      }
      treemap[childRun.parent_run_id].push(childRun);
      runs[childRun.id] = childRun;
    }
    run.child_runs = treemap[run.id] || [];
    for (const runId in treemap) {
      if (runId !== run.id) {
        runs[runId].child_runs = treemap[runId];
      }
    }
    return run;
  }
  /**
   * List runs from the LangSmith server.
   * @param projectId - The ID of the project to filter by.
   * @param projectName - The name of the project to filter by.
   * @param parentRunId - The ID of the parent run to filter by.
   * @param traceId - The ID of the trace to filter by.
   * @param referenceExampleId - The ID of the reference example to filter by.
   * @param startTime - The start time to filter by.
   * @param isRoot - Indicates whether to only return root runs.
   * @param runType - The run type to filter by.
   * @param error - Indicates whether to filter by error runs.
   * @param id - The ID of the run to filter by.
   * @param query - The query string to filter by.
   * @param filter - The filter string to apply to the run spans.
   * @param traceFilter - The filter string to apply on the root run of the trace.
   * @param treeFilter - The filter string to apply on other runs in the trace.
   * @param limit - The maximum number of runs to retrieve.
   * @returns {AsyncIterable<Run>} - The runs.
   *
   * @example
   * // List all runs in a project
   * const projectRuns = client.listRuns({ projectName: "<your_project>" });
   *
   * @example
   * // List LLM and Chat runs in the last 24 hours
   * const todaysLLMRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
   *   run_type: "llm",
   * });
   *
   * @example
   * // List traces in a project
   * const rootRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   execution_order: 1,
   * });
   *
   * @example
   * // List runs without errors
   * const correctRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   error: false,
   * });
   *
   * @example
   * // List runs by run ID
   * const runIds = [
   *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
   *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
   * ];
   * const selectedRuns = client.listRuns({ run_ids: runIds });
   *
   * @example
   * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
   * const chainRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
   * });
   *
   * @example
   * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
   * const goodExtractorRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'eq(name, "extractor")',
   *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
   * });
   *
   * @example
   * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
   * const complexRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
   * });
   *
   * @example
   * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
   * const taggedRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
   * });
   */
  async *listRuns(props) {
    const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select } = props;
    let projectIds = [];
    if (projectId) {
      projectIds = Array.isArray(projectId) ? projectId : [projectId];
    }
    if (projectName) {
      const projectNames = Array.isArray(projectName) ? projectName : [projectName];
      const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));
      projectIds.push(...projectIds_);
    }
    const default_select = [
      "app_path",
      "child_run_ids",
      "completion_cost",
      "completion_tokens",
      "dotted_order",
      "end_time",
      "error",
      "events",
      "extra",
      "feedback_stats",
      "first_token_time",
      "id",
      "inputs",
      "name",
      "outputs",
      "parent_run_id",
      "parent_run_ids",
      "prompt_cost",
      "prompt_tokens",
      "reference_example_id",
      "run_type",
      "session_id",
      "start_time",
      "status",
      "tags",
      "total_cost",
      "total_tokens",
      "trace_id"
    ];
    const body = {
      session: projectIds.length ? projectIds : null,
      run_type: runType,
      reference_example: referenceExampleId,
      query,
      filter,
      trace_filter: traceFilter,
      tree_filter: treeFilter,
      execution_order: executionOrder,
      parent_run: parentRunId,
      start_time: startTime ? startTime.toISOString() : null,
      error,
      id,
      limit,
      trace: traceId,
      select: select ? select : default_select,
      is_root: isRoot
    };
    let runsYielded = 0;
    for await (const runs of this._getCursorPaginatedList("/runs/query", body)) {
      if (limit) {
        if (runsYielded >= limit) {
          break;
        }
        if (runs.length + runsYielded > limit) {
          const newRuns = runs.slice(0, limit - runsYielded);
          yield* newRuns;
          break;
        }
        runsYielded += runs.length;
        yield* runs;
      } else {
        yield* runs;
      }
    }
  }
  async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {
    let projectIds_ = projectIds || [];
    if (projectNames) {
      projectIds_ = [
        ...projectIds || [],
        ...await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))
      ];
    }
    const payload = {
      id,
      trace,
      parent_run: parentRun,
      run_type: runType,
      session: projectIds_,
      reference_example: referenceExampleIds,
      start_time: startTime,
      end_time: endTime,
      error,
      query,
      filter,
      trace_filter: traceFilter,
      tree_filter: treeFilter,
      is_root: isRoot,
      data_source_type: dataSourceType
    };
    const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== void 0));
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/stats`, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(filteredPayload),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const result = await response.json();
    return result;
  }
  async shareRun(runId, { shareId } = {}) {
    const data = {
      run_id: runId,
      share_token: shareId || v4_default()
    };
    assertUuid(runId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {
      method: "PUT",
      headers: this.headers,
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      throw new Error("Invalid response from server");
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async unshareRun(runId) {
    assertUuid(runId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "unshare run", true);
  }
  async readRunSharedLink(runId) {
    assertUuid(runId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      return void 0;
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async listSharedRuns(shareToken, { runIds } = {}) {
    const queryParams = new URLSearchParams({
      share_token: shareToken
    });
    if (runIds !== void 0) {
      for (const runId of runIds) {
        queryParams.append("id", runId);
      }
    }
    assertUuid(shareToken);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const runs = await response.json();
    return runs;
  }
  async readDatasetSharedSchema(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    assertUuid(datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
    return shareSchema;
  }
  async shareDataset(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    const data = {
      dataset_id: datasetId
    };
    assertUuid(datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {
      method: "PUT",
      headers: this.headers,
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
    return shareSchema;
  }
  async unshareDataset(datasetId) {
    assertUuid(datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "unshare dataset", true);
  }
  async readSharedDataset(shareToken) {
    assertUuid(shareToken);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/datasets`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const dataset = await response.json();
    return dataset;
  }
  /**
   * Get shared examples.
   *
   * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.
   * @param {Object} [options] Additional options for listing the examples.
   * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.
   * @returns {Promise<Example[]>} The shared examples.
   */
  async listSharedExamples(shareToken, options) {
    const params = {};
    if (options == null ? void 0 : options.exampleIds) {
      params.id = options.exampleIds;
    }
    const urlParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        value.forEach((v) => urlParams.append(key, v));
      } else {
        urlParams.append(key, value);
      }
    });
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const result = await response.json();
    if (!response.ok) {
      if ("detail" in result) {
        throw new Error(`Failed to list shared examples.
Status: ${response.status}
Message: ${result.detail.join("\n")}`);
      }
      throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);
    }
    return result.map((example) => ({
      ...example,
      _hostUrl: this.getHostUrl()
    }));
  }
  async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {
    const upsert_ = upsert ? `?upsert=true` : "";
    const endpoint = `${this.apiUrl}/sessions${upsert_}`;
    const extra = projectExtra || {};
    if (metadata) {
      extra["metadata"] = metadata;
    }
    const body = {
      name: projectName,
      extra,
      description
    };
    if (referenceDatasetId !== null) {
      body["reference_dataset_id"] = referenceDatasetId;
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), endpoint, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create project");
    const result = await response.json();
    return result;
  }
  async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {
    const endpoint = `${this.apiUrl}/sessions/${projectId}`;
    let extra = projectExtra;
    if (metadata) {
      extra = { ...extra || {}, metadata };
    }
    const body = {
      name,
      extra,
      description,
      end_time: endTime ? new Date(endTime).toISOString() : null
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), endpoint, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update project");
    const result = await response.json();
    return result;
  }
  async hasProject({ projectId, projectName }) {
    let path = "/sessions";
    const params = new URLSearchParams();
    if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== void 0) {
      assertUuid(projectId);
      path += `/${projectId}`;
    } else if (projectName !== void 0) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${path}?${params}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    try {
      const result = await response.json();
      if (!response.ok) {
        return false;
      }
      if (Array.isArray(result)) {
        return result.length > 0;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  async readProject({ projectId, projectName, includeStats }) {
    let path = "/sessions";
    const params = new URLSearchParams();
    if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== void 0) {
      assertUuid(projectId);
      path += `/${projectId}`;
    } else if (projectName !== void 0) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    if (includeStats !== void 0) {
      params.append("include_stats", includeStats.toString());
    }
    const response = await this._get(path, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async getProjectUrl({ projectId, projectName }) {
    if (projectId === void 0 && projectName === void 0) {
      throw new Error("Must provide either projectName or projectId");
    }
    const project = await this.readProject({ projectId, projectName });
    const tenantId = await this._getTenantId();
    return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;
  }
  async getDatasetUrl({ datasetId, datasetName }) {
    if (datasetId === void 0 && datasetName === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const dataset = await this.readDataset({ datasetId, datasetName });
    const tenantId = await this._getTenantId();
    return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;
  }
  async _getTenantId() {
    if (this._tenantId !== null) {
      return this._tenantId;
    }
    const queryParams = new URLSearchParams({ limit: "1" });
    for await (const projects of this._getPaginated("/sessions", queryParams)) {
      this._tenantId = projects[0].tenant_id;
      return projects[0].tenant_id;
    }
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata } = {}) {
    const params = new URLSearchParams();
    if (projectIds !== void 0) {
      for (const projectId of projectIds) {
        params.append("id", projectId);
      }
    }
    if (name !== void 0) {
      params.append("name", name);
    }
    if (nameContains !== void 0) {
      params.append("name_contains", nameContains);
    }
    if (referenceDatasetId !== void 0) {
      params.append("reference_dataset", referenceDatasetId);
    } else if (referenceDatasetName !== void 0) {
      const dataset = await this.readDataset({
        datasetName: referenceDatasetName
      });
      params.append("reference_dataset", dataset.id);
    }
    if (referenceFree !== void 0) {
      params.append("reference_free", referenceFree.toString());
    }
    if (metadata !== void 0) {
      params.append("metadata", JSON.stringify(metadata));
    }
    for await (const projects of this._getPaginated("/sessions", params)) {
      yield* projects;
    }
  }
  async deleteProject({ projectId, projectName }) {
    let projectId_;
    if (projectId === void 0 && projectName === void 0) {
      throw new Error("Must provide projectName or projectId");
    } else if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId === void 0) {
      projectId_ = (await this.readProject({ projectName })).id;
    } else {
      projectId_ = projectId;
    }
    assertUuid(projectId_);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/sessions/${projectId_}`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `delete session ${projectId_} (${projectName})`, true);
  }
  async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {
    const url = `${this.apiUrl}/datasets/upload`;
    const formData = new FormData();
    formData.append("file", csvFile, fileName);
    inputKeys.forEach((key) => {
      formData.append("input_keys", key);
    });
    outputKeys.forEach((key) => {
      formData.append("output_keys", key);
    });
    if (description) {
      formData.append("description", description);
    }
    if (dataType) {
      formData.append("data_type", dataType);
    }
    if (name) {
      formData.append("name", name);
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), url, {
      method: "POST",
      headers: this.headers,
      body: formData,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "upload CSV");
    const result = await response.json();
    return result;
  }
  async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {
    const body = {
      name,
      description,
      extra: metadata ? { metadata } : void 0
    };
    if (dataType) {
      body.data_type = dataType;
    }
    if (inputsSchema) {
      body.inputs_schema_definition = inputsSchema;
    }
    if (outputsSchema) {
      body.outputs_schema_definition = outputsSchema;
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create dataset");
    const result = await response.json();
    return result;
  }
  async readDataset({ datasetId, datasetName }) {
    let path = "/datasets";
    const params = new URLSearchParams({ limit: "1" });
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId !== void 0) {
      assertUuid(datasetId);
      path += `/${datasetId}`;
    } else if (datasetName !== void 0) {
      params.append("name", datasetName);
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this._get(path, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async hasDataset({ datasetId, datasetName }) {
    try {
      await this.readDataset({ datasetId, datasetName });
      return true;
    } catch (e) {
      if (
        // eslint-disable-next-line no-instanceof/no-instanceof
        e instanceof Error && e.message.toLocaleLowerCase().includes("not found")
      ) {
        return false;
      }
      throw e;
    }
  }
  async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {
    let datasetId_ = datasetId;
    if (datasetId_ === void 0 && datasetName === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    const urlParams = new URLSearchParams({
      from_version: typeof fromVersion === "string" ? fromVersion : fromVersion.toISOString(),
      to_version: typeof toVersion === "string" ? toVersion : toVersion.toISOString()
    });
    const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);
    return response;
  }
  async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
    const path = "/datasets";
    if (datasetId !== void 0) {
    } else if (datasetName !== void 0) {
      datasetId = (await this.readDataset({ datasetName })).id;
    } else {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);
    const datasetText = await response.text();
    const dataset = datasetText.trim().split("\n").map((line) => JSON.parse(line));
    return dataset;
  }
  async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {
    const path = "/datasets";
    const params = new URLSearchParams({
      limit: limit.toString(),
      offset: offset.toString()
    });
    if (datasetIds !== void 0) {
      for (const id_ of datasetIds) {
        params.append("id", id_);
      }
    }
    if (datasetName !== void 0) {
      params.append("name", datasetName);
    }
    if (datasetNameContains !== void 0) {
      params.append("name_contains", datasetNameContains);
    }
    if (metadata !== void 0) {
      params.append("metadata", JSON.stringify(metadata));
    }
    for await (const datasets of this._getPaginated(path, params)) {
      yield* datasets;
    }
  }
  /**
   * Update a dataset
   * @param props The dataset details to update
   * @returns The updated dataset
   */
  async updateDataset(props) {
    const { datasetId, datasetName, ...update } = props;
    if (!datasetId && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const _datasetId = datasetId != null ? datasetId : (await this.readDataset({ datasetName })).id;
    assertUuid(_datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${_datasetId}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(update),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update dataset");
    return await response.json();
  }
  /**
   * Updates a tag on a dataset.
   *
   * If the tag is already assigned to a different version of this dataset,
   * the tag will be moved to the new version. The as_of parameter is used to
   * determine which version of the dataset to apply the new tags to.
   *
   * It must be an exact version of the dataset to succeed. You can
   * use the "readDatasetVersion" method to find the exact version
   * to apply the tags to.
   * @param params.datasetId The ID of the dataset to update. Must be provided if "datasetName" is not provided.
   * @param params.datasetName The name of the dataset to update. Must be provided if "datasetId" is not provided.
   * @param params.asOf The timestamp of the dataset to apply the new tags to.
   * @param params.tag The new tag to apply to the dataset.
   */
  async updateDatasetTag(props) {
    const { datasetId, datasetName, asOf, tag } = props;
    if (!datasetId && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    }
    const _datasetId = datasetId != null ? datasetId : (await this.readDataset({ datasetName })).id;
    assertUuid(_datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${_datasetId}/tags`, {
      method: "PUT",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify({
        as_of: typeof asOf === "string" ? asOf : asOf.toISOString(),
        tag
      }),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update dataset tags");
  }
  async deleteDataset({ datasetId, datasetName }) {
    let path = "/datasets";
    let datasetId_ = datasetId;
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetName !== void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    if (datasetId_ !== void 0) {
      assertUuid(datasetId_);
      path += `/${datasetId_}`;
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `delete ${path}`);
    await response.json();
  }
  async indexDataset({ datasetId, datasetName, tag }) {
    let datasetId_ = datasetId;
    if (!datasetId_ && !datasetName) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ && datasetName) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (!datasetId_) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    assertUuid(datasetId_);
    const data = {
      tag
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId_}/index`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "index dataset");
    await response.json();
  }
  /**
   * Lets you run a similarity search query on a dataset.
   *
   * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.
   *
   * @param inputs      The input on which to run the similarity search. Must have the
   *                    same schema as the dataset.
   *
   * @param datasetId   The dataset to search for similar examples.
   *
   * @param limit       The maximum number of examples to return. Will return the top `limit` most
   *                    similar examples in order of most similar to least similar. If no similar
   *                    examples are found, random examples will be returned.
   *
   * @param filter      A filter string to apply to the search. Only examples will be returned that
   *                    match the filter string. Some examples of filters
   *
   *                    - eq(metadata.mykey, "value")
   *                    - and(neq(metadata.my.nested.key, "value"), neq(metadata.mykey, "value"))
   *                    - or(eq(metadata.mykey, "value"), eq(metadata.mykey, "othervalue"))
   *
   * @returns           A list of similar examples.
   *
   *
   * @example
   * dataset_id = "123e4567-e89b-12d3-a456-426614174000"
   * inputs = {"text": "How many people live in Berlin?"}
   * limit = 5
   * examples = await client.similarExamples(inputs, dataset_id, limit)
   */
  async similarExamples(inputs, datasetId, limit, { filter } = {}) {
    const data = {
      limit,
      inputs
    };
    if (filter !== void 0) {
      data["filter"] = filter;
    }
    assertUuid(datasetId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/search`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "fetch similar examples");
    const result = await response.json();
    return result["examples"];
  }
  async createExample(inputsOrUpdate, outputs, options) {
    var _a, _b;
    if (isExampleCreate(inputsOrUpdate)) {
      if (outputs !== void 0 || options !== void 0) {
        throw new Error("Cannot provide outputs or options when using ExampleCreate object");
      }
    }
    let datasetId_ = outputs ? options == null ? void 0 : options.datasetId : inputsOrUpdate.dataset_id;
    const datasetName_ = outputs ? options == null ? void 0 : options.datasetName : inputsOrUpdate.dataset_name;
    if (datasetId_ === void 0 && datasetName_ === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName_ !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName: datasetName_ });
      datasetId_ = dataset.id;
    }
    const createdAt_ = (outputs ? options == null ? void 0 : options.createdAt : inputsOrUpdate.created_at) || new Date();
    let data;
    if (!isExampleCreate(inputsOrUpdate)) {
      data = {
        inputs: inputsOrUpdate,
        outputs,
        created_at: createdAt_ == null ? void 0 : createdAt_.toISOString(),
        id: options == null ? void 0 : options.exampleId,
        metadata: options == null ? void 0 : options.metadata,
        split: options == null ? void 0 : options.split,
        source_run_id: options == null ? void 0 : options.sourceRunId,
        use_source_run_io: options == null ? void 0 : options.useSourceRunIO,
        use_source_run_attachments: options == null ? void 0 : options.useSourceRunAttachments,
        attachments: options == null ? void 0 : options.attachments
      };
    } else {
      data = inputsOrUpdate;
    }
    const response = await this._uploadExamplesMultipart(datasetId_, [data]);
    const example = await this.readExample((_b = (_a = response.example_ids) == null ? void 0 : _a[0]) != null ? _b : v4_default());
    return example;
  }
  async createExamples(propsOrUploads) {
    if (Array.isArray(propsOrUploads)) {
      if (propsOrUploads.length === 0) {
        return [];
      }
      const uploads = propsOrUploads;
      let datasetId_2 = uploads[0].dataset_id;
      const datasetName_2 = uploads[0].dataset_name;
      if (datasetId_2 === void 0 && datasetName_2 === void 0) {
        throw new Error("Must provide either datasetName or datasetId");
      } else if (datasetId_2 !== void 0 && datasetName_2 !== void 0) {
        throw new Error("Must provide either datasetName or datasetId, not both");
      } else if (datasetId_2 === void 0) {
        const dataset = await this.readDataset({ datasetName: datasetName_2 });
        datasetId_2 = dataset.id;
      }
      const response2 = await this._uploadExamplesMultipart(datasetId_2, uploads);
      const examples2 = await Promise.all(response2.example_ids.map((id) => this.readExample(id)));
      return examples2;
    }
    const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName } = propsOrUploads;
    if (inputs === void 0) {
      throw new Error("Must provide inputs when using legacy parameters");
    }
    let datasetId_ = datasetId;
    const datasetName_ = datasetName;
    if (datasetId_ === void 0 && datasetName_ === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName_ !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName: datasetName_ });
      datasetId_ = dataset.id;
    }
    const formattedExamples = inputs.map((input, idx) => {
      return {
        dataset_id: datasetId_,
        inputs: input,
        outputs: outputs == null ? void 0 : outputs[idx],
        metadata: metadata == null ? void 0 : metadata[idx],
        split: splits == null ? void 0 : splits[idx],
        id: exampleIds == null ? void 0 : exampleIds[idx],
        attachments: attachments == null ? void 0 : attachments[idx],
        source_run_id: sourceRunIds == null ? void 0 : sourceRunIds[idx],
        use_source_run_io: useSourceRunIOs == null ? void 0 : useSourceRunIOs[idx],
        use_source_run_attachments: useSourceRunAttachments == null ? void 0 : useSourceRunAttachments[idx]
      };
    });
    const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);
    const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));
    return examples;
  }
  async createLLMExample(input, generation, options) {
    return this.createExample({ input }, { output: generation }, options);
  }
  async createChatExample(input, generations, options) {
    const finalInput = input.map((message) => {
      if (isLangChainMessage(message)) {
        return convertLangChainMessageToExample(message);
      }
      return message;
    });
    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;
    return this.createExample({ input: finalInput }, { output: finalOutput }, options);
  }
  async readExample(exampleId) {
    assertUuid(exampleId);
    const path = `/examples/${exampleId}`;
    const rawExample = await this._get(path);
    const { attachment_urls, ...rest } = rawExample;
    const example = rest;
    if (attachment_urls) {
      example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
        acc[key.slice("attachment.".length)] = {
          presigned_url: value.presigned_url,
          mime_type: value.mime_type
        };
        return acc;
      }, {});
    }
    return example;
  }
  async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments } = {}) {
    let datasetId_;
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId !== void 0) {
      datasetId_ = datasetId;
    } else if (datasetName !== void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      throw new Error("Must provide a datasetName or datasetId");
    }
    const params = new URLSearchParams({ dataset: datasetId_ });
    const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf == null ? void 0 : asOf.toISOString() : void 0;
    if (dataset_version) {
      params.append("as_of", dataset_version);
    }
    const inlineS3Urls_ = inlineS3Urls != null ? inlineS3Urls : true;
    params.append("inline_s3_urls", inlineS3Urls_.toString());
    if (exampleIds !== void 0) {
      for (const id_ of exampleIds) {
        params.append("id", id_);
      }
    }
    if (splits !== void 0) {
      for (const split of splits) {
        params.append("splits", split);
      }
    }
    if (metadata !== void 0) {
      const serializedMetadata = JSON.stringify(metadata);
      params.append("metadata", serializedMetadata);
    }
    if (limit !== void 0) {
      params.append("limit", limit.toString());
    }
    if (offset !== void 0) {
      params.append("offset", offset.toString());
    }
    if (filter !== void 0) {
      params.append("filter", filter);
    }
    if (includeAttachments === true) {
      ["attachment_urls", "outputs", "metadata"].forEach((field) => params.append("select", field));
    }
    let i = 0;
    for await (const rawExamples of this._getPaginated("/examples", params)) {
      for (const rawExample of rawExamples) {
        const { attachment_urls, ...rest } = rawExample;
        const example = rest;
        if (attachment_urls) {
          example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {
            acc[key.slice("attachment.".length)] = {
              presigned_url: value.presigned_url,
              mime_type: value.mime_type || void 0
            };
            return acc;
          }, {});
        }
        yield example;
        i++;
      }
      if (limit !== void 0 && i >= limit) {
        break;
      }
    }
  }
  async deleteExample(exampleId) {
    assertUuid(exampleId);
    const path = `/examples/${exampleId}`;
    const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `delete ${path}`);
    await response.json();
  }
  async updateExample(exampleIdOrUpdate, update) {
    let exampleId;
    if (update) {
      exampleId = exampleIdOrUpdate;
    } else {
      exampleId = exampleIdOrUpdate.id;
    }
    assertUuid(exampleId);
    let updateToUse;
    if (update) {
      updateToUse = { id: exampleId, ...update };
    } else {
      updateToUse = exampleIdOrUpdate;
    }
    let datasetId;
    if (updateToUse.dataset_id !== void 0) {
      datasetId = updateToUse.dataset_id;
    } else {
      const example = await this.readExample(exampleId);
      datasetId = example.dataset_id;
    }
    return this._updateExamplesMultipart(datasetId, [updateToUse]);
  }
  async updateExamples(update) {
    let datasetId;
    if (update[0].dataset_id === void 0) {
      const example = await this.readExample(update[0].id);
      datasetId = example.dataset_id;
    } else {
      datasetId = update[0].dataset_id;
    }
    return this._updateExamplesMultipart(datasetId, update);
  }
  /**
   * Get dataset version by closest date or exact tag.
   *
   * Use this to resolve the nearest version to a given timestamp or for a given tag.
   *
   * @param options The options for getting the dataset version
   * @param options.datasetId The ID of the dataset
   * @param options.datasetName The name of the dataset
   * @param options.asOf The timestamp of the dataset to retrieve
   * @param options.tag The tag of the dataset to retrieve
   * @returns The dataset version
   */
  async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {
    let resolvedDatasetId;
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      resolvedDatasetId = dataset.id;
    } else {
      resolvedDatasetId = datasetId;
    }
    assertUuid(resolvedDatasetId);
    if (asOf && tag || !asOf && !tag) {
      throw new Error("Exactly one of asOf and tag must be specified.");
    }
    const params = new URLSearchParams();
    if (asOf !== void 0) {
      params.append("as_of", typeof asOf === "string" ? asOf : asOf.toISOString());
    }
    if (tag !== void 0) {
      params.append("tag", tag);
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {
      method: "GET",
      headers: { ...this.headers },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "read dataset version");
    return await response.json();
  }
  async listDatasetSplits({ datasetId, datasetName, asOf }) {
    let datasetId_;
    if (datasetId === void 0 && datasetName === void 0) {
      throw new Error("Must provide dataset name or ID");
    } else if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      datasetId_ = datasetId;
    }
    assertUuid(datasetId_);
    const params = new URLSearchParams();
    const dataset_version = asOf ? typeof asOf === "string" ? asOf : asOf == null ? void 0 : asOf.toISOString() : void 0;
    if (dataset_version) {
      params.append("as_of", dataset_version);
    }
    const response = await this._get(`/datasets/${datasetId_}/splits`, params);
    return response;
  }
  async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {
    let datasetId_;
    if (datasetId === void 0 && datasetName === void 0) {
      throw new Error("Must provide dataset name or ID");
    } else if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      datasetId_ = datasetId;
    }
    assertUuid(datasetId_);
    const data = {
      split_name: splitName,
      examples: exampleIds.map((id) => {
        assertUuid(id);
        return id;
      }),
      remove
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId_}/splits`, {
      method: "PUT",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update dataset splits", true);
  }
  /**
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.
   */
  async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = { loadChildRuns: false }) {
    warnOnce("This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.");
    let run_;
    if (typeof run === "string") {
      run_ = await this.readRun(run, { loadChildRuns });
    } else if (typeof run === "object" && "id" in run) {
      run_ = run;
    } else {
      throw new Error(`Invalid run type: ${typeof run}`);
    }
    if (run_.reference_example_id !== null && run_.reference_example_id !== void 0) {
      referenceExample = await this.readExample(run_.reference_example_id);
    }
    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);
    const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);
    return feedbacks[0];
  }
  async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = "api", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {
    var _a;
    if (!runId && !projectId) {
      throw new Error("One of runId or projectId must be provided");
    }
    if (runId && projectId) {
      throw new Error("Only one of runId or projectId can be provided");
    }
    const feedback_source = {
      type: feedbackSourceType != null ? feedbackSourceType : "api",
      metadata: sourceInfo != null ? sourceInfo : {}
    };
    if (sourceRunId !== void 0 && (feedback_source == null ? void 0 : feedback_source.metadata) !== void 0 && !feedback_source.metadata["__run"]) {
      feedback_source.metadata["__run"] = { run_id: sourceRunId };
    }
    if ((feedback_source == null ? void 0 : feedback_source.metadata) !== void 0 && ((_a = feedback_source.metadata["__run"]) == null ? void 0 : _a.run_id) !== void 0) {
      assertUuid(feedback_source.metadata["__run"].run_id);
    }
    const feedback = {
      id: feedbackId != null ? feedbackId : v4_default(),
      run_id: runId,
      key,
      score: _formatFeedbackScore(score),
      value,
      correction,
      comment,
      feedback_source,
      comparative_experiment_id: comparativeExperimentId,
      feedbackConfig,
      session_id: projectId
    };
    const url = `${this.apiUrl}/feedback`;
    const response = await this.caller.call(_getFetchImplementation(this.debug), url, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(feedback),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create feedback", true);
    return feedback;
  }
  async updateFeedback(feedbackId, { score, value, correction, comment }) {
    const feedbackUpdate = {};
    if (score !== void 0 && score !== null) {
      feedbackUpdate["score"] = _formatFeedbackScore(score);
    }
    if (value !== void 0 && value !== null) {
      feedbackUpdate["value"] = value;
    }
    if (correction !== void 0 && correction !== null) {
      feedbackUpdate["correction"] = correction;
    }
    if (comment !== void 0 && comment !== null) {
      feedbackUpdate["comment"] = comment;
    }
    assertUuid(feedbackId);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/feedback/${feedbackId}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(feedbackUpdate),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update feedback", true);
  }
  async readFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path = `/feedback/${feedbackId}`;
    const response = await this._get(path);
    return response;
  }
  async deleteFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path = `/feedback/${feedbackId}`;
    const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `delete ${path}`);
    await response.json();
  }
  async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
    const queryParams = new URLSearchParams();
    if (runIds) {
      queryParams.append("run", runIds.join(","));
    }
    if (feedbackKeys) {
      for (const key of feedbackKeys) {
        queryParams.append("key", key);
      }
    }
    if (feedbackSourceTypes) {
      for (const type of feedbackSourceTypes) {
        queryParams.append("source", type);
      }
    }
    for await (const feedbacks of this._getPaginated("/feedback", queryParams)) {
      yield* feedbacks;
    }
  }
  /**
   * Creates a presigned feedback token and URL.
   *
   * The token can be used to authorize feedback metrics without
   * needing an API key. This is useful for giving browser-based
   * applications the ability to submit feedback without needing
   * to expose an API key.
   *
   * @param runId The ID of the run.
   * @param feedbackKey The feedback key.
   * @param options Additional options for the token.
   * @param options.expiration The expiration time for the token.
   *
   * @returns A promise that resolves to a FeedbackIngestToken.
   */
  async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {
    const body = {
      run_id: runId,
      feedback_key: feedbackKey,
      feedback_config: feedbackConfig
    };
    if (expiration) {
      if (typeof expiration === "string") {
        body["expires_at"] = expiration;
      } else if ((expiration == null ? void 0 : expiration.hours) || (expiration == null ? void 0 : expiration.minutes) || (expiration == null ? void 0 : expiration.days)) {
        body["expires_in"] = expiration;
      }
    } else {
      body["expires_in"] = {
        hours: 3
      };
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/feedback/tokens`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const result = await response.json();
    return result;
  }
  async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {
    var _a;
    if (experimentIds.length === 0) {
      throw new Error("At least one experiment is required");
    }
    if (!referenceDatasetId) {
      referenceDatasetId = (await this.readProject({
        projectId: experimentIds[0]
      })).reference_dataset_id;
    }
    if (!referenceDatasetId == null) {
      throw new Error("A reference dataset is required");
    }
    const body = {
      id,
      name,
      experiment_ids: experimentIds,
      reference_dataset_id: referenceDatasetId,
      description,
      created_at: (_a = createdAt != null ? createdAt : new Date()) == null ? void 0 : _a.toISOString(),
      extra: {}
    };
    if (metadata)
      body.extra["metadata"] = metadata;
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/comparative`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await response.json();
  }
  /**
   * Retrieves a list of presigned feedback tokens for a given run ID.
   * @param runId The ID of the run.
   * @returns An async iterable of FeedbackIngestToken objects.
   */
  async *listPresignedFeedbackTokens(runId) {
    assertUuid(runId);
    const params = new URLSearchParams({ run_id: runId });
    for await (const tokens of this._getPaginated("/feedback/tokens", params)) {
      yield* tokens;
    }
  }
  _selectEvalResults(results) {
    let results_;
    if ("results" in results) {
      results_ = results.results;
    } else if (Array.isArray(results)) {
      results_ = results;
    } else {
      results_ = [results];
    }
    return results_;
  }
  async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
    const evalResults = this._selectEvalResults(evaluatorResponse);
    const feedbacks = [];
    for (const res of evalResults) {
      let sourceInfo_ = sourceInfo || {};
      if (res.evaluatorInfo) {
        sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };
      }
      let runId_ = null;
      if (res.targetRunId) {
        runId_ = res.targetRunId;
      } else if (run) {
        runId_ = run.id;
      }
      feedbacks.push(await this.createFeedback(runId_, res.key, {
        score: res.score,
        value: res.value,
        comment: res.comment,
        correction: res.correction,
        sourceInfo: sourceInfo_,
        sourceRunId: res.sourceRunId,
        feedbackConfig: res.feedbackConfig,
        feedbackSourceType: "model"
      }));
    }
    return [evalResults, feedbacks];
  }
  async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {
    const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);
    return results;
  }
  /**
   * API for managing annotation queues
   */
  /**
   * List the annotation queues on the LangSmith API.
   * @param options - The options for listing annotation queues
   * @param options.queueIds - The IDs of the queues to filter by
   * @param options.name - The name of the queue to filter by
   * @param options.nameContains - The substring that the queue name should contain
   * @param options.limit - The maximum number of queues to return
   * @returns An iterator of AnnotationQueue objects
   */
  async *listAnnotationQueues(options = {}) {
    const { queueIds, name, nameContains, limit } = options;
    const params = new URLSearchParams();
    if (queueIds) {
      queueIds.forEach((id, i) => {
        assertUuid(id, `queueIds[${i}]`);
        params.append("ids", id);
      });
    }
    if (name)
      params.append("name", name);
    if (nameContains)
      params.append("name_contains", nameContains);
    params.append("limit", (limit !== void 0 ? Math.min(limit, 100) : 100).toString());
    let count = 0;
    for await (const queues of this._getPaginated("/annotation-queues", params)) {
      yield* queues;
      count++;
      if (limit !== void 0 && count >= limit)
        break;
    }
  }
  /**
   * Create an annotation queue on the LangSmith API.
   * @param options - The options for creating an annotation queue
   * @param options.name - The name of the annotation queue
   * @param options.description - The description of the annotation queue
   * @param options.queueId - The ID of the annotation queue
   * @returns The created AnnotationQueue object
   */
  async createAnnotationQueue(options) {
    const { name, description, queueId, rubricInstructions } = options;
    const body = {
      name,
      description,
      id: queueId || v4_default(),
      rubric_instructions: rubricInstructions
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== void 0))),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create annotation queue");
    const data = await response.json();
    return data;
  }
  /**
   * Read an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to read
   * @returns The AnnotationQueueWithDetails object
   */
  async readAnnotationQueue(queueId) {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "read annotation queue");
    const data = await response.json();
    return data;
  }
  /**
   * Update an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to update
   * @param options - The options for updating the annotation queue
   * @param options.name - The new name for the annotation queue
   * @param options.description - The new description for the annotation queue
   */
  async updateAnnotationQueue(queueId, options) {
    const { name, description, rubricInstructions } = options;
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify({
        name,
        description,
        rubric_instructions: rubricInstructions
      }),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update annotation queue");
  }
  /**
   * Delete an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue to delete
   */
  async deleteAnnotationQueue(queueId) {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}`, {
      method: "DELETE",
      headers: { ...this.headers, Accept: "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "delete annotation queue");
  }
  /**
   * Add runs to an annotation queue with the specified queue ID.
   * @param queueId - The ID of the annotation queue
   * @param runIds - The IDs of the runs to be added to the annotation queue
   */
  async addRunsToAnnotationQueue(queueId, runIds) {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(runIds.map((id, i) => assertUuid(id, `runIds[${i}]`).toString())),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "add runs to annotation queue");
  }
  /**
   * Get a run from an annotation queue at the specified index.
   * @param queueId - The ID of the annotation queue
   * @param index - The index of the run to retrieve
   * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object
   * @throws {Error} If the run is not found at the given index or for other API-related errors
   */
  async getRunFromAnnotationQueue(queueId, index) {
    const baseUrl = `/annotation-queues/${assertUuid(queueId, "queueId")}/run`;
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${baseUrl}/${index}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "get run from annotation queue");
    return await response.json();
  }
  /**
   * Delete a run from an an annotation queue.
   * @param queueId - The ID of the annotation queue to delete the run from
   * @param queueRunId - The ID of the run to delete from the annotation queue
   */
  async deleteRunFromAnnotationQueue(queueId, queueRunId) {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/runs/${assertUuid(queueRunId, "queueRunId")}`, {
      method: "DELETE",
      headers: { ...this.headers, Accept: "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "delete run from annotation queue");
  }
  /**
   * Get the size of an annotation queue.
   * @param queueId - The ID of the annotation queue
   */
  async getSizeFromAnnotationQueue(queueId) {
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, "queueId")}/size`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "get size from annotation queue");
    return await response.json();
  }
  async _currentTenantIsOwner(owner) {
    const settings = await this._getSettings();
    return owner == "-" || settings.tenant_handle === owner;
  }
  async _ownerConflictError(action, owner) {
    const settings = await this._getSettings();
    return new Error(`Cannot ${action} for another tenant.

      Current tenant: ${settings.tenant_handle}

      Requested tenant: ${owner}`);
  }
  async _getLatestCommitHash(promptOwnerAndName) {
    const res = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    const json = await res.json();
    if (!res.ok) {
      const detail = typeof json.detail === "string" ? json.detail : JSON.stringify(json.detail);
      const error = new Error(`Error ${res.status}: ${res.statusText}
${detail}`);
      error.statusCode = res.status;
      throw error;
    }
    if (json.commits.length === 0) {
      return void 0;
    }
    return json.commits[0].commit_hash;
  }
  async _likeOrUnlikePrompt(promptIdentifier, like) {
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/likes/${owner}/${promptName}`, {
      method: "POST",
      body: JSON.stringify({ like }),
      headers: { ...this.headers, "Content-Type": "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, `${like ? "like" : "unlike"} prompt`);
    return await response.json();
  }
  async _getPromptUrl(promptIdentifier) {
    const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      if (commitHash !== "latest") {
        return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;
      } else {
        return `${this.getHostUrl()}/hub/${owner}/${promptName}`;
      }
    } else {
      const settings = await this._getSettings();
      if (commitHash !== "latest") {
        return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;
      } else {
        return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;
      }
    }
  }
  async promptExists(promptIdentifier) {
    const prompt = await this.getPrompt(promptIdentifier);
    return !!prompt;
  }
  async likePrompt(promptIdentifier) {
    return this._likeOrUnlikePrompt(promptIdentifier, true);
  }
  async unlikePrompt(promptIdentifier) {
    return this._likeOrUnlikePrompt(promptIdentifier, false);
  }
  async *listCommits(promptOwnerAndName) {
    for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {
      yield* commits;
    }
  }
  async *listPrompts(options) {
    var _a;
    const params = new URLSearchParams();
    params.append("sort_field", (_a = options == null ? void 0 : options.sortField) != null ? _a : "updated_at");
    params.append("sort_direction", "desc");
    params.append("is_archived", (!!(options == null ? void 0 : options.isArchived)).toString());
    if ((options == null ? void 0 : options.isPublic) !== void 0) {
      params.append("is_public", options.isPublic.toString());
    }
    if (options == null ? void 0 : options.query) {
      params.append("query", options.query);
    }
    for await (const prompts of this._getPaginated("/repos", params, (res) => res.repos)) {
      yield* prompts;
    }
  }
  async getPrompt(promptIdentifier) {
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    if (response.status === 404) {
      return null;
    }
    await raiseForStatus(response, "get prompt");
    const result = await response.json();
    if (result.repo) {
      return result.repo;
    } else {
      return null;
    }
  }
  async createPrompt(promptIdentifier, options) {
    const settings = await this._getSettings();
    if ((options == null ? void 0 : options.isPublic) && !settings.tenant_handle) {
      throw new Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle. 
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("create a prompt", owner);
    }
    const data = {
      repo_handle: promptName,
      ...(options == null ? void 0 : options.description) && { description: options.description },
      ...(options == null ? void 0 : options.readme) && { readme: options.readme },
      ...(options == null ? void 0 : options.tags) && { tags: options.tags },
      is_public: !!(options == null ? void 0 : options.isPublic)
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create prompt");
    const { repo } = await response.json();
    return repo;
  }
  async createCommit(promptIdentifier, object, options) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    const resolvedParentCommitHash = (options == null ? void 0 : options.parentCommitHash) === "latest" || !(options == null ? void 0 : options.parentCommitHash) ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options == null ? void 0 : options.parentCommitHash;
    const payload = {
      manifest: JSON.parse(JSON.stringify(object)),
      parent_commit: resolvedParentCommitHash
    };
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${owner}/${promptName}`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "create commit");
    const result = await response.json();
    return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : ""}`);
  }
  /**
   * Update examples with attachments using multipart form data.
   * @param updates List of ExampleUpdateWithAttachments objects to upsert
   * @returns Promise with the update response
   */
  async updateExamplesMultipart(datasetId, updates = []) {
    return this._updateExamplesMultipart(datasetId, updates);
  }
  async _updateExamplesMultipart(datasetId, updates = []) {
    var _a;
    if (!await this._getMultiPartSupport()) {
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    }
    const formData = new FormData();
    for (const example of updates) {
      const exampleId = example.id;
      const exampleBody = {
        ...example.metadata && { metadata: example.metadata },
        ...example.split && { split: example.split }
      };
      const stringifiedExample = serialize(exampleBody);
      const exampleBlob = new Blob([stringifiedExample], {
        type: "application/json"
      });
      formData.append(exampleId, exampleBlob);
      if (example.inputs) {
        const stringifiedInputs = serialize(example.inputs);
        const inputsBlob = new Blob([stringifiedInputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.inputs`, inputsBlob);
      }
      if (example.outputs) {
        const stringifiedOutputs = serialize(example.outputs);
        const outputsBlob = new Blob([stringifiedOutputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.outputs`, outputsBlob);
      }
      if (example.attachments) {
        for (const [name, attachment] of Object.entries(example.attachments)) {
          let mimeType;
          let data;
          if (Array.isArray(attachment)) {
            [mimeType, data] = attachment;
          } else {
            mimeType = attachment.mimeType;
            data = attachment.data;
          }
          const attachmentBlob = new Blob([data], {
            type: `${mimeType}; length=${data.byteLength}`
          });
          formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
        }
      }
      if (example.attachments_operations) {
        const stringifiedAttachmentsOperations = serialize(example.attachments_operations);
        const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {
          type: "application/json"
        });
        formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);
      }
    }
    const datasetIdToUse = datasetId != null ? datasetId : (_a = updates[0]) == null ? void 0 : _a.dataset_id;
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/v1/platform/datasets/${datasetIdToUse}/examples`, {
      method: "PATCH",
      headers: this.headers,
      body: formData
    });
    const result = await response.json();
    return result;
  }
  /**
   * Upload examples with attachments using multipart form data.
   * @param uploads List of ExampleUploadWithAttachments objects to upload
   * @returns Promise with the upload response
   * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead
   */
  async uploadExamplesMultipart(datasetId, uploads = []) {
    return this._uploadExamplesMultipart(datasetId, uploads);
  }
  async _uploadExamplesMultipart(datasetId, uploads = []) {
    var _a;
    if (!await this._getMultiPartSupport()) {
      throw new Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");
    }
    const formData = new FormData();
    for (const example of uploads) {
      const exampleId = ((_a = example.id) != null ? _a : v4_default()).toString();
      const exampleBody = {
        created_at: example.created_at,
        ...example.metadata && { metadata: example.metadata },
        ...example.split && { split: example.split },
        ...example.source_run_id && { source_run_id: example.source_run_id },
        ...example.use_source_run_io && {
          use_source_run_io: example.use_source_run_io
        },
        ...example.use_source_run_attachments && {
          use_source_run_attachments: example.use_source_run_attachments
        }
      };
      const stringifiedExample = serialize(exampleBody);
      const exampleBlob = new Blob([stringifiedExample], {
        type: "application/json"
      });
      formData.append(exampleId, exampleBlob);
      if (example.inputs) {
        const stringifiedInputs = serialize(example.inputs);
        const inputsBlob = new Blob([stringifiedInputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.inputs`, inputsBlob);
      }
      if (example.outputs) {
        const stringifiedOutputs = serialize(example.outputs);
        const outputsBlob = new Blob([stringifiedOutputs], {
          type: "application/json"
        });
        formData.append(`${exampleId}.outputs`, outputsBlob);
      }
      if (example.attachments) {
        for (const [name, attachment] of Object.entries(example.attachments)) {
          let mimeType;
          let data;
          if (Array.isArray(attachment)) {
            [mimeType, data] = attachment;
          } else {
            mimeType = attachment.mimeType;
            data = attachment.data;
          }
          const attachmentBlob = new Blob([data], {
            type: `${mimeType}; length=${data.byteLength}`
          });
          formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);
        }
      }
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/v1/platform/datasets/${datasetId}/examples`, {
      method: "POST",
      headers: this.headers,
      body: formData
    });
    await raiseForStatus(response, "upload examples");
    const result = await response.json();
    return result;
  }
  async updatePrompt(promptIdentifier, options) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("update a prompt", owner);
    }
    const payload = {};
    if ((options == null ? void 0 : options.description) !== void 0)
      payload.description = options.description;
    if ((options == null ? void 0 : options.readme) !== void 0)
      payload.readme = options.readme;
    if ((options == null ? void 0 : options.tags) !== void 0)
      payload.tags = options.tags;
    if ((options == null ? void 0 : options.isPublic) !== void 0)
      payload.is_public = options.isPublic;
    if ((options == null ? void 0 : options.isArchived) !== void 0)
      payload.is_archived = options.isArchived;
    if (Object.keys(payload).length === 0) {
      throw new Error("No valid update options provided");
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {
      method: "PATCH",
      body: JSON.stringify(payload),
      headers: {
        ...this.headers,
        "Content-Type": "application/json"
      },
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "update prompt");
    return response.json();
  }
  async deletePrompt(promptIdentifier) {
    if (!await this.promptExists(promptIdentifier)) {
      throw new Error("Prompt does not exist, you must create it first.");
    }
    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);
    if (!await this._currentTenantIsOwner(owner)) {
      throw await this._ownerConflictError("delete a prompt", owner);
    }
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    return await response.json();
  }
  async pullPromptCommit(promptIdentifier, options) {
    const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);
    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${(options == null ? void 0 : options.includeModel) ? "?include_model=true" : ""}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms),
      ...this.fetchOptions
    });
    await raiseForStatus(response, "pull prompt commit");
    const result = await response.json();
    return {
      owner,
      repo: promptName,
      commit_hash: result.commit_hash,
      manifest: result.manifest,
      examples: result.examples
    };
  }
  /**
   * This method should not be used directly, use `import { pull } from "langchain/hub"` instead.
   * Using this method directly returns the JSON string of the prompt rather than a LangChain object.
   * @private
   */
  async _pullPrompt(promptIdentifier, options) {
    const promptObject = await this.pullPromptCommit(promptIdentifier, {
      includeModel: options == null ? void 0 : options.includeModel
    });
    const prompt = JSON.stringify(promptObject.manifest);
    return prompt;
  }
  async pushPrompt(promptIdentifier, options) {
    if (await this.promptExists(promptIdentifier)) {
      if (options && Object.keys(options).some((key) => key !== "object")) {
        await this.updatePrompt(promptIdentifier, {
          description: options == null ? void 0 : options.description,
          readme: options == null ? void 0 : options.readme,
          tags: options == null ? void 0 : options.tags,
          isPublic: options == null ? void 0 : options.isPublic
        });
      }
    } else {
      await this.createPrompt(promptIdentifier, {
        description: options == null ? void 0 : options.description,
        readme: options == null ? void 0 : options.readme,
        tags: options == null ? void 0 : options.tags,
        isPublic: options == null ? void 0 : options.isPublic
      });
    }
    if (!(options == null ? void 0 : options.object)) {
      return await this._getPromptUrl(promptIdentifier);
    }
    const url = await this.createCommit(promptIdentifier, options == null ? void 0 : options.object, {
      parentCommitHash: options == null ? void 0 : options.parentCommitHash
    });
    return url;
  }
  /**
     * Clone a public dataset to your own langsmith tenant.
     * This operation is idempotent. If you already have a dataset with the given name,
     * this function will do nothing.
  
     * @param {string} tokenOrUrl The token of the public dataset to clone.
     * @param {Object} [options] Additional options for cloning the dataset.
     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.
     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.
     * @returns {Promise<void>}
     */
  async clonePublicDataset(tokenOrUrl, options = {}) {
    var _a, _b;
    const { sourceApiUrl = this.apiUrl, datasetName } = options;
    const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);
    const sourceClient = new Client({
      apiUrl: parsedApiUrl,
      // Placeholder API key not needed anymore in most cases, but
      // some private deployments may have API key-based rate limiting
      // that would cause this to fail if we provide no value.
      apiKey: "placeholder"
    });
    const ds = await sourceClient.readSharedDataset(tokenUuid);
    const finalDatasetName = datasetName || ds.name;
    try {
      if (await this.hasDataset({ datasetId: finalDatasetName })) {
        console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);
        return;
      }
    } catch (_) {
    }
    const examples = await sourceClient.listSharedExamples(tokenUuid);
    const dataset = await this.createDataset(finalDatasetName, {
      description: ds.description,
      dataType: ds.data_type || "kv",
      inputsSchema: (_a = ds.inputs_schema_definition) != null ? _a : void 0,
      outputsSchema: (_b = ds.outputs_schema_definition) != null ? _b : void 0
    });
    try {
      await this.createExamples({
        inputs: examples.map((e) => e.inputs),
        outputs: examples.flatMap((e) => e.outputs ? [e.outputs] : []),
        datasetId: dataset.id
      });
    } catch (e) {
      console.error(`An error occurred while creating dataset ${finalDatasetName}. You should delete it manually.`);
      throw e;
    }
  }
  parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = "dataset") {
    try {
      assertUuid(urlOrToken);
      return [apiUrl, urlOrToken];
    } catch (_) {
    }
    try {
      const parsedUrl = new URL(urlOrToken);
      const pathParts = parsedUrl.pathname.split("/").filter((part) => part !== "");
      if (pathParts.length >= numParts) {
        const tokenUuid = pathParts[pathParts.length - numParts];
        return [apiUrl, tokenUuid];
      } else {
        throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);
      }
    } catch (error) {
      throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);
    }
  }
  /**
   * Awaits all pending trace batches. Useful for environments where
   * you need to be sure that all tracing requests finish before execution ends,
   * such as serverless environments.
   *
   * @example
   * ```
   * import { Client } from "langsmith";
   *
   * const client = new Client();
   *
   * try {
   *   // Tracing happens here
   *   ...
   * } finally {
   *   await client.awaitPendingTraceBatches();
   * }
   * ```
   *
   * @returns A promise that resolves once all currently pending traces have sent.
   */
  awaitPendingTraceBatches() {
    if (this.manualFlushMode) {
      console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.");
      return Promise.resolve();
    }
    return Promise.all([
      ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),
      this.batchIngestCaller.queue.onIdle()
    ]);
  }
};
function isExampleCreate(input) {
  return "dataset_id" in input || "dataset_name" in input;
}

// node_modules/langsmith/dist/index.js
var __version__ = "0.3.25";

// node_modules/langsmith/dist/utils/env.js
var globalEnv;
var isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var isJsDom = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
var isDeno = () => typeof Deno !== "undefined";
var isNode = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno();
var getEnv = () => {
  if (globalEnv) {
    return globalEnv;
  }
  if (isBrowser()) {
    globalEnv = "browser";
  } else if (isNode()) {
    globalEnv = "node";
  } else if (isWebWorker()) {
    globalEnv = "webworker";
  } else if (isJsDom()) {
    globalEnv = "jsdom";
  } else if (isDeno()) {
    globalEnv = "deno";
  } else {
    globalEnv = "other";
  }
  return globalEnv;
};
var runtimeEnvironment;
function getRuntimeEnvironment() {
  if (runtimeEnvironment === void 0) {
    const env = getEnv();
    const releaseEnv = getShas();
    runtimeEnvironment = {
      library: "langsmith",
      runtime: env,
      sdk: "langsmith-js",
      sdk_version: __version__,
      ...releaseEnv
    };
  }
  return runtimeEnvironment;
}
function getLangChainEnvVarsMetadata() {
  const allEnvVars = getEnvironmentVariables() || {};
  const envVars = {};
  const excluded = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION",
    "LANGSMITH_API_KEY",
    "LANGSMITH_ENDPOINT",
    "LANGSMITH_TRACING_V2",
    "LANGSMITH_PROJECT",
    "LANGSMITH_SESSION"
  ];
  for (const [key, value] of Object.entries(allEnvVars)) {
    if ((key.startsWith("LANGCHAIN_") || key.startsWith("LANGSMITH_")) && typeof value === "string" && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
      if (key === "LANGCHAIN_REVISION_ID") {
        envVars["revision_id"] = value;
      } else {
        envVars[key] = value;
      }
    }
  }
  return envVars;
}
function getEnvironmentVariables() {
  try {
    if (typeof process !== "undefined" && process.env) {
      return Object.entries(process.env).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {});
    }
    return void 0;
  } catch (e) {
    return void 0;
  }
}
function getEnvironmentVariable(name) {
  var _a;
  try {
    return typeof process !== "undefined" ? (
      // eslint-disable-next-line no-process-env
      (_a = process.env) == null ? void 0 : _a[name]
    ) : void 0;
  } catch (e) {
    return void 0;
  }
}
function getLangSmithEnvironmentVariable(name) {
  return getEnvironmentVariable(`LANGSMITH_${name}`) || getEnvironmentVariable(`LANGCHAIN_${name}`);
}
var cachedCommitSHAs;
function getShas() {
  if (cachedCommitSHAs !== void 0) {
    return cachedCommitSHAs;
  }
  const common_release_envs = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ];
  const shas = {};
  for (const env of common_release_envs) {
    const envVar = getEnvironmentVariable(env);
    if (envVar !== void 0) {
      shas[env] = envVar;
    }
  }
  cachedCommitSHAs = shas;
  return shas;
}

// node_modules/langsmith/dist/env.js
var isTracingEnabled = (tracingEnabled) => {
  if (tracingEnabled !== void 0) {
    return tracingEnabled;
  }
  const envVars = ["TRACING_V2", "TRACING"];
  return !!envVars.find((envVar) => getLangSmithEnvironmentVariable(envVar) === "true");
};

// node_modules/langsmith/dist/singletons/constants.js
var _LC_CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");

// node_modules/langsmith/dist/run_trees.js
function stripNonAlphanumeric(input) {
  return input.replace(/[-:.]/g, "");
}
function convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {
  const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
  return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;
}
var Baggage = class {
  constructor(metadata, tags, project_name) {
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "project_name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.metadata = metadata;
    this.tags = tags;
    this.project_name = project_name;
  }
  static fromHeader(value) {
    const items = value.split(",");
    let metadata = {};
    let tags = [];
    let project_name;
    for (const item of items) {
      const [key, uriValue] = item.split("=");
      const value2 = decodeURIComponent(uriValue);
      if (key === "langsmith-metadata") {
        metadata = JSON.parse(value2);
      } else if (key === "langsmith-tags") {
        tags = value2.split(",");
      } else if (key === "langsmith-project") {
        project_name = value2;
      }
    }
    return new Baggage(metadata, tags, project_name);
  }
  toHeader() {
    const items = [];
    if (this.metadata && Object.keys(this.metadata).length > 0) {
      items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);
    }
    if (this.tags && this.tags.length > 0) {
      items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(","))}`);
    }
    if (this.project_name) {
      items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);
    }
    return items.join(",");
  }
};
var RunTree = class {
  constructor(originalConfig) {
    var _a, _b, _c, _d, _e;
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "run_type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "project_name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "parent_run", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "child_runs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "start_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "end_time", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "extra", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "error", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "serialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "inputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "outputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "reference_example_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "events", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "trace_id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "dotted_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tracingEnabled", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "execution_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "child_execution_order", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "attachments", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (isRunTree(originalConfig)) {
      Object.assign(this, { ...originalConfig });
      return;
    }
    const defaultConfig = RunTree.getDefaultConfig();
    const { metadata, ...config } = originalConfig;
    const client2 = (_a = config.client) != null ? _a : RunTree.getSharedClient();
    const dedupedMetadata = {
      ...metadata,
      ...(_b = config == null ? void 0 : config.extra) == null ? void 0 : _b.metadata
    };
    config.extra = { ...config.extra, metadata: dedupedMetadata };
    Object.assign(this, { ...defaultConfig, ...config, client: client2 });
    if (!this.trace_id) {
      if (this.parent_run) {
        this.trace_id = (_c = this.parent_run.trace_id) != null ? _c : this.id;
      } else {
        this.trace_id = this.id;
      }
    }
    (_d = this.execution_order) != null ? _d : this.execution_order = 1;
    (_e = this.child_execution_order) != null ? _e : this.child_execution_order = 1;
    if (!this.dotted_order) {
      const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);
      if (this.parent_run) {
        this.dotted_order = this.parent_run.dotted_order + "." + currentDottedOrder;
      } else {
        this.dotted_order = currentDottedOrder;
      }
    }
  }
  static getDefaultConfig() {
    var _a, _b, _c;
    return {
      id: v4_default(),
      run_type: "chain",
      project_name: (_b = (_a = getLangSmithEnvironmentVariable("PROJECT")) != null ? _a : getEnvironmentVariable("LANGCHAIN_SESSION")) != null ? _b : (
        // TODO: Deprecate
        "default"
      ),
      child_runs: [],
      api_url: (_c = getEnvironmentVariable("LANGCHAIN_ENDPOINT")) != null ? _c : "http://localhost:1984",
      api_key: getEnvironmentVariable("LANGCHAIN_API_KEY"),
      caller_options: {},
      start_time: Date.now(),
      serialized: {},
      inputs: {},
      extra: {}
    };
  }
  static getSharedClient() {
    if (!RunTree.sharedClient) {
      RunTree.sharedClient = new Client();
    }
    return RunTree.sharedClient;
  }
  createChild(config) {
    var _a, _b, _c, _d, _e, _f, _g;
    const child_execution_order = this.child_execution_order + 1;
    const child = new RunTree({
      ...config,
      parent_run: this,
      project_name: this.project_name,
      client: this.client,
      tracingEnabled: this.tracingEnabled,
      execution_order: child_execution_order,
      child_execution_order
    });
    if (_LC_CONTEXT_VARIABLES_KEY in this) {
      child[_LC_CONTEXT_VARIABLES_KEY] = this[_LC_CONTEXT_VARIABLES_KEY];
    }
    const LC_CHILD = Symbol.for("lc:child_config");
    const presentConfig = (_b = (_a = config.extra) == null ? void 0 : _a[LC_CHILD]) != null ? _b : this.extra[LC_CHILD];
    if (isRunnableConfigLike(presentConfig)) {
      const newConfig = { ...presentConfig };
      const callbacks = isCallbackManagerLike(newConfig.callbacks) ? (_d = (_c = newConfig.callbacks).copy) == null ? void 0 : _d.call(_c) : void 0;
      if (callbacks) {
        Object.assign(callbacks, { _parentRunId: child.id });
        (_g = (_f = (_e = callbacks.handlers) == null ? void 0 : _e.find(isLangChainTracerLike)) == null ? void 0 : _f.updateFromRunTree) == null ? void 0 : _g.call(_f, child);
        newConfig.callbacks = callbacks;
      }
      child.extra[LC_CHILD] = newConfig;
    }
    const visited = /* @__PURE__ */ new Set();
    let current = this;
    while (current != null && !visited.has(current.id)) {
      visited.add(current.id);
      current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);
      current = current.parent_run;
    }
    this.child_runs.push(child);
    return child;
  }
  async end(outputs, error, endTime = Date.now(), metadata) {
    var _a, _b, _c;
    this.outputs = (_a = this.outputs) != null ? _a : outputs;
    this.error = (_b = this.error) != null ? _b : error;
    this.end_time = (_c = this.end_time) != null ? _c : endTime;
    if (metadata && Object.keys(metadata).length > 0) {
      this.extra = this.extra ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } } : { metadata };
    }
  }
  _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {
    var _a, _b;
    const runExtra = (_a = run.extra) != null ? _a : {};
    if (!runExtra.runtime) {
      runExtra.runtime = {};
    }
    if (runtimeEnv) {
      for (const [k, v] of Object.entries(runtimeEnv)) {
        if (!runExtra.runtime[k]) {
          runExtra.runtime[k] = v;
        }
      }
    }
    let child_runs;
    let parent_run_id;
    if (!excludeChildRuns) {
      child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));
      parent_run_id = void 0;
    } else {
      parent_run_id = (_b = run.parent_run) == null ? void 0 : _b.id;
      child_runs = [];
    }
    const persistedRun = {
      id: run.id,
      name: run.name,
      start_time: run.start_time,
      end_time: run.end_time,
      run_type: run.run_type,
      reference_example_id: run.reference_example_id,
      extra: runExtra,
      serialized: run.serialized,
      error: run.error,
      inputs: run.inputs,
      outputs: run.outputs,
      session_name: run.project_name,
      child_runs,
      parent_run_id,
      trace_id: run.trace_id,
      dotted_order: run.dotted_order,
      tags: run.tags,
      attachments: run.attachments
    };
    return persistedRun;
  }
  async postRun(excludeChildRuns = true) {
    try {
      const runtimeEnv = getRuntimeEnvironment();
      const runCreate = await this._convertToCreate(this, runtimeEnv, true);
      await this.client.createRun(runCreate);
      if (!excludeChildRuns) {
        warnOnce("Posting with excludeChildRuns=false is deprecated and will be removed in a future version.");
        for (const childRun of this.child_runs) {
          await childRun.postRun(false);
        }
      }
    } catch (error) {
      console.error(`Error in postRun for run ${this.id}:`, error);
    }
  }
  async patchRun() {
    var _a;
    try {
      const runUpdate = {
        end_time: this.end_time,
        error: this.error,
        inputs: this.inputs,
        outputs: this.outputs,
        parent_run_id: (_a = this.parent_run) == null ? void 0 : _a.id,
        reference_example_id: this.reference_example_id,
        extra: this.extra,
        events: this.events,
        dotted_order: this.dotted_order,
        trace_id: this.trace_id,
        tags: this.tags,
        attachments: this.attachments,
        session_name: this.project_name
      };
      await this.client.updateRun(this.id, runUpdate);
    } catch (error) {
      console.error(`Error in patchRun for run ${this.id}`, error);
    }
  }
  toJSON() {
    return this._convertToCreate(this, void 0, false);
  }
  /**
   * Add an event to the run tree.
   * @param event - A single event or string to add
   */
  addEvent(event) {
    var _a;
    if (!this.events) {
      this.events = [];
    }
    if (typeof event === "string") {
      this.events.push({
        name: "event",
        time: new Date().toISOString(),
        message: event
      });
    } else {
      this.events.push({
        ...event,
        time: (_a = event.time) != null ? _a : new Date().toISOString()
      });
    }
  }
  static fromRunnableConfig(parentConfig, props) {
    var _a, _b, _c, _d, _e, _f, _g;
    const callbackManager = parentConfig == null ? void 0 : parentConfig.callbacks;
    let parentRun;
    let projectName;
    let client2;
    let tracingEnabled = isTracingEnabled();
    if (callbackManager) {
      const parentRunId = (_b = (_a = callbackManager == null ? void 0 : callbackManager.getParentRunId) == null ? void 0 : _a.call(callbackManager)) != null ? _b : "";
      const langChainTracer = (_c = callbackManager == null ? void 0 : callbackManager.handlers) == null ? void 0 : _c.find((handler) => (handler == null ? void 0 : handler.name) == "langchain_tracer");
      parentRun = (_d = langChainTracer == null ? void 0 : langChainTracer.getRun) == null ? void 0 : _d.call(langChainTracer, parentRunId);
      projectName = langChainTracer == null ? void 0 : langChainTracer.projectName;
      client2 = langChainTracer == null ? void 0 : langChainTracer.client;
      tracingEnabled = tracingEnabled || !!langChainTracer;
    }
    if (!parentRun) {
      return new RunTree({
        ...props,
        client: client2,
        tracingEnabled,
        project_name: projectName
      });
    }
    const parentRunTree = new RunTree({
      name: parentRun.name,
      id: parentRun.id,
      trace_id: parentRun.trace_id,
      dotted_order: parentRun.dotted_order,
      client: client2,
      tracingEnabled,
      project_name: projectName,
      tags: [
        ...new Set(((_e = parentRun == null ? void 0 : parentRun.tags) != null ? _e : []).concat((_f = parentConfig == null ? void 0 : parentConfig.tags) != null ? _f : []))
      ],
      extra: {
        metadata: {
          ...(_g = parentRun == null ? void 0 : parentRun.extra) == null ? void 0 : _g.metadata,
          ...parentConfig == null ? void 0 : parentConfig.metadata
        }
      }
    });
    return parentRunTree.createChild(props);
  }
  static fromDottedOrder(dottedOrder) {
    return this.fromHeaders({ "langsmith-trace": dottedOrder });
  }
  static fromHeaders(headers, inheritArgs) {
    var _a, _b, _c, _d;
    const rawHeaders = "get" in headers && typeof headers.get === "function" ? {
      "langsmith-trace": headers.get("langsmith-trace"),
      baggage: headers.get("baggage")
    } : headers;
    const headerTrace = rawHeaders["langsmith-trace"];
    if (!headerTrace || typeof headerTrace !== "string")
      return void 0;
    const parentDottedOrder = headerTrace.trim();
    const parsedDottedOrder = parentDottedOrder.split(".").map((part) => {
      const [strTime, uuid] = part.split("Z");
      return { strTime, time: Date.parse(strTime + "Z"), uuid };
    });
    const traceId = parsedDottedOrder[0].uuid;
    const config = {
      ...inheritArgs,
      name: (_a = inheritArgs == null ? void 0 : inheritArgs["name"]) != null ? _a : "parent",
      run_type: (_b = inheritArgs == null ? void 0 : inheritArgs["run_type"]) != null ? _b : "chain",
      start_time: (_c = inheritArgs == null ? void 0 : inheritArgs["start_time"]) != null ? _c : Date.now(),
      id: (_d = parsedDottedOrder.at(-1)) == null ? void 0 : _d.uuid,
      trace_id: traceId,
      dotted_order: parentDottedOrder
    };
    if (rawHeaders["baggage"] && typeof rawHeaders["baggage"] === "string") {
      const baggage = Baggage.fromHeader(rawHeaders["baggage"]);
      config.metadata = baggage.metadata;
      config.tags = baggage.tags;
      config.project_name = baggage.project_name;
    }
    return new RunTree(config);
  }
  toHeaders(headers) {
    var _a;
    const result = {
      "langsmith-trace": this.dotted_order,
      baggage: new Baggage((_a = this.extra) == null ? void 0 : _a.metadata, this.tags, this.project_name).toHeader()
    };
    if (headers) {
      for (const [key, value] of Object.entries(result)) {
        headers.set(key, value);
      }
    }
    return result;
  }
};
Object.defineProperty(RunTree, "sharedClient", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: null
});
function isRunTree(x) {
  return x !== void 0 && typeof x.createChild === "function" && typeof x.postRun === "function";
}
function isLangChainTracerLike(x) {
  return typeof x === "object" && x != null && typeof x.name === "string" && x.name === "langchain_tracer";
}
function containsLangChainTracerLike(x) {
  return Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback));
}
function isCallbackManagerLike(x) {
  return typeof x === "object" && x != null && Array.isArray(x.handlers);
}
function isRunnableConfigLike(x) {
  var _a;
  return x !== void 0 && typeof x.callbacks === "object" && // Callback manager with a langchain tracer
  (containsLangChainTracerLike((_a = x.callbacks) == null ? void 0 : _a.handlers) || // Or it's an array with a LangChainTracerLike object within it
  containsLangChainTracerLike(x.callbacks));
}

// node_modules/langsmith/dist/singletons/traceable.js
var MockAsyncLocalStorage = class {
  getStore() {
    return void 0;
  }
  run(_, callback) {
    return callback();
  }
};
var TRACING_ALS_KEY = Symbol.for("ls:tracing_async_local_storage");
var mockAsyncLocalStorage = new MockAsyncLocalStorage();
var AsyncLocalStorageProvider = class {
  getInstance() {
    var _a;
    return (_a = globalThis[TRACING_ALS_KEY]) != null ? _a : mockAsyncLocalStorage;
  }
  initializeGlobalInstance(instance) {
    if (globalThis[TRACING_ALS_KEY] === void 0) {
      globalThis[TRACING_ALS_KEY] = instance;
    }
  }
};
var AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();
var getCurrentRunTree = () => {
  const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();
  if (!isRunTree(runTree)) {
    throw new Error([
      "Could not get the current run tree.",
      "",
      "Please make sure you are calling this method within a traceable function and that tracing is enabled."
    ].join("\n"));
  }
  return runTree;
};
var ROOT = Symbol.for("langsmith:traceable:root");
function isTraceableFunction(x) {
  return typeof x === "function" && "langsmith:traceable" in x;
}

// node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate2,
  validator: () => validator
});

// node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    const keys2 = new Array(obj.length);
    for (let k = 0; k < keys2.length; k++) {
      keys2[k] = "" + k;
    }
    return keys2;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  let keys = [];
  for (let i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys.push(i);
    }
  }
  return keys;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str) {
  let i = 0;
  const len = str.length;
  let charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1)
    return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (let i2 = 0, len = obj.length; i2 < len; i2++) {
        if (hasUndefined(obj[i2])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      const objKeys = _objectKeys(obj);
      const objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  const messageParts = [message];
  for (const key in args) {
    const value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
    if (typeof value !== "undefined") {
      messageParts.push(`${key}: ${value}`);
    }
  }
  return messageParts.join("\n");
}
var PatchError = class extends Error {
  constructor(message, name, index, operation, tree) {
    super(patchErrorMessageFormatter(message, { name, index, operation, tree }));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: name
    });
    Object.defineProperty(this, "index", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: index
    });
    Object.defineProperty(this, "operation", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: operation
    });
    Object.defineProperty(this, "tree", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tree
    });
    Object.setPrototypeOf(this, new.target.prototype);
    this.message = patchErrorMessageFormatter(message, {
      name,
      index,
      operation,
      tree
    });
  }
};

// node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key, document) {
    obj[key] = this.value;
    return { newDocument: document };
  },
  remove: function(obj, key, document) {
    var removed = obj[key];
    delete obj[key];
    return { newDocument: document, removed };
  },
  replace: function(obj, key, document) {
    var removed = obj[key];
    obj[key] = this.value;
    return { newDocument: document, removed };
  },
  move: function(obj, key, document) {
    let removed = getValueByPointer(document, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    const originalValue = applyOperation(document, {
      op: "remove",
      path: this.from
    }).removed;
    applyOperation(document, {
      op: "add",
      path: this.path,
      value: originalValue
    });
    return { newDocument: document, removed };
  },
  copy: function(obj, key, document) {
    const valueToCopy = getValueByPointer(document, this.from);
    applyOperation(document, {
      op: "add",
      path: this.path,
      value: _deepClone(valueToCopy)
    });
    return { newDocument: document };
  },
  test: function(obj, key, document) {
    return { newDocument: document, test: _areEquals(obj[key], this.value) };
  },
  _get: function(obj, key, document) {
    this.value = obj[key];
    return { newDocument: document };
  }
};
var arrOps = {
  add: function(arr2, i, document) {
    if (isInteger(i)) {
      arr2.splice(i, 0, this.value);
    } else {
      arr2[i] = this.value;
    }
    return { newDocument: document, index: i };
  },
  remove: function(arr2, i, document) {
    var removedList = arr2.splice(i, 1);
    return { newDocument: document, removed: removedList[0] };
  },
  replace: function(arr2, i, document) {
    var removed = arr2[i];
    arr2[i] = this.value;
    return { newDocument: document, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document, pointer) {
  if (pointer == "") {
    return document;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    let returnValue = { newDocument: document };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
      }
      returnValue.newDocument = document;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document = _deepClone(document);
    }
    const path = operation.path || "";
    const keys = path.split("/");
    let obj = document;
    let t = 1;
    let len = keys.length;
    let existingPathFragment = void 0;
    let key;
    let validateFunction;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key = keys[t];
      if (key && key.indexOf("~") != -1) {
        key = unescapePathComponent(key);
      }
      if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && keys[t - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key] === void 0) {
            existingPathFragment = keys.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key === "-") {
          key = obj.length;
        } else {
          if (validateOperation && !isInteger(key)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
          } else if (isInteger(key)) {
            key = ~~key;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
          }
          const returnValue = arrOps[operation.op].call(operation, obj, key, document);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
          }
          return returnValue;
        }
      } else {
        if (t >= len) {
          const returnValue = objOps[operation.op].call(operation, obj, key, document);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
          }
          return returnValue;
        }
      }
      obj = obj[key];
      if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
      }
    }
  }
}
function applyPatch(document, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document = _deepClone(document);
  }
  const results = new Array(patch.length);
  for (let i = 0, length = patch.length; i < length; i++) {
    results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
    document = results[i].newDocument;
  }
  results.newDocument = document;
  return results;
}
function applyReducer(document, operation, index) {
  const operationResult = applyOperation(document, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
  }
  return operationResult.newDocument;
}
function validator(operation, index, document, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document);
  } else if (document) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = {
        op: "_get",
        path: operation.from,
        value: void 0
      };
      var error = validate2([existingValue], document);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document);
      }
    }
  }
}
function validate2(sequence, document, externalValidator) {
  try {
    if (!Array.isArray(sequence)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document) {
      applyPatch(_deepClone(document), _deepClone(sequence), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence.length; i++) {
        externalValidator(sequence[i], i, document, void 0);
      }
    }
  } catch (e) {
    if (e instanceof JsonPatchError) {
      return e;
    } else {
      throw e;
    }
  }
}
function _areEquals(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!_areEquals(a[i], b[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!b.hasOwnProperty(keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      key = keys[i];
      if (!_areEquals(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}

// node_modules/@langchain/core/dist/utils/fast-json-patch/src/duplex.js
function _generate(mirror, obj, patches, path, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var changed = false;
  var deleted = false;
  for (var t = oldKeys.length - 1; t >= 0; t--) {
    var key = oldKeys[t];
    var oldVal = mirror[key];
    if (hasOwnProperty(obj, key) && !(obj[key] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key), invertible);
      } else {
        if (oldVal !== newVal) {
          changed = true;
          if (invertible) {
            patches.push({
              op: "test",
              path: path + "/" + escapePathComponent(key),
              value: _deepClone(oldVal)
            });
          }
          patches.push({
            op: "replace",
            path: path + "/" + escapePathComponent(key),
            value: _deepClone(newVal)
          });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({
          op: "test",
          path: path + "/" + escapePathComponent(key),
          value: _deepClone(oldVal)
        });
      }
      patches.push({
        op: "remove",
        path: path + "/" + escapePathComponent(key)
      });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path, value: mirror });
      }
      patches.push({ op: "replace", path, value: obj });
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t = 0; t < newKeys.length; t++) {
    var key = newKeys[t];
    if (!hasOwnProperty(mirror, key) && obj[key] !== void 0) {
      patches.push({
        op: "add",
        path: path + "/" + escapePathComponent(key),
        value: _deepClone(obj[key])
      });
    }
  }
}
function compare(tree1, tree2, invertible = false) {
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}

// node_modules/@langchain/core/dist/utils/fast-json-patch/index.js
var fast_json_patch_default = {
  ...core_exports,
  // ...duplex,
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
};

// node_modules/@langchain/core/dist/utils/env.js
var isBrowser2 = () => typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker2 = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var isJsDom2 = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
var isDeno2 = () => typeof Deno !== "undefined";
var isNode2 = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno2();
var getEnv2 = () => {
  let env;
  if (isBrowser2()) {
    env = "browser";
  } else if (isNode2()) {
    env = "node";
  } else if (isWebWorker2()) {
    env = "webworker";
  } else if (isJsDom2()) {
    env = "jsdom";
  } else if (isDeno2()) {
    env = "deno";
  } else {
    env = "other";
  }
  return env;
};
var runtimeEnvironment2;
async function getRuntimeEnvironment2() {
  if (runtimeEnvironment2 === void 0) {
    const env = getEnv2();
    runtimeEnvironment2 = {
      library: "langchain-js",
      runtime: env
    };
  }
  return runtimeEnvironment2;
}
function getEnvironmentVariable2(name) {
  var _a;
  try {
    if (typeof process !== "undefined") {
      return (_a = process.env) == null ? void 0 : _a[name];
    } else if (isDeno2()) {
      return Deno == null ? void 0 : Deno.env.get(name);
    } else {
      return void 0;
    }
  } catch (e) {
    return void 0;
  }
}

// node_modules/@langchain/core/dist/callbacks/base.js
var BaseCallbackHandlerMethodsClass = class {
};
function callbackHandlerPrefersStreaming(x) {
  return "lc_prefer_streaming" in x && x.lc_prefer_streaming;
}
var BaseCallbackHandler = class extends BaseCallbackHandlerMethodsClass {
  get lc_namespace() {
    return ["langchain_core", "callbacks", this.name];
  }
  get lc_secrets() {
    return void 0;
  }
  get lc_attributes() {
    return void 0;
  }
  get lc_aliases() {
    return void 0;
  }
  get lc_serializable_keys() {
    return void 0;
  }
  /**
   * The name of the serializable. Override to provide an alias or
   * to preserve the serialized module name in minified environments.
   *
   * Implemented as a static method to support loading logic.
   */
  static lc_name() {
    return this.name;
  }
  /**
   * The final serialized identifier for the module.
   */
  get lc_id() {
    return [
      ...this.lc_namespace,
      get_lc_unique_name(this.constructor)
    ];
  }
  constructor(input) {
    var _a, _b, _c, _d, _e, _f, _g;
    super();
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "lc_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "ignoreLLM", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreChain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreAgent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreRetriever", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreCustomEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "raiseError", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "awaitHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: getEnvironmentVariable2("LANGCHAIN_CALLBACKS_BACKGROUND") === "false"
    });
    this.lc_kwargs = input || {};
    if (input) {
      this.ignoreLLM = (_a = input.ignoreLLM) != null ? _a : this.ignoreLLM;
      this.ignoreChain = (_b = input.ignoreChain) != null ? _b : this.ignoreChain;
      this.ignoreAgent = (_c = input.ignoreAgent) != null ? _c : this.ignoreAgent;
      this.ignoreRetriever = (_d = input.ignoreRetriever) != null ? _d : this.ignoreRetriever;
      this.ignoreCustomEvent = (_e = input.ignoreCustomEvent) != null ? _e : this.ignoreCustomEvent;
      this.raiseError = (_f = input.raiseError) != null ? _f : this.raiseError;
      this.awaitHandlers = this.raiseError || ((_g = input._awaitHandler) != null ? _g : this.awaitHandlers);
    }
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return Serializable.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return Serializable.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(methods2) {
    class Handler extends BaseCallbackHandler {
      constructor() {
        super();
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: v4_default()
        });
        Object.assign(this, methods2);
      }
    }
    return new Handler();
  }
};
var isBaseCallbackHandler = (x) => {
  const callbackHandler = x;
  return callbackHandler !== void 0 && typeof callbackHandler.copy === "function" && typeof callbackHandler.name === "string" && typeof callbackHandler.awaitHandlers === "boolean";
};

// node_modules/@langchain/core/dist/tracers/base.js
function _coerceToDict(value, defaultKey) {
  return value && !Array.isArray(value) && typeof value === "object" ? value : { [defaultKey]: value };
}
function stripNonAlphanumeric2(input) {
  return input.replace(/[-:.]/g, "");
}
function convertToDottedOrderFormat2(epoch, runId, executionOrder) {
  const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, "0");
  return stripNonAlphanumeric2(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;
}
function isBaseTracer(x) {
  return typeof x._addRunToRunMap === "function";
}
var BaseTracer = class extends BaseCallbackHandler {
  constructor(_fields) {
    super(...arguments);
    Object.defineProperty(this, "runMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
  }
  copy() {
    return this;
  }
  stringifyError(error) {
    if (error instanceof Error) {
      return error.message + ((error == null ? void 0 : error.stack) ? `

${error.stack}` : "");
    }
    if (typeof error === "string") {
      return error;
    }
    return `${error}`;
  }
  _addChildRun(parentRun, childRun) {
    parentRun.child_runs.push(childRun);
  }
  _addRunToRunMap(run) {
    const currentDottedOrder = convertToDottedOrderFormat2(run.start_time, run.id, run.execution_order);
    const storedRun = { ...run };
    if (storedRun.parent_run_id !== void 0) {
      const parentRun = this.runMap.get(storedRun.parent_run_id);
      if (parentRun) {
        this._addChildRun(parentRun, storedRun);
        parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
        storedRun.trace_id = parentRun.trace_id;
        if (parentRun.dotted_order !== void 0) {
          storedRun.dotted_order = [
            parentRun.dotted_order,
            currentDottedOrder
          ].join(".");
        } else {
        }
      } else {
      }
    } else {
      storedRun.trace_id = storedRun.id;
      storedRun.dotted_order = currentDottedOrder;
    }
    this.runMap.set(storedRun.id, storedRun);
    return storedRun;
  }
  async _endTrace(run) {
    var _a;
    const parentRun = run.parent_run_id !== void 0 && this.runMap.get(run.parent_run_id);
    if (parentRun) {
      parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);
    } else {
      await this.persistRun(run);
    }
    this.runMap.delete(run.id);
    await ((_a = this.onRunUpdate) == null ? void 0 : _a.call(this, run));
  }
  _getExecutionOrder(parentRunId) {
    const parentRun = parentRunId !== void 0 && this.runMap.get(parentRunId);
    if (!parentRun) {
      return 1;
    }
    return parentRun.child_execution_order + 1;
  }
  /**
   * Create and add a run to the run map for LLM start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata ? { ...extraParams, metadata } : extraParams;
    const run = {
      id: runId,
      name: name != null ? name : llm.id[llm.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { prompts },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams != null ? finalExtraParams : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    var _a, _b, _c;
    const run = (_a = this.runMap.get(runId)) != null ? _a : this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);
    await ((_b = this.onRunCreate) == null ? void 0 : _b.call(this, run));
    await ((_c = this.onLLMStart) == null ? void 0 : _c.call(this, run));
    return run;
  }
  /**
   * Create and add a run to the run map for chat model start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata ? { ...extraParams, metadata } : extraParams;
    const run = {
      id: runId,
      name: name != null ? name : llm.id[llm.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { messages },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams != null ? finalExtraParams : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    var _a, _b, _c;
    const run = (_a = this.runMap.get(runId)) != null ? _a : this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);
    await ((_b = this.onRunCreate) == null ? void 0 : _b.call(this, run));
    await ((_c = this.onLLMStart) == null ? void 0 : _c.call(this, run));
    return run;
  }
  async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
      throw new Error("No LLM run to end.");
    }
    run.end_time = Date.now();
    run.outputs = output;
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    run.extra = { ...run.extra, ...extraParams };
    await ((_a = this.onLLMEnd) == null ? void 0 : _a.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
      throw new Error("No LLM run to end.");
    }
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    run.extra = { ...run.extra, ...extraParams };
    await ((_a = this.onLLMError) == null ? void 0 : _a.call(this, run));
    await this._endTrace(run);
    return run;
  }
  /**
   * Create and add a run to the run map for chain start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name != null ? name : chain.id[chain.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: chain,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs,
      execution_order,
      child_execution_order: execution_order,
      run_type: runType != null ? runType : "chain",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    var _a, _b, _c;
    const run = (_a = this.runMap.get(runId)) != null ? _a : this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);
    await ((_b = this.onRunCreate) == null ? void 0 : _b.call(this, run));
    await ((_c = this.onChainStart) == null ? void 0 : _c.call(this, run));
    return run;
  }
  async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run) {
      throw new Error("No chain run to end.");
    }
    run.end_time = Date.now();
    run.outputs = _coerceToDict(outputs, "output");
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) {
      run.inputs = _coerceToDict(kwargs.inputs, "input");
    }
    await ((_a = this.onChainEnd) == null ? void 0 : _a.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleChainError(error, runId, _parentRunId, _tags, kwargs) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run) {
      throw new Error("No chain run to end.");
    }
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) {
      run.inputs = _coerceToDict(kwargs.inputs, "input");
    }
    await ((_a = this.onChainError) == null ? void 0 : _a.call(this, run));
    await this._endTrace(run);
    return run;
  }
  /**
   * Create and add a run to the run map for tool start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name != null ? name : tool.id[tool.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: tool,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { input },
      execution_order,
      child_execution_order: execution_order,
      run_type: "tool",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
    var _a, _b, _c;
    const run = (_a = this.runMap.get(runId)) != null ? _a : this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);
    await ((_b = this.onRunCreate) == null ? void 0 : _b.call(this, run));
    await ((_c = this.onToolStart) == null ? void 0 : _c.call(this, run));
    return run;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleToolEnd(output, runId) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "tool") {
      throw new Error("No tool run to end");
    }
    run.end_time = Date.now();
    run.outputs = { output };
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    await ((_a = this.onToolEnd) == null ? void 0 : _a.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleToolError(error, runId) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "tool") {
      throw new Error("No tool run to end");
    }
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    await ((_a = this.onToolError) == null ? void 0 : _a.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleAgentAction(action, runId) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
      return;
    }
    const agentRun = run;
    agentRun.actions = agentRun.actions || [];
    agentRun.actions.push(action);
    agentRun.events.push({
      name: "agent_action",
      time: new Date().toISOString(),
      kwargs: { action }
    });
    await ((_a = this.onAgentAction) == null ? void 0 : _a.call(this, run));
  }
  async handleAgentEnd(action, runId) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
      return;
    }
    run.events.push({
      name: "agent_end",
      time: new Date().toISOString(),
      kwargs: { action }
    });
    await ((_a = this.onAgentEnd) == null ? void 0 : _a.call(this, run));
  }
  /**
   * Create and add a run to the run map for retriever start events.
   * This must sometimes be done synchronously to avoid race conditions
   * when callbacks are backgrounded, so we expose it as a separate method here.
   */
  _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run = {
      id: runId,
      name: name != null ? name : retriever.id[retriever.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: retriever,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { query },
      execution_order,
      child_execution_order: execution_order,
      run_type: "retriever",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    return this._addRunToRunMap(run);
  }
  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    var _a, _b, _c;
    const run = (_a = this.runMap.get(runId)) != null ? _a : this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);
    await ((_b = this.onRunCreate) == null ? void 0 : _b.call(this, run));
    await ((_c = this.onRetrieverStart) == null ? void 0 : _c.call(this, run));
    return run;
  }
  async handleRetrieverEnd(documents, runId) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "retriever") {
      throw new Error("No retriever run to end");
    }
    run.end_time = Date.now();
    run.outputs = { documents };
    run.events.push({
      name: "end",
      time: new Date(run.end_time).toISOString()
    });
    await ((_a = this.onRetrieverEnd) == null ? void 0 : _a.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleRetrieverError(error, runId) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "retriever") {
      throw new Error("No retriever run to end");
    }
    run.end_time = Date.now();
    run.error = this.stringifyError(error);
    run.events.push({
      name: "error",
      time: new Date(run.end_time).toISOString()
    });
    await ((_a = this.onRetrieverError) == null ? void 0 : _a.call(this, run));
    await this._endTrace(run);
    return run;
  }
  async handleText(text, runId) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "chain") {
      return;
    }
    run.events.push({
      name: "text",
      time: new Date().toISOString(),
      kwargs: { text }
    });
    await ((_a = this.onText) == null ? void 0 : _a.call(this, run));
  }
  async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
    var _a;
    const run = this.runMap.get(runId);
    if (!run || (run == null ? void 0 : run.run_type) !== "llm") {
      throw new Error(`Invalid "runId" provided to "handleLLMNewToken" callback.`);
    }
    run.events.push({
      name: "new_token",
      time: new Date().toISOString(),
      kwargs: { token, idx, chunk: fields == null ? void 0 : fields.chunk }
    });
    await ((_a = this.onLLMNewToken) == null ? void 0 : _a.call(this, run, token, { chunk: fields == null ? void 0 : fields.chunk }));
    return run;
  }
};

// node_modules/@langchain/core/dist/tracers/console.js
var import_ansi_styles = __toESM(require_ansi_styles(), 1);
function wrap(style, text) {
  return `${style.open}${text}${style.close}`;
}
function tryJsonStringify(obj, fallback) {
  try {
    return JSON.stringify(obj, null, 2);
  } catch (err) {
    return fallback;
  }
}
function formatKVMapItem(value) {
  if (typeof value === "string") {
    return value.trim();
  }
  if (value === null || value === void 0) {
    return value;
  }
  return tryJsonStringify(value, value.toString());
}
function elapsed(run) {
  if (!run.end_time)
    return "";
  const elapsed2 = run.end_time - run.start_time;
  if (elapsed2 < 1e3) {
    return `${elapsed2}ms`;
  }
  return `${(elapsed2 / 1e3).toFixed(2)}s`;
}
var { color } = import_ansi_styles.default;
var ConsoleCallbackHandler = class extends BaseTracer {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "console_callback_handler"
    });
  }
  /**
   * Method used to persist the run. In this case, it simply returns a
   * resolved promise as there's no persistence logic.
   * @param _run The run to persist.
   * @returns A resolved promise.
   */
  persistRun(_run) {
    return Promise.resolve();
  }
  // utility methods
  /**
   * Method used to get all the parent runs of a given run.
   * @param run The run whose parents are to be retrieved.
   * @returns An array of parent runs.
   */
  getParents(run) {
    const parents = [];
    let currentRun = run;
    while (currentRun.parent_run_id) {
      const parent = this.runMap.get(currentRun.parent_run_id);
      if (parent) {
        parents.push(parent);
        currentRun = parent;
      } else {
        break;
      }
    }
    return parents;
  }
  /**
   * Method used to get a string representation of the run's lineage, which
   * is used in logging.
   * @param run The run whose lineage is to be retrieved.
   * @returns A string representation of the run's lineage.
   */
  getBreadcrumbs(run) {
    const parents = this.getParents(run).reverse();
    const string = [...parents, run].map((parent, i, arr2) => {
      const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
      return i === arr2.length - 1 ? wrap(import_ansi_styles.default.bold, name) : name;
    }).join(" > ");
    return wrap(color.grey, string);
  }
  // logging methods
  /**
   * Method used to log the start of a chain run.
   * @param run The chain run that has started.
   * @returns void
   */
  onChainStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of a chain run.
   * @param run The chain run that has ended.
   * @returns void
   */
  onChainEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(run)}] Exiting Chain run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
  }
  /**
   * Method used to log any errors of a chain run.
   * @param run The chain run that has errored.
   * @returns void
   */
  onChainError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(run)}] Chain run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
   * Method used to log the start of an LLM run.
   * @param run The LLM run that has started.
   * @returns void
   */
  onLLMStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    const inputs = "prompts" in run.inputs ? { prompts: run.inputs.prompts.map((p) => p.trim()) } : run.inputs;
    console.log(`${wrap(color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of an LLM run.
   * @param run The LLM run that has ended.
   * @returns void
   */
  onLLMEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(run)}] Exiting LLM run with output: ${tryJsonStringify(run.outputs, "[response]")}`);
  }
  /**
   * Method used to log any errors of an LLM run.
   * @param run The LLM run that has errored.
   * @returns void
   */
  onLLMError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(run)}] LLM run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
   * Method used to log the start of a tool run.
   * @param run The tool run that has started.
   * @returns void
   */
  onToolStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${formatKVMapItem(run.inputs.input)}"`);
  }
  /**
   * Method used to log the end of a tool run.
   * @param run The tool run that has ended.
   * @returns void
   */
  onToolEnd(run) {
    var _a;
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(run)}] Exiting Tool run with output: "${formatKVMapItem((_a = run.outputs) == null ? void 0 : _a.output)}"`);
  }
  /**
   * Method used to log any errors of a tool run.
   * @param run The tool run that has errored.
   * @returns void
   */
  onToolError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(run)}] Tool run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
   * Method used to log the start of a retriever run.
   * @param run The retriever run that has started.
   * @returns void
   */
  onRetrieverStart(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.green, "[retriever/start]")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run.inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of a retriever run.
   * @param run The retriever run that has ended.
   * @returns void
   */
  onRetrieverEnd(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.cyan, "[retriever/end]")} [${crumbs}] [${elapsed(run)}] Exiting Retriever run with output: ${tryJsonStringify(run.outputs, "[outputs]")}`);
  }
  /**
   * Method used to log any errors of a retriever run.
   * @param run The retriever run that has errored.
   * @returns void
   */
  onRetrieverError(run) {
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.red, "[retriever/error]")} [${crumbs}] [${elapsed(run)}] Retriever run errored with error: ${tryJsonStringify(run.error, "[error]")}`);
  }
  /**
   * Method used to log the action selected by the agent.
   * @param run The run in which the agent action occurred.
   * @returns void
   */
  onAgentAction(run) {
    const agentRun = run;
    const crumbs = this.getBreadcrumbs(run);
    console.log(`${wrap(color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")}`);
  }
};

// node_modules/@langchain/core/dist/singletons/tracer.js
var client;
var getDefaultLangChainClientSingleton = () => {
  if (client === void 0) {
    const clientParams = getEnvironmentVariable2("LANGCHAIN_CALLBACKS_BACKGROUND") === "false" ? {
      // LangSmith has its own backgrounding system
      blockOnRootRunFinalization: true
    } : {};
    client = new Client(clientParams);
  }
  return client;
};

// node_modules/@langchain/core/dist/tracers/tracer_langchain.js
var LangChainTracer = class extends BaseTracer {
  constructor(fields = {}) {
    var _a;
    super(fields);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "langchain_tracer"
    });
    Object.defineProperty(this, "projectName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "exampleId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    const { exampleId, projectName, client: client2 } = fields;
    this.projectName = (_a = projectName != null ? projectName : getEnvironmentVariable2("LANGCHAIN_PROJECT")) != null ? _a : getEnvironmentVariable2("LANGCHAIN_SESSION");
    this.exampleId = exampleId;
    this.client = client2 != null ? client2 : getDefaultLangChainClientSingleton();
    const traceableTree = LangChainTracer.getTraceableRunTree();
    if (traceableTree) {
      this.updateFromRunTree(traceableTree);
    }
  }
  async _convertToCreate(run, example_id = void 0) {
    return {
      ...run,
      extra: {
        ...run.extra,
        runtime: await getRuntimeEnvironment2()
      },
      child_runs: void 0,
      session_name: this.projectName,
      reference_example_id: run.parent_run_id ? void 0 : example_id
    };
  }
  async persistRun(_run) {
  }
  async onRunCreate(run) {
    const persistedRun = await this._convertToCreate(run, this.exampleId);
    await this.client.createRun(persistedRun);
  }
  async onRunUpdate(run) {
    const runUpdate = {
      end_time: run.end_time,
      error: run.error,
      outputs: run.outputs,
      events: run.events,
      inputs: run.inputs,
      trace_id: run.trace_id,
      dotted_order: run.dotted_order,
      parent_run_id: run.parent_run_id,
      extra: run.extra,
      session_name: this.projectName
    };
    await this.client.updateRun(run.id, runUpdate);
  }
  getRun(id) {
    return this.runMap.get(id);
  }
  updateFromRunTree(runTree) {
    var _a, _b, _c;
    let rootRun = runTree;
    const visited = /* @__PURE__ */ new Set();
    while (rootRun.parent_run) {
      if (visited.has(rootRun.id))
        break;
      visited.add(rootRun.id);
      if (!rootRun.parent_run)
        break;
      rootRun = rootRun.parent_run;
    }
    visited.clear();
    const queue2 = [rootRun];
    while (queue2.length > 0) {
      const current = queue2.shift();
      if (!current || visited.has(current.id))
        continue;
      visited.add(current.id);
      this.runMap.set(current.id, current);
      if (current.child_runs) {
        queue2.push(...current.child_runs);
      }
    }
    this.client = (_a = runTree.client) != null ? _a : this.client;
    this.projectName = (_b = runTree.project_name) != null ? _b : this.projectName;
    this.exampleId = (_c = runTree.reference_example_id) != null ? _c : this.exampleId;
  }
  convertToRunTree(id) {
    const runTreeMap = {};
    const runTreeList = [];
    for (const [id2, run] of this.runMap) {
      const runTree = new RunTree({
        ...run,
        child_runs: [],
        parent_run: void 0,
        // inherited properties
        client: this.client,
        project_name: this.projectName,
        reference_example_id: this.exampleId,
        tracingEnabled: true
      });
      runTreeMap[id2] = runTree;
      runTreeList.push([id2, run.dotted_order]);
    }
    runTreeList.sort((a, b) => {
      if (!a[1] || !b[1])
        return 0;
      return a[1].localeCompare(b[1]);
    });
    for (const [id2] of runTreeList) {
      const run = this.runMap.get(id2);
      const runTree = runTreeMap[id2];
      if (!run || !runTree)
        continue;
      if (run.parent_run_id) {
        const parentRunTree = runTreeMap[run.parent_run_id];
        if (parentRunTree) {
          parentRunTree.child_runs.push(runTree);
          runTree.parent_run = parentRunTree;
        }
      }
    }
    return runTreeMap[id];
  }
  static getTraceableRunTree() {
    try {
      return getCurrentRunTree();
    } catch (e) {
      return void 0;
    }
  }
};

// node_modules/@langchain/core/dist/singletons/callbacks.js
var import_p_queue2 = __toESM(require_dist(), 1);

// node_modules/@langchain/core/dist/singletons/async_local_storage/globals.js
var TRACING_ALS_KEY2 = Symbol.for("ls:tracing_async_local_storage");
var _CONTEXT_VARIABLES_KEY = Symbol.for("lc:context_variables");
var setGlobalAsyncLocalStorageInstance = (instance) => {
  globalThis[TRACING_ALS_KEY2] = instance;
};
var getGlobalAsyncLocalStorageInstance = () => {
  return globalThis[TRACING_ALS_KEY2];
};

// node_modules/@langchain/core/dist/singletons/callbacks.js
var queue;
function createQueue() {
  const PQueue = "default" in import_p_queue2.default ? import_p_queue2.default.default : import_p_queue2.default;
  return new PQueue({
    autoStart: true,
    concurrency: 1
  });
}
function getQueue() {
  if (typeof queue === "undefined") {
    queue = createQueue();
  }
  return queue;
}
async function consumeCallback(promiseFn, wait) {
  if (wait === true) {
    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
    if (asyncLocalStorageInstance !== void 0) {
      await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
    } else {
      await promiseFn();
    }
  } else {
    queue = getQueue();
    void queue.add(async () => {
      const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
      if (asyncLocalStorageInstance !== void 0) {
        await asyncLocalStorageInstance.run(void 0, async () => promiseFn());
      } else {
        await promiseFn();
      }
    });
  }
}

// node_modules/@langchain/core/dist/utils/callbacks.js
var isTracingEnabled2 = (tracingEnabled) => {
  if (tracingEnabled !== void 0) {
    return tracingEnabled;
  }
  const envVars = [
    "LANGSMITH_TRACING_V2",
    "LANGCHAIN_TRACING_V2",
    "LANGSMITH_TRACING",
    "LANGCHAIN_TRACING"
  ];
  return !!envVars.find((envVar) => getEnvironmentVariable2(envVar) === "true");
};

// node_modules/@langchain/core/dist/singletons/async_local_storage/context.js
function getContextVariable(name) {
  var _a;
  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();
  if (asyncLocalStorageInstance === void 0) {
    return void 0;
  }
  const runTree = asyncLocalStorageInstance.getStore();
  return (_a = runTree == null ? void 0 : runTree[_CONTEXT_VARIABLES_KEY]) == null ? void 0 : _a[name];
}
var LC_CONFIGURE_HOOKS_KEY = Symbol("lc:configure_hooks");
var _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];

// node_modules/@langchain/core/dist/callbacks/manager.js
var BaseCallbackManager = class {
  setHandler(handler) {
    return this.setHandlers([handler]);
  }
};
var BaseRunManager = class {
  constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {
    Object.defineProperty(this, "runId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: runId
    });
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: handlers
    });
    Object.defineProperty(this, "inheritableHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableHandlers
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tags
    });
    Object.defineProperty(this, "inheritableTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableTags
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: metadata
    });
    Object.defineProperty(this, "inheritableMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableMetadata
    });
    Object.defineProperty(this, "_parentRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _parentRunId
    });
  }
  get parentRunId() {
    return this._parentRunId;
  }
  async handleText(text) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      try {
        await ((_a = handler.handleText) == null ? void 0 : _a.call(handler, text, this.runId, this._parentRunId, this.tags));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);
        if (handler.raiseError) {
          throw err;
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleCustomEvent(eventName, data, _runId, _tags, _metadata) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      try {
        await ((_a = handler.handleCustomEvent) == null ? void 0 : _a.call(handler, eventName, data, this.runId, this.tags, this.metadata));
      } catch (err) {
        const logFunction = handler.raiseError ? console.error : console.warn;
        logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
        if (handler.raiseError) {
          throw err;
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForRetrieverRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleRetrieverEnd(documents) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreRetriever) {
        try {
          await ((_a = handler.handleRetrieverEnd) == null ? void 0 : _a.call(handler, documents, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleRetrieverError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreRetriever) {
        try {
          await ((_a = handler.handleRetrieverError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags));
        } catch (error) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForLLMRun = class extends BaseRunManager {
  async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreLLM) {
        try {
          await ((_a = handler.handleLLMNewToken) == null ? void 0 : _a.call(handler, token, idx != null ? idx : { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreLLM) {
        try {
          await ((_a = handler.handleLLMError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags, extraParams));
        } catch (err2) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err2}`);
          if (handler.raiseError) {
            throw err2;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreLLM) {
        try {
          await ((_a = handler.handleLLMEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId, this.tags, extraParams));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForChainRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreChain) {
        try {
          await ((_a = handler.handleChainError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags, kwargs));
        } catch (err2) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err2}`);
          if (handler.raiseError) {
            throw err2;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreChain) {
        try {
          await ((_a = handler.handleChainEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId, this.tags, kwargs));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleAgentAction(action) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreAgent) {
        try {
          await ((_a = handler.handleAgentAction) == null ? void 0 : _a.call(handler, action, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleAgentEnd(action) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreAgent) {
        try {
          await ((_a = handler.handleAgentEnd) == null ? void 0 : _a.call(handler, action, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForToolRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleToolError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreAgent) {
        try {
          await ((_a = handler.handleToolError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags));
        } catch (err2) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err2}`);
          if (handler.raiseError) {
            throw err2;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleToolEnd(output) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreAgent) {
        try {
          await ((_a = handler.handleToolEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManager = class extends BaseCallbackManager {
  constructor(parentRunId, options) {
    var _a, _b, _c, _d, _e, _f;
    super();
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "inheritableHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "inheritableTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "inheritableMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "callback_manager"
    });
    Object.defineProperty(this, "_parentRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.handlers = (_a = options == null ? void 0 : options.handlers) != null ? _a : this.handlers;
    this.inheritableHandlers = (_b = options == null ? void 0 : options.inheritableHandlers) != null ? _b : this.inheritableHandlers;
    this.tags = (_c = options == null ? void 0 : options.tags) != null ? _c : this.tags;
    this.inheritableTags = (_d = options == null ? void 0 : options.inheritableTags) != null ? _d : this.inheritableTags;
    this.metadata = (_e = options == null ? void 0 : options.metadata) != null ? _e : this.metadata;
    this.inheritableMetadata = (_f = options == null ? void 0 : options.inheritableMetadata) != null ? _f : this.inheritableMetadata;
    this._parentRunId = parentRunId;
  }
  /**
   * Gets the parent run ID, if any.
   *
   * @returns The parent run ID.
   */
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(llm, prompts, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    return Promise.all(prompts.map(async (prompt, idx) => {
      const runId_ = idx === 0 && runId ? runId : v4_default();
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreLLM) {
          return;
        }
        if (isBaseTracer(handler)) {
          handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
        }
        return consumeCallback(async () => {
          var _a;
          try {
            await ((_a = handler.handleLLMStart) == null ? void 0 : _a.call(handler, llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(llm, messages, runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    return Promise.all(messages.map(async (messageGroup, idx) => {
      const runId_ = idx === 0 && runId ? runId : v4_default();
      await Promise.all(this.handlers.map((handler) => {
        if (handler.ignoreLLM) {
          return;
        }
        if (isBaseTracer(handler)) {
          handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);
        }
        return consumeCallback(async () => {
          var _a, _b;
          try {
            if (handler.handleChatModelStart) {
              await ((_a = handler.handleChatModelStart) == null ? void 0 : _a.call(handler, llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
            } else if (handler.handleLLMStart) {
              const messageString = getBufferString(messageGroup);
              await ((_b = handler.handleLLMStart) == null ? void 0 : _b.call(handler, llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName));
            }
          } catch (err) {
            const logFunction = handler.raiseError ? console.error : console.warn;
            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
            if (handler.raiseError) {
              throw err;
            }
          }
        }, handler.awaitHandlers);
      }));
      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(chain, inputs, runId = v4_default(), runType = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreChain) {
        return;
      }
      if (isBaseTracer(handler)) {
        handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);
      }
      return consumeCallback(async () => {
        var _a;
        try {
          await ((_a = handler.handleChainStart) == null ? void 0 : _a.call(handler, chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(tool, input, runId = v4_default(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreAgent) {
        return;
      }
      if (isBaseTracer(handler)) {
        handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);
      }
      return consumeCallback(async () => {
        var _a;
        try {
          await ((_a = handler.handleToolStart) == null ? void 0 : _a.call(handler, tool, input, runId, this._parentRunId, this.tags, this.metadata, runName));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(retriever, query, runId = v4_default(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => {
      if (handler.ignoreRetriever) {
        return;
      }
      if (isBaseTracer(handler)) {
        handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);
      }
      return consumeCallback(async () => {
        var _a;
        try {
          await ((_a = handler.handleRetrieverStart) == null ? void 0 : _a.call(handler, retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }, handler.awaitHandlers);
    }));
    return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleCustomEvent(eventName, data, runId, _tags, _metadata) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreCustomEvent) {
        try {
          await ((_a = handler.handleCustomEvent) == null ? void 0 : _a.call(handler, eventName, data, runId, this.tags, this.metadata));
        } catch (err) {
          const logFunction = handler.raiseError ? console.error : console.warn;
          logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);
          if (handler.raiseError) {
            throw err;
          }
        }
      }
    }, handler.awaitHandlers)));
  }
  addHandler(handler, inherit = true) {
    this.handlers.push(handler);
    if (inherit) {
      this.inheritableHandlers.push(handler);
    }
  }
  removeHandler(handler) {
    this.handlers = this.handlers.filter((_handler) => _handler !== handler);
    this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);
  }
  setHandlers(handlers, inherit = true) {
    this.handlers = [];
    this.inheritableHandlers = [];
    for (const handler of handlers) {
      this.addHandler(handler, inherit);
    }
  }
  addTags(tags, inherit = true) {
    this.removeTags(tags);
    this.tags.push(...tags);
    if (inherit) {
      this.inheritableTags.push(...tags);
    }
  }
  removeTags(tags) {
    this.tags = this.tags.filter((tag) => !tags.includes(tag));
    this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));
  }
  addMetadata(metadata, inherit = true) {
    this.metadata = { ...this.metadata, ...metadata };
    if (inherit) {
      this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };
    }
  }
  removeMetadata(metadata) {
    for (const key of Object.keys(metadata)) {
      delete this.metadata[key];
      delete this.inheritableMetadata[key];
    }
  }
  copy(additionalHandlers = [], inherit = true) {
    const manager = new CallbackManager(this._parentRunId);
    for (const handler of this.handlers) {
      const inheritable = this.inheritableHandlers.includes(handler);
      manager.addHandler(handler, inheritable);
    }
    for (const tag of this.tags) {
      const inheritable = this.inheritableTags.includes(tag);
      manager.addTags([tag], inheritable);
    }
    for (const key of Object.keys(this.metadata)) {
      const inheritable = Object.keys(this.inheritableMetadata).includes(key);
      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);
    }
    for (const handler of additionalHandlers) {
      if (
        // Prevent multiple copies of console_callback_handler
        manager.handlers.filter((h) => h.name === "console_callback_handler").some((h) => h.name === handler.name)
      ) {
        continue;
      }
      manager.addHandler(handler, inherit);
    }
    return manager;
  }
  static fromHandlers(handlers) {
    class Handler extends BaseCallbackHandler {
      constructor() {
        super();
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: v4_default()
        });
        Object.assign(this, handlers);
      }
    }
    const manager = new this();
    manager.addHandler(new Handler());
    return manager;
  }
  static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
    return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);
  }
  // TODO: Deprecate async method in favor of this one.
  static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
    var _a, _b, _c, _d, _e;
    let callbackManager;
    if (inheritableHandlers || localHandlers) {
      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
        callbackManager = new CallbackManager();
        callbackManager.setHandlers((_a = inheritableHandlers == null ? void 0 : inheritableHandlers.map(ensureHandler)) != null ? _a : [], true);
      } else {
        callbackManager = inheritableHandlers;
      }
      callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers == null ? void 0 : localHandlers.handlers, false);
    }
    const verboseEnabled = getEnvironmentVariable2("LANGCHAIN_VERBOSE") === "true" || (options == null ? void 0 : options.verbose);
    const tracingV2Enabled = ((_b = LangChainTracer.getTraceableRunTree()) == null ? void 0 : _b.tracingEnabled) || isTracingEnabled2();
    const tracingEnabled = tracingV2Enabled || ((_c = getEnvironmentVariable2("LANGCHAIN_TRACING")) != null ? _c : false);
    if (verboseEnabled || tracingEnabled) {
      if (!callbackManager) {
        callbackManager = new CallbackManager();
      }
      if (verboseEnabled && !callbackManager.handlers.some((handler) => handler.name === ConsoleCallbackHandler.prototype.name)) {
        const consoleHandler = new ConsoleCallbackHandler();
        callbackManager.addHandler(consoleHandler, true);
      }
      if (tracingEnabled && !callbackManager.handlers.some((handler) => handler.name === "langchain_tracer")) {
        if (tracingV2Enabled) {
          const tracerV2 = new LangChainTracer();
          callbackManager.addHandler(tracerV2, true);
          callbackManager._parentRunId = (_e = (_d = LangChainTracer.getTraceableRunTree()) == null ? void 0 : _d.id) != null ? _e : callbackManager._parentRunId;
        }
      }
    }
    for (const { contextVar, inheritable = true, handlerClass, envVar } of _getConfigureHooks()) {
      const createIfNotInContext = envVar && getEnvironmentVariable2(envVar) === "true" && handlerClass;
      let handler;
      const contextVarValue = contextVar !== void 0 ? getContextVariable(contextVar) : void 0;
      if (contextVarValue && isBaseCallbackHandler(contextVarValue)) {
        handler = contextVarValue;
      } else if (createIfNotInContext) {
        handler = new handlerClass({});
      }
      if (handler !== void 0) {
        if (!callbackManager) {
          callbackManager = new CallbackManager();
        }
        if (!callbackManager.handlers.some((h) => h.name === handler.name)) {
          callbackManager.addHandler(handler, inheritable);
        }
      }
    }
    if (inheritableTags || localTags) {
      if (callbackManager) {
        callbackManager.addTags(inheritableTags != null ? inheritableTags : []);
        callbackManager.addTags(localTags != null ? localTags : [], false);
      }
    }
    if (inheritableMetadata || localMetadata) {
      if (callbackManager) {
        callbackManager.addMetadata(inheritableMetadata != null ? inheritableMetadata : {});
        callbackManager.addMetadata(localMetadata != null ? localMetadata : {}, false);
      }
    }
    return callbackManager;
  }
};
function ensureHandler(handler) {
  if ("name" in handler) {
    return handler;
  }
  return BaseCallbackHandler.fromMethods(handler);
}

// node_modules/@langchain/core/dist/singletons/async_local_storage/index.js
var MockAsyncLocalStorage2 = class {
  getStore() {
    return void 0;
  }
  run(_store, callback) {
    return callback();
  }
  enterWith(_store) {
    return void 0;
  }
};
var mockAsyncLocalStorage2 = new MockAsyncLocalStorage2();
var LC_CHILD_KEY = Symbol.for("lc:child_config");
var AsyncLocalStorageProvider2 = class {
  getInstance() {
    var _a;
    return (_a = getGlobalAsyncLocalStorageInstance()) != null ? _a : mockAsyncLocalStorage2;
  }
  getRunnableConfig() {
    var _a, _b;
    const storage = this.getInstance();
    return (_b = (_a = storage.getStore()) == null ? void 0 : _a.extra) == null ? void 0 : _b[LC_CHILD_KEY];
  }
  runWithConfig(config, callback, avoidCreatingRootRunTree) {
    var _a;
    const callbackManager = CallbackManager._configureSync(config == null ? void 0 : config.callbacks, void 0, config == null ? void 0 : config.tags, void 0, config == null ? void 0 : config.metadata);
    const storage = this.getInstance();
    const previousValue = storage.getStore();
    const parentRunId = callbackManager == null ? void 0 : callbackManager.getParentRunId();
    const langChainTracer = (_a = callbackManager == null ? void 0 : callbackManager.handlers) == null ? void 0 : _a.find((handler) => (handler == null ? void 0 : handler.name) === "langchain_tracer");
    let runTree;
    if (langChainTracer && parentRunId) {
      runTree = langChainTracer.convertToRunTree(parentRunId);
    } else if (!avoidCreatingRootRunTree) {
      runTree = new RunTree({
        name: "<runnable_lambda>",
        tracingEnabled: false
      });
    }
    if (runTree) {
      runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };
    }
    if (previousValue !== void 0 && previousValue[_CONTEXT_VARIABLES_KEY] !== void 0) {
      if (runTree === void 0) {
        runTree = {};
      }
      runTree[_CONTEXT_VARIABLES_KEY] = previousValue[_CONTEXT_VARIABLES_KEY];
    }
    return storage.run(runTree, callback);
  }
  initializeGlobalInstance(instance) {
    if (getGlobalAsyncLocalStorageInstance() === void 0) {
      setGlobalAsyncLocalStorageInstance(instance);
    }
  }
};
var AsyncLocalStorageProviderSingleton2 = new AsyncLocalStorageProvider2();

// node_modules/@langchain/core/dist/runnables/config.js
var DEFAULT_RECURSION_LIMIT = 25;
async function getCallbackManagerForConfig(config) {
  return CallbackManager._configureSync(config == null ? void 0 : config.callbacks, void 0, config == null ? void 0 : config.tags, void 0, config == null ? void 0 : config.metadata);
}
function mergeConfigs(...configs) {
  var _a, _b, _c;
  const copy = {};
  for (const options of configs.filter((c) => !!c)) {
    for (const key of Object.keys(options)) {
      if (key === "metadata") {
        copy[key] = { ...copy[key], ...options[key] };
      } else if (key === "tags") {
        const baseKeys = (_a = copy[key]) != null ? _a : [];
        copy[key] = [...new Set(baseKeys.concat((_b = options[key]) != null ? _b : []))];
      } else if (key === "configurable") {
        copy[key] = { ...copy[key], ...options[key] };
      } else if (key === "timeout") {
        if (copy.timeout === void 0) {
          copy.timeout = options.timeout;
        } else if (options.timeout !== void 0) {
          copy.timeout = Math.min(copy.timeout, options.timeout);
        }
      } else if (key === "signal") {
        if (copy.signal === void 0) {
          copy.signal = options.signal;
        } else if (options.signal !== void 0) {
          if ("any" in AbortSignal) {
            copy.signal = AbortSignal.any([
              copy.signal,
              options.signal
            ]);
          } else {
            copy.signal = options.signal;
          }
        }
      } else if (key === "callbacks") {
        const baseCallbacks = copy.callbacks;
        const providedCallbacks = options.callbacks;
        if (Array.isArray(providedCallbacks)) {
          if (!baseCallbacks) {
            copy.callbacks = providedCallbacks;
          } else if (Array.isArray(baseCallbacks)) {
            copy.callbacks = baseCallbacks.concat(providedCallbacks);
          } else {
            const manager = baseCallbacks.copy();
            for (const callback of providedCallbacks) {
              manager.addHandler(ensureHandler(callback), true);
            }
            copy.callbacks = manager;
          }
        } else if (providedCallbacks) {
          if (!baseCallbacks) {
            copy.callbacks = providedCallbacks;
          } else if (Array.isArray(baseCallbacks)) {
            const manager = providedCallbacks.copy();
            for (const callback of baseCallbacks) {
              manager.addHandler(ensureHandler(callback), true);
            }
            copy.callbacks = manager;
          } else {
            copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {
              handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),
              inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),
              tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),
              inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),
              metadata: {
                ...baseCallbacks.metadata,
                ...providedCallbacks.metadata
              }
            });
          }
        }
      } else {
        const typedKey = key;
        copy[typedKey] = (_c = options[typedKey]) != null ? _c : copy[typedKey];
      }
    }
  }
  return copy;
}
var PRIMITIVES = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
function ensureConfig(config) {
  var _a;
  const implicitConfig = AsyncLocalStorageProviderSingleton2.getRunnableConfig();
  let empty = {
    tags: [],
    metadata: {},
    recursionLimit: 25,
    runId: void 0
  };
  if (implicitConfig) {
    const { runId, runName, ...rest } = implicitConfig;
    empty = Object.entries(rest).reduce(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (currentConfig, [key, value]) => {
        if (value !== void 0) {
          currentConfig[key] = value;
        }
        return currentConfig;
      },
      empty
    );
  }
  if (config) {
    empty = Object.entries(config).reduce(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (currentConfig, [key, value]) => {
        if (value !== void 0) {
          currentConfig[key] = value;
        }
        return currentConfig;
      },
      empty
    );
  }
  if (empty == null ? void 0 : empty.configurable) {
    for (const key of Object.keys(empty.configurable)) {
      if (PRIMITIVES.has(typeof empty.configurable[key]) && !((_a = empty.metadata) == null ? void 0 : _a[key])) {
        if (!empty.metadata) {
          empty.metadata = {};
        }
        empty.metadata[key] = empty.configurable[key];
      }
    }
  }
  if (empty.timeout !== void 0) {
    if (empty.timeout <= 0) {
      throw new Error("Timeout must be a positive number");
    }
    const timeoutSignal = AbortSignal.timeout(empty.timeout);
    if (empty.signal !== void 0) {
      if ("any" in AbortSignal) {
        empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);
      }
    } else {
      empty.signal = timeoutSignal;
    }
    delete empty.timeout;
  }
  return empty;
}
function patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId } = {}) {
  const newConfig = ensureConfig(config);
  if (callbacks !== void 0) {
    delete newConfig.runName;
    newConfig.callbacks = callbacks;
  }
  if (recursionLimit !== void 0) {
    newConfig.recursionLimit = recursionLimit;
  }
  if (maxConcurrency !== void 0) {
    newConfig.maxConcurrency = maxConcurrency;
  }
  if (runName !== void 0) {
    newConfig.runName = runName;
  }
  if (configurable !== void 0) {
    newConfig.configurable = { ...newConfig.configurable, ...configurable };
  }
  if (runId !== void 0) {
    delete newConfig.runId;
  }
  return newConfig;
}
function pickRunnableConfigKeys(config) {
  return config ? {
    configurable: config.configurable,
    recursionLimit: config.recursionLimit,
    callbacks: config.callbacks,
    tags: config.tags,
    metadata: config.metadata,
    maxConcurrency: config.maxConcurrency,
    timeout: config.timeout,
    signal: config.signal
  } : void 0;
}

// node_modules/@langchain/core/dist/utils/signal.js
async function raceWithSignal(promise, signal) {
  if (signal === void 0) {
    return promise;
  }
  let listener;
  return Promise.race([
    promise.catch((err) => {
      if (!(signal == null ? void 0 : signal.aborted)) {
        throw err;
      } else {
        return void 0;
      }
    }),
    new Promise((_, reject) => {
      listener = () => {
        reject(new Error("Aborted"));
      };
      signal.addEventListener("abort", listener);
      if (signal.aborted) {
        reject(new Error("Aborted"));
      }
    })
  ]).finally(() => signal.removeEventListener("abort", listener));
}

// node_modules/@langchain/core/dist/utils/stream.js
var IterableReadableStream = class extends ReadableStream {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "reader", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  ensureReader() {
    if (!this.reader) {
      this.reader = this.getReader();
    }
  }
  async next() {
    this.ensureReader();
    try {
      const result = await this.reader.read();
      if (result.done) {
        this.reader.releaseLock();
        return {
          done: true,
          value: void 0
        };
      } else {
        return {
          done: false,
          value: result.value
        };
      }
    } catch (e) {
      this.reader.releaseLock();
      throw e;
    }
  }
  async return() {
    this.ensureReader();
    if (this.locked) {
      const cancelPromise = this.reader.cancel();
      this.reader.releaseLock();
      await cancelPromise;
    }
    return { done: true, value: void 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async throw(e) {
    this.ensureReader();
    if (this.locked) {
      const cancelPromise = this.reader.cancel();
      this.reader.releaseLock();
      await cancelPromise;
    }
    throw e;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore Not present in Node 18 types, required in latest Node 22
  async [Symbol.asyncDispose]() {
    await this.return();
  }
  static fromReadableStream(stream) {
    const reader = stream.getReader();
    return new IterableReadableStream({
      start(controller) {
        return pump();
        function pump() {
          return reader.read().then(({ done, value }) => {
            if (done) {
              controller.close();
              return;
            }
            controller.enqueue(value);
            return pump();
          });
        }
      },
      cancel() {
        reader.releaseLock();
      }
    });
  }
  static fromAsyncGenerator(generator) {
    return new IterableReadableStream({
      async pull(controller) {
        const { value, done } = await generator.next();
        if (done) {
          controller.close();
        }
        controller.enqueue(value);
      },
      async cancel(reason) {
        await generator.return(reason);
      }
    });
  }
};
function atee(iter, length = 2) {
  const buffers = Array.from({ length }, () => []);
  return buffers.map(async function* makeIter(buffer) {
    while (true) {
      if (buffer.length === 0) {
        const result = await iter.next();
        for (const buffer2 of buffers) {
          buffer2.push(result);
        }
      } else if (buffer[0].done) {
        return;
      } else {
        yield buffer.shift().value;
      }
    }
  });
}
function concat(first, second) {
  if (Array.isArray(first) && Array.isArray(second)) {
    return first.concat(second);
  } else if (typeof first === "string" && typeof second === "string") {
    return first + second;
  } else if (typeof first === "number" && typeof second === "number") {
    return first + second;
  } else if (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    "concat" in first && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof first.concat === "function"
  ) {
    return first.concat(second);
  } else if (typeof first === "object" && typeof second === "object") {
    const chunk = { ...first };
    for (const [key, value] of Object.entries(second)) {
      if (key in chunk && !Array.isArray(chunk[key])) {
        chunk[key] = concat(chunk[key], value);
      } else {
        chunk[key] = value;
      }
    }
    return chunk;
  } else {
    throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);
  }
}
var AsyncGeneratorWithSetup = class {
  constructor(params) {
    var _a, _b;
    Object.defineProperty(this, "generator", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "setup", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "signal", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "firstResult", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "firstResultUsed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    this.generator = params.generator;
    this.config = params.config;
    this.signal = (_b = params.signal) != null ? _b : (_a = this.config) == null ? void 0 : _a.signal;
    this.setup = new Promise((resolve, reject) => {
      void AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(params.config), async () => {
        this.firstResult = params.generator.next();
        if (params.startSetup) {
          this.firstResult.then(params.startSetup).then(resolve, reject);
        } else {
          this.firstResult.then((_result) => resolve(void 0), reject);
        }
      }, true);
    });
  }
  async next(...args) {
    var _a;
    (_a = this.signal) == null ? void 0 : _a.throwIfAborted();
    if (!this.firstResultUsed) {
      this.firstResultUsed = true;
      return this.firstResult;
    }
    return AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(this.config), this.signal ? async () => {
      return raceWithSignal(this.generator.next(...args), this.signal);
    } : async () => {
      return this.generator.next(...args);
    }, true);
  }
  async return(value) {
    return this.generator.return(value);
  }
  async throw(e) {
    return this.generator.throw(e);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore Not present in Node 18 types, required in latest Node 22
  async [Symbol.asyncDispose]() {
    await this.return();
  }
};
async function pipeGeneratorWithSetup(to, generator, startSetup, signal, ...args) {
  const gen = new AsyncGeneratorWithSetup({
    generator,
    startSetup,
    signal
  });
  const setup = await gen.setup;
  return { output: to(gen, setup, ...args), setup };
}

// node_modules/@langchain/core/dist/tracers/log_stream.js
var RunLogPatch = class {
  constructor(fields) {
    var _a;
    Object.defineProperty(this, "ops", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.ops = (_a = fields.ops) != null ? _a : [];
  }
  concat(other) {
    const ops = this.ops.concat(other.ops);
    const states = applyPatch({}, ops);
    return new RunLog({
      ops,
      state: states[states.length - 1].newDocument
    });
  }
};
var RunLog = class extends RunLogPatch {
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "state", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.state = fields.state;
  }
  concat(other) {
    const ops = this.ops.concat(other.ops);
    const states = applyPatch(this.state, other.ops);
    return new RunLog({ ops, state: states[states.length - 1].newDocument });
  }
  static fromRunLogPatch(patch) {
    const states = applyPatch({}, patch.ops);
    return new RunLog({
      ops: patch.ops,
      state: states[states.length - 1].newDocument
    });
  }
};
var isLogStreamHandler = (handler) => handler.name === "log_stream_tracer";
async function _getStandardizedInputs(run, schemaFormat) {
  if (schemaFormat === "original") {
    throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  }
  const { inputs } = run;
  if (["retriever", "llm", "prompt"].includes(run.run_type)) {
    return inputs;
  }
  if (Object.keys(inputs).length === 1 && (inputs == null ? void 0 : inputs.input) === "") {
    return void 0;
  }
  return inputs.input;
}
async function _getStandardizedOutputs(run, schemaFormat) {
  const { outputs } = run;
  if (schemaFormat === "original") {
    return outputs;
  }
  if (["retriever", "llm", "prompt"].includes(run.run_type)) {
    return outputs;
  }
  if (outputs !== void 0 && Object.keys(outputs).length === 1 && (outputs == null ? void 0 : outputs.output) !== void 0) {
    return outputs.output;
  }
  return outputs;
}
function isChatGenerationChunk(x) {
  return x !== void 0 && x.message !== void 0;
}
var LogStreamCallbackHandler = class extends BaseTracer {
  constructor(fields) {
    var _a, _b;
    super({ _awaitHandler: true, ...fields });
    Object.defineProperty(this, "autoClose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "includeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_schemaFormat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "original"
    });
    Object.defineProperty(this, "rootId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "keyMapByRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "counterMapByRunName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "transformStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "writer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "receiveStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "log_stream_tracer"
    });
    Object.defineProperty(this, "lc_prefer_streaming", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    this.autoClose = (_a = fields == null ? void 0 : fields.autoClose) != null ? _a : true;
    this.includeNames = fields == null ? void 0 : fields.includeNames;
    this.includeTypes = fields == null ? void 0 : fields.includeTypes;
    this.includeTags = fields == null ? void 0 : fields.includeTags;
    this.excludeNames = fields == null ? void 0 : fields.excludeNames;
    this.excludeTypes = fields == null ? void 0 : fields.excludeTypes;
    this.excludeTags = fields == null ? void 0 : fields.excludeTags;
    this._schemaFormat = (_b = fields == null ? void 0 : fields._schemaFormat) != null ? _b : this._schemaFormat;
    this.transformStream = new TransformStream();
    this.writer = this.transformStream.writable.getWriter();
    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(_run) {
  }
  _includeRun(run) {
    var _a;
    if (run.id === this.rootId) {
      return false;
    }
    const runTags = (_a = run.tags) != null ? _a : [];
    let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    if (this.includeNames !== void 0) {
      include = include || this.includeNames.includes(run.name);
    }
    if (this.includeTypes !== void 0) {
      include = include || this.includeTypes.includes(run.run_type);
    }
    if (this.includeTags !== void 0) {
      include = include || runTags.find((tag) => {
        var _a2;
        return (_a2 = this.includeTags) == null ? void 0 : _a2.includes(tag);
      }) !== void 0;
    }
    if (this.excludeNames !== void 0) {
      include = include && !this.excludeNames.includes(run.name);
    }
    if (this.excludeTypes !== void 0) {
      include = include && !this.excludeTypes.includes(run.run_type);
    }
    if (this.excludeTags !== void 0) {
      include = include && runTags.every((tag) => {
        var _a2;
        return !((_a2 = this.excludeTags) == null ? void 0 : _a2.includes(tag));
      });
    }
    return include;
  }
  async *tapOutputIterable(runId, output) {
    for await (const chunk of output) {
      if (runId !== this.rootId) {
        const key = this.keyMapByRunId[runId];
        if (key) {
          await this.writer.write(new RunLogPatch({
            ops: [
              {
                op: "add",
                path: `/logs/${key}/streamed_output/-`,
                value: chunk
              }
            ]
          }));
        }
      }
      yield chunk;
    }
  }
  async onRunCreate(run) {
    var _a, _b, _c;
    if (this.rootId === void 0) {
      this.rootId = run.id;
      await this.writer.write(new RunLogPatch({
        ops: [
          {
            op: "replace",
            path: "",
            value: {
              id: run.id,
              name: run.name,
              type: run.run_type,
              streamed_output: [],
              final_output: void 0,
              logs: {}
            }
          }
        ]
      }));
    }
    if (!this._includeRun(run)) {
      return;
    }
    if (this.counterMapByRunName[run.name] === void 0) {
      this.counterMapByRunName[run.name] = 0;
    }
    this.counterMapByRunName[run.name] += 1;
    const count = this.counterMapByRunName[run.name];
    this.keyMapByRunId[run.id] = count === 1 ? run.name : `${run.name}:${count}`;
    const logEntry = {
      id: run.id,
      name: run.name,
      type: run.run_type,
      tags: (_a = run.tags) != null ? _a : [],
      metadata: (_c = (_b = run.extra) == null ? void 0 : _b.metadata) != null ? _c : {},
      start_time: new Date(run.start_time).toISOString(),
      streamed_output: [],
      streamed_output_str: [],
      final_output: void 0,
      end_time: void 0
    };
    if (this._schemaFormat === "streaming_events") {
      logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);
    }
    await this.writer.write(new RunLogPatch({
      ops: [
        {
          op: "add",
          path: `/logs/${this.keyMapByRunId[run.id]}`,
          value: logEntry
        }
      ]
    }));
  }
  async onRunUpdate(run) {
    try {
      const runName = this.keyMapByRunId[run.id];
      if (runName === void 0) {
        return;
      }
      const ops = [];
      if (this._schemaFormat === "streaming_events") {
        ops.push({
          op: "replace",
          path: `/logs/${runName}/inputs`,
          value: await _getStandardizedInputs(run, this._schemaFormat)
        });
      }
      ops.push({
        op: "add",
        path: `/logs/${runName}/final_output`,
        value: await _getStandardizedOutputs(run, this._schemaFormat)
      });
      if (run.end_time !== void 0) {
        ops.push({
          op: "add",
          path: `/logs/${runName}/end_time`,
          value: new Date(run.end_time).toISOString()
        });
      }
      const patch = new RunLogPatch({ ops });
      await this.writer.write(patch);
    } finally {
      if (run.id === this.rootId) {
        const patch = new RunLogPatch({
          ops: [
            {
              op: "replace",
              path: "/final_output",
              value: await _getStandardizedOutputs(run, this._schemaFormat)
            }
          ]
        });
        await this.writer.write(patch);
        if (this.autoClose) {
          await this.writer.close();
        }
      }
    }
  }
  async onLLMNewToken(run, token, kwargs) {
    const runName = this.keyMapByRunId[run.id];
    if (runName === void 0) {
      return;
    }
    const isChatModel = run.inputs.messages !== void 0;
    let streamedOutputValue;
    if (isChatModel) {
      if (isChatGenerationChunk(kwargs == null ? void 0 : kwargs.chunk)) {
        streamedOutputValue = kwargs == null ? void 0 : kwargs.chunk;
      } else {
        streamedOutputValue = new AIMessageChunk({
          id: `run-${run.id}`,
          content: token
        });
      }
    } else {
      streamedOutputValue = token;
    }
    const patch = new RunLogPatch({
      ops: [
        {
          op: "add",
          path: `/logs/${runName}/streamed_output_str/-`,
          value: token
        },
        {
          op: "add",
          path: `/logs/${runName}/streamed_output/-`,
          value: streamedOutputValue
        }
      ]
    });
    await this.writer.write(patch);
  }
};

// node_modules/@langchain/core/dist/outputs.js
var RUN_KEY = "__run";
var GenerationChunk = class {
  constructor(fields) {
    Object.defineProperty(this, "text", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "generationInfo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.text = fields.text;
    this.generationInfo = fields.generationInfo;
  }
  concat(chunk) {
    return new GenerationChunk({
      text: this.text + chunk.text,
      generationInfo: {
        ...this.generationInfo,
        ...chunk.generationInfo
      }
    });
  }
};
var ChatGenerationChunk = class extends GenerationChunk {
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "message", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.message = fields.message;
  }
  concat(chunk) {
    return new ChatGenerationChunk({
      text: this.text + chunk.text,
      generationInfo: {
        ...this.generationInfo,
        ...chunk.generationInfo
      },
      message: this.message.concat(chunk.message)
    });
  }
};

// node_modules/@langchain/core/dist/tracers/event_stream.js
function assignName({ name, serialized }) {
  if (name !== void 0) {
    return name;
  }
  if ((serialized == null ? void 0 : serialized.name) !== void 0) {
    return serialized.name;
  } else if ((serialized == null ? void 0 : serialized.id) !== void 0 && Array.isArray(serialized == null ? void 0 : serialized.id)) {
    return serialized.id[serialized.id.length - 1];
  }
  return "Unnamed";
}
var isStreamEventsHandler = (handler) => handler.name === "event_stream_tracer";
var EventStreamCallbackHandler = class extends BaseTracer {
  constructor(fields) {
    var _a;
    super({ _awaitHandler: true, ...fields });
    Object.defineProperty(this, "autoClose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "includeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "runInfoMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    Object.defineProperty(this, "tappedPromises", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    Object.defineProperty(this, "transformStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "writer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "receiveStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "event_stream_tracer"
    });
    Object.defineProperty(this, "lc_prefer_streaming", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    this.autoClose = (_a = fields == null ? void 0 : fields.autoClose) != null ? _a : true;
    this.includeNames = fields == null ? void 0 : fields.includeNames;
    this.includeTypes = fields == null ? void 0 : fields.includeTypes;
    this.includeTags = fields == null ? void 0 : fields.includeTags;
    this.excludeNames = fields == null ? void 0 : fields.excludeNames;
    this.excludeTypes = fields == null ? void 0 : fields.excludeTypes;
    this.excludeTags = fields == null ? void 0 : fields.excludeTags;
    this.transformStream = new TransformStream();
    this.writer = this.transformStream.writable.getWriter();
    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(_run) {
  }
  _includeRun(run) {
    var _a;
    const runTags = (_a = run.tags) != null ? _a : [];
    let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    if (this.includeNames !== void 0) {
      include = include || this.includeNames.includes(run.name);
    }
    if (this.includeTypes !== void 0) {
      include = include || this.includeTypes.includes(run.runType);
    }
    if (this.includeTags !== void 0) {
      include = include || runTags.find((tag) => {
        var _a2;
        return (_a2 = this.includeTags) == null ? void 0 : _a2.includes(tag);
      }) !== void 0;
    }
    if (this.excludeNames !== void 0) {
      include = include && !this.excludeNames.includes(run.name);
    }
    if (this.excludeTypes !== void 0) {
      include = include && !this.excludeTypes.includes(run.runType);
    }
    if (this.excludeTags !== void 0) {
      include = include && runTags.every((tag) => {
        var _a2;
        return !((_a2 = this.excludeTags) == null ? void 0 : _a2.includes(tag));
      });
    }
    return include;
  }
  async *tapOutputIterable(runId, outputStream) {
    const firstChunk = await outputStream.next();
    if (firstChunk.done) {
      return;
    }
    const runInfo = this.runInfoMap.get(runId);
    if (runInfo === void 0) {
      yield firstChunk.value;
      return;
    }
    function _formatOutputChunk(eventType, data) {
      if (eventType === "llm" && typeof data === "string") {
        return new GenerationChunk({ text: data });
      }
      return data;
    }
    let tappedPromise = this.tappedPromises.get(runId);
    if (tappedPromise === void 0) {
      let tappedPromiseResolver;
      tappedPromise = new Promise((resolve) => {
        tappedPromiseResolver = resolve;
      });
      this.tappedPromises.set(runId, tappedPromise);
      try {
        const event = {
          event: `on_${runInfo.runType}_stream`,
          run_id: runId,
          name: runInfo.name,
          tags: runInfo.tags,
          metadata: runInfo.metadata,
          data: {}
        };
        await this.send({
          ...event,
          data: {
            chunk: _formatOutputChunk(runInfo.runType, firstChunk.value)
          }
        }, runInfo);
        yield firstChunk.value;
        for await (const chunk of outputStream) {
          if (runInfo.runType !== "tool" && runInfo.runType !== "retriever") {
            await this.send({
              ...event,
              data: {
                chunk: _formatOutputChunk(runInfo.runType, chunk)
              }
            }, runInfo);
          }
          yield chunk;
        }
      } finally {
        tappedPromiseResolver();
      }
    } else {
      yield firstChunk.value;
      for await (const chunk of outputStream) {
        yield chunk;
      }
    }
  }
  async send(payload, run) {
    if (this._includeRun(run)) {
      await this.writer.write(payload);
    }
  }
  async sendEndEvent(payload, run) {
    const tappedPromise = this.tappedPromises.get(payload.run_id);
    if (tappedPromise !== void 0) {
      void tappedPromise.then(() => {
        void this.send(payload, run);
      });
    } else {
      await this.send(payload, run);
    }
  }
  async onLLMStart(run) {
    var _a, _b, _c, _d, _e, _f;
    const runName = assignName(run);
    const runType = run.inputs.messages !== void 0 ? "chat_model" : "llm";
    const runInfo = {
      tags: (_a = run.tags) != null ? _a : [],
      metadata: (_c = (_b = run.extra) == null ? void 0 : _b.metadata) != null ? _c : {},
      name: runName,
      runType,
      inputs: run.inputs
    };
    this.runInfoMap.set(run.id, runInfo);
    const eventName = `on_${runType}_start`;
    await this.send({
      event: eventName,
      data: {
        input: run.inputs
      },
      name: runName,
      tags: (_d = run.tags) != null ? _d : [],
      run_id: run.id,
      metadata: (_f = (_e = run.extra) == null ? void 0 : _e.metadata) != null ? _f : {}
    }, runInfo);
  }
  async onLLMNewToken(run, token, kwargs) {
    const runInfo = this.runInfoMap.get(run.id);
    let chunk;
    let eventName;
    if (runInfo === void 0) {
      throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);
    }
    if (this.runInfoMap.size === 1) {
      return;
    }
    if (runInfo.runType === "chat_model") {
      eventName = "on_chat_model_stream";
      if ((kwargs == null ? void 0 : kwargs.chunk) === void 0) {
        chunk = new AIMessageChunk({ content: token, id: `run-${run.id}` });
      } else {
        chunk = kwargs.chunk.message;
      }
    } else if (runInfo.runType === "llm") {
      eventName = "on_llm_stream";
      if ((kwargs == null ? void 0 : kwargs.chunk) === void 0) {
        chunk = new GenerationChunk({ text: token });
      } else {
        chunk = kwargs.chunk;
      }
    } else {
      throw new Error(`Unexpected run type ${runInfo.runType}`);
    }
    await this.send({
      event: eventName,
      data: {
        chunk
      },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async onLLMEnd(run) {
    var _a, _b, _c, _d;
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    let eventName;
    if (runInfo === void 0) {
      throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);
    }
    const generations = (_a = run.outputs) == null ? void 0 : _a.generations;
    let output;
    if (runInfo.runType === "chat_model") {
      for (const generation of generations != null ? generations : []) {
        if (output !== void 0) {
          break;
        }
        output = (_b = generation[0]) == null ? void 0 : _b.message;
      }
      eventName = "on_chat_model_end";
    } else if (runInfo.runType === "llm") {
      output = {
        generations: generations == null ? void 0 : generations.map((generation) => {
          return generation.map((chunk) => {
            return {
              text: chunk.text,
              generationInfo: chunk.generationInfo
            };
          });
        }),
        llmOutput: (_d = (_c = run.outputs) == null ? void 0 : _c.llmOutput) != null ? _d : {}
      };
      eventName = "on_llm_end";
    } else {
      throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);
    }
    await this.sendEndEvent({
      event: eventName,
      data: {
        output,
        input: runInfo.inputs
      },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async onChainStart(run) {
    var _a, _b, _c, _d, _e, _f, _g;
    const runName = assignName(run);
    const runType = (_a = run.run_type) != null ? _a : "chain";
    const runInfo = {
      tags: (_b = run.tags) != null ? _b : [],
      metadata: (_d = (_c = run.extra) == null ? void 0 : _c.metadata) != null ? _d : {},
      name: runName,
      runType: run.run_type
    };
    let eventData = {};
    if (run.inputs.input === "" && Object.keys(run.inputs).length === 1) {
      eventData = {};
      runInfo.inputs = {};
    } else if (run.inputs.input !== void 0) {
      eventData.input = run.inputs.input;
      runInfo.inputs = run.inputs.input;
    } else {
      eventData.input = run.inputs;
      runInfo.inputs = run.inputs;
    }
    this.runInfoMap.set(run.id, runInfo);
    await this.send({
      event: `on_${runType}_start`,
      data: eventData,
      name: runName,
      tags: (_e = run.tags) != null ? _e : [],
      run_id: run.id,
      metadata: (_g = (_f = run.extra) == null ? void 0 : _f.metadata) != null ? _g : {}
    }, runInfo);
  }
  async onChainEnd(run) {
    var _a, _b, _c, _d, _e;
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    if (runInfo === void 0) {
      throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);
    }
    const eventName = `on_${run.run_type}_end`;
    const inputs = (_b = (_a = run.inputs) != null ? _a : runInfo.inputs) != null ? _b : {};
    const outputs = (_d = (_c = run.outputs) == null ? void 0 : _c.output) != null ? _d : run.outputs;
    const data = {
      output: outputs,
      input: inputs
    };
    if (inputs.input && Object.keys(inputs).length === 1) {
      data.input = inputs.input;
      runInfo.inputs = inputs.input;
    }
    await this.sendEndEvent({
      event: eventName,
      data,
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: (_e = runInfo.metadata) != null ? _e : {}
    }, runInfo);
  }
  async onToolStart(run) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const runName = assignName(run);
    const runInfo = {
      tags: (_a = run.tags) != null ? _a : [],
      metadata: (_c = (_b = run.extra) == null ? void 0 : _b.metadata) != null ? _c : {},
      name: runName,
      runType: "tool",
      inputs: (_d = run.inputs) != null ? _d : {}
    };
    this.runInfoMap.set(run.id, runInfo);
    await this.send({
      event: "on_tool_start",
      data: {
        input: (_e = run.inputs) != null ? _e : {}
      },
      name: runName,
      run_id: run.id,
      tags: (_f = run.tags) != null ? _f : [],
      metadata: (_h = (_g = run.extra) == null ? void 0 : _g.metadata) != null ? _h : {}
    }, runInfo);
  }
  async onToolEnd(run) {
    var _a;
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    if (runInfo === void 0) {
      throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);
    }
    if (runInfo.inputs === void 0) {
      throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);
    }
    const output = ((_a = run.outputs) == null ? void 0 : _a.output) === void 0 ? run.outputs : run.outputs.output;
    await this.sendEndEvent({
      event: "on_tool_end",
      data: {
        output,
        input: runInfo.inputs
      },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  async onRetrieverStart(run) {
    var _a, _b, _c, _d, _e, _f;
    const runName = assignName(run);
    const runType = "retriever";
    const runInfo = {
      tags: (_a = run.tags) != null ? _a : [],
      metadata: (_c = (_b = run.extra) == null ? void 0 : _b.metadata) != null ? _c : {},
      name: runName,
      runType,
      inputs: {
        query: run.inputs.query
      }
    };
    this.runInfoMap.set(run.id, runInfo);
    await this.send({
      event: "on_retriever_start",
      data: {
        input: {
          query: run.inputs.query
        }
      },
      name: runName,
      tags: (_d = run.tags) != null ? _d : [],
      run_id: run.id,
      metadata: (_f = (_e = run.extra) == null ? void 0 : _e.metadata) != null ? _f : {}
    }, runInfo);
  }
  async onRetrieverEnd(run) {
    var _a, _b;
    const runInfo = this.runInfoMap.get(run.id);
    this.runInfoMap.delete(run.id);
    if (runInfo === void 0) {
      throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);
    }
    await this.sendEndEvent({
      event: "on_retriever_end",
      data: {
        output: (_b = (_a = run.outputs) == null ? void 0 : _a.documents) != null ? _b : run.outputs,
        input: runInfo.inputs
      },
      run_id: run.id,
      name: runInfo.name,
      tags: runInfo.tags,
      metadata: runInfo.metadata
    }, runInfo);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleCustomEvent(eventName, data, runId) {
    const runInfo = this.runInfoMap.get(runId);
    if (runInfo === void 0) {
      throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);
    }
    await this.send({
      event: "on_custom_event",
      run_id: runId,
      name: eventName,
      tags: runInfo.tags,
      metadata: runInfo.metadata,
      data
    }, runInfo);
  }
  async finish() {
    const pendingPromises = [...this.tappedPromises.values()];
    void Promise.all(pendingPromises).finally(() => {
      void this.writer.close();
    });
  }
};

// node_modules/@langchain/core/dist/utils/async_caller.js
var import_p_retry2 = __toESM(require_p_retry(), 1);
var import_p_queue3 = __toESM(require_dist(), 1);
var STATUS_NO_RETRY2 = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  409
  // Conflict
];
var defaultFailedAttemptHandler = (error) => {
  var _a, _b, _c;
  if (error.message.startsWith("Cancel") || error.message.startsWith("AbortError") || error.name === "AbortError") {
    throw error;
  }
  if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
    throw error;
  }
  const status = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (_b = (_a = error == null ? void 0 : error.response) == null ? void 0 : _a.status) != null ? _b : error == null ? void 0 : error.status
  );
  if (status && STATUS_NO_RETRY2.includes(+status)) {
    throw error;
  }
  if (((_c = error == null ? void 0 : error.error) == null ? void 0 : _c.code) === "insufficient_quota") {
    const err = new Error(error == null ? void 0 : error.message);
    err.name = "InsufficientQuotaError";
    throw err;
  }
};
var AsyncCaller2 = class {
  constructor(params) {
    var _a, _b, _c;
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "onFailedAttempt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxConcurrency = (_a = params.maxConcurrency) != null ? _a : Infinity;
    this.maxRetries = (_b = params.maxRetries) != null ? _b : 6;
    this.onFailedAttempt = (_c = params.onFailedAttempt) != null ? _c : defaultFailedAttemptHandler;
    const PQueue = "default" in import_p_queue3.default ? import_p_queue3.default.default : import_p_queue3.default;
    this.queue = new PQueue({ concurrency: this.maxConcurrency });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(callable, ...args) {
    return this.queue.add(() => (0, import_p_retry2.default)(() => callable(...args).catch((error) => {
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error(error);
      }
    }), {
      onFailedAttempt: this.onFailedAttempt,
      retries: this.maxRetries,
      randomize: true
      // If needed we can change some of the defaults here,
      // but they're quite sensible.
    }), { throwOnTimeout: true });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(options, callable, ...args) {
    if (options.signal) {
      return Promise.race([
        this.call(callable, ...args),
        new Promise((_, reject) => {
          var _a;
          (_a = options.signal) == null ? void 0 : _a.addEventListener("abort", () => {
            reject(new Error("AbortError"));
          });
        })
      ]);
    }
    return this.call(callable, ...args);
  }
  fetch(...args) {
    return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)));
  }
};

// node_modules/@langchain/core/dist/tracers/root_listener.js
var RootListenersTracer = class extends BaseTracer {
  constructor({ config, onStart, onEnd, onError }) {
    super({ _awaitHandler: true });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RootListenersTracer"
    });
    Object.defineProperty(this, "rootId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "argOnStart", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "argOnEnd", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "argOnError", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.config = config;
    this.argOnStart = onStart;
    this.argOnEnd = onEnd;
    this.argOnError = onError;
  }
  /**
   * This is a legacy method only called once for an entire run tree
   * therefore not useful here
   * @param {Run} _ Not used
   */
  persistRun(_) {
    return Promise.resolve();
  }
  async onRunCreate(run) {
    if (this.rootId) {
      return;
    }
    this.rootId = run.id;
    if (this.argOnStart) {
      await this.argOnStart(run, this.config);
    }
  }
  async onRunUpdate(run) {
    if (run.id !== this.rootId) {
      return;
    }
    if (!run.error) {
      if (this.argOnEnd) {
        await this.argOnEnd(run, this.config);
      }
    } else if (this.argOnError) {
      await this.argOnError(run, this.config);
    }
  }
};

// node_modules/@langchain/core/dist/runnables/utils.js
function isRunnableInterface(thing) {
  return thing ? thing.lc_runnable : false;
}
var _RootEventFilter = class {
  constructor(fields) {
    Object.defineProperty(this, "includeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.includeNames = fields.includeNames;
    this.includeTypes = fields.includeTypes;
    this.includeTags = fields.includeTags;
    this.excludeNames = fields.excludeNames;
    this.excludeTypes = fields.excludeTypes;
    this.excludeTags = fields.excludeTags;
  }
  includeEvent(event, rootType) {
    var _a;
    let include = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
    const eventTags = (_a = event.tags) != null ? _a : [];
    if (this.includeNames !== void 0) {
      include = include || this.includeNames.includes(event.name);
    }
    if (this.includeTypes !== void 0) {
      include = include || this.includeTypes.includes(rootType);
    }
    if (this.includeTags !== void 0) {
      include = include || eventTags.some((tag) => {
        var _a2;
        return (_a2 = this.includeTags) == null ? void 0 : _a2.includes(tag);
      });
    }
    if (this.excludeNames !== void 0) {
      include = include && !this.excludeNames.includes(event.name);
    }
    if (this.excludeTypes !== void 0) {
      include = include && !this.excludeTypes.includes(rootType);
    }
    if (this.excludeTags !== void 0) {
      include = include && eventTags.every((tag) => {
        var _a2;
        return !((_a2 = this.excludeTags) == null ? void 0 : _a2.includes(tag));
      });
    }
    return include;
  }
};

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions2 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions2,
  name: options
} : {
  ...defaultOptions2,
  ...options
};

// node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};

// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages))
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef() {
  return {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
  var _a, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a = def.type) == null ? void 0 : _a._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var emojiRegex2 = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex2 === void 0) {
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex2;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          ((_) => {
          })(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  var _a;
  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}
function addPattern(schema, regex2, message, refs) {
  var _a;
  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex2, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex2, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex2, refs) {
  var _a;
  if (!refs.applyRegexFlags || !regex2.flags) {
    return regex2.source;
  }
  const flags = {
    i: regex2.flags.includes("i"),
    m: regex2.flags.includes("m"),
    s: regex2.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex2.source.toLowerCase() : regex2.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a = source[i + 2]) == null ? void 0 : _a.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex2.source;
  }
  return pattern;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && ((_a = def.keyType) == null ? void 0 : _a._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => {
        var _a2;
        return {
          ...acc,
          [key]: (_a2 = parseDef(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "properties", key]
          })) != null ? _a2 : {}
        };
      }, {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: (_b = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _b : refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_c = def.keyType) == null ? void 0 : _c._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_d = def.keyType._def.checks) == null ? void 0 : _d.length)) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_f = def.keyType) == null ? void 0 : _f._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_g = def.keyType._def.type._def.checks) == null ? void 0 : _g.length)) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || {};
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef() {
  return {
    not: {}
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef instanceof ZodOptional) {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return true;
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  var _a;
  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: {}
      },
      innerSchema
    ]
  } : {};
};

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef() {
  return {
    not: {}
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef() {
  return {};
}

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return ((_) => void 0)(typeName);
  }
};

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  var _a;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(refs, def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return {};
      }
      return refs.$refStrategy === "seen" ? {} : void 0;
    }
  }
};
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
var addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  var _a;
  const refs = getRefs(options);
  const definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => {
    var _a2;
    return {
      ...acc,
      [name2]: (_a2 = parseDef(schema2._def, {
        ...refs,
        currentPath: [...refs.basePath, refs.definitionPath, name2]
      }, true)) != null ? _a2 : {}
    };
  }, {}) : void 0;
  const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a = parseDef(schema._def, name === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false)) != null ? _a : {};
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};

// node_modules/@langchain/core/dist/runnables/graph_mermaid.js
function _escapeNodeLabel(nodeLabel) {
  return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, "_");
}
var MARKDOWN_SPECIAL_CHARS = ["*", "_", "`"];
function _generateMermaidGraphStyles(nodeColors) {
  let styles2 = "";
  for (const [className, color2] of Object.entries(nodeColors)) {
    styles2 += `	classDef ${className} ${color2};
`;
  }
  return styles2;
}
function drawMermaid(nodes, edges, config) {
  var _a, _b, _c, _d, _e;
  const { firstNode, lastNode, nodeColors, withStyles = true, curveStyle = "linear", wrapLabelNWords = 9 } = config != null ? config : {};
  let mermaidGraph = withStyles ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%
graph TD;
` : "graph TD;\n";
  if (withStyles) {
    const defaultClassLabel = "default";
    const formatDict = {
      [defaultClassLabel]: "{0}({1})"
    };
    if (firstNode !== void 0) {
      formatDict[firstNode] = "{0}([{1}]):::first";
    }
    if (lastNode !== void 0) {
      formatDict[lastNode] = "{0}([{1}]):::last";
    }
    for (const [key, node] of Object.entries(nodes)) {
      const nodeName = (_a = node.name.split(":").pop()) != null ? _a : "";
      const label = MARKDOWN_SPECIAL_CHARS.some((char) => nodeName.startsWith(char) && nodeName.endsWith(char)) ? `<p>${nodeName}</p>` : nodeName;
      let finalLabel = label;
      if (Object.keys((_b = node.metadata) != null ? _b : {}).length) {
        finalLabel += `<hr/><small><em>${Object.entries((_c = node.metadata) != null ? _c : {}).map(([k, v]) => `${k} = ${v}`).join("\n")}</em></small>`;
      }
      const nodeLabel = ((_d = formatDict[key]) != null ? _d : formatDict[defaultClassLabel]).replace("{0}", _escapeNodeLabel(key)).replace("{1}", finalLabel);
      mermaidGraph += `	${nodeLabel}
`;
    }
  }
  const edgeGroups = {};
  for (const edge of edges) {
    const srcParts = edge.source.split(":");
    const tgtParts = edge.target.split(":");
    const commonPrefix = srcParts.filter((src, i) => src === tgtParts[i]).join(":");
    if (!edgeGroups[commonPrefix]) {
      edgeGroups[commonPrefix] = [];
    }
    edgeGroups[commonPrefix].push(edge);
  }
  const seenSubgraphs = /* @__PURE__ */ new Set();
  function addSubgraph(edges2, prefix) {
    const selfLoop = edges2.length === 1 && edges2[0].source === edges2[0].target;
    if (prefix && !selfLoop) {
      const subgraph = prefix.split(":").pop();
      if (seenSubgraphs.has(subgraph)) {
        throw new Error(`Found duplicate subgraph '${subgraph}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);
      }
      seenSubgraphs.add(subgraph);
      mermaidGraph += `	subgraph ${subgraph}
`;
    }
    for (const edge of edges2) {
      const { source, target, data, conditional } = edge;
      let edgeLabel = "";
      if (data !== void 0) {
        let edgeData = data;
        const words = edgeData.split(" ");
        if (words.length > wrapLabelNWords) {
          edgeData = Array.from({ length: Math.ceil(words.length / wrapLabelNWords) }, (_, i) => words.slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords).join(" ")).join("&nbsp;<br>&nbsp;");
        }
        edgeLabel = conditional ? ` -. &nbsp;${edgeData}&nbsp; .-> ` : ` -- &nbsp;${edgeData}&nbsp; --> `;
      } else {
        edgeLabel = conditional ? " -.-> " : " --> ";
      }
      mermaidGraph += `	${_escapeNodeLabel(source)}${edgeLabel}${_escapeNodeLabel(target)};
`;
    }
    for (const nestedPrefix in edgeGroups) {
      if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) {
        addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);
      }
    }
    if (prefix && !selfLoop) {
      mermaidGraph += "	end\n";
    }
  }
  addSubgraph((_e = edgeGroups[""]) != null ? _e : [], "");
  for (const prefix in edgeGroups) {
    if (!prefix.includes(":") && prefix !== "") {
      addSubgraph(edgeGroups[prefix], prefix);
    }
  }
  if (withStyles) {
    mermaidGraph += _generateMermaidGraphStyles(nodeColors != null ? nodeColors : {});
  }
  return mermaidGraph;
}
async function drawMermaidPng(mermaidSyntax, config) {
  let { backgroundColor = "white" } = config != null ? config : {};
  const mermaidSyntaxEncoded = btoa(mermaidSyntax);
  if (backgroundColor !== void 0) {
    const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;
    if (!hexColorPattern.test(backgroundColor)) {
      backgroundColor = `!${backgroundColor}`;
    }
  }
  const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}`;
  const res = await fetch(imageUrl);
  if (!res.ok) {
    throw new Error([
      `Failed to render the graph using the Mermaid.INK API.`,
      `Status code: ${res.status}`,
      `Status text: ${res.statusText}`
    ].join("\n"));
  }
  const content = await res.blob();
  return content;
}

// node_modules/@langchain/core/dist/runnables/graph.js
function nodeDataStr(id, data) {
  var _a;
  if (id !== void 0 && !validate_default(id)) {
    return id;
  } else if (isRunnableInterface(data)) {
    try {
      let dataStr = data.getName();
      dataStr = dataStr.startsWith("Runnable") ? dataStr.slice("Runnable".length) : dataStr;
      return dataStr;
    } catch (error) {
      return data.getName();
    }
  } else {
    return (_a = data.name) != null ? _a : "UnknownSchema";
  }
}
function nodeDataJson(node) {
  if (isRunnableInterface(node.data)) {
    return {
      type: "runnable",
      data: {
        id: node.data.lc_id,
        name: node.data.getName()
      }
    };
  } else {
    return {
      type: "schema",
      data: { ...zodToJsonSchema(node.data.schema), title: node.data.name }
    };
  }
}
var Graph = class {
  constructor(params) {
    var _a, _b;
    Object.defineProperty(this, "nodes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "edges", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    this.nodes = (_a = params == null ? void 0 : params.nodes) != null ? _a : this.nodes;
    this.edges = (_b = params == null ? void 0 : params.edges) != null ? _b : this.edges;
  }
  // Convert the graph to a JSON-serializable format.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  toJSON() {
    const stableNodeIds = {};
    Object.values(this.nodes).forEach((node, i) => {
      stableNodeIds[node.id] = validate_default(node.id) ? i : node.id;
    });
    return {
      nodes: Object.values(this.nodes).map((node) => ({
        id: stableNodeIds[node.id],
        ...nodeDataJson(node)
      })),
      edges: this.edges.map((edge) => {
        const item = {
          source: stableNodeIds[edge.source],
          target: stableNodeIds[edge.target]
        };
        if (typeof edge.data !== "undefined") {
          item.data = edge.data;
        }
        if (typeof edge.conditional !== "undefined") {
          item.conditional = edge.conditional;
        }
        return item;
      })
    };
  }
  addNode(data, id, metadata) {
    if (id !== void 0 && this.nodes[id] !== void 0) {
      throw new Error(`Node with id ${id} already exists`);
    }
    const nodeId = id != null ? id : v4_default();
    const node = {
      id: nodeId,
      data,
      name: nodeDataStr(id, data),
      metadata
    };
    this.nodes[nodeId] = node;
    return node;
  }
  removeNode(node) {
    delete this.nodes[node.id];
    this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);
  }
  addEdge(source, target, data, conditional) {
    if (this.nodes[source.id] === void 0) {
      throw new Error(`Source node ${source.id} not in graph`);
    }
    if (this.nodes[target.id] === void 0) {
      throw new Error(`Target node ${target.id} not in graph`);
    }
    const edge = {
      source: source.id,
      target: target.id,
      data,
      conditional
    };
    this.edges.push(edge);
    return edge;
  }
  firstNode() {
    return _firstNode(this);
  }
  lastNode() {
    return _lastNode(this);
  }
  /**
   * Add all nodes and edges from another graph.
   * Note this doesn't check for duplicates, nor does it connect the graphs.
   */
  extend(graph, prefix = "") {
    let finalPrefix = prefix;
    const nodeIds = Object.values(graph.nodes).map((node) => node.id);
    if (nodeIds.every(validate_default)) {
      finalPrefix = "";
    }
    const prefixed = (id) => {
      return finalPrefix ? `${finalPrefix}:${id}` : id;
    };
    Object.entries(graph.nodes).forEach(([key, value]) => {
      this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };
    });
    const newEdges = graph.edges.map((edge) => {
      return {
        ...edge,
        source: prefixed(edge.source),
        target: prefixed(edge.target)
      };
    });
    this.edges = [...this.edges, ...newEdges];
    const first = graph.firstNode();
    const last = graph.lastNode();
    return [
      first ? { id: prefixed(first.id), data: first.data } : void 0,
      last ? { id: prefixed(last.id), data: last.data } : void 0
    ];
  }
  trimFirstNode() {
    const firstNode = this.firstNode();
    if (firstNode && _firstNode(this, [firstNode.id])) {
      this.removeNode(firstNode);
    }
  }
  trimLastNode() {
    const lastNode = this.lastNode();
    if (lastNode && _lastNode(this, [lastNode.id])) {
      this.removeNode(lastNode);
    }
  }
  /**
   * Return a new graph with all nodes re-identified,
   * using their unique, readable names where possible.
   */
  reid() {
    const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));
    const nodeLabelCounts = /* @__PURE__ */ new Map();
    Object.values(nodeLabels).forEach((label) => {
      nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);
    });
    const getNodeId = (nodeId) => {
      const label = nodeLabels[nodeId];
      if (validate_default(nodeId) && nodeLabelCounts.get(label) === 1) {
        return label;
      } else {
        return nodeId;
      }
    };
    return new Graph({
      nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [
        getNodeId(id),
        { ...node, id: getNodeId(id) }
      ])),
      edges: this.edges.map((edge) => ({
        ...edge,
        source: getNodeId(edge.source),
        target: getNodeId(edge.target)
      }))
    });
  }
  drawMermaid(params) {
    const { withStyles, curveStyle, nodeColors = {
      default: "fill:#f2f0ff,line-height:1.2",
      first: "fill-opacity:0",
      last: "fill:#bfb6fc"
    }, wrapLabelNWords } = params != null ? params : {};
    const graph = this.reid();
    const firstNode = graph.firstNode();
    const lastNode = graph.lastNode();
    return drawMermaid(graph.nodes, graph.edges, {
      firstNode: firstNode == null ? void 0 : firstNode.id,
      lastNode: lastNode == null ? void 0 : lastNode.id,
      withStyles,
      curveStyle,
      nodeColors,
      wrapLabelNWords
    });
  }
  async drawMermaidPng(params) {
    const mermaidSyntax = this.drawMermaid(params);
    return drawMermaidPng(mermaidSyntax, {
      backgroundColor: params == null ? void 0 : params.backgroundColor
    });
  }
};
function _firstNode(graph, exclude = []) {
  const targets = new Set(graph.edges.filter((edge) => !exclude.includes(edge.source)).map((edge) => edge.target));
  const found = [];
  for (const node of Object.values(graph.nodes)) {
    if (!exclude.includes(node.id) && !targets.has(node.id)) {
      found.push(node);
    }
  }
  return found.length === 1 ? found[0] : void 0;
}
function _lastNode(graph, exclude = []) {
  const sources = new Set(graph.edges.filter((edge) => !exclude.includes(edge.target)).map((edge) => edge.source));
  const found = [];
  for (const node of Object.values(graph.nodes)) {
    if (!exclude.includes(node.id) && !sources.has(node.id)) {
      found.push(node);
    }
  }
  return found.length === 1 ? found[0] : void 0;
}

// node_modules/@langchain/core/dist/runnables/wrappers.js
function convertToHttpEventStream(stream) {
  const encoder2 = new TextEncoder();
  const finalStream = new ReadableStream({
    async start(controller) {
      for await (const chunk of stream) {
        controller.enqueue(encoder2.encode(`event: data
data: ${JSON.stringify(chunk)}

`));
      }
      controller.enqueue(encoder2.encode("event: end\n\n"));
      controller.close();
    }
  });
  return IterableReadableStream.fromReadableStream(finalStream);
}

// node_modules/@langchain/core/dist/runnables/iter.js
function isIterableIterator(thing) {
  return typeof thing === "object" && thing !== null && typeof thing[Symbol.iterator] === "function" && // avoid detecting array/set as iterator
  typeof thing.next === "function";
}
var isIterator = (x) => x != null && typeof x === "object" && "next" in x && typeof x.next === "function";
function isAsyncIterable(thing) {
  return typeof thing === "object" && thing !== null && typeof thing[Symbol.asyncIterator] === "function";
}
function* consumeIteratorInContext(context, iter) {
  while (true) {
    const { value, done } = AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(context), iter.next.bind(iter), true);
    if (done) {
      break;
    } else {
      yield value;
    }
  }
}
async function* consumeAsyncIterableInContext(context, iter) {
  const iterator = iter[Symbol.asyncIterator]();
  while (true) {
    const { value, done } = await AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(context), iterator.next.bind(iter), true);
    if (done) {
      break;
    } else {
      yield value;
    }
  }
}

// node_modules/@langchain/core/dist/runnables/base.js
function _coerceToDict2(value, defaultKey) {
  return value && !Array.isArray(value) && // eslint-disable-next-line no-instanceof/no-instanceof
  !(value instanceof Date) && typeof value === "object" ? value : { [defaultKey]: value };
}
var Runnable = class extends Serializable {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "lc_runnable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  getName(suffix) {
    var _a, _b;
    const name = (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (_b = (_a = this.name) != null ? _a : this.constructor.lc_name()) != null ? _b : this.constructor.name
    );
    return suffix ? `${name}${suffix}` : name;
  }
  /**
   * Bind arguments to a Runnable, returning a new Runnable.
   * @param kwargs
   * @returns A new RunnableBinding that, when invoked, will apply the bound args.
   */
  bind(kwargs) {
    return new RunnableBinding({ bound: this, kwargs, config: {} });
  }
  /**
   * Return a new Runnable that maps a list of inputs to a list of outputs,
   * by calling invoke() with each input.
   */
  map() {
    return new RunnableEach({ bound: this });
  }
  /**
   * Add retry logic to an existing runnable.
   * @param kwargs
   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
   */
  withRetry(fields) {
    return new RunnableRetry({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: fields == null ? void 0 : fields.stopAfterAttempt,
      ...fields
    });
  }
  /**
   * Bind config to a Runnable, returning a new Runnable.
   * @param config New configuration parameters to attach to the new runnable.
   * @returns A new RunnableBinding with a config matching what's passed.
   */
  withConfig(config) {
    return new RunnableBinding({
      bound: this,
      config,
      kwargs: {}
    });
  }
  /**
   * Create a new runnable from the current one that will try invoking
   * other passed fallback runnables if the initial invocation fails.
   * @param fields.fallbacks Other runnables to call if the runnable errors.
   * @returns A new RunnableWithFallbacks.
   */
  withFallbacks(fields) {
    const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;
    return new RunnableWithFallbacks({
      runnable: this,
      fallbacks
    });
  }
  _getOptionsList(options, length = 0) {
    if (Array.isArray(options) && options.length !== length) {
      throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);
    }
    if (Array.isArray(options)) {
      return options.map(ensureConfig);
    }
    if (length > 1 && !Array.isArray(options) && options.runId) {
      console.warn("Provided runId will be used only for the first element of the batch.");
      const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== "runId"));
      return Array.from({ length }, (_, i) => ensureConfig(i === 0 ? options : subsequent));
    }
    return Array.from({ length }, () => ensureConfig(options));
  }
  async batch(inputs, options, batchOptions) {
    var _a, _b;
    const configList = this._getOptionsList(options != null ? options : {}, inputs.length);
    const maxConcurrency = (_b = (_a = configList[0]) == null ? void 0 : _a.maxConcurrency) != null ? _b : batchOptions == null ? void 0 : batchOptions.maxConcurrency;
    const caller2 = new AsyncCaller2({
      maxConcurrency,
      onFailedAttempt: (e) => {
        throw e;
      }
    });
    const batchCalls = inputs.map((input, i) => caller2.call(async () => {
      try {
        const result = await this.invoke(input, configList[i]);
        return result;
      } catch (e) {
        if (batchOptions == null ? void 0 : batchOptions.returnExceptions) {
          return e;
        }
        throw e;
      }
    }));
    return Promise.all(batchCalls);
  }
  /**
   * Default streaming implementation.
   * Subclasses should override this method if they support streaming output.
   * @param input
   * @param options
   */
  async *_streamIterator(input, options) {
    yield this.invoke(input, options);
  }
  /**
   * Stream output in chunks.
   * @param input
   * @param options
   * @returns A readable stream that is also an iterable.
   */
  async stream(input, options) {
    const config = ensureConfig(options);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this._streamIterator(input, config),
      config
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
  _separateRunnableConfigFromCallOptions(options) {
    let runnableConfig;
    if (options === void 0) {
      runnableConfig = ensureConfig(options);
    } else {
      runnableConfig = ensureConfig({
        callbacks: options.callbacks,
        tags: options.tags,
        metadata: options.metadata,
        runName: options.runName,
        configurable: options.configurable,
        recursionLimit: options.recursionLimit,
        maxConcurrency: options.maxConcurrency,
        runId: options.runId,
        timeout: options.timeout,
        signal: options.signal
      });
    }
    const callOptions = { ...options };
    delete callOptions.callbacks;
    delete callOptions.tags;
    delete callOptions.metadata;
    delete callOptions.runName;
    delete callOptions.configurable;
    delete callOptions.recursionLimit;
    delete callOptions.maxConcurrency;
    delete callOptions.runId;
    delete callOptions.timeout;
    delete callOptions.signal;
    return [runnableConfig, callOptions];
  }
  async _callWithConfig(func, input, options) {
    var _a;
    const config = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), config.runId, config == null ? void 0 : config.runType, void 0, void 0, (_a = config == null ? void 0 : config.runName) != null ? _a : this.getName()));
    delete config.runId;
    let output;
    try {
      const promise = func.call(this, input, config, runManager);
      output = await raceWithSignal(promise, options == null ? void 0 : options.signal);
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(output, "output")));
    return output;
  }
  /**
   * Internal method that handles batching and configuration for a runnable
   * It takes a function, input values, and optional configuration, and
   * returns a promise that resolves to the output values.
   * @param func The function to be executed for each input value.
   * @param input The input values to be processed.
   * @param config Optional configuration for the function execution.
   * @returns A promise that resolves to the output values.
   */
  async _batchWithConfig(func, inputs, options, batchOptions) {
    var _a;
    const optionsList = this._getOptionsList(options != null ? options : {}, inputs.length);
    const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));
    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
      var _a2;
      const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), optionsList[i].runId, optionsList[i].runType, void 0, void 0, (_a2 = optionsList[i].runName) != null ? _a2 : this.getName()));
      delete optionsList[i].runId;
      return handleStartRes;
    }));
    let outputs;
    try {
      const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);
      outputs = await raceWithSignal(promise, (_a = optionsList == null ? void 0 : optionsList[0]) == null ? void 0 : _a.signal);
    } catch (e) {
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(e)));
      throw e;
    }
    await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(outputs, "output"))));
    return outputs;
  }
  /**
   * Helper method to transform an Iterator of Input values into an Iterator of
   * Output values, with callbacks.
   * Use this to implement `stream()` or `transform()` in Runnable subclasses.
   */
  async *_transformStreamWithConfig(inputGenerator, transformer, options) {
    let finalInput;
    let finalInputSupported = true;
    let finalOutput;
    let finalOutputSupported = true;
    const config = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config);
    async function* wrapInputForTracing() {
      for await (const chunk of inputGenerator) {
        if (finalInputSupported) {
          if (finalInput === void 0) {
            finalInput = chunk;
          } else {
            try {
              finalInput = concat(finalInput, chunk);
            } catch (e) {
              finalInput = void 0;
              finalInputSupported = false;
            }
          }
        }
        yield chunk;
      }
    }
    let runManager;
    try {
      const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => {
        var _a;
        return callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), { input: "" }, config.runId, config.runType, void 0, void 0, (_a = config.runName) != null ? _a : this.getName());
      }, options == null ? void 0 : options.signal, config);
      delete config.runId;
      runManager = pipe.setup;
      const streamEventsHandler = runManager == null ? void 0 : runManager.handlers.find(isStreamEventsHandler);
      let iterator = pipe.output;
      if (streamEventsHandler !== void 0 && runManager !== void 0) {
        iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);
      }
      const streamLogHandler = runManager == null ? void 0 : runManager.handlers.find(isLogStreamHandler);
      if (streamLogHandler !== void 0 && runManager !== void 0) {
        iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);
      }
      for await (const chunk of iterator) {
        yield chunk;
        if (finalOutputSupported) {
          if (finalOutput === void 0) {
            finalOutput = chunk;
          } else {
            try {
              finalOutput = concat(finalOutput, chunk);
            } catch (e) {
              finalOutput = void 0;
              finalOutputSupported = false;
            }
          }
        }
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e, void 0, void 0, void 0, {
        inputs: _coerceToDict2(finalInput, "input")
      }));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(finalOutput != null ? finalOutput : {}, void 0, void 0, void 0, { inputs: _coerceToDict2(finalInput, "input") }));
  }
  getGraph(_) {
    const graph = new Graph();
    const inputNode = graph.addNode({
      name: `${this.getName()}Input`,
      schema: z.any()
    });
    const runnableNode = graph.addNode(this);
    const outputNode = graph.addNode({
      name: `${this.getName()}Output`,
      schema: z.any()
    });
    graph.addEdge(inputNode, runnableNode);
    graph.addEdge(runnableNode, outputNode);
    return graph;
  }
  /**
   * Create a new runnable sequence that runs each individual runnable in series,
   * piping the output of one runnable into another runnable or runnable-like.
   * @param coerceable A runnable, function, or object whose values are functions or runnables.
   * @returns A new runnable sequence.
   */
  pipe(coerceable) {
    return new RunnableSequence({
      first: this,
      last: _coerceToRunnable(coerceable)
    });
  }
  /**
   * Pick keys from the dict output of this runnable. Returns a new runnable.
   */
  pick(keys) {
    return this.pipe(new RunnablePick(keys));
  }
  /**
   * Assigns new fields to the dict output of this runnable. Returns a new runnable.
   */
  assign(mapping) {
    return this.pipe(
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      new RunnableAssign(
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        new RunnableMap({ steps: mapping })
      )
    );
  }
  /**
   * Default implementation of transform, which buffers input and then calls stream.
   * Subclasses should override this method if they can start producing output while
   * input is still being generated.
   * @param generator
   * @param options
   */
  async *transform(generator, options) {
    let finalChunk;
    for await (const chunk of generator) {
      if (finalChunk === void 0) {
        finalChunk = chunk;
      } else {
        finalChunk = concat(finalChunk, chunk);
      }
    }
    yield* this._streamIterator(finalChunk, ensureConfig(options));
  }
  /**
   * Stream all output from a runnable, as reported to the callback system.
   * This includes all inner runs of LLMs, Retrievers, Tools, etc.
   * Output is streamed as Log objects, which include a list of
   * jsonpatch ops that describe how the state of the run has changed in each
   * step, and the final state of the run.
   * The jsonpatch ops can be applied in order to construct state.
   * @param input
   * @param options
   * @param streamOptions
   */
  async *streamLog(input, options, streamOptions) {
    const logStreamCallbackHandler = new LogStreamCallbackHandler({
      ...streamOptions,
      autoClose: false,
      _schemaFormat: "original"
    });
    const config = ensureConfig(options);
    yield* this._streamLog(input, logStreamCallbackHandler, config);
  }
  async *_streamLog(input, logStreamCallbackHandler, config) {
    const { callbacks } = config;
    if (callbacks === void 0) {
      config.callbacks = [logStreamCallbackHandler];
    } else if (Array.isArray(callbacks)) {
      config.callbacks = callbacks.concat([logStreamCallbackHandler]);
    } else {
      const copiedCallbacks = callbacks.copy();
      copiedCallbacks.addHandler(logStreamCallbackHandler, true);
      config.callbacks = copiedCallbacks;
    }
    const runnableStreamPromise = this.stream(input, config);
    async function consumeRunnableStream() {
      try {
        const runnableStream = await runnableStreamPromise;
        for await (const chunk of runnableStream) {
          const patch = new RunLogPatch({
            ops: [
              {
                op: "add",
                path: "/streamed_output/-",
                value: chunk
              }
            ]
          });
          await logStreamCallbackHandler.writer.write(patch);
        }
      } finally {
        await logStreamCallbackHandler.writer.close();
      }
    }
    const runnableStreamConsumePromise = consumeRunnableStream();
    try {
      for await (const log of logStreamCallbackHandler) {
        yield log;
      }
    } finally {
      await runnableStreamConsumePromise;
    }
  }
  streamEvents(input, options, streamOptions) {
    let stream;
    if (options.version === "v1") {
      stream = this._streamEventsV1(input, options, streamOptions);
    } else if (options.version === "v2") {
      stream = this._streamEventsV2(input, options, streamOptions);
    } else {
      throw new Error(`Only versions "v1" and "v2" of the schema are currently supported.`);
    }
    if (options.encoding === "text/event-stream") {
      return convertToHttpEventStream(stream);
    } else {
      return IterableReadableStream.fromAsyncGenerator(stream);
    }
  }
  async *_streamEventsV2(input, options, streamOptions) {
    var _a, _b;
    const eventStreamer = new EventStreamCallbackHandler({
      ...streamOptions,
      autoClose: false
    });
    const config = ensureConfig(options);
    const runId = (_a = config.runId) != null ? _a : v4_default();
    config.runId = runId;
    const callbacks = config.callbacks;
    if (callbacks === void 0) {
      config.callbacks = [eventStreamer];
    } else if (Array.isArray(callbacks)) {
      config.callbacks = callbacks.concat(eventStreamer);
    } else {
      const copiedCallbacks = callbacks.copy();
      copiedCallbacks.addHandler(eventStreamer, true);
      config.callbacks = copiedCallbacks;
    }
    const abortController = new AbortController();
    const outerThis = this;
    async function consumeRunnableStream() {
      try {
        let signal;
        if (options == null ? void 0 : options.signal) {
          if ("any" in AbortSignal) {
            signal = AbortSignal.any([
              abortController.signal,
              options.signal
            ]);
          } else {
            signal = options.signal;
            options.signal.addEventListener("abort", () => {
              abortController.abort();
            }, { once: true });
          }
        } else {
          signal = abortController.signal;
        }
        const runnableStream = await outerThis.stream(input, {
          ...config,
          signal
        });
        const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);
        for await (const _ of tappedStream) {
          if (abortController.signal.aborted)
            break;
        }
      } finally {
        await eventStreamer.finish();
      }
    }
    const runnableStreamConsumePromise = consumeRunnableStream();
    let firstEventSent = false;
    let firstEventRunId;
    try {
      for await (const event of eventStreamer) {
        if (!firstEventSent) {
          event.data.input = input;
          firstEventSent = true;
          firstEventRunId = event.run_id;
          yield event;
          continue;
        }
        if (event.run_id === firstEventRunId && event.event.endsWith("_end")) {
          if ((_b = event.data) == null ? void 0 : _b.input) {
            delete event.data.input;
          }
        }
        yield event;
      }
    } finally {
      abortController.abort();
      await runnableStreamConsumePromise;
    }
  }
  async *_streamEventsV1(input, options, streamOptions) {
    var _a, _b, _c;
    let runLog;
    let hasEncounteredStartEvent = false;
    const config = ensureConfig(options);
    const rootTags = (_a = config.tags) != null ? _a : [];
    const rootMetadata = (_b = config.metadata) != null ? _b : {};
    const rootName = (_c = config.runName) != null ? _c : this.getName();
    const logStreamCallbackHandler = new LogStreamCallbackHandler({
      ...streamOptions,
      autoClose: false,
      _schemaFormat: "streaming_events"
    });
    const rootEventFilter = new _RootEventFilter({
      ...streamOptions
    });
    const logStream = this._streamLog(input, logStreamCallbackHandler, config);
    for await (const log of logStream) {
      if (!runLog) {
        runLog = RunLog.fromRunLogPatch(log);
      } else {
        runLog = runLog.concat(log);
      }
      if (runLog.state === void 0) {
        throw new Error(`Internal error: "streamEvents" state is missing. Please open a bug report.`);
      }
      if (!hasEncounteredStartEvent) {
        hasEncounteredStartEvent = true;
        const state3 = { ...runLog.state };
        const event = {
          run_id: state3.id,
          event: `on_${state3.type}_start`,
          name: rootName,
          tags: rootTags,
          metadata: rootMetadata,
          data: {
            input
          }
        };
        if (rootEventFilter.includeEvent(event, state3.type)) {
          yield event;
        }
      }
      const paths = log.ops.filter((op) => op.path.startsWith("/logs/")).map((op) => op.path.split("/")[2]);
      const dedupedPaths = [...new Set(paths)];
      for (const path of dedupedPaths) {
        let eventType;
        let data = {};
        const logEntry = runLog.state.logs[path];
        if (logEntry.end_time === void 0) {
          if (logEntry.streamed_output.length > 0) {
            eventType = "stream";
          } else {
            eventType = "start";
          }
        } else {
          eventType = "end";
        }
        if (eventType === "start") {
          if (logEntry.inputs !== void 0) {
            data.input = logEntry.inputs;
          }
        } else if (eventType === "end") {
          if (logEntry.inputs !== void 0) {
            data.input = logEntry.inputs;
          }
          data.output = logEntry.final_output;
        } else if (eventType === "stream") {
          const chunkCount = logEntry.streamed_output.length;
          if (chunkCount !== 1) {
            throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${logEntry.name}"`);
          }
          data = { chunk: logEntry.streamed_output[0] };
          logEntry.streamed_output = [];
        }
        yield {
          event: `on_${logEntry.type}_${eventType}`,
          name: logEntry.name,
          run_id: logEntry.id,
          tags: logEntry.tags,
          metadata: logEntry.metadata,
          data
        };
      }
      const { state: state2 } = runLog;
      if (state2.streamed_output.length > 0) {
        const chunkCount = state2.streamed_output.length;
        if (chunkCount !== 1) {
          throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${state2.name}"`);
        }
        const data = { chunk: state2.streamed_output[0] };
        state2.streamed_output = [];
        const event = {
          event: `on_${state2.type}_stream`,
          run_id: state2.id,
          tags: rootTags,
          metadata: rootMetadata,
          name: rootName,
          data
        };
        if (rootEventFilter.includeEvent(event, state2.type)) {
          yield event;
        }
      }
    }
    const state = runLog == null ? void 0 : runLog.state;
    if (state !== void 0) {
      const event = {
        event: `on_${state.type}_end`,
        name: rootName,
        run_id: state.id,
        tags: rootTags,
        metadata: rootMetadata,
        data: {
          output: state.final_output
        }
      };
      if (rootEventFilter.includeEvent(event, state.type))
        yield event;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isRunnable(thing) {
    return isRunnableInterface(thing);
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart, onEnd, onError }) {
    return new RunnableBinding({
      bound: this,
      config: {},
      configFactories: [
        (config) => ({
          callbacks: [
            new RootListenersTracer({
              config,
              onStart,
              onEnd,
              onError
            })
          ]
        })
      ]
    });
  }
  /**
   * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`
   * which contains the runnable, name, description and schema.
   *
   * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.
   *
   * @param fields
   * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.
   * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.
   * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.
   * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.
   */
  asTool(fields) {
    return convertRunnableToTool(this, fields);
  }
};
var RunnableBinding = class extends Runnable {
  static lc_name() {
    return "RunnableBinding";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "bound", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "configFactories", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.bound = fields.bound;
    this.kwargs = fields.kwargs;
    this.config = fields.config;
    this.configFactories = fields.configFactories;
  }
  getName(suffix) {
    return this.bound.getName(suffix);
  }
  async _mergeConfig(...options) {
    const config = mergeConfigs(this.config, ...options);
    return mergeConfigs(config, ...this.configFactories ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config))) : []);
  }
  bind(kwargs) {
    return new this.constructor({
      bound: this.bound,
      kwargs: { ...this.kwargs, ...kwargs },
      config: this.config
    });
  }
  withConfig(config) {
    return new this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: { ...this.config, ...config }
    });
  }
  withRetry(fields) {
    return new this.constructor({
      bound: this.bound.withRetry(fields),
      kwargs: this.kwargs,
      config: this.config
    });
  }
  async invoke(input, options) {
    return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
  }
  async batch(inputs, options, batchOptions) {
    const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options), this.kwargs);
    return this.bound.batch(inputs, mergedOptions, batchOptions);
  }
  async *_streamIterator(input, options) {
    yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
  }
  async stream(input, options) {
    return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));
  }
  async *transform(generator, options) {
    yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));
  }
  streamEvents(input, options, streamOptions) {
    const outerThis = this;
    const generator = async function* () {
      yield* outerThis.bound.streamEvents(input, {
        ...await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs),
        version: options.version
      }, streamOptions);
    };
    return IterableReadableStream.fromAsyncGenerator(generator());
  }
  static isRunnableBinding(thing) {
    return thing.bound && Runnable.isRunnable(thing.bound);
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart, onEnd, onError }) {
    return new RunnableBinding({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      configFactories: [
        (config) => ({
          callbacks: [
            new RootListenersTracer({
              config,
              onStart,
              onEnd,
              onError
            })
          ]
        })
      ]
    });
  }
};
var RunnableEach = class extends Runnable {
  static lc_name() {
    return "RunnableEach";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "bound", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.bound = fields.bound;
  }
  /**
   * Binds the runnable with the specified arguments.
   * @param kwargs The arguments to bind the runnable with.
   * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.
   */
  bind(kwargs) {
    return new RunnableEach({
      bound: this.bound.bind(kwargs)
    });
  }
  /**
   * Invokes the runnable with the specified input and configuration.
   * @param input The input to invoke the runnable with.
   * @param config The configuration to invoke the runnable with.
   * @returns A promise that resolves to the output of the runnable.
   */
  async invoke(inputs, config) {
    return this._callWithConfig(this._invoke.bind(this), inputs, config);
  }
  /**
   * A helper method that is used to invoke the runnable with the specified input and configuration.
   * @param input The input to invoke the runnable with.
   * @param config The configuration to invoke the runnable with.
   * @returns A promise that resolves to the output of the runnable.
   */
  async _invoke(inputs, config, runManager) {
    return this.bound.batch(inputs, patchConfig(config, { callbacks: runManager == null ? void 0 : runManager.getChild() }));
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart, onEnd, onError }) {
    return new RunnableEach({
      bound: this.bound.withListeners({ onStart, onEnd, onError })
    });
  }
};
var RunnableRetry = class extends RunnableBinding {
  static lc_name() {
    return "RunnableRetry";
  }
  constructor(fields) {
    var _a, _b;
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "maxAttemptNumber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(this, "onFailedAttempt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => {
      }
    });
    this.maxAttemptNumber = (_a = fields.maxAttemptNumber) != null ? _a : this.maxAttemptNumber;
    this.onFailedAttempt = (_b = fields.onFailedAttempt) != null ? _b : this.onFailedAttempt;
  }
  _patchConfigForRetry(attempt, config, runManager) {
    const tag = attempt > 1 ? `retry:attempt:${attempt}` : void 0;
    return patchConfig(config, { callbacks: runManager == null ? void 0 : runManager.getChild(tag) });
  }
  async _invoke(input, config, runManager) {
    return (0, import_p_retry3.default)((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onFailedAttempt: (error) => this.onFailedAttempt(error, input),
      retries: Math.max(this.maxAttemptNumber - 1, 0),
      randomize: true
    });
  }
  /**
   * Method that invokes the runnable with the specified input, run manager,
   * and config. It handles the retry logic by catching any errors and
   * recursively invoking itself with the updated config for the next retry
   * attempt.
   * @param input The input for the runnable.
   * @param runManager The run manager for the runnable.
   * @param config The config for the runnable.
   * @returns A promise that resolves to the output of the runnable.
   */
  async invoke(input, config) {
    return this._callWithConfig(this._invoke.bind(this), input, config);
  }
  async _batch(inputs, configs, runManagers, batchOptions) {
    const resultsMap = {};
    try {
      await (0, import_p_retry3.default)(async (attemptNumber) => {
        const remainingIndexes = inputs.map((_, i) => i).filter((i) => resultsMap[i.toString()] === void 0 || // eslint-disable-next-line no-instanceof/no-instanceof
        resultsMap[i.toString()] instanceof Error);
        const remainingInputs = remainingIndexes.map((i) => inputs[i]);
        const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs == null ? void 0 : configs[i], runManagers == null ? void 0 : runManagers[i]));
        const results = await super.batch(remainingInputs, patchedConfigs, {
          ...batchOptions,
          returnExceptions: true
        });
        let firstException;
        for (let i = 0; i < results.length; i += 1) {
          const result = results[i];
          const resultMapIndex = remainingIndexes[i];
          if (result instanceof Error) {
            if (firstException === void 0) {
              firstException = result;
              firstException.input = remainingInputs[i];
            }
          }
          resultsMap[resultMapIndex.toString()] = result;
        }
        if (firstException) {
          throw firstException;
        }
        return results;
      }, {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: true
      });
    } catch (e) {
      if ((batchOptions == null ? void 0 : batchOptions.returnExceptions) !== true) {
        throw e;
      }
    }
    return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map((key) => resultsMap[parseInt(key, 10)]);
  }
  async batch(inputs, options, batchOptions) {
    return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);
  }
};
var RunnableSequence = class extends Runnable {
  static lc_name() {
    return "RunnableSequence";
  }
  constructor(fields) {
    var _a, _b;
    super(fields);
    Object.defineProperty(this, "first", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "middle", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "last", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "omitSequenceTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    this.first = fields.first;
    this.middle = (_a = fields.middle) != null ? _a : this.middle;
    this.last = fields.last;
    this.name = fields.name;
    this.omitSequenceTags = (_b = fields.omitSequenceTags) != null ? _b : this.omitSequenceTags;
  }
  get steps() {
    return [this.first, ...this.middle, this.last];
  }
  async invoke(input, options) {
    var _a;
    const config = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), config.runId, void 0, void 0, void 0, config == null ? void 0 : config.runName));
    delete config.runId;
    let nextStepInput = input;
    let finalOutput;
    try {
      const initialSteps = [this.first, ...this.middle];
      for (let i = 0; i < initialSteps.length; i += 1) {
        const step = initialSteps[i];
        const promise = step.invoke(nextStepInput, patchConfig(config, {
          callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`)
        }));
        nextStepInput = await raceWithSignal(promise, options == null ? void 0 : options.signal);
      }
      if ((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted) {
        throw new Error("Aborted");
      }
      finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {
        callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${this.steps.length}`)
      }));
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(finalOutput, "output")));
    return finalOutput;
  }
  async batch(inputs, options, batchOptions) {
    var _a;
    const configList = this._getOptionsList(options != null ? options : {}, inputs.length);
    const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));
    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
      const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), configList[i].runId, void 0, void 0, void 0, configList[i].runName));
      delete configList[i].runId;
      return handleStartRes;
    }));
    let nextStepInputs = inputs;
    try {
      for (let i = 0; i < this.steps.length; i += 1) {
        const step = this.steps[i];
        const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {
          const childRunManager = runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`);
          return patchConfig(configList[j], { callbacks: childRunManager });
        }), batchOptions);
        nextStepInputs = await raceWithSignal(promise, (_a = configList[0]) == null ? void 0 : _a.signal);
      }
    } catch (e) {
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(e)));
      throw e;
    }
    await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(nextStepInputs, "output"))));
    return nextStepInputs;
  }
  async *_streamIterator(input, options) {
    var _a;
    const callbackManager_ = await getCallbackManagerForConfig(options);
    const { runId, ...otherOptions } = options != null ? options : {};
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), runId, void 0, void 0, void 0, otherOptions == null ? void 0 : otherOptions.runName));
    const steps = [this.first, ...this.middle, this.last];
    let concatSupported = true;
    let finalOutput;
    async function* inputGenerator() {
      yield input;
    }
    try {
      let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, {
        callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:1`)
      }));
      for (let i = 1; i < steps.length; i += 1) {
        const step = steps[i];
        finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, {
          callbacks: runManager == null ? void 0 : runManager.getChild(this.omitSequenceTags ? void 0 : `seq:step:${i + 1}`)
        }));
      }
      for await (const chunk of finalGenerator) {
        (_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.throwIfAborted();
        yield chunk;
        if (concatSupported) {
          if (finalOutput === void 0) {
            finalOutput = chunk;
          } else {
            try {
              finalOutput = concat(finalOutput, chunk);
            } catch (e) {
              finalOutput = void 0;
              concatSupported = false;
            }
          }
        }
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(finalOutput, "output")));
  }
  getGraph(config) {
    const graph = new Graph();
    let currentLastNode = null;
    this.steps.forEach((step, index) => {
      const stepGraph = step.getGraph(config);
      if (index !== 0) {
        stepGraph.trimFirstNode();
      }
      if (index !== this.steps.length - 1) {
        stepGraph.trimLastNode();
      }
      graph.extend(stepGraph);
      const stepFirstNode = stepGraph.firstNode();
      if (!stepFirstNode) {
        throw new Error(`Runnable ${step} has no first node`);
      }
      if (currentLastNode) {
        graph.addEdge(currentLastNode, stepFirstNode);
      }
      currentLastNode = stepGraph.lastNode();
    });
    return graph;
  }
  pipe(coerceable) {
    var _a;
    if (RunnableSequence.isRunnableSequence(coerceable)) {
      return new RunnableSequence({
        first: this.first,
        middle: this.middle.concat([
          this.last,
          coerceable.first,
          ...coerceable.middle
        ]),
        last: coerceable.last,
        name: (_a = this.name) != null ? _a : coerceable.name
      });
    } else {
      return new RunnableSequence({
        first: this.first,
        middle: [...this.middle, this.last],
        last: _coerceToRunnable(coerceable),
        name: this.name
      });
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isRunnableSequence(thing) {
    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static from([first, ...runnables], nameOrFields) {
    let extra = {};
    if (typeof nameOrFields === "string") {
      extra.name = nameOrFields;
    } else if (nameOrFields !== void 0) {
      extra = nameOrFields;
    }
    return new RunnableSequence({
      ...extra,
      first: _coerceToRunnable(first),
      middle: runnables.slice(0, -1).map(_coerceToRunnable),
      last: _coerceToRunnable(runnables[runnables.length - 1])
    });
  }
};
var RunnableMap = class extends Runnable {
  static lc_name() {
    return "RunnableMap";
  }
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "steps", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.steps = {};
    for (const [key, value] of Object.entries(fields.steps)) {
      this.steps[key] = _coerceToRunnable(value);
    }
  }
  static from(steps) {
    return new RunnableMap({ steps });
  }
  async invoke(input, options) {
    const config = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), {
      input
    }, config.runId, void 0, void 0, void 0, config == null ? void 0 : config.runName));
    delete config.runId;
    const output = {};
    try {
      const promises = Object.entries(this.steps).map(async ([key, runnable]) => {
        output[key] = await runnable.invoke(input, patchConfig(config, {
          callbacks: runManager == null ? void 0 : runManager.getChild(`map:key:${key}`)
        }));
      });
      await raceWithSignal(Promise.all(promises), options == null ? void 0 : options.signal);
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(output));
    return output;
  }
  async *_transform(generator, runManager, options) {
    const steps = { ...this.steps };
    const inputCopies = atee(generator, Object.keys(steps).length);
    const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {
      const gen = runnable.transform(inputCopies[i], patchConfig(options, {
        callbacks: runManager == null ? void 0 : runManager.getChild(`map:key:${key}`)
      }));
      return [key, gen.next().then((result) => ({ key, gen, result }))];
    }));
    while (tasks.size) {
      const promise = Promise.race(tasks.values());
      const { key, result, gen } = await raceWithSignal(promise, options == null ? void 0 : options.signal);
      tasks.delete(key);
      if (!result.done) {
        yield { [key]: result.value };
        tasks.set(key, gen.next().then((result2) => ({ key, gen, result: result2 })));
      }
    }
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const config = ensureConfig(options);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config),
      config
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableTraceable = class extends Runnable {
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "func", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (!isTraceableFunction(fields.func)) {
      throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");
    }
    this.func = fields.func;
  }
  async invoke(input, options) {
    const [config] = this._getOptionsList(options != null ? options : {}, 1);
    const callbacks = await getCallbackManagerForConfig(config);
    const promise = this.func(patchConfig(config, { callbacks }), input);
    return raceWithSignal(promise, config == null ? void 0 : config.signal);
  }
  async *_streamIterator(input, options) {
    var _a, _b;
    const [config] = this._getOptionsList(options != null ? options : {}, 1);
    const result = await this.invoke(input, options);
    if (isAsyncIterable(result)) {
      for await (const item of result) {
        (_a = config == null ? void 0 : config.signal) == null ? void 0 : _a.throwIfAborted();
        yield item;
      }
      return;
    }
    if (isIterator(result)) {
      while (true) {
        (_b = config == null ? void 0 : config.signal) == null ? void 0 : _b.throwIfAborted();
        const state = result.next();
        if (state.done)
          break;
        yield state.value;
      }
      return;
    }
    yield result;
  }
  static from(func) {
    return new RunnableTraceable({ func });
  }
};
function assertNonTraceableFunction(func) {
  if (isTraceableFunction(func)) {
    throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.");
  }
}
var RunnableLambda = class extends Runnable {
  static lc_name() {
    return "RunnableLambda";
  }
  constructor(fields) {
    if (isTraceableFunction(fields.func)) {
      return RunnableTraceable.from(fields.func);
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "func", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    assertNonTraceableFunction(fields.func);
    this.func = fields.func;
  }
  static from(func) {
    return new RunnableLambda({
      func
    });
  }
  async _invoke(input, config, runManager) {
    return new Promise((resolve, reject) => {
      var _a;
      const childConfig = patchConfig(config, {
        callbacks: runManager == null ? void 0 : runManager.getChild(),
        recursionLimit: ((_a = config == null ? void 0 : config.recursionLimit) != null ? _a : DEFAULT_RECURSION_LIMIT) - 1
      });
      void AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
        var _a2, _b, _c;
        try {
          let output = await this.func(input, {
            ...childConfig
          });
          if (output && Runnable.isRunnable(output)) {
            if ((config == null ? void 0 : config.recursionLimit) === 0) {
              throw new Error("Recursion limit reached.");
            }
            output = await output.invoke(input, {
              ...childConfig,
              recursionLimit: ((_a2 = childConfig.recursionLimit) != null ? _a2 : DEFAULT_RECURSION_LIMIT) - 1
            });
          } else if (isAsyncIterable(output)) {
            let finalOutput;
            for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
              (_b = config == null ? void 0 : config.signal) == null ? void 0 : _b.throwIfAborted();
              if (finalOutput === void 0) {
                finalOutput = chunk;
              } else {
                try {
                  finalOutput = concat(finalOutput, chunk);
                } catch (e) {
                  finalOutput = chunk;
                }
              }
            }
            output = finalOutput;
          } else if (isIterableIterator(output)) {
            let finalOutput;
            for (const chunk of consumeIteratorInContext(childConfig, output)) {
              (_c = config == null ? void 0 : config.signal) == null ? void 0 : _c.throwIfAborted();
              if (finalOutput === void 0) {
                finalOutput = chunk;
              } else {
                try {
                  finalOutput = concat(finalOutput, chunk);
                } catch (e) {
                  finalOutput = chunk;
                }
              }
            }
            output = finalOutput;
          }
          resolve(output);
        } catch (e) {
          reject(e);
        }
      });
    });
  }
  async invoke(input, options) {
    return this._callWithConfig(this._invoke.bind(this), input, options);
  }
  async *_transform(generator, runManager, config) {
    var _a, _b, _c;
    let finalChunk;
    for await (const chunk of generator) {
      if (finalChunk === void 0) {
        finalChunk = chunk;
      } else {
        try {
          finalChunk = concat(finalChunk, chunk);
        } catch (e) {
          finalChunk = chunk;
        }
      }
    }
    const childConfig = patchConfig(config, {
      callbacks: runManager == null ? void 0 : runManager.getChild(),
      recursionLimit: ((_a = config == null ? void 0 : config.recursionLimit) != null ? _a : DEFAULT_RECURSION_LIMIT) - 1
    });
    const output = await new Promise((resolve, reject) => {
      void AsyncLocalStorageProviderSingleton2.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {
        try {
          const res = await this.func(finalChunk, {
            ...childConfig,
            config: childConfig
          });
          resolve(res);
        } catch (e) {
          reject(e);
        }
      });
    });
    if (output && Runnable.isRunnable(output)) {
      if ((config == null ? void 0 : config.recursionLimit) === 0) {
        throw new Error("Recursion limit reached.");
      }
      const stream = await output.stream(finalChunk, childConfig);
      for await (const chunk of stream) {
        yield chunk;
      }
    } else if (isAsyncIterable(output)) {
      for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {
        (_b = config == null ? void 0 : config.signal) == null ? void 0 : _b.throwIfAborted();
        yield chunk;
      }
    } else if (isIterableIterator(output)) {
      for (const chunk of consumeIteratorInContext(childConfig, output)) {
        (_c = config == null ? void 0 : config.signal) == null ? void 0 : _c.throwIfAborted();
        yield chunk;
      }
    } else {
      yield output;
    }
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const config = ensureConfig(options);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config),
      config
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableWithFallbacks = class extends Runnable {
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "runnable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "fallbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.runnable = fields.runnable;
    this.fallbacks = fields.fallbacks;
  }
  *runnables() {
    yield this.runnable;
    for (const fallback of this.fallbacks) {
      yield fallback;
    }
  }
  async invoke(input, options) {
    const config = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config);
    const { runId, ...otherConfigFields } = config;
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), runId, void 0, void 0, void 0, otherConfigFields == null ? void 0 : otherConfigFields.runName));
    const childConfig = patchConfig(otherConfigFields, {
      callbacks: runManager == null ? void 0 : runManager.getChild()
    });
    const res = await AsyncLocalStorageProviderSingleton2.runWithConfig(childConfig, async () => {
      var _a;
      let firstError;
      for (const runnable of this.runnables()) {
        (_a = config == null ? void 0 : config.signal) == null ? void 0 : _a.throwIfAborted();
        try {
          const output = await runnable.invoke(input, childConfig);
          await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(output, "output")));
          return output;
        } catch (e) {
          if (firstError === void 0) {
            firstError = e;
          }
        }
      }
      if (firstError === void 0) {
        throw new Error("No error stored at end of fallback.");
      }
      await (runManager == null ? void 0 : runManager.handleChainError(firstError));
      throw firstError;
    });
    return res;
  }
  async *_streamIterator(input, options) {
    var _a;
    const config = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config);
    const { runId, ...otherConfigFields } = config;
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), runId, void 0, void 0, void 0, otherConfigFields == null ? void 0 : otherConfigFields.runName));
    let firstError;
    let stream;
    for (const runnable of this.runnables()) {
      (_a = config == null ? void 0 : config.signal) == null ? void 0 : _a.throwIfAborted();
      const childConfig = patchConfig(otherConfigFields, {
        callbacks: runManager == null ? void 0 : runManager.getChild()
      });
      try {
        const originalStream = await runnable.stream(input, childConfig);
        stream = consumeAsyncIterableInContext(childConfig, originalStream);
        break;
      } catch (e) {
        if (firstError === void 0) {
          firstError = e;
        }
      }
    }
    if (stream === void 0) {
      const error = firstError != null ? firstError : new Error("No error stored at end of fallback.");
      await (runManager == null ? void 0 : runManager.handleChainError(error));
      throw error;
    }
    let output;
    try {
      for await (const chunk of stream) {
        yield chunk;
        try {
          output = output === void 0 ? output : concat(output, chunk);
        } catch (e) {
          output = void 0;
        }
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(output, "output")));
  }
  async batch(inputs, options, batchOptions) {
    var _a;
    if (batchOptions == null ? void 0 : batchOptions.returnExceptions) {
      throw new Error("Not implemented.");
    }
    const configList = this._getOptionsList(options != null ? options : {}, inputs.length);
    const callbackManagers = await Promise.all(configList.map((config) => getCallbackManagerForConfig(config)));
    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {
      const handleStartRes = await (callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), configList[i].runId, void 0, void 0, void 0, configList[i].runName));
      delete configList[i].runId;
      return handleStartRes;
    }));
    let firstError;
    for (const runnable of this.runnables()) {
      (_a = configList[0].signal) == null ? void 0 : _a.throwIfAborted();
      try {
        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {
          callbacks: runManager == null ? void 0 : runManager.getChild()
        })), batchOptions);
        await Promise.all(runManagers.map((runManager, i) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(outputs[i], "output"))));
        return outputs;
      } catch (e) {
        if (firstError === void 0) {
          firstError = e;
        }
      }
    }
    if (!firstError) {
      throw new Error("No error stored at end of fallbacks.");
    }
    await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(firstError)));
    throw firstError;
  }
};
function _coerceToRunnable(coerceable) {
  if (typeof coerceable === "function") {
    return new RunnableLambda({ func: coerceable });
  } else if (Runnable.isRunnable(coerceable)) {
    return coerceable;
  } else if (!Array.isArray(coerceable) && typeof coerceable === "object") {
    const runnables = {};
    for (const [key, value] of Object.entries(coerceable)) {
      runnables[key] = _coerceToRunnable(value);
    }
    return new RunnableMap({
      steps: runnables
    });
  } else {
    throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
  }
}
var RunnableAssign = class extends Runnable {
  static lc_name() {
    return "RunnableAssign";
  }
  constructor(fields) {
    if (fields instanceof RunnableMap) {
      fields = { mapper: fields };
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "mapper", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.mapper = fields.mapper;
  }
  async invoke(input, options) {
    const mapperResult = await this.mapper.invoke(input, options);
    return {
      ...input,
      ...mapperResult
    };
  }
  async *_transform(generator, runManager, options) {
    const mapperKeys = this.mapper.getStepsKeys();
    const [forPassthrough, forMapper] = atee(generator);
    const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, { callbacks: runManager == null ? void 0 : runManager.getChild() }));
    const firstMapperChunkPromise = mapperOutput.next();
    for await (const chunk of forPassthrough) {
      if (typeof chunk !== "object" || Array.isArray(chunk)) {
        throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);
      }
      const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));
      if (Object.keys(filtered).length > 0) {
        yield filtered;
      }
    }
    yield (await firstMapperChunkPromise).value;
    for await (const chunk of mapperOutput) {
      yield chunk;
    }
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const config = ensureConfig(options);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config),
      config
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnablePick = class extends Runnable {
  static lc_name() {
    return "RunnablePick";
  }
  constructor(fields) {
    if (typeof fields === "string" || Array.isArray(fields)) {
      fields = { keys: fields };
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "keys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.keys = fields.keys;
  }
  async _pick(input) {
    if (typeof this.keys === "string") {
      return input[this.keys];
    } else {
      const picked = this.keys.map((key) => [key, input[key]]).filter((v) => v[1] !== void 0);
      return picked.length === 0 ? void 0 : Object.fromEntries(picked);
    }
  }
  async invoke(input, options) {
    return this._callWithConfig(this._pick.bind(this), input, options);
  }
  async *_transform(generator) {
    for await (const chunk of generator) {
      const picked = await this._pick(chunk);
      if (picked !== void 0) {
        yield picked;
      }
    }
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const config = ensureConfig(options);
    const wrappedGenerator = new AsyncGeneratorWithSetup({
      generator: this.transform(generator(), config),
      config
    });
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableToolLike = class extends RunnableBinding {
  constructor(fields) {
    var _a;
    const sequence = RunnableSequence.from([
      RunnableLambda.from(async (input) => {
        let toolInput;
        if (_isToolCall(input)) {
          try {
            toolInput = await this.schema.parseAsync(input.args);
          } catch (e) {
            throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));
          }
        } else {
          toolInput = input;
        }
        return toolInput;
      }).withConfig({ runName: `${fields.name}:parse_input` }),
      fields.bound
    ]).withConfig({ runName: fields.name });
    super({
      bound: sequence,
      config: (_a = fields.config) != null ? _a : {}
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "description", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "schema", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = fields.name;
    this.description = fields.description;
    this.schema = fields.schema;
  }
  static lc_name() {
    return "RunnableToolLike";
  }
};
function convertRunnableToTool(runnable, fields) {
  var _a, _b, _c;
  const name = (_a = fields.name) != null ? _a : runnable.getName();
  const description = (_c = fields.description) != null ? _c : (_b = fields.schema) == null ? void 0 : _b.description;
  if (fields.schema.constructor === z.ZodString) {
    return new RunnableToolLike({
      name,
      description,
      schema: z.object({
        input: z.string()
      }).transform((input) => input.input),
      bound: runnable
    });
  }
  return new RunnableToolLike({
    name,
    description,
    schema: fields.schema,
    bound: runnable
  });
}

// node_modules/@langchain/core/dist/utils/js-sha1/hash.js
var root = typeof window === "object" ? window : {};
var HEX_CHARS = "0123456789abcdef".split("");
var EXTRA = [-2147483648, 8388608, 32768, 128];
var SHIFT = [24, 16, 8, 0];
var blocks = [];
function Sha1(sharedMemory) {
  if (sharedMemory) {
    blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    this.blocks = blocks;
  } else {
    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  this.h0 = 1732584193;
  this.h1 = 4023233417;
  this.h2 = 2562383102;
  this.h3 = 271733878;
  this.h4 = 3285377520;
  this.block = this.start = this.bytes = this.hBytes = 0;
  this.finalized = this.hashed = false;
  this.first = true;
}
Sha1.prototype.update = function(message) {
  if (this.finalized) {
    return;
  }
  var notString = typeof message !== "string";
  if (notString && message.constructor === root.ArrayBuffer) {
    message = new Uint8Array(message);
  }
  var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
  while (index < length) {
    if (this.hashed) {
      this.hashed = false;
      blocks2[0] = this.block;
      blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
    }
    if (notString) {
      for (i = this.start; index < length && i < 64; ++index) {
        blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
      }
    } else {
      for (i = this.start; index < length && i < 64; ++index) {
        code = message.charCodeAt(index);
        if (code < 128) {
          blocks2[i >> 2] |= code << SHIFT[i++ & 3];
        } else if (code < 2048) {
          blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        } else if (code < 55296 || code >= 57344) {
          blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        } else {
          code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
          blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        }
      }
    }
    this.lastByteIndex = i;
    this.bytes += i - this.start;
    if (i >= 64) {
      this.block = blocks2[16];
      this.start = i - 64;
      this.hash();
      this.hashed = true;
    } else {
      this.start = i;
    }
  }
  if (this.bytes > 4294967295) {
    this.hBytes += this.bytes / 4294967296 << 0;
    this.bytes = this.bytes % 4294967296;
  }
  return this;
};
Sha1.prototype.finalize = function() {
  if (this.finalized) {
    return;
  }
  this.finalized = true;
  var blocks2 = this.blocks, i = this.lastByteIndex;
  blocks2[16] = this.block;
  blocks2[i >> 2] |= EXTRA[i & 3];
  this.block = blocks2[16];
  if (i >= 56) {
    if (!this.hashed) {
      this.hash();
    }
    blocks2[0] = this.block;
    blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
  }
  blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
  blocks2[15] = this.bytes << 3;
  this.hash();
};
Sha1.prototype.hash = function() {
  var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;
  var f, j, t, blocks2 = this.blocks;
  for (j = 16; j < 80; ++j) {
    t = blocks2[j - 3] ^ blocks2[j - 8] ^ blocks2[j - 14] ^ blocks2[j - 16];
    blocks2[j] = t << 1 | t >>> 31;
  }
  for (j = 0; j < 20; j += 5) {
    f = b & c | ~b & d;
    t = a << 5 | a >>> 27;
    e = t + f + e + 1518500249 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a & b | ~a & c;
    t = e << 5 | e >>> 27;
    d = t + f + d + 1518500249 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e & a | ~e & b;
    t = d << 5 | d >>> 27;
    c = t + f + c + 1518500249 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d & e | ~d & a;
    t = c << 5 | c >>> 27;
    b = t + f + b + 1518500249 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c & d | ~c & e;
    t = b << 5 | b >>> 27;
    a = t + f + a + 1518500249 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  for (; j < 40; j += 5) {
    f = b ^ c ^ d;
    t = a << 5 | a >>> 27;
    e = t + f + e + 1859775393 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a ^ b ^ c;
    t = e << 5 | e >>> 27;
    d = t + f + d + 1859775393 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e ^ a ^ b;
    t = d << 5 | d >>> 27;
    c = t + f + c + 1859775393 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d ^ e ^ a;
    t = c << 5 | c >>> 27;
    b = t + f + b + 1859775393 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c ^ d ^ e;
    t = b << 5 | b >>> 27;
    a = t + f + a + 1859775393 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  for (; j < 60; j += 5) {
    f = b & c | b & d | c & d;
    t = a << 5 | a >>> 27;
    e = t + f + e - 1894007588 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a & b | a & c | b & c;
    t = e << 5 | e >>> 27;
    d = t + f + d - 1894007588 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e & a | e & b | a & b;
    t = d << 5 | d >>> 27;
    c = t + f + c - 1894007588 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d & e | d & a | e & a;
    t = c << 5 | c >>> 27;
    b = t + f + b - 1894007588 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c & d | c & e | d & e;
    t = b << 5 | b >>> 27;
    a = t + f + a - 1894007588 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  for (; j < 80; j += 5) {
    f = b ^ c ^ d;
    t = a << 5 | a >>> 27;
    e = t + f + e - 899497514 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a ^ b ^ c;
    t = e << 5 | e >>> 27;
    d = t + f + d - 899497514 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e ^ a ^ b;
    t = d << 5 | d >>> 27;
    c = t + f + c - 899497514 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d ^ e ^ a;
    t = c << 5 | c >>> 27;
    b = t + f + b - 899497514 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c ^ d ^ e;
    t = b << 5 | b >>> 27;
    a = t + f + a - 899497514 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  this.h0 = this.h0 + a << 0;
  this.h1 = this.h1 + b << 0;
  this.h2 = this.h2 + c << 0;
  this.h3 = this.h3 + d << 0;
  this.h4 = this.h4 + e << 0;
};
Sha1.prototype.hex = function() {
  this.finalize();
  var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
  return HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15];
};
Sha1.prototype.toString = Sha1.prototype.hex;
Sha1.prototype.digest = function() {
  this.finalize();
  var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
  return [
    h0 >> 24 & 255,
    h0 >> 16 & 255,
    h0 >> 8 & 255,
    h0 & 255,
    h1 >> 24 & 255,
    h1 >> 16 & 255,
    h1 >> 8 & 255,
    h1 & 255,
    h2 >> 24 & 255,
    h2 >> 16 & 255,
    h2 >> 8 & 255,
    h2 & 255,
    h3 >> 24 & 255,
    h3 >> 16 & 255,
    h3 >> 8 & 255,
    h3 & 255,
    h4 >> 24 & 255,
    h4 >> 16 & 255,
    h4 >> 8 & 255,
    h4 & 255
  ];
};
Sha1.prototype.array = Sha1.prototype.digest;
Sha1.prototype.arrayBuffer = function() {
  this.finalize();
  var buffer = new ArrayBuffer(20);
  var dataView = new DataView(buffer);
  dataView.setUint32(0, this.h0);
  dataView.setUint32(4, this.h1);
  dataView.setUint32(8, this.h2);
  dataView.setUint32(12, this.h3);
  dataView.setUint32(16, this.h4);
  return buffer;
};
var insecureHash = (message) => {
  return new Sha1(true).update(message)["hex"]();
};

// node_modules/@langchain/core/dist/caches/base.js
var getCacheKey = (...strings) => insecureHash(strings.join("_"));
var BaseCache = class {
};
var GLOBAL_MAP = /* @__PURE__ */ new Map();
var InMemoryCache = class extends BaseCache {
  constructor(map) {
    super();
    Object.defineProperty(this, "cache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cache = map != null ? map : /* @__PURE__ */ new Map();
  }
  /**
   * Retrieves data from the cache using a prompt and an LLM key. If the
   * data is not found, it returns null.
   * @param prompt The prompt used to find the data.
   * @param llmKey The LLM key used to find the data.
   * @returns The data corresponding to the prompt and LLM key, or null if not found.
   */
  lookup(prompt, llmKey) {
    var _a;
    return Promise.resolve((_a = this.cache.get(getCacheKey(prompt, llmKey))) != null ? _a : null);
  }
  /**
   * Updates the cache with new data using a prompt and an LLM key.
   * @param prompt The prompt used to store the data.
   * @param llmKey The LLM key used to store the data.
   * @param value The data to be stored.
   */
  async update(prompt, llmKey, value) {
    this.cache.set(getCacheKey(prompt, llmKey), value);
  }
  /**
   * Returns a global instance of InMemoryCache using a predefined global
   * map as the initial cache.
   * @returns A global instance of InMemoryCache.
   */
  static global() {
    return new InMemoryCache(GLOBAL_MAP);
  }
};

// node_modules/@langchain/core/dist/prompt_values.js
var BasePromptValue = class extends Serializable {
};
var StringPromptValue = class extends BasePromptValue {
  static lc_name() {
    return "StringPromptValue";
  }
  constructor(value) {
    super({ value });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "prompt_values"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "value", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.value = value;
  }
  toString() {
    return this.value;
  }
  toChatMessages() {
    return [new HumanMessage(this.value)];
  }
};
var ChatPromptValue = class extends BasePromptValue {
  static lc_name() {
    return "ChatPromptValue";
  }
  constructor(fields) {
    if (Array.isArray(fields)) {
      fields = { messages: fields };
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "prompt_values"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "messages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.messages = fields.messages;
  }
  toString() {
    return getBufferString(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
};

// node_modules/js-tiktoken/dist/chunk-ZDNLBERF.js
var import_base64_js = __toESM(require_base64_js(), 1);
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function bytePairMerge(piece, ranks) {
  let parts = Array.from(
    { length: piece.length },
    (_, i) => ({ start: i, end: i + 1 })
  );
  while (parts.length > 1) {
    let minRank = null;
    for (let i = 0; i < parts.length - 1; i++) {
      const slice = piece.slice(parts[i].start, parts[i + 1].end);
      const rank = ranks.get(slice.join(","));
      if (rank == null)
        continue;
      if (minRank == null || rank < minRank[0]) {
        minRank = [rank, i];
      }
    }
    if (minRank != null) {
      const i = minRank[1];
      parts[i] = { start: parts[i].start, end: parts[i + 1].end };
      parts.splice(i + 1, 1);
    } else {
      break;
    }
  }
  return parts;
}
function bytePairEncode(piece, ranks) {
  if (piece.length === 1)
    return [ranks.get(piece.join(","))];
  return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
function escapeRegex(str) {
  return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var _Tiktoken = class {
  constructor(ranks, extendedSpecialTokens) {
    /** @internal */
    __publicField(this, "specialTokens");
    /** @internal */
    __publicField(this, "inverseSpecialTokens");
    /** @internal */
    __publicField(this, "patStr");
    /** @internal */
    __publicField(this, "textEncoder", new TextEncoder());
    /** @internal */
    __publicField(this, "textDecoder", new TextDecoder("utf-8"));
    /** @internal */
    __publicField(this, "rankMap", /* @__PURE__ */ new Map());
    /** @internal */
    __publicField(this, "textMap", /* @__PURE__ */ new Map());
    this.patStr = ranks.pat_str;
    const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
      const [_, offsetStr, ...tokens] = x.split(" ");
      const offset = Number.parseInt(offsetStr, 10);
      tokens.forEach((token, i) => memo[token] = offset + i);
      return memo;
    }, {});
    for (const [token, rank] of Object.entries(uncompressed)) {
      const bytes = import_base64_js.default.toByteArray(token);
      this.rankMap.set(bytes.join(","), rank);
      this.textMap.set(rank, bytes);
    }
    this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
    this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {
      memo[rank] = this.textEncoder.encode(text);
      return memo;
    }, {});
  }
  encode(text, allowedSpecial = [], disallowedSpecial = "all") {
    var _a;
    const regexes = new RegExp(this.patStr, "ug");
    const specialRegex = _Tiktoken.specialTokenRegex(
      Object.keys(this.specialTokens)
    );
    const ret = [];
    const allowedSpecialSet = new Set(
      allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
    );
    const disallowedSpecialSet = new Set(
      disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
        (x) => !allowedSpecialSet.has(x)
      ) : disallowedSpecial
    );
    if (disallowedSpecialSet.size > 0) {
      const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
        ...disallowedSpecialSet
      ]);
      const specialMatch = text.match(disallowedSpecialRegex);
      if (specialMatch != null) {
        throw new Error(
          `The text contains a special token that is not allowed: ${specialMatch[0]}`
        );
      }
    }
    let start = 0;
    while (true) {
      let nextSpecial = null;
      let startFind = start;
      while (true) {
        specialRegex.lastIndex = startFind;
        nextSpecial = specialRegex.exec(text);
        if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
          break;
        startFind = nextSpecial.index + 1;
      }
      const end = (_a = nextSpecial == null ? void 0 : nextSpecial.index) != null ? _a : text.length;
      for (const match of text.substring(start, end).matchAll(regexes)) {
        const piece = this.textEncoder.encode(match[0]);
        const token2 = this.rankMap.get(piece.join(","));
        if (token2 != null) {
          ret.push(token2);
          continue;
        }
        ret.push(...bytePairEncode(piece, this.rankMap));
      }
      if (nextSpecial == null)
        break;
      let token = this.specialTokens[nextSpecial[0]];
      ret.push(token);
      start = nextSpecial.index + nextSpecial[0].length;
    }
    return ret;
  }
  decode(tokens) {
    var _a;
    const res = [];
    let length = 0;
    for (let i2 = 0; i2 < tokens.length; ++i2) {
      const token = tokens[i2];
      const bytes = (_a = this.textMap.get(token)) != null ? _a : this.inverseSpecialTokens[token];
      if (bytes != null) {
        res.push(bytes);
        length += bytes.length;
      }
    }
    const mergedArray = new Uint8Array(length);
    let i = 0;
    for (const bytes of res) {
      mergedArray.set(bytes, i);
      i += bytes.length;
    }
    return this.textDecoder.decode(mergedArray);
  }
};
var Tiktoken = _Tiktoken;
__publicField2(Tiktoken, "specialTokenRegex", (tokens) => {
  return new RegExp(tokens.map((i) => escapeRegex(i)).join("|"), "g");
});
function getEncodingNameForModel(model) {
  switch (model) {
    case "gpt2": {
      return "gpt2";
    }
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003": {
      return "p50k_base";
    }
    case "code-davinci-edit-001":
    case "text-davinci-edit-001": {
      return "p50k_edit";
    }
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001": {
      return "r50k_base";
    }
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo":
    case "gpt-4-turbo-2024-04-09":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002":
    case "text-embedding-3-small":
    case "text-embedding-3-large": {
      return "cl100k_base";
    }
    case "gpt-4o":
    case "gpt-4o-2024-05-13":
    case "gpt-4o-2024-08-06":
    case "gpt-4o-2024-11-20":
    case "gpt-4o-mini-2024-07-18":
    case "gpt-4o-mini":
    case "gpt-4o-search-preview":
    case "gpt-4o-search-preview-2025-03-11":
    case "gpt-4o-mini-search-preview":
    case "gpt-4o-mini-search-preview-2025-03-11":
    case "gpt-4o-audio-preview":
    case "gpt-4o-audio-preview-2024-12-17":
    case "gpt-4o-audio-preview-2024-10-01":
    case "gpt-4o-mini-audio-preview":
    case "gpt-4o-mini-audio-preview-2024-12-17":
    case "o1":
    case "o1-2024-12-17":
    case "o1-mini":
    case "o1-mini-2024-09-12":
    case "o1-preview":
    case "o1-preview-2024-09-12":
    case "o1-pro":
    case "o1-pro-2025-03-19":
    case "o3":
    case "o3-2025-04-16":
    case "o3-mini":
    case "o3-mini-2025-01-31":
    case "o4-mini":
    case "o4-mini-2025-04-16":
    case "chatgpt-4o-latest":
    case "gpt-4o-realtime":
    case "gpt-4o-realtime-preview-2024-10-01":
    case "gpt-4o-realtime-preview-2024-12-17":
    case "gpt-4o-mini-realtime-preview":
    case "gpt-4o-mini-realtime-preview-2024-12-17":
    case "gpt-4.1":
    case "gpt-4.1-2025-04-14":
    case "gpt-4.1-mini":
    case "gpt-4.1-mini-2025-04-14":
    case "gpt-4.1-nano":
    case "gpt-4.1-nano-2025-04-14":
    case "gpt-4.5-preview":
    case "gpt-4.5-preview-2025-02-27": {
      return "o200k_base";
    }
    default:
      throw new Error("Unknown model");
  }
}

// node_modules/@langchain/core/dist/utils/tiktoken.js
var cache = {};
var caller = /* @__PURE__ */ new AsyncCaller2({});
async function getEncoding(encoding) {
  if (!(encoding in cache)) {
    cache[encoding] = caller.fetch(`https://tiktoken.pages.dev/js/${encoding}.json`).then((res) => res.json()).then((data) => new Tiktoken(data)).catch((e) => {
      delete cache[encoding];
      throw e;
    });
  }
  return await cache[encoding];
}
async function encodingForModel(model) {
  return getEncoding(getEncodingNameForModel(model));
}

// node_modules/@langchain/core/dist/language_models/base.js
var getModelNameForTiktoken = (modelName) => {
  if (modelName.startsWith("gpt-3.5-turbo-16k")) {
    return "gpt-3.5-turbo-16k";
  }
  if (modelName.startsWith("gpt-3.5-turbo-")) {
    return "gpt-3.5-turbo";
  }
  if (modelName.startsWith("gpt-4-32k")) {
    return "gpt-4-32k";
  }
  if (modelName.startsWith("gpt-4-")) {
    return "gpt-4";
  }
  if (modelName.startsWith("gpt-4o")) {
    return "gpt-4o";
  }
  return modelName;
};
var getVerbosity = () => false;
var BaseLangChain = class extends Runnable {
  get lc_attributes() {
    return {
      callbacks: void 0,
      verbose: void 0
    };
  }
  constructor(params) {
    var _a, _b, _c;
    super(params);
    Object.defineProperty(this, "verbose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "callbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.verbose = (_a = params.verbose) != null ? _a : getVerbosity();
    this.callbacks = params.callbacks;
    this.tags = (_b = params.tags) != null ? _b : [];
    this.metadata = (_c = params.metadata) != null ? _c : {};
  }
};
var BaseLanguageModel = class extends BaseLangChain {
  /**
   * Keys that the language model accepts as call options.
   */
  get callKeys() {
    return ["stop", "timeout", "signal", "tags", "metadata", "callbacks"];
  }
  constructor({ callbacks, callbackManager, ...params }) {
    const { cache: cache2, ...rest } = params;
    super({
      callbacks: callbacks != null ? callbacks : callbackManager,
      ...rest
    });
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_encoding", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (typeof cache2 === "object") {
      this.cache = cache2;
    } else if (cache2) {
      this.cache = InMemoryCache.global();
    } else {
      this.cache = void 0;
    }
    this.caller = new AsyncCaller2(params != null ? params : {});
  }
  async getNumTokens(content) {
    if (typeof content !== "string") {
      return 0;
    }
    let numTokens = Math.ceil(content.length / 4);
    if (!this._encoding) {
      try {
        this._encoding = await encodingForModel("modelName" in this ? getModelNameForTiktoken(this.modelName) : "gpt2");
      } catch (error) {
        console.warn("Failed to calculate number of tokens, falling back to approximate count", error);
      }
    }
    if (this._encoding) {
      try {
        numTokens = this._encoding.encode(content).length;
      } catch (error) {
        console.warn("Failed to calculate number of tokens, falling back to approximate count", error);
      }
    }
    return numTokens;
  }
  static _convertInputToPromptValue(input) {
    if (typeof input === "string") {
      return new StringPromptValue(input);
    } else if (Array.isArray(input)) {
      return new ChatPromptValue(input.map(coerceMessageLikeToMessage));
    } else {
      return input;
    }
  }
  /**
   * Get the identifying parameters of the LLM.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _identifyingParams() {
    return {};
  }
  /**
   * Create a unique cache key for a specific call to a specific language model.
   * @param callOptions Call options for the model
   * @returns A unique cache key.
   */
  _getSerializedCacheKeyParametersForCall({ config, ...callOptions }) {
    const params = {
      ...this._identifyingParams(),
      ...callOptions,
      _type: this._llmType(),
      _model: this._modelType()
    };
    const filteredEntries = Object.entries(params).filter(([_, value]) => value !== void 0);
    const serializedEntries = filteredEntries.map(([key, value]) => `${key}:${JSON.stringify(value)}`).sort().join(",");
    return serializedEntries;
  }
  /**
   * @deprecated
   * Return a json-like object representing this LLM.
   */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
   * @deprecated
   * Load an LLM from a json-like object describing it.
   */
  static async deserialize(_data) {
    throw new Error("Use .toJSON() instead");
  }
};

// node_modules/@langchain/core/dist/runnables/passthrough.js
var RunnablePassthrough = class extends Runnable {
  static lc_name() {
    return "RunnablePassthrough";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "func", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (fields) {
      this.func = fields.func;
    }
  }
  async invoke(input, options) {
    const config = ensureConfig(options);
    if (this.func) {
      await this.func(input, config);
    }
    return this._callWithConfig((input2) => Promise.resolve(input2), input, config);
  }
  async *transform(generator, options) {
    const config = ensureConfig(options);
    let finalOutput;
    let finalOutputSupported = true;
    for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config)) {
      yield chunk;
      if (finalOutputSupported) {
        if (finalOutput === void 0) {
          finalOutput = chunk;
        } else {
          try {
            finalOutput = concat(finalOutput, chunk);
          } catch (e) {
            finalOutput = void 0;
            finalOutputSupported = false;
          }
        }
      }
    }
    if (this.func && finalOutput !== void 0) {
      await this.func(finalOutput, config);
    }
  }
  /**
   * A runnable that assigns key-value pairs to the input.
   *
   * The example below shows how you could use it with an inline function.
   *
   * @example
   * ```typescript
   * const prompt =
   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}
   * Question: {question}
   * SQL Query:`);
   *
   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`
   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.
   * // In this case, we're passing the schema.
   * const sqlQueryGeneratorChain = RunnableSequence.from([
   *   RunnablePassthrough.assign({
   *     schema: async () => db.getTableInfo(),
   *   }),
   *   prompt,
   *   new ChatOpenAI({}).bind({ stop: ["\nSQLResult:"] }),
   *   new StringOutputParser(),
   * ]);
   * const result = await sqlQueryGeneratorChain.invoke({
   *   question: "How many employees are there?",
   * });
   * ```
   */
  static assign(mapping) {
    return new RunnableAssign(new RunnableMap({ steps: mapping }));
  }
};

// node_modules/@langchain/core/dist/utils/types/is_zod_schema.js
function isZodSchema(input) {
  var _a, _b;
  if (!input) {
    return false;
  }
  if (typeof input !== "object") {
    return false;
  }
  if (Array.isArray(input)) {
    return false;
  }
  const asZodSchema = input;
  if (asZodSchema._def) {
    return true;
  }
  const zodFirstPartyTypeKinds = Object.values(z.ZodFirstPartyTypeKind);
  if (zodFirstPartyTypeKinds.includes((_b = (_a = asZodSchema.constructor) == null ? void 0 : _a.name) != null ? _b : "NOT_INCLUDED")) {
    return true;
  }
  return typeof asZodSchema.parse === "function" && typeof asZodSchema.parseAsync === "function" && typeof asZodSchema.safeParse === "function" && typeof asZodSchema.safeParseAsync === "function";
}

// node_modules/@langchain/core/dist/language_models/chat_models.js
function _formatForTracing(messages) {
  const messagesToTrace = [];
  for (const message of messages) {
    let messageToTrace = message;
    if (Array.isArray(message.content)) {
      for (let idx = 0; idx < message.content.length; idx++) {
        const block = message.content[idx];
        if (isURLContentBlock(block) || isBase64ContentBlock(block)) {
          if (messageToTrace === message) {
            messageToTrace = new message.constructor({
              ...messageToTrace,
              content: [
                ...message.content.slice(0, idx),
                convertToOpenAIImageBlock(block),
                ...message.content.slice(idx + 1)
              ]
            });
          }
        }
      }
    }
    messagesToTrace.push(messageToTrace);
  }
  return messagesToTrace;
}
var BaseChatModel = class extends BaseLanguageModel {
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "chat_models", this._llmType()]
    });
    Object.defineProperty(this, "disableStreaming", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
  }
  _separateRunnableConfigFromCallOptionsCompat(options) {
    const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);
    callOptions.signal = runnableConfig.signal;
    return [runnableConfig, callOptions];
  }
  /**
   * Invokes the chat model with a single input.
   * @param input The input for the language model.
   * @param options The call options.
   * @returns A Promise that resolves to a BaseMessageChunk.
   */
  async invoke(input, options) {
    const promptValue = BaseChatModel._convertInputToPromptValue(input);
    const result = await this.generatePrompt([promptValue], options, options == null ? void 0 : options.callbacks);
    const chatGeneration = result.generations[0][0];
    return chatGeneration.message;
  }
  // eslint-disable-next-line require-yield
  async *_streamResponseChunks(_messages, _options, _runManager) {
    throw new Error("Not implemented.");
  }
  async *_streamIterator(input, options) {
    var _a;
    if (this._streamResponseChunks === BaseChatModel.prototype._streamResponseChunks || this.disableStreaming) {
      yield this.invoke(input, options);
    } else {
      const prompt = BaseChatModel._convertInputToPromptValue(input);
      const messages = prompt.toChatMessages();
      const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(options);
      const inheritableMetadata = {
        ...runnableConfig.metadata,
        ...this.getLsParams(callOptions)
      };
      const callbackManager_ = await CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
      const extra = {
        options: callOptions,
        invocation_params: this == null ? void 0 : this.invocationParams(callOptions),
        batch_size: 1
      };
      const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleChatModelStart(this.toJSON(), [_formatForTracing(messages)], runnableConfig.runId, void 0, extra, void 0, void 0, runnableConfig.runName));
      let generationChunk;
      let llmOutput;
      try {
        for await (const chunk of this._streamResponseChunks(messages, callOptions, runManagers == null ? void 0 : runManagers[0])) {
          if (chunk.message.id == null) {
            const runId = (_a = runManagers == null ? void 0 : runManagers.at(0)) == null ? void 0 : _a.runId;
            if (runId != null)
              chunk.message._updateId(`run-${runId}`);
          }
          chunk.message.response_metadata = {
            ...chunk.generationInfo,
            ...chunk.message.response_metadata
          };
          yield chunk.message;
          if (!generationChunk) {
            generationChunk = chunk;
          } else {
            generationChunk = generationChunk.concat(chunk);
          }
          if (isAIMessageChunk(chunk.message) && chunk.message.usage_metadata !== void 0) {
            llmOutput = {
              tokenUsage: {
                promptTokens: chunk.message.usage_metadata.input_tokens,
                completionTokens: chunk.message.usage_metadata.output_tokens,
                totalTokens: chunk.message.usage_metadata.total_tokens
              }
            };
          }
        }
      } catch (err) {
        await Promise.all((runManagers != null ? runManagers : []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMError(err)));
        throw err;
      }
      await Promise.all((runManagers != null ? runManagers : []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMEnd({
        // TODO: Remove cast after figuring out inheritance
        generations: [[generationChunk]],
        llmOutput
      })));
    }
  }
  getLsParams(options) {
    const providerName = this.getName().startsWith("Chat") ? this.getName().replace("Chat", "") : this.getName();
    return {
      ls_model_type: "chat",
      ls_stop: options.stop,
      ls_provider: providerName
    };
  }
  /** @ignore */
  async _generateUncached(messages, parsedOptions, handledOptions, startedRunManagers) {
    var _a, _b;
    const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
    let runManagers;
    if (startedRunManagers !== void 0 && startedRunManagers.length === baseMessages.length) {
      runManagers = startedRunManagers;
    } else {
      const inheritableMetadata = {
        ...handledOptions.metadata,
        ...this.getLsParams(parsedOptions)
      };
      const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
      const extra = {
        options: parsedOptions,
        invocation_params: this == null ? void 0 : this.invocationParams(parsedOptions),
        batch_size: 1
      };
      runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, void 0, extra, void 0, void 0, handledOptions.runName));
    }
    const generations = [];
    const llmOutputs = [];
    const hasStreamingHandler = !!(runManagers == null ? void 0 : runManagers[0].handlers.find(callbackHandlerPrefersStreaming));
    if (hasStreamingHandler && !this.disableStreaming && baseMessages.length === 1 && this._streamResponseChunks !== BaseChatModel.prototype._streamResponseChunks) {
      try {
        const stream = await this._streamResponseChunks(baseMessages[0], parsedOptions, runManagers == null ? void 0 : runManagers[0]);
        let aggregated;
        let llmOutput;
        for await (const chunk of stream) {
          if (chunk.message.id == null) {
            const runId = (_a = runManagers == null ? void 0 : runManagers.at(0)) == null ? void 0 : _a.runId;
            if (runId != null)
              chunk.message._updateId(`run-${runId}`);
          }
          if (aggregated === void 0) {
            aggregated = chunk;
          } else {
            aggregated = concat(aggregated, chunk);
          }
          if (isAIMessageChunk(chunk.message) && chunk.message.usage_metadata !== void 0) {
            llmOutput = {
              tokenUsage: {
                promptTokens: chunk.message.usage_metadata.input_tokens,
                completionTokens: chunk.message.usage_metadata.output_tokens,
                totalTokens: chunk.message.usage_metadata.total_tokens
              }
            };
          }
        }
        if (aggregated === void 0) {
          throw new Error("Received empty response from chat model call.");
        }
        generations.push([aggregated]);
        await (runManagers == null ? void 0 : runManagers[0].handleLLMEnd({
          generations,
          llmOutput
        }));
      } catch (e) {
        await (runManagers == null ? void 0 : runManagers[0].handleLLMError(e));
        throw e;
      }
    } else {
      const results = await Promise.allSettled(baseMessages.map((messageList, i) => this._generate(messageList, { ...parsedOptions, promptIndex: i }, runManagers == null ? void 0 : runManagers[i])));
      await Promise.all(results.map(async (pResult, i) => {
        var _a2, _b2, _c;
        if (pResult.status === "fulfilled") {
          const result = pResult.value;
          for (const generation of result.generations) {
            if (generation.message.id == null) {
              const runId = (_a2 = runManagers == null ? void 0 : runManagers.at(0)) == null ? void 0 : _a2.runId;
              if (runId != null)
                generation.message._updateId(`run-${runId}`);
            }
            generation.message.response_metadata = {
              ...generation.generationInfo,
              ...generation.message.response_metadata
            };
          }
          if (result.generations.length === 1) {
            result.generations[0].message.response_metadata = {
              ...result.llmOutput,
              ...result.generations[0].message.response_metadata
            };
          }
          generations[i] = result.generations;
          llmOutputs[i] = result.llmOutput;
          return (_b2 = runManagers == null ? void 0 : runManagers[i]) == null ? void 0 : _b2.handleLLMEnd({
            generations: [result.generations],
            llmOutput: result.llmOutput
          });
        } else {
          await ((_c = runManagers == null ? void 0 : runManagers[i]) == null ? void 0 : _c.handleLLMError(pResult.reason));
          return Promise.reject(pResult.reason);
        }
      }));
    }
    const output = {
      generations,
      llmOutput: llmOutputs.length ? (_b = this._combineLLMOutput) == null ? void 0 : _b.call(this, ...llmOutputs) : void 0
    };
    Object.defineProperty(output, RUN_KEY, {
      value: runManagers ? { runIds: runManagers == null ? void 0 : runManagers.map((manager) => manager.runId) } : void 0,
      configurable: true
    });
    return output;
  }
  async _generateCached({ messages, cache: cache2, llmStringKey, parsedOptions, handledOptions }) {
    const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
    const inheritableMetadata = {
      ...handledOptions.metadata,
      ...this.getLsParams(parsedOptions)
    };
    const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, inheritableMetadata, this.metadata, { verbose: this.verbose });
    const extra = {
      options: parsedOptions,
      invocation_params: this == null ? void 0 : this.invocationParams(parsedOptions),
      batch_size: 1
    };
    const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleChatModelStart(this.toJSON(), baseMessages.map(_formatForTracing), handledOptions.runId, void 0, extra, void 0, void 0, handledOptions.runName));
    const missingPromptIndices = [];
    const results = await Promise.allSettled(baseMessages.map(async (baseMessage, index) => {
      const prompt = BaseChatModel._convertInputToPromptValue(baseMessage).toString();
      const result = await cache2.lookup(prompt, llmStringKey);
      if (result == null) {
        missingPromptIndices.push(index);
      }
      return result;
    }));
    const cachedResults = results.map((result, index) => ({ result, runManager: runManagers == null ? void 0 : runManagers[index] })).filter(({ result }) => result.status === "fulfilled" && result.value != null || result.status === "rejected");
    const generations = [];
    await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {
      if (promiseResult.status === "fulfilled") {
        const result = promiseResult.value;
        generations[i] = result.map((result2) => {
          if ("message" in result2 && isBaseMessage(result2.message) && isAIMessage(result2.message)) {
            result2.message.usage_metadata = {
              input_tokens: 0,
              output_tokens: 0,
              total_tokens: 0
            };
          }
          result2.generationInfo = {
            ...result2.generationInfo,
            tokenUsage: {}
          };
          return result2;
        });
        if (result.length) {
          await (runManager == null ? void 0 : runManager.handleLLMNewToken(result[0].text));
        }
        return runManager == null ? void 0 : runManager.handleLLMEnd({
          generations: [result]
        }, void 0, void 0, void 0, {
          cached: true
        });
      } else {
        await (runManager == null ? void 0 : runManager.handleLLMError(promiseResult.reason, void 0, void 0, void 0, {
          cached: true
        }));
        return Promise.reject(promiseResult.reason);
      }
    }));
    const output = {
      generations,
      missingPromptIndices,
      startedRunManagers: runManagers
    };
    Object.defineProperty(output, RUN_KEY, {
      value: runManagers ? { runIds: runManagers == null ? void 0 : runManagers.map((manager) => manager.runId) } : void 0,
      configurable: true
    });
    return output;
  }
  /**
   * Generates chat based on the input messages.
   * @param messages An array of arrays of BaseMessage instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to an LLMResult.
   */
  async generate(messages, options, callbacks) {
    var _a, _b;
    let parsedOptions;
    if (Array.isArray(options)) {
      parsedOptions = { stop: options };
    } else {
      parsedOptions = options;
    }
    const baseMessages = messages.map((messageList) => messageList.map(coerceMessageLikeToMessage));
    const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);
    runnableConfig.callbacks = (_a = runnableConfig.callbacks) != null ? _a : callbacks;
    if (!this.cache) {
      return this._generateUncached(baseMessages, callOptions, runnableConfig);
    }
    const { cache: cache2 } = this;
    const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);
    const { generations, missingPromptIndices, startedRunManagers } = await this._generateCached({
      messages: baseMessages,
      cache: cache2,
      llmStringKey,
      parsedOptions: callOptions,
      handledOptions: runnableConfig
    });
    let llmOutput = {};
    if (missingPromptIndices.length > 0) {
      const results = await this._generateUncached(missingPromptIndices.map((i) => baseMessages[i]), callOptions, runnableConfig, startedRunManagers !== void 0 ? missingPromptIndices.map((i) => startedRunManagers == null ? void 0 : startedRunManagers[i]) : void 0);
      await Promise.all(results.generations.map(async (generation, index) => {
        const promptIndex = missingPromptIndices[index];
        generations[promptIndex] = generation;
        const prompt = BaseChatModel._convertInputToPromptValue(baseMessages[promptIndex]).toString();
        return cache2.update(prompt, llmStringKey, generation);
      }));
      llmOutput = (_b = results.llmOutput) != null ? _b : {};
    }
    return { generations, llmOutput };
  }
  /**
   * Get the parameters used to invoke the model
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  invocationParams(_options) {
    return {};
  }
  _modelType() {
    return "base_chat_model";
  }
  /**
   * @deprecated
   * Return a json-like object representing this LLM.
   */
  serialize() {
    return {
      ...this.invocationParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
   * Generates a prompt based on the input prompt values.
   * @param promptValues An array of BasePromptValue instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to an LLMResult.
   */
  async generatePrompt(promptValues, options, callbacks) {
    const promptMessages = promptValues.map((promptValue) => promptValue.toChatMessages());
    return this.generate(promptMessages, options, callbacks);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Makes a single call to the chat model.
   * @param messages An array of BaseMessage instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a BaseMessage.
   */
  async call(messages, options, callbacks) {
    const result = await this.generate([messages.map(coerceMessageLikeToMessage)], options, callbacks);
    const generations = result.generations;
    return generations[0][0].message;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Makes a single call to the chat model with a prompt value.
   * @param promptValue The value of the prompt.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a BaseMessage.
   */
  async callPrompt(promptValue, options, callbacks) {
    const promptMessages = promptValue.toChatMessages();
    return this.call(promptMessages, options, callbacks);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Predicts the next message based on the input messages.
   * @param messages An array of BaseMessage instances.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a BaseMessage.
   */
  async predictMessages(messages, options, callbacks) {
    return this.call(messages, options, callbacks);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * Predicts the next message based on a text input.
   * @param text The text input.
   * @param options The call options or an array of stop sequences.
   * @param callbacks The callbacks for the language model.
   * @returns A Promise that resolves to a string.
   */
  async predict(text, options, callbacks) {
    const message = new HumanMessage(text);
    const result = await this.call([message], options, callbacks);
    if (typeof result.content !== "string") {
      throw new Error("Cannot use predict when output is not a string.");
    }
    return result.content;
  }
  withStructuredOutput(outputSchema, config) {
    var _a;
    if (typeof this.bindTools !== "function") {
      throw new Error(`Chat model must implement ".bindTools()" to use withStructuredOutput.`);
    }
    if (config == null ? void 0 : config.strict) {
      throw new Error(`"strict" mode is not supported for this model by default.`);
    }
    const schema = outputSchema;
    const name = config == null ? void 0 : config.name;
    const description = (_a = schema.description) != null ? _a : "A function available to call.";
    const method = config == null ? void 0 : config.method;
    const includeRaw = config == null ? void 0 : config.includeRaw;
    if (method === "jsonMode") {
      throw new Error(`Base withStructuredOutput implementation only supports "functionCalling" as a method.`);
    }
    let functionName = name != null ? name : "extract";
    let tools;
    if (isZodSchema(schema)) {
      tools = [
        {
          type: "function",
          function: {
            name: functionName,
            description,
            parameters: zodToJsonSchema(schema)
          }
        }
      ];
    } else {
      if ("name" in schema) {
        functionName = schema.name;
      }
      tools = [
        {
          type: "function",
          function: {
            name: functionName,
            description,
            parameters: schema
          }
        }
      ];
    }
    const llm = this.bindTools(tools);
    const outputParser = RunnableLambda.from((input) => {
      if (!input.tool_calls || input.tool_calls.length === 0) {
        throw new Error("No tool calls found in the response.");
      }
      const toolCall = input.tool_calls.find((tc) => tc.name === functionName);
      if (!toolCall) {
        throw new Error(`No tool call found with name ${functionName}.`);
      }
      return toolCall.args;
    });
    if (!includeRaw) {
      return llm.pipe(outputParser).withConfig({
        runName: "StructuredOutput"
      });
    }
    const parserAssign = RunnablePassthrough.assign({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      parsed: (input, config2) => outputParser.invoke(input.raw, config2)
    });
    const parserNone = RunnablePassthrough.assign({
      parsed: () => null
    });
    const parsedWithFallback = parserAssign.withFallbacks({
      fallbacks: [parserNone]
    });
    return RunnableSequence.from([
      {
        raw: llm
      },
      parsedWithFallback
    ]).withConfig({
      runName: "StructuredOutputRunnable"
    });
  }
};

// node_modules/whatwg-fetch/fetch.js
var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof global !== "undefined" && global || {};
var support = {
  searchParams: "URLSearchParams" in g,
  iterable: "Symbol" in g && "iterator" in Symbol,
  blob: "FileReader" in g && "Blob" in g && function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: "FormData" in g,
  arrayBuffer: "ArrayBuffer" in g
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers2(headers) {
  this.map = {};
  if (headers instanceof Headers2) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers2.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers2.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers2.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers2.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers2.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers2.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers2.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers2.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers2.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
}
function consumed(body) {
  if (body._noBody)
    return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers2(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers2(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers2();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers2(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers2(this.headers),
    url: this.url
  });
};
Response.error = function() {
  var response = new Response(null, { status: 200, statusText: "" });
  response.ok = false;
  response.status = 0;
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = g.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch2(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch2.polyfill = true;
if (!g.fetch) {
  g.fetch = fetch2;
  g.Headers = Headers2;
  g.Request = Request;
  g.Response = Response;
}

// node_modules/ollama/dist/browser.mjs
var defaultPort = "11434";
var defaultHost = `http://127.0.0.1:${defaultPort}`;
var version = "0.5.15";
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ResponseError = class extends Error {
  constructor(error, status_code) {
    super(error);
    this.error = error;
    this.status_code = status_code;
    this.name = "ResponseError";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ResponseError);
    }
  }
};
var AbortableAsyncIterator = class {
  constructor(abortController, itr, doneCallback) {
    __publicField$1(this, "abortController");
    __publicField$1(this, "itr");
    __publicField$1(this, "doneCallback");
    this.abortController = abortController;
    this.itr = itr;
    this.doneCallback = doneCallback;
  }
  abort() {
    this.abortController.abort();
  }
  async *[Symbol.asyncIterator]() {
    for await (const message of this.itr) {
      if ("error" in message) {
        throw new Error(message.error);
      }
      yield message;
      if (message.done || message.status === "success") {
        this.doneCallback();
        return;
      }
    }
    throw new Error("Did not receive done or success response in stream.");
  }
};
var checkOk = async (response) => {
  var _a;
  if (response.ok) {
    return;
  }
  let message = `Error ${response.status}: ${response.statusText}`;
  let errorData = null;
  if ((_a = response.headers.get("content-type")) == null ? void 0 : _a.includes("application/json")) {
    try {
      errorData = await response.json();
      message = errorData.error || message;
    } catch (error) {
      console.log("Failed to parse error response as JSON");
    }
  } else {
    try {
      console.log("Getting text from response");
      const textResponse = await response.text();
      message = textResponse || message;
    } catch (error) {
      console.log("Failed to get text from error response");
    }
  }
  throw new ResponseError(message, response.status);
};
function getPlatform() {
  var _a;
  if (typeof window !== "undefined" && window.navigator) {
    const nav = navigator;
    if ("userAgentData" in nav && ((_a = nav.userAgentData) == null ? void 0 : _a.platform)) {
      return `${nav.userAgentData.platform.toLowerCase()} Browser/${navigator.userAgent};`;
    }
    if (navigator.platform) {
      return `${navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;
    }
    return `unknown Browser/${navigator.userAgent};`;
  } else if (typeof process !== "undefined") {
    return `${process.arch} ${process.platform} Node.js/${process.version}`;
  }
  return "";
}
function normalizeHeaders(headers) {
  if (headers instanceof Headers) {
    const obj = {};
    headers.forEach((value, key) => {
      obj[key] = value;
    });
    return obj;
  } else if (Array.isArray(headers)) {
    return Object.fromEntries(headers);
  } else {
    return headers || {};
  }
}
var fetchWithHeaders = async (fetch3, url, options = {}) => {
  const defaultHeaders = {
    "Content-Type": "application/json",
    Accept: "application/json",
    "User-Agent": `ollama-js/${version} (${getPlatform()})`
  };
  options.headers = normalizeHeaders(options.headers);
  const customHeaders = Object.fromEntries(
    Object.entries(options.headers).filter(([key]) => !Object.keys(defaultHeaders).some((defaultKey) => defaultKey.toLowerCase() === key.toLowerCase()))
  );
  options.headers = {
    ...defaultHeaders,
    ...customHeaders
  };
  return fetch3(url, options);
};
var get = async (fetch3, host, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var post = async (fetch3, host, data, options) => {
  const isRecord = (input) => {
    return input !== null && typeof input === "object" && !Array.isArray(input);
  };
  const formattedData = isRecord(data) ? JSON.stringify(data) : data;
  const response = await fetchWithHeaders(fetch3, host, {
    method: "POST",
    body: formattedData,
    signal: options == null ? void 0 : options.signal,
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var del = async (fetch3, host, data, options) => {
  const response = await fetchWithHeaders(fetch3, host, {
    method: "DELETE",
    body: JSON.stringify(data),
    headers: options == null ? void 0 : options.headers
  });
  await checkOk(response);
  return response;
};
var parseJSON = async function* (itr) {
  var _a;
  const decoder = new TextDecoder("utf-8");
  let buffer = "";
  const reader = itr.getReader();
  while (true) {
    const { done, value: chunk } = await reader.read();
    if (done) {
      break;
    }
    buffer += decoder.decode(chunk);
    const parts = buffer.split("\n");
    buffer = (_a = parts.pop()) != null ? _a : "";
    for (const part of parts) {
      try {
        yield JSON.parse(part);
      } catch (error) {
        console.warn("invalid json: ", part);
      }
    }
  }
  for (const part of buffer.split("\n").filter((p) => p !== "")) {
    try {
      yield JSON.parse(part);
    } catch (error) {
      console.warn("invalid json: ", part);
    }
  }
};
var formatHost = (host) => {
  if (!host) {
    return defaultHost;
  }
  let isExplicitProtocol = host.includes("://");
  if (host.startsWith(":")) {
    host = `http://127.0.0.1${host}`;
    isExplicitProtocol = true;
  }
  if (!isExplicitProtocol) {
    host = `http://${host}`;
  }
  const url = new URL(host);
  let port = url.port;
  if (!port) {
    if (!isExplicitProtocol) {
      port = defaultPort;
    } else {
      port = url.protocol === "https:" ? "443" : "80";
    }
  }
  let auth = "";
  if (url.username) {
    auth = url.username;
    if (url.password) {
      auth += `:${url.password}`;
    }
    auth += "@";
  }
  let formattedHost = `${url.protocol}//${auth}${url.hostname}:${port}${url.pathname}`;
  if (formattedHost.endsWith("/")) {
    formattedHost = formattedHost.slice(0, -1);
  }
  return formattedHost;
};
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => {
  __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var Ollama$1 = class Ollama {
  constructor(config) {
    var _a, _b;
    __publicField3(this, "config");
    __publicField3(this, "fetch");
    __publicField3(this, "ongoingStreamedRequests", []);
    this.config = {
      host: "",
      headers: config == null ? void 0 : config.headers
    };
    if (!(config == null ? void 0 : config.proxy)) {
      this.config.host = formatHost((_a = config == null ? void 0 : config.host) != null ? _a : defaultHost);
    }
    this.fetch = (_b = config == null ? void 0 : config.fetch) != null ? _b : fetch;
  }
  // Abort any ongoing streamed requests to Ollama
  abort() {
    for (const request of this.ongoingStreamedRequests) {
      request.abort();
    }
    this.ongoingStreamedRequests.length = 0;
  }
  /**
   * Processes a request to the Ollama server. If the request is streamable, it will return a
   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response
   * object.
   * @param endpoint {string} - The endpoint to send the request to.
   * @param request {object} - The request object to send to the endpoint.
   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields
   * response messages.
   * @throws {Error} - If the response body is missing or if the response is an error.
   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.
   */
  async processStreamableRequest(endpoint, request) {
    var _a;
    request.stream = (_a = request.stream) != null ? _a : false;
    const host = `${this.config.host}/api/${endpoint}`;
    if (request.stream) {
      const abortController = new AbortController();
      const response2 = await post(this.fetch, host, request, {
        signal: abortController.signal,
        headers: this.config.headers
      });
      if (!response2.body) {
        throw new Error("Missing body");
      }
      const itr = parseJSON(response2.body);
      const abortableAsyncIterator = new AbortableAsyncIterator(
        abortController,
        itr,
        () => {
          const i = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);
          if (i > -1) {
            this.ongoingStreamedRequests.splice(i, 1);
          }
        }
      );
      this.ongoingStreamedRequests.push(abortableAsyncIterator);
      return abortableAsyncIterator;
    }
    const response = await post(this.fetch, host, request, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Encodes an image to base64 if it is a Uint8Array.
   * @param image {Uint8Array | string} - The image to encode.
   * @returns {Promise<string>} - The base64 encoded image.
   */
  async encodeImage(image) {
    if (typeof image !== "string") {
      const uint8Array = new Uint8Array(image);
      let byteString = "";
      const len = uint8Array.byteLength;
      for (let i = 0; i < len; i++) {
        byteString += String.fromCharCode(uint8Array[i]);
      }
      return btoa(byteString);
    }
    return image;
  }
  /**
   * Generates a response from a text prompt.
   * @param request {GenerateRequest} - The request object.
   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async generate(request) {
    if (request.images) {
      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));
    }
    return this.processStreamableRequest("generate", request);
  }
  /**
   * Chats with the model. The request object can contain messages with images that are either
   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the
   * request.
   * @param request {ChatRequest} - The request object.
   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an
   * AbortableAsyncIterator that yields response messages.
   */
  async chat(request) {
    if (request.messages) {
      for (const message of request.messages) {
        if (message.images) {
          message.images = await Promise.all(
            message.images.map(this.encodeImage.bind(this))
          );
        }
      }
    }
    return this.processStreamableRequest("chat", request);
  }
  /**
   * Creates a new model from a stream of data.
   * @param request {CreateRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.
   */
  async create(request) {
    return this.processStreamableRequest("create", {
      ...request
    });
  }
  /**
   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PullRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async pull(request) {
    return this.processStreamableRequest("pull", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the
   * response should be streamed.
   * @param request {PushRequest} - The request object.
   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or
   * an AbortableAsyncIterator that yields response messages.
   */
  async push(request) {
    return this.processStreamableRequest("push", {
      name: request.model,
      stream: request.stream,
      insecure: request.insecure
    });
  }
  /**
   * Deletes a model from the server. The request object should contain the name of the model to
   * delete.
   * @param request {DeleteRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async delete(request) {
    await del(
      this.fetch,
      `${this.config.host}/api/delete`,
      { name: request.model },
      { headers: this.config.headers }
    );
    return { status: "success" };
  }
  /**
   * Copies a model from one name to another. The request object should contain the name of the
   * model to copy and the new name.
   * @param request {CopyRequest} - The request object.
   * @returns {Promise<StatusResponse>} - The response object.
   */
  async copy(request) {
    await post(this.fetch, `${this.config.host}/api/copy`, { ...request }, {
      headers: this.config.headers
    });
    return { status: "success" };
  }
  /**
   * Lists the models on the server.
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async list() {
    const response = await get(this.fetch, `${this.config.host}/api/tags`, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Shows the metadata of a model. The request object should contain the name of the model.
   * @param request {ShowRequest} - The request object.
   * @returns {Promise<ShowResponse>} - The response object.
   */
  async show(request) {
    const response = await post(this.fetch, `${this.config.host}/api/show`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds text input into vectors.
   * @param request {EmbedRequest} - The request object.
   * @returns {Promise<EmbedResponse>} - The response object.
   */
  async embed(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embed`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Embeds a text prompt into a vector.
   * @param request {EmbeddingsRequest} - The request object.
   * @returns {Promise<EmbeddingsResponse>} - The response object.
   */
  async embeddings(request) {
    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {
      ...request
    }, {
      headers: this.config.headers
    });
    return await response.json();
  }
  /**
   * Lists the running models on the server
   * @returns {Promise<ListResponse>} - The response object.
   * @throws {Error} - If the response body is missing.
   */
  async ps() {
    const response = await get(this.fetch, `${this.config.host}/api/ps`, {
      headers: this.config.headers
    });
    return await response.json();
  }
};
var browser = new Ollama$1();

// node_modules/@langchain/core/dist/tools/types.js
function isStructuredTool(tool) {
  return tool !== void 0 && Array.isArray(tool.lc_namespace);
}
function isRunnableToolLike(tool) {
  return tool !== void 0 && Runnable.isRunnable(tool) && "lc_name" in tool.constructor && typeof tool.constructor.lc_name === "function" && tool.constructor.lc_name() === "RunnableToolLike";
}
function isStructuredToolParams(tool) {
  return !!tool && typeof tool === "object" && "name" in tool && "schema" in tool && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (isZodSchema(tool.schema) || tool.schema != null && typeof tool.schema === "object" && "type" in tool.schema && typeof tool.schema.type === "string" && ["null", "boolean", "object", "array", "number", "string"].includes(tool.schema.type));
}
function isLangChainTool(tool) {
  return isStructuredToolParams(tool) || isRunnableToolLike(tool) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  isStructuredTool(tool);
}

// node_modules/@cfworker/json-schema/dist/esm/deep-compare-strict.js
function deepCompareStrict(a, b) {
  const typeofa = typeof a;
  if (typeofa !== typeof b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    const length = a.length;
    if (length !== b.length) {
      return false;
    }
    for (let i = 0; i < length; i++) {
      if (!deepCompareStrict(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  if (typeofa === "object") {
    if (!a || !b) {
      return a === b;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    const length = aKeys.length;
    if (length !== bKeys.length) {
      return false;
    }
    for (const k of aKeys) {
      if (!deepCompareStrict(a[k], b[k])) {
        return false;
      }
    }
    return true;
  }
  return a === b;
}

// node_modules/@cfworker/json-schema/dist/esm/dereference.js
var initialBaseURI = typeof self !== "undefined" && self.location && self.location.origin !== "null" ? new URL(self.location.origin + self.location.pathname + location.search) : new URL("https://github.com/cfworker");

// node_modules/@cfworker/json-schema/dist/esm/format.js
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var URL_ = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var EMAIL = (input) => {
  if (input[0] === '"')
    return false;
  const [name, host, ...rest] = input.split("@");
  if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253)
    return false;
  if (name[0] === "." || name.endsWith(".") || name.includes(".."))
    return false;
  if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))
    return false;
  return host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));
};
var IPV4 = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
var IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
var DURATION = (input) => input.length > 1 && input.length < 80 && (/^P\d+([.,]\d+)?W$/.test(input) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(input) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(input));
function bind(r) {
  return r.test.bind(r);
}
var format = {
  date,
  time: time.bind(void 0, false),
  "date-time": date_time,
  duration: DURATION,
  uri,
  "uri-reference": bind(URIREF),
  "uri-template": bind(URITEMPLATE),
  url: bind(URL_),
  email: EMAIL,
  hostname: bind(HOSTNAME),
  ipv4: bind(IPV4),
  ipv6: bind(IPV6),
  regex,
  uuid: bind(UUID),
  "json-pointer": bind(JSON_POINTER),
  "json-pointer-uri-fragment": bind(JSON_POINTER_URI_FRAGMENT),
  "relative-json-pointer": bind(RELATIVE_JSON_POINTER)
};
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date(str) {
  const matches = str.match(DATE);
  if (!matches)
    return false;
  const year = +matches[1];
  const month = +matches[2];
  const day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time(full, str) {
  const matches = str.match(TIME);
  if (!matches)
    return false;
  const hour = +matches[1];
  const minute = +matches[2];
  const second = +matches[3];
  const timeZone = !!matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  const dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(true, dateTime[1]);
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI_PATTERN = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str, "u");
    return true;
  } catch (e) {
    return false;
  }
}

// node_modules/@cfworker/json-schema/dist/esm/types.js
var OutputFormat;
(function(OutputFormat2) {
  OutputFormat2[OutputFormat2["Flag"] = 1] = "Flag";
  OutputFormat2[OutputFormat2["Basic"] = 2] = "Basic";
  OutputFormat2[OutputFormat2["Detailed"] = 4] = "Detailed";
})(OutputFormat || (OutputFormat = {}));

// node_modules/@langchain/core/dist/utils/json_schema.js
function toJsonSchema(schema) {
  if (isZodSchema(schema)) {
    return zodToJsonSchema(schema);
  }
  return schema;
}

// node_modules/@langchain/core/dist/utils/function_calling.js
function convertToOpenAIFunction(tool, fields) {
  const fieldsCopy = typeof fields === "number" ? void 0 : fields;
  return {
    name: tool.name,
    description: tool.description,
    parameters: toJsonSchema(tool.schema),
    // Do not include the `strict` field if it is `undefined`.
    ...(fieldsCopy == null ? void 0 : fieldsCopy.strict) !== void 0 ? { strict: fieldsCopy.strict } : {}
  };
}
function convertToOpenAITool(tool, fields) {
  const fieldsCopy = typeof fields === "number" ? void 0 : fields;
  let toolDef;
  if (isLangChainTool(tool)) {
    toolDef = {
      type: "function",
      function: convertToOpenAIFunction(tool)
    };
  } else {
    toolDef = tool;
  }
  if ((fieldsCopy == null ? void 0 : fieldsCopy.strict) !== void 0) {
    toolDef.function.strict = fieldsCopy.strict;
  }
  return toolDef;
}

// node_modules/@langchain/core/dist/output_parsers/base.js
var BaseLLMOutputParser = class extends Runnable {
  /**
   * Parses the result of an LLM call with a given prompt. By default, it
   * simply calls `parseResult`.
   * @param generations The generations from an LLM call.
   * @param _prompt The prompt used in the LLM call.
   * @param callbacks Optional callbacks.
   * @returns A promise of the parsed output.
   */
  parseResultWithPrompt(generations, _prompt, callbacks) {
    return this.parseResult(generations, callbacks);
  }
  _baseMessageToString(message) {
    return typeof message.content === "string" ? message.content : this._baseMessageContentToString(message.content);
  }
  _baseMessageContentToString(content) {
    return JSON.stringify(content);
  }
  /**
   * Calls the parser with a given input and optional configuration options.
   * If the input is a string, it creates a generation with the input as
   * text and calls `parseResult`. If the input is a `BaseMessage`, it
   * creates a generation with the input as a message and the content of the
   * input as text, and then calls `parseResult`.
   * @param input The input to the parser, which can be a string or a `BaseMessage`.
   * @param options Optional configuration options.
   * @returns A promise of the parsed output.
   */
  async invoke(input, options) {
    if (typeof input === "string") {
      return this._callWithConfig(async (input2, options2) => this.parseResult([{ text: input2 }], options2 == null ? void 0 : options2.callbacks), input, { ...options, runType: "parser" });
    } else {
      return this._callWithConfig(async (input2, options2) => this.parseResult([
        {
          message: input2,
          text: this._baseMessageToString(input2)
        }
      ], options2 == null ? void 0 : options2.callbacks), input, { ...options, runType: "parser" });
    }
  }
};
var BaseOutputParser = class extends BaseLLMOutputParser {
  parseResult(generations, callbacks) {
    return this.parse(generations[0].text, callbacks);
  }
  async parseWithPrompt(text, _prompt, callbacks) {
    return this.parse(text, callbacks);
  }
  /**
   * Return the string type key uniquely identifying this class of parser
   */
  _type() {
    throw new Error("_type not implemented");
  }
};
var OutputParserException = class extends Error {
  constructor(message, llmOutput, observation, sendToLLM = false) {
    super(message);
    Object.defineProperty(this, "llmOutput", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "observation", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "sendToLLM", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.llmOutput = llmOutput;
    this.observation = observation;
    this.sendToLLM = sendToLLM;
    if (sendToLLM) {
      if (observation === void 0 || llmOutput === void 0) {
        throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");
      }
    }
    addLangChainErrorFields(this, "OUTPUT_PARSING_FAILURE");
  }
};

// node_modules/@langchain/core/dist/output_parsers/transform.js
var BaseTransformOutputParser = class extends BaseOutputParser {
  async *_transform(inputGenerator) {
    for await (const chunk of inputGenerator) {
      if (typeof chunk === "string") {
        yield this.parseResult([{ text: chunk }]);
      } else {
        yield this.parseResult([
          {
            message: chunk,
            text: this._baseMessageToString(chunk)
          }
        ]);
      }
    }
  }
  /**
   * Transforms an asynchronous generator of input into an asynchronous
   * generator of parsed output.
   * @param inputGenerator An asynchronous generator of input.
   * @param options A configuration object.
   * @returns An asynchronous generator of parsed output.
   */
  async *transform(inputGenerator, options) {
    yield* this._transformStreamWithConfig(inputGenerator, this._transform.bind(this), {
      ...options,
      runType: "parser"
    });
  }
};
var BaseCumulativeTransformOutputParser = class extends BaseTransformOutputParser {
  constructor(fields) {
    var _a;
    super(fields);
    Object.defineProperty(this, "diff", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    this.diff = (_a = fields == null ? void 0 : fields.diff) != null ? _a : this.diff;
  }
  async *_transform(inputGenerator) {
    let prevParsed;
    let accGen;
    for await (const chunk of inputGenerator) {
      if (typeof chunk !== "string" && typeof chunk.content !== "string") {
        throw new Error("Cannot handle non-string output.");
      }
      let chunkGen;
      if (isBaseMessageChunk(chunk)) {
        if (typeof chunk.content !== "string") {
          throw new Error("Cannot handle non-string message output.");
        }
        chunkGen = new ChatGenerationChunk({
          message: chunk,
          text: chunk.content
        });
      } else if (isBaseMessage(chunk)) {
        if (typeof chunk.content !== "string") {
          throw new Error("Cannot handle non-string message output.");
        }
        chunkGen = new ChatGenerationChunk({
          message: convertToChunk(chunk),
          text: chunk.content
        });
      } else {
        chunkGen = new GenerationChunk({ text: chunk });
      }
      if (accGen === void 0) {
        accGen = chunkGen;
      } else {
        accGen = accGen.concat(chunkGen);
      }
      const parsed = await this.parsePartialResult([accGen]);
      if (parsed !== void 0 && parsed !== null && !deepCompareStrict(parsed, prevParsed)) {
        if (this.diff) {
          yield this._diff(prevParsed, parsed);
        } else {
          yield parsed;
        }
        prevParsed = parsed;
      }
    }
  }
  getFormatInstructions() {
    return "";
  }
};

// node_modules/@langchain/core/dist/output_parsers/structured.js
var StructuredOutputParser = class extends BaseOutputParser {
  static lc_name() {
    return "StructuredOutputParser";
  }
  toJSON() {
    return this.toJSONNotImplemented();
  }
  constructor(schema) {
    super(schema);
    Object.defineProperty(this, "schema", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: schema
    });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "output_parsers", "structured"]
    });
  }
  /**
   * Creates a new StructuredOutputParser from a Zod schema.
   * @param schema The Zod schema which the output should match
   * @returns A new instance of StructuredOutputParser.
   */
  static fromZodSchema(schema) {
    return new this(schema);
  }
  /**
   * Creates a new StructuredOutputParser from a set of names and
   * descriptions.
   * @param schemas An object where each key is a name and each value is a description
   * @returns A new instance of StructuredOutputParser.
   */
  static fromNamesAndDescriptions(schemas) {
    const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));
    return new this(zodSchema);
  }
  /**
   * Returns a markdown code snippet with a JSON object formatted according
   * to the schema.
   * @param options Optional. The options for formatting the instructions
   * @returns A markdown code snippet with a JSON object formatted according to the schema.
   */
  getFormatInstructions() {
    return `You must format your output as a JSON value that adheres to a given "JSON Schema" instance.

"JSON Schema" is a declarative language that allows you to annotate and validate JSON documents.

For example, the example "JSON Schema" instance {{"properties": {{"foo": {{"description": "a list of test words", "type": "array", "items": {{"type": "string"}}}}}}, "required": ["foo"]}}
would match an object with one required property, "foo". The "type" property specifies "foo" must be an "array", and the "description" property semantically describes it as "a list of test words". The items within "foo" must be strings.
Thus, the object {{"foo": ["bar", "baz"]}} is a well-formatted instance of this example "JSON Schema". The object {{"properties": {{"foo": ["bar", "baz"]}}}} is not well-formatted.

Your output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!

Here is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:
\`\`\`json
${JSON.stringify(zodToJsonSchema(this.schema))}
\`\`\`
`;
  }
  /**
   * Parses the given text according to the schema.
   * @param text The text to parse
   * @returns The parsed output.
   */
  async parse(text) {
    try {
      const json = text.includes("```") ? text.trim().split(/```(?:json)?/)[1] : text.trim();
      const escapedJson = json.replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (_match, capturedGroup) => {
        const escapedInsideQuotes = capturedGroup.replace(/\n/g, "\\n");
        return `"${escapedInsideQuotes}"`;
      }).replace(/\n/g, "");
      return await this.schema.parseAsync(JSON.parse(escapedJson));
    } catch (e) {
      throw new OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
    }
  }
};

// node_modules/@langchain/core/dist/output_parsers/json.js
var JsonOutputParser = class extends BaseCumulativeTransformOutputParser {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "output_parsers"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
  }
  static lc_name() {
    return "JsonOutputParser";
  }
  _diff(prev, next) {
    if (!next) {
      return void 0;
    }
    if (!prev) {
      return [{ op: "replace", path: "", value: next }];
    }
    return compare(prev, next);
  }
  // This should actually return Partial<T>, but there's no way
  // to specify emitted chunks as instances separate from the main output type.
  async parsePartialResult(generations) {
    return parseJsonMarkdown(generations[0].text);
  }
  async parse(text) {
    return parseJsonMarkdown(text, JSON.parse);
  }
  getFormatInstructions() {
    return "";
  }
};

// node_modules/@langchain/ollama/dist/utils.js
function convertOllamaMessagesToLangChain(messages, extra) {
  var _a, _b;
  return new AIMessageChunk({
    content: (_a = messages.content) != null ? _a : "",
    tool_call_chunks: (_b = messages.tool_calls) == null ? void 0 : _b.map((tc) => ({
      name: tc.function.name,
      args: JSON.stringify(tc.function.arguments),
      type: "tool_call_chunk",
      index: 0,
      id: v4_default()
    })),
    response_metadata: extra == null ? void 0 : extra.responseMetadata,
    usage_metadata: extra == null ? void 0 : extra.usageMetadata
  });
}
function extractBase64FromDataUrl(dataUrl) {
  const match = dataUrl.match(/^data:.*?;base64,(.*)$/);
  return match ? match[1] : "";
}
function convertAMessagesToOllama(messages) {
  var _a, _b, _c;
  if (typeof messages.content === "string") {
    return [
      {
        role: "assistant",
        content: messages.content
      }
    ];
  }
  const textFields = messages.content.filter((c) => c.type === "text" && typeof c.text === "string");
  const textMessages = textFields.map((c) => ({
    role: "assistant",
    content: c.text
  }));
  let toolCallMsgs;
  if (messages.content.find((c) => c.type === "tool_use") && ((_a = messages.tool_calls) == null ? void 0 : _a.length)) {
    const toolCalls = (_b = messages.tool_calls) == null ? void 0 : _b.map((tc) => ({
      id: tc.id,
      type: "function",
      function: {
        name: tc.name,
        arguments: tc.args
      }
    }));
    if (toolCalls) {
      toolCallMsgs = {
        role: "assistant",
        tool_calls: toolCalls,
        content: ""
      };
    }
  } else if (messages.content.find((c) => c.type === "tool_use") && !((_c = messages.tool_calls) == null ? void 0 : _c.length)) {
    throw new Error("'tool_use' content type is not supported without tool calls.");
  }
  return [...textMessages, ...toolCallMsgs ? [toolCallMsgs] : []];
}
function convertHumanGenericMessagesToOllama(message) {
  if (typeof message.content === "string") {
    return [
      {
        role: "user",
        content: message.content
      }
    ];
  }
  return message.content.map((c) => {
    if (c.type === "text") {
      return {
        role: "user",
        content: c.text
      };
    } else if (c.type === "image_url") {
      if (typeof c.image_url === "string") {
        return {
          role: "user",
          content: "",
          images: [extractBase64FromDataUrl(c.image_url)]
        };
      } else if (c.image_url.url && typeof c.image_url.url === "string") {
        return {
          role: "user",
          content: "",
          images: [extractBase64FromDataUrl(c.image_url.url)]
        };
      }
    }
    throw new Error(`Unsupported content type: ${c.type}`);
  });
}
function convertSystemMessageToOllama(message) {
  if (typeof message.content === "string") {
    return [
      {
        role: "system",
        content: message.content
      }
    ];
  } else if (message.content.every((c) => c.type === "text" && typeof c.text === "string")) {
    return message.content.map((c) => ({
      role: "system",
      content: c.text
    }));
  } else {
    throw new Error(`Unsupported content type(s): ${message.content.map((c) => c.type).join(", ")}`);
  }
}
function convertToolMessageToOllama(message) {
  if (typeof message.content !== "string") {
    throw new Error("Non string tool message content is not supported");
  }
  return [
    {
      role: "tool",
      content: message.content
    }
  ];
}
function convertToOllamaMessages(messages) {
  return messages.flatMap((msg) => {
    if (["human", "generic"].includes(msg._getType())) {
      return convertHumanGenericMessagesToOllama(msg);
    } else if (msg._getType() === "ai") {
      return convertAMessagesToOllama(msg);
    } else if (msg._getType() === "system") {
      return convertSystemMessageToOllama(msg);
    } else if (msg._getType() === "tool") {
      return convertToolMessageToOllama(msg);
    } else {
      throw new Error(`Unsupported message type: ${msg._getType()}`);
    }
  });
}

// node_modules/@langchain/ollama/dist/chat_models.js
var ChatOllama = class extends BaseChatModel {
  // Used for tracing, replace with the same name as your class
  static lc_name() {
    return "ChatOllama";
  }
  constructor(fields) {
    var _a, _b, _c;
    super(fields != null ? fields : {});
    Object.defineProperty(this, "model", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "llama3"
    });
    Object.defineProperty(this, "numa", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "numCtx", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "numBatch", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "numGpu", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "mainGpu", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "lowVram", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "f16Kv", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "logitsAll", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "vocabOnly", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "useMmap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "useMlock", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "embeddingOnly", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "numThread", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "numKeep", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "seed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "numPredict", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "topK", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "topP", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tfsZ", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "typicalP", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "repeatLastN", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "temperature", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "repeatPenalty", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "presencePenalty", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "frequencyPenalty", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "mirostat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "mirostatTau", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "mirostatEta", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "penalizeNewline", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "streaming", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "format", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "keepAlive", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "checkOrPullModel", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "baseUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "http://127.0.0.1:11434"
    });
    this.client = new Ollama$1({
      host: fields == null ? void 0 : fields.baseUrl,
      headers: fields == null ? void 0 : fields.headers
    });
    this.baseUrl = (_a = fields == null ? void 0 : fields.baseUrl) != null ? _a : this.baseUrl;
    this.model = (_b = fields == null ? void 0 : fields.model) != null ? _b : this.model;
    this.numa = fields == null ? void 0 : fields.numa;
    this.numCtx = fields == null ? void 0 : fields.numCtx;
    this.numBatch = fields == null ? void 0 : fields.numBatch;
    this.numGpu = fields == null ? void 0 : fields.numGpu;
    this.mainGpu = fields == null ? void 0 : fields.mainGpu;
    this.lowVram = fields == null ? void 0 : fields.lowVram;
    this.f16Kv = fields == null ? void 0 : fields.f16Kv;
    this.logitsAll = fields == null ? void 0 : fields.logitsAll;
    this.vocabOnly = fields == null ? void 0 : fields.vocabOnly;
    this.useMmap = fields == null ? void 0 : fields.useMmap;
    this.useMlock = fields == null ? void 0 : fields.useMlock;
    this.embeddingOnly = fields == null ? void 0 : fields.embeddingOnly;
    this.numThread = fields == null ? void 0 : fields.numThread;
    this.numKeep = fields == null ? void 0 : fields.numKeep;
    this.seed = fields == null ? void 0 : fields.seed;
    this.numPredict = fields == null ? void 0 : fields.numPredict;
    this.topK = fields == null ? void 0 : fields.topK;
    this.topP = fields == null ? void 0 : fields.topP;
    this.tfsZ = fields == null ? void 0 : fields.tfsZ;
    this.typicalP = fields == null ? void 0 : fields.typicalP;
    this.repeatLastN = fields == null ? void 0 : fields.repeatLastN;
    this.temperature = fields == null ? void 0 : fields.temperature;
    this.repeatPenalty = fields == null ? void 0 : fields.repeatPenalty;
    this.presencePenalty = fields == null ? void 0 : fields.presencePenalty;
    this.frequencyPenalty = fields == null ? void 0 : fields.frequencyPenalty;
    this.mirostat = fields == null ? void 0 : fields.mirostat;
    this.mirostatTau = fields == null ? void 0 : fields.mirostatTau;
    this.mirostatEta = fields == null ? void 0 : fields.mirostatEta;
    this.penalizeNewline = fields == null ? void 0 : fields.penalizeNewline;
    this.streaming = fields == null ? void 0 : fields.streaming;
    this.format = fields == null ? void 0 : fields.format;
    this.keepAlive = fields == null ? void 0 : fields.keepAlive;
    this.checkOrPullModel = (_c = fields == null ? void 0 : fields.checkOrPullModel) != null ? _c : this.checkOrPullModel;
  }
  // Replace
  _llmType() {
    return "ollama";
  }
  /**
   * Download a model onto the local machine.
   *
   * @param {string} model The name of the model to download.
   * @param {PullModelOptions | undefined} options Options for pulling the model.
   * @returns {Promise<void>}
   */
  async pull(model, options) {
    const { stream, insecure, logProgress } = {
      stream: true,
      ...options
    };
    if (stream) {
      for await (const chunk of await this.client.pull({
        model,
        insecure,
        stream
      })) {
        if (logProgress) {
          console.log(chunk);
        }
      }
    } else {
      const response = await this.client.pull({ model, insecure });
      if (logProgress) {
        console.log(response);
      }
    }
  }
  bindTools(tools, kwargs) {
    return this.bind({
      tools: tools.map((tool) => convertToOpenAITool(tool)),
      ...kwargs
    });
  }
  getLsParams(options) {
    var _a, _b, _c, _d;
    const params = this.invocationParams(options);
    return {
      ls_provider: "ollama",
      ls_model_name: this.model,
      ls_model_type: "chat",
      ls_temperature: (_b = (_a = params.options) == null ? void 0 : _a.temperature) != null ? _b : void 0,
      ls_max_tokens: (_d = (_c = params.options) == null ? void 0 : _c.num_predict) != null ? _d : void 0,
      ls_stop: options.stop
    };
  }
  invocationParams(options) {
    var _a, _b;
    if (options == null ? void 0 : options.tool_choice) {
      throw new Error("Tool choice is not supported for ChatOllama.");
    }
    return {
      model: this.model,
      format: (_a = options == null ? void 0 : options.format) != null ? _a : this.format,
      keep_alive: this.keepAlive,
      options: {
        numa: this.numa,
        num_ctx: this.numCtx,
        num_batch: this.numBatch,
        num_gpu: this.numGpu,
        main_gpu: this.mainGpu,
        low_vram: this.lowVram,
        f16_kv: this.f16Kv,
        logits_all: this.logitsAll,
        vocab_only: this.vocabOnly,
        use_mmap: this.useMmap,
        use_mlock: this.useMlock,
        embedding_only: this.embeddingOnly,
        num_thread: this.numThread,
        num_keep: this.numKeep,
        seed: this.seed,
        num_predict: this.numPredict,
        top_k: this.topK,
        top_p: this.topP,
        tfs_z: this.tfsZ,
        typical_p: this.typicalP,
        repeat_last_n: this.repeatLastN,
        temperature: this.temperature,
        repeat_penalty: this.repeatPenalty,
        presence_penalty: this.presencePenalty,
        frequency_penalty: this.frequencyPenalty,
        mirostat: this.mirostat,
        mirostat_tau: this.mirostatTau,
        mirostat_eta: this.mirostatEta,
        penalize_newline: this.penalizeNewline,
        stop: options == null ? void 0 : options.stop
      },
      tools: ((_b = options == null ? void 0 : options.tools) == null ? void 0 : _b.length) ? options.tools.map((tool) => convertToOpenAITool(tool)) : void 0
    };
  }
  /**
   * Check if a model exists on the local machine.
   *
   * @param {string} model The name of the model to check.
   * @returns {Promise<boolean>} Whether or not the model exists.
   */
  async checkModelExistsOnMachine(model) {
    const { models } = await this.client.list();
    return !!models.find((m) => m.name === model || m.name === `${model}:latest`);
  }
  async _generate(messages, options, runManager) {
    var _a;
    if (this.checkOrPullModel) {
      if (!await this.checkModelExistsOnMachine(this.model)) {
        await this.pull(this.model, {
          logProgress: true
        });
      }
    }
    let finalChunk;
    for await (const chunk of this._streamResponseChunks(messages, options, runManager)) {
      if (!finalChunk) {
        finalChunk = chunk.message;
      } else {
        finalChunk = concat(finalChunk, chunk.message);
      }
    }
    const nonChunkMessage = new AIMessage({
      id: finalChunk == null ? void 0 : finalChunk.id,
      content: (_a = finalChunk == null ? void 0 : finalChunk.content) != null ? _a : "",
      tool_calls: finalChunk == null ? void 0 : finalChunk.tool_calls,
      response_metadata: finalChunk == null ? void 0 : finalChunk.response_metadata,
      usage_metadata: finalChunk == null ? void 0 : finalChunk.usage_metadata
    });
    return {
      generations: [
        {
          text: typeof nonChunkMessage.content === "string" ? nonChunkMessage.content : "",
          message: nonChunkMessage
        }
      ]
    };
  }
  /**
   * Implement to support streaming.
   * Should yield chunks iteratively.
   */
  async *_streamResponseChunks(messages, options, runManager) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (this.checkOrPullModel) {
      if (!await this.checkModelExistsOnMachine(this.model)) {
        await this.pull(this.model, {
          logProgress: true
        });
      }
    }
    const params = this.invocationParams(options);
    const ollamaMessages = convertToOllamaMessages(messages);
    const usageMetadata = {
      input_tokens: 0,
      output_tokens: 0,
      total_tokens: 0
    };
    if (params.tools && params.tools.length > 0) {
      const toolResult = await this.client.chat({
        ...params,
        messages: ollamaMessages,
        stream: false
        // Ollama currently does not support streaming with tools
      });
      const { message: responseMessage, ...rest } = toolResult;
      usageMetadata.input_tokens += (_a = rest.prompt_eval_count) != null ? _a : 0;
      usageMetadata.output_tokens += (_b = rest.eval_count) != null ? _b : 0;
      usageMetadata.total_tokens = usageMetadata.input_tokens + usageMetadata.output_tokens;
      yield new ChatGenerationChunk({
        text: responseMessage.content,
        message: convertOllamaMessagesToLangChain(responseMessage, {
          responseMetadata: rest,
          usageMetadata
        })
      });
      return runManager == null ? void 0 : runManager.handleLLMNewToken(responseMessage.content);
    }
    const stream = await this.client.chat({
      ...params,
      messages: ollamaMessages,
      stream: true
    });
    let lastMetadata;
    for await (const chunk of stream) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        this.client.abort();
      }
      const { message: responseMessage, ...rest } = chunk;
      usageMetadata.input_tokens += (_d = rest.prompt_eval_count) != null ? _d : 0;
      usageMetadata.output_tokens += (_e = rest.eval_count) != null ? _e : 0;
      usageMetadata.total_tokens = usageMetadata.input_tokens + usageMetadata.output_tokens;
      lastMetadata = rest;
      yield new ChatGenerationChunk({
        text: (_f = responseMessage.content) != null ? _f : "",
        message: convertOllamaMessagesToLangChain(responseMessage)
      });
      await (runManager == null ? void 0 : runManager.handleLLMNewToken((_g = responseMessage.content) != null ? _g : ""));
    }
    yield new ChatGenerationChunk({
      text: "",
      message: new AIMessageChunk({
        content: "",
        response_metadata: lastMetadata,
        usage_metadata: usageMetadata
      })
    });
  }
  withStructuredOutput(outputSchema, config) {
    if ((config == null ? void 0 : config.method) === void 0 || (config == null ? void 0 : config.method) === "jsonSchema") {
      const outputSchemaIsZod = isZodSchema(outputSchema);
      const jsonSchema = outputSchemaIsZod ? zodToJsonSchema(outputSchema) : outputSchema;
      const llm = this.bind({
        format: jsonSchema
      });
      const outputParser = outputSchemaIsZod ? StructuredOutputParser.fromZodSchema(outputSchema) : new JsonOutputParser();
      if (!(config == null ? void 0 : config.includeRaw)) {
        return llm.pipe(outputParser);
      }
      const parserAssign = RunnablePassthrough.assign({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parsed: (input, config2) => outputParser.invoke(input.raw, config2)
      });
      const parserNone = RunnablePassthrough.assign({
        parsed: () => null
      });
      const parsedWithFallback = parserAssign.withFallbacks({
        fallbacks: [parserNone]
      });
      return RunnableSequence.from([
        {
          raw: llm
        },
        parsedWithFallback
      ]);
    } else {
      return super.withStructuredOutput(outputSchema, config);
    }
  }
};

// src/lib/langchain.ts
var SYSTEM_PROMPT_TEMPLATE = "You are a call-and-response assistant. Keep replies clear, concise. Your response must be within {{TOKEN_LIMIT}} tokens.";
var DEFAULT_MODEL = "gemma3";
var DEFAULT_TEMPERATURE = 0.7;
var DEFAULT_MAX_RETRIES = 5;
async function callOllama(inputText, options = {}) {
  const {
    prompt,
    model = DEFAULT_MODEL,
    temperature = DEFAULT_TEMPERATURE,
    maxRetries = DEFAULT_MAX_RETRIES
  } = options;
  const tokenEstimate = estimateSmartTokenLimit(inputText);
  const chat = new ChatOllama({
    model,
    temperature,
    maxRetries,
    numPredict: tokenEstimate
  });
  const systemPrompt = SYSTEM_PROMPT_TEMPLATE.replace(
    "{{TOKEN_LIMIT}}",
    tokenEstimate.toString()
  );
  const fullSystemPrompt = [systemPrompt, prompt].filter(Boolean).join("\n\n");
  const messages = [
    new SystemMessage(fullSystemPrompt),
    new HumanMessage(inputText)
  ];
  return chat.invoke(messages);
}
function estimateSmartTokenLimit(inputText) {
  const wordCount = inputText.trim().split(/\s+/).length;
  let estimatedTokens = 0;
  if (wordCount < 100) {
    estimatedTokens = 128;
  } else if (wordCount < 500) {
    estimatedTokens = Math.ceil(wordCount * 1.5) + 200;
  } else if (wordCount < 1500) {
    estimatedTokens = Math.ceil(wordCount * 1.3) + 300;
  } else {
    estimatedTokens = 2048;
  }
  const MIN_TOKENS = 128;
  const MAX_TOKENS = 2048;
  return Math.min(Math.max(estimatedTokens, MIN_TOKENS), MAX_TOKENS);
}

// src/daily-note-synth/format-note.ts
var INSTRUCTIONS = `
You are an expert note organizer and formatter for Obsidian.

Your job:
- Analyze the raw input note and intelligently organize it into well-structured sections.
- Classify content into the appropriate Obsidian callout type based on meaning, using the following map:
note (blue)
abstract, summary, tldr (green)
info (blue)
todo (blue)
tip, hint, important (sky blue)
success, check, done (green)
question, help, faq (yellow)
warning, caution, attention (orange)
failure, fail, missing (red)
danger, error (red)
bug (red)
example (purple)
quote, cite (grey)
`;
var FORMATTING_RULES = `
**Output format:**
- Start with a **title** at the top (e.g., "# \u{1F4DD} Daily Note: May 7, 2025")
- Add a **Summary section** (abstract) in its own callout:
    - The **callout header** must be: \`> [!abstract] Summary\`
    - **After the callout header, insert ONE blank line.**
    - Then write a plain paragraph (2\u20135 sentences) with NO blockquotes.
    - This blank line ensures the paragraph is OUTSIDE the callout box but under the header.

    - Use a **neutral, objective tone** (no personal pronouns like "I", "we").
    - Clearly distinguish between:
      - \u2705 Events that actually happened
      - \u{1F4DD} Planned tasks (pending)
      - \u{1F50D} Research/questions (topics of interest)
    - DO NOT misrepresent planned tasks as completed.
    - DO NOT use bulletpoints in the summary.

- After the summary section, add a **line for tags**, like:  
  \`tags: #discord #hypercore #scuttlebutt #workplace\`
    - Tags must be **dynamically generated from the content.**
    - Avoid generic/filler tags like \`#daily\` unless directly relevant.
    - Tags should be **unique to the content, lowercase, prefixed by \`#\`.**
    - NO hardcoded or default tags.

- Then create sections for todos, questions, notes, and other relevant categories:
    - Each section must be in **ONE callout.**
    - Use bulletpoints for lists inside the callouts.
`;
var IMPORTANT_NOTES = `
---

**IMPORTANT:**
- DO NOT answer any questions.
- The **summary must be a paragraph with NO blockquotes** (even though it\u2019s inside the callout structure).
- Insert ONE blank line after the callout header.
- Tags must be **dynamically generated** based on the content.
- Ensure ALL sections use **Obsidian callout formatting.**
`;
var EXAMPLES = [
  `**Example 1: Developer Work Log**

# \u{1F4DD} Daily Note: May 10, 2025

> [!abstract] Summary

Today's focus was on resolving a persistent API authentication bug and planning UI improvements for the dashboard module. Pending tasks include refactoring the login component and writing unit tests for new API handlers. Research is ongoing regarding OAuth 2.0 best practices.

tags: #api #authentication #dashboard #oauth #frontend

> [!todo] Todo
> - Refactor login component
> - Write unit tests for API handlers
> - Prepare UI mockups for the new dashboard

> [!question] Questions
> - What are the best practices for implementing OAuth 2.0 in SPAs?
> - How can we optimize error handling for failed authentication?

> [!bug] Bugs
> - API returned 401 error despite valid token
> - Dashboard loading spinner not disappearing after fetch

> [!note] Reflection
> - Progress was slower than expected due to multiple debugging sessions.
`,
  `**Example 2: Personal Productivity Log**

# \u{1F4DD} Daily Note: May 11, 2025

> [!abstract] Summary

The day centered on personal organization, including decluttering my workspace and scheduling upcoming appointments. Planned tasks include updating my calendar and finalizing the grocery shopping list. Additional notes focus on researching minimalism techniques.

tags: #organization #minimalism #calendar #groceries #workspace

> [!todo] Todo
> - Update calendar with medical and work appointments
> - Finalize grocery shopping list
> - Sort digital files on laptop

> [!tip] Tips
> - Break down decluttering tasks into 15-minute sessions.
> - Use a single inbox system for both digital and physical paperwork.

> [!question] Questions
> - What are effective minimalism strategies for small living spaces?
> - Best apps for task and calendar integration?

> [!note] Reflection
> - Decluttering my workspace noticeably boosted my focus today.
`,
  `**Example 3: Research + Learning Note**

# \u{1F4DD} Daily Note: May 12, 2025

> [!abstract] Summary

Today\u2019s study session explored distributed ledger technologies, with a focus on comparing blockchain and DAG architectures. Upcoming tasks include reviewing the IOTA whitepaper and summarizing key differences. Open questions target security models and scalability concerns.

tags: #blockchain #dag #iota #distributed-systems #scalability

> [!todo] Todo
> - Review the IOTA whitepaper
> - Draft a summary comparing blockchain vs DAG
> - Explore real-world applications of DAGs

> [!question] Questions
> - How do DAGs improve scalability over traditional blockchains?
> - What are the security trade-offs between blockchain and DAG?

> [!example] References
> - IOTA Whitepaper: https://www.iota.org/research/whitepaper
> - Article: "DAG vs Blockchain" on Medium

> [!note] Reflection
> - DAGs seem promising for IoT use cases but raise new security challenges.
`
];
var SYSTEM_PROMPT_ORGANIZER = `
${INSTRUCTIONS}

${FORMATTING_RULES}

${IMPORTANT_NOTES}

---

${EXAMPLES.join("\n\n---\n\n")}

---

Return clean Obsidian markdown only.
`;

// src/daily-note-synth/synthesize-daily-note.ts
async function synthesizeDailyNote(content) {
  new import_obsidian.Notice("Synthesizing daily note...");
  const systemPrompt = SYSTEM_PROMPT_ORGANIZER;
  const response = await callOllama(content, {
    prompt: systemPrompt
  });
  if (!response.text) {
    console.error("Error in synthesis: No text returned");
    new import_obsidian.Notice("Synthesis failed!");
    return content;
  }
  return response.text;
}

// src/daily-note-synth/run-daily-note-synth.ts
async function runDailyNoteSynthesis(app) {
  const dailyNotes = getNotesFromFolder(app, "Daily Notes");
  if (dailyNotes.length === 0) {
    console.log(`No daily notes found in Daily Notes folder.`);
    return;
  }
  const today = new Date().toLocaleDateString("sv");
  const pastDailyNotes = dailyNotes.filter((file) => file.name !== `${today}.md`);
  const synthDir = "synthesized-notes";
  if (!app.vault.getAbstractFileByPath(synthDir)) {
    await app.vault.createFolder(synthDir);
  }
  pastDailyNotes.forEach((file) => {
    app.vault.read(file).then(async (content) => {
      const processedContent = await synthesizeDailyNote(content);
      const newFileName = `${synthDir}/${file.name.replace(".md", "")}-synthesized.md`;
      const newFile = app.vault.getAbstractFileByPath(newFileName);
      if (newFile) {
        console.log(`File ${newFileName} already exists. Skipping.`);
        return;
      }
      await app.vault.create(newFileName, processedContent);
      new import_obsidian2.Notice(`Synthesized daily note created: ${newFileName}`);
    });
  });
}

// src/main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var MyPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.app.workspace.onLayoutReady(() => {
    });
    this.addCommand({
      id: "run-daily-note-synthesis",
      name: "Run Daily Note Synthesis",
      callback: () => {
        runDailyNoteSynthesis(this.app);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

@langchain/core/dist/utils/fast-json-patch/src/helpers.js:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   *)

@langchain/core/dist/utils/fast-json-patch/src/duplex.js:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2013-2021 Joachim Wester
   * MIT license
   *)

@langchain/core/dist/utils/js-sha1/hash.js:
  (*
   * [js-sha1]{@link https://github.com/emn178/js-sha1}
   *
   * @version 0.6.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2RlY2FtZWxpemUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2NhbWVsY2FzZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvcmV0cnkvbGliL3JldHJ5X29wZXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvcmV0cnkvbGliL3JldHJ5LmpzIiwgIm5vZGVfbW9kdWxlcy9yZXRyeS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvcC1yZXRyeS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvcC1maW5hbGx5L2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9wLXRpbWVvdXQvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3AtcXVldWUvZGlzdC9sb3dlci1ib3VuZC5qcyIsICJub2RlX21vZHVsZXMvcC1xdWV1ZS9kaXN0L3ByaW9yaXR5LXF1ZXVlLmpzIiwgIm5vZGVfbW9kdWxlcy9wLXF1ZXVlL2Rpc3QvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9kZWJ1Zy5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvcGFyc2Utb3B0aW9ucy5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2lkZW50aWZpZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGFyc2UuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvdmFsaWQuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvaW5jLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2RpZmYuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWlub3IuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcGF0Y2guanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcHJlcmVsZWFzZS5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1idWlsZC5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jzb3J0LmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0LmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2VxLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL25lcS5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndGUuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NtcC5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb2VyY2UuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9scnVjYWNoZS5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2NsYXNzZXMvcmFuZ2UuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3RvLWNvbXBhcmF0b3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi12ZXJzaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCAibm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvZ3RyLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2x0ci5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3NpbXBsaWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3N1YnNldC5qcyIsICJub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9hbnNpLXN0eWxlcy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwgInNyYy9tYWluLnRzIiwgInNyYy9kYWlseS1ub3RlLXN5bnRoL3J1bi1kYWlseS1ub3RlLXN5bnRoLnRzIiwgInNyYy9kYWlseS1ub3RlLXN5bnRoL3V0aWxzLnRzIiwgInNyYy9kYWlseS1ub3RlLXN5bnRoL3N5bnRoZXNpemUtZGFpbHktbm90ZS50cyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvanNvbi5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9tYXBfa2V5cy5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbG9hZC9zZXJpYWxpemFibGUuanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2NvbnRlbnRfYmxvY2tzLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9iYXNlLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy90b29sLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9haS5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvY2hhdC5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbWVzc2FnZXMvZnVuY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL2h1bWFuLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9zeXN0ZW0uanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2Vycm9ycy9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdG9vbHMvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L21lc3NhZ2VzL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QvbGliL2luZGV4Lm1qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2Jhc2UuanMiLCAibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcyIsICJub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmF0aXZlLmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCAibm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5qcyIsICJub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcyIsICJub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCAibm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL191dWlkLmpzIiwgIm5vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy93YXJuLmpzIiwgIm5vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9wcm9tcHRzLmpzIiwgIm5vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9lcnJvci5qcyIsICJub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwgIm5vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9lbnYuanMiLCAibm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3NpbmdsZXRvbnMvY29uc3RhbnRzLmpzIiwgIm5vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9ydW5fdHJlZXMuanMiLCAibm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mYXN0LWpzb24tcGF0Y2gvc3JjL2NvcmUuanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Zhc3QtanNvbi1wYXRjaC9zcmMvaGVscGVycy5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9kdXBsZXguanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Zhc3QtanNvbi1wYXRjaC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZW52LmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9jYWxsYmFja3MvYmFzZS5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9iYXNlLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL2NvbnNvbGUuanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3NpbmdsZXRvbnMvdHJhY2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL3RyYWNlcl9sYW5nY2hhaW4uanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3NpbmdsZXRvbnMvY2FsbGJhY2tzLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9zaW5nbGV0b25zL2FzeW5jX2xvY2FsX3N0b3JhZ2UvZ2xvYmFscy5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvY2FsbGJhY2tzLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9zaW5nbGV0b25zL2FzeW5jX2xvY2FsX3N0b3JhZ2UvY29udGV4dC5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvY2FsbGJhY2tzL21hbmFnZXIuanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3NpbmdsZXRvbnMvYXN5bmNfbG9jYWxfc3RvcmFnZS9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2NvbmZpZy5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvc2lnbmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9zdHJlYW0uanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3RyYWNlcnMvbG9nX3N0cmVhbS5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0cy5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9ldmVudF9zdHJlYW0uanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9yb290X2xpc3RlbmVyLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvdXRpbHMuanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9PcHRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vUmVmcy5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL2Vycm9yTWVzc2FnZXMuanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2FueS5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvYXJyYXkuanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2JpZ2ludC5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvYm9vbGVhbi5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvYnJhbmRlZC5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvY2F0Y2guanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2RhdGUuanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2RlZmF1bHQuanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2VmZmVjdHMuanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2VudW0uanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2ludGVyc2VjdGlvbi5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvbGl0ZXJhbC5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvc3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9yZWNvcmQuanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL21hcC5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvbmF0aXZlRW51bS5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvbmV2ZXIuanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL251bGwuanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3VuaW9uLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9udWxsYWJsZS5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvbnVtYmVyLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9vYmplY3QuanMiLCAibm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL29wdGlvbmFsLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9waXBlbGluZS5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvcHJvbWlzZS5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvc2V0LmpzIiwgIm5vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy90dXBsZS5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvdW5kZWZpbmVkLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy91bmtub3duLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9yZWFkb25seS5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3NlbGVjdFBhcnNlci5qcyIsICJub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlRGVmLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vem9kVG9Kc29uU2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvZ3JhcGhfbWVybWFpZC5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2dyYXBoLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvd3JhcHBlcnMuanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9pdGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9qcy1zaGExL2hhc2guanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2NhY2hlcy9iYXNlLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9wcm9tcHRfdmFsdWVzLmpzIiwgIm5vZGVfbW9kdWxlcy9qcy10aWt0b2tlbi9kaXN0L2NodW5rLVpETkxCRVJGLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy90aWt0b2tlbi5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2Jhc2UuanMiLCAibm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy9wYXNzdGhyb3VnaC5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvdHlwZXMvaXNfem9kX3NjaGVtYS5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2NoYXRfbW9kZWxzLmpzIiwgIm5vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCAibm9kZV9tb2R1bGVzL29sbGFtYS9kaXN0L2Jyb3dzZXIubWpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90b29scy90eXBlcy5qcyIsICJub2RlX21vZHVsZXMvQGNmd29ya2VyL2pzb24tc2NoZW1hL2Rpc3QvZXNtL2RlZXAtY29tcGFyZS1zdHJpY3QuanMiLCAibm9kZV9tb2R1bGVzL0BjZndvcmtlci9qc29uLXNjaGVtYS9kaXN0L2VzbS9kZXJlZmVyZW5jZS5qcyIsICJub2RlX21vZHVsZXMvQGNmd29ya2VyL2pzb24tc2NoZW1hL2Rpc3QvZXNtL2Zvcm1hdC5qcyIsICJub2RlX21vZHVsZXMvQGNmd29ya2VyL2pzb24tc2NoZW1hL2Rpc3QvZXNtL3R5cGVzLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9qc29uX3NjaGVtYS5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZnVuY3Rpb25fY2FsbGluZy5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvYmFzZS5qcyIsICJub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3Qvb3V0cHV0X3BhcnNlcnMvdHJhbnNmb3JtLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy9zdHJ1Y3R1cmVkLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRfcGFyc2Vycy9qc29uLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL29sbGFtYS9kaXN0L3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL29sbGFtYS9kaXN0L2NoYXRfbW9kZWxzLmpzIiwgInNyYy9saWIvbGFuZ2NoYWluLnRzIiwgInNyYy9kYWlseS1ub3RlLXN5bnRoL2Zvcm1hdC1ub3RlLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIHNlcCkge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuXHR9XG5cblx0c2VwID0gdHlwZW9mIHNlcCA9PT0gJ3VuZGVmaW5lZCcgPyAnXycgOiBzZXA7XG5cblx0cmV0dXJuIHN0clxuXHRcdC5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKS9nLCAnJDEnICsgc2VwICsgJyQyJylcblx0XHQucmVwbGFjZSgvKFtBLVpdKykoW0EtWl1bYS16XFxkXSspL2csICckMScgKyBzZXAgKyAnJDInKVxuXHRcdC50b0xvd2VyQ2FzZSgpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFVQUEVSQ0FTRSA9IC9bXFxwe0x1fV0vdTtcbmNvbnN0IExPV0VSQ0FTRSA9IC9bXFxwe0xsfV0vdTtcbmNvbnN0IExFQURJTkdfQ0FQSVRBTCA9IC9eW1xccHtMdX1dKD8hW1xccHtMdX1dKS9ndTtcbmNvbnN0IElERU5USUZJRVIgPSAvKFtcXHB7QWxwaGF9XFxwe059X118JCkvdTtcbmNvbnN0IFNFUEFSQVRPUlMgPSAvW18uXFwtIF0rLztcblxuY29uc3QgTEVBRElOR19TRVBBUkFUT1JTID0gbmV3IFJlZ0V4cCgnXicgKyBTRVBBUkFUT1JTLnNvdXJjZSk7XG5jb25zdCBTRVBBUkFUT1JTX0FORF9JREVOVElGSUVSID0gbmV3IFJlZ0V4cChTRVBBUkFUT1JTLnNvdXJjZSArIElERU5USUZJRVIuc291cmNlLCAnZ3UnKTtcbmNvbnN0IE5VTUJFUlNfQU5EX0lERU5USUZJRVIgPSBuZXcgUmVnRXhwKCdcXFxcZCsnICsgSURFTlRJRklFUi5zb3VyY2UsICdndScpO1xuXG5jb25zdCBwcmVzZXJ2ZUNhbWVsQ2FzZSA9IChzdHJpbmcsIHRvTG93ZXJDYXNlLCB0b1VwcGVyQ2FzZSkgPT4ge1xuXHRsZXQgaXNMYXN0Q2hhckxvd2VyID0gZmFsc2U7XG5cdGxldCBpc0xhc3RDaGFyVXBwZXIgPSBmYWxzZTtcblx0bGV0IGlzTGFzdExhc3RDaGFyVXBwZXIgPSBmYWxzZTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGNoYXJhY3RlciA9IHN0cmluZ1tpXTtcblxuXHRcdGlmIChpc0xhc3RDaGFyTG93ZXIgJiYgVVBQRVJDQVNFLnRlc3QoY2hhcmFjdGVyKSkge1xuXHRcdFx0c3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIGkpICsgJy0nICsgc3RyaW5nLnNsaWNlKGkpO1xuXHRcdFx0aXNMYXN0Q2hhckxvd2VyID0gZmFsc2U7XG5cdFx0XHRpc0xhc3RMYXN0Q2hhclVwcGVyID0gaXNMYXN0Q2hhclVwcGVyO1xuXHRcdFx0aXNMYXN0Q2hhclVwcGVyID0gdHJ1ZTtcblx0XHRcdGkrKztcblx0XHR9IGVsc2UgaWYgKGlzTGFzdENoYXJVcHBlciAmJiBpc0xhc3RMYXN0Q2hhclVwcGVyICYmIExPV0VSQ0FTRS50ZXN0KGNoYXJhY3RlcikpIHtcblx0XHRcdHN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBpIC0gMSkgKyAnLScgKyBzdHJpbmcuc2xpY2UoaSAtIDEpO1xuXHRcdFx0aXNMYXN0TGFzdENoYXJVcHBlciA9IGlzTGFzdENoYXJVcHBlcjtcblx0XHRcdGlzTGFzdENoYXJVcHBlciA9IGZhbHNlO1xuXHRcdFx0aXNMYXN0Q2hhckxvd2VyID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXNMYXN0Q2hhckxvd2VyID0gdG9Mb3dlckNhc2UoY2hhcmFjdGVyKSA9PT0gY2hhcmFjdGVyICYmIHRvVXBwZXJDYXNlKGNoYXJhY3RlcikgIT09IGNoYXJhY3Rlcjtcblx0XHRcdGlzTGFzdExhc3RDaGFyVXBwZXIgPSBpc0xhc3RDaGFyVXBwZXI7XG5cdFx0XHRpc0xhc3RDaGFyVXBwZXIgPSB0b1VwcGVyQ2FzZShjaGFyYWN0ZXIpID09PSBjaGFyYWN0ZXIgJiYgdG9Mb3dlckNhc2UoY2hhcmFjdGVyKSAhPT0gY2hhcmFjdGVyO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHJpbmc7XG59O1xuXG5jb25zdCBwcmVzZXJ2ZUNvbnNlY3V0aXZlVXBwZXJjYXNlID0gKGlucHV0LCB0b0xvd2VyQ2FzZSkgPT4ge1xuXHRMRUFESU5HX0NBUElUQUwubGFzdEluZGV4ID0gMDtcblxuXHRyZXR1cm4gaW5wdXQucmVwbGFjZShMRUFESU5HX0NBUElUQUwsIG0xID0+IHRvTG93ZXJDYXNlKG0xKSk7XG59O1xuXG5jb25zdCBwb3N0UHJvY2VzcyA9IChpbnB1dCwgdG9VcHBlckNhc2UpID0+IHtcblx0U0VQQVJBVE9SU19BTkRfSURFTlRJRklFUi5sYXN0SW5kZXggPSAwO1xuXHROVU1CRVJTX0FORF9JREVOVElGSUVSLmxhc3RJbmRleCA9IDA7XG5cblx0cmV0dXJuIGlucHV0LnJlcGxhY2UoU0VQQVJBVE9SU19BTkRfSURFTlRJRklFUiwgKF8sIGlkZW50aWZpZXIpID0+IHRvVXBwZXJDYXNlKGlkZW50aWZpZXIpKVxuXHRcdC5yZXBsYWNlKE5VTUJFUlNfQU5EX0lERU5USUZJRVIsIG0gPT4gdG9VcHBlckNhc2UobSkpO1xufTtcblxuY29uc3QgY2FtZWxDYXNlID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG5cdGlmICghKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShpbnB1dCkpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIGlucHV0IHRvIGJlIGBzdHJpbmcgfCBzdHJpbmdbXWAnKTtcblx0fVxuXG5cdG9wdGlvbnMgPSB7XG5cdFx0cGFzY2FsQ2FzZTogZmFsc2UsXG5cdFx0cHJlc2VydmVDb25zZWN1dGl2ZVVwcGVyY2FzZTogZmFsc2UsXG5cdFx0Li4ub3B0aW9uc1xuXHR9O1xuXG5cdGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuXHRcdGlucHV0ID0gaW5wdXQubWFwKHggPT4geC50cmltKCkpXG5cdFx0XHQuZmlsdGVyKHggPT4geC5sZW5ndGgpXG5cdFx0XHQuam9pbignLScpO1xuXHR9IGVsc2Uge1xuXHRcdGlucHV0ID0gaW5wdXQudHJpbSgpO1xuXHR9XG5cblx0aWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdGNvbnN0IHRvTG93ZXJDYXNlID0gb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlID9cblx0XHRzdHJpbmcgPT4gc3RyaW5nLnRvTG93ZXJDYXNlKCkgOlxuXHRcdHN0cmluZyA9PiBzdHJpbmcudG9Mb2NhbGVMb3dlckNhc2Uob3B0aW9ucy5sb2NhbGUpO1xuXHRjb25zdCB0b1VwcGVyQ2FzZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/XG5cdFx0c3RyaW5nID0+IHN0cmluZy50b1VwcGVyQ2FzZSgpIDpcblx0XHRzdHJpbmcgPT4gc3RyaW5nLnRvTG9jYWxlVXBwZXJDYXNlKG9wdGlvbnMubG9jYWxlKTtcblxuXHRpZiAoaW5wdXQubGVuZ3RoID09PSAxKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMucGFzY2FsQ2FzZSA/IHRvVXBwZXJDYXNlKGlucHV0KSA6IHRvTG93ZXJDYXNlKGlucHV0KTtcblx0fVxuXG5cdGNvbnN0IGhhc1VwcGVyQ2FzZSA9IGlucHV0ICE9PSB0b0xvd2VyQ2FzZShpbnB1dCk7XG5cblx0aWYgKGhhc1VwcGVyQ2FzZSkge1xuXHRcdGlucHV0ID0gcHJlc2VydmVDYW1lbENhc2UoaW5wdXQsIHRvTG93ZXJDYXNlLCB0b1VwcGVyQ2FzZSk7XG5cdH1cblxuXHRpbnB1dCA9IGlucHV0LnJlcGxhY2UoTEVBRElOR19TRVBBUkFUT1JTLCAnJyk7XG5cblx0aWYgKG9wdGlvbnMucHJlc2VydmVDb25zZWN1dGl2ZVVwcGVyY2FzZSkge1xuXHRcdGlucHV0ID0gcHJlc2VydmVDb25zZWN1dGl2ZVVwcGVyY2FzZShpbnB1dCwgdG9Mb3dlckNhc2UpO1xuXHR9IGVsc2Uge1xuXHRcdGlucHV0ID0gdG9Mb3dlckNhc2UoaW5wdXQpO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMucGFzY2FsQ2FzZSkge1xuXHRcdGlucHV0ID0gdG9VcHBlckNhc2UoaW5wdXQuY2hhckF0KDApKSArIGlucHV0LnNsaWNlKDEpO1xuXHR9XG5cblx0cmV0dXJuIHBvc3RQcm9jZXNzKGlucHV0LCB0b1VwcGVyQ2FzZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsQ2FzZTtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gY2FtZWxDYXNlO1xuIiwgImZ1bmN0aW9uIFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCBvcHRpb25zKSB7XG4gIC8vIENvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgKHRpbWVvdXRzLCByZXRyeUZvcmV2ZXIpIHNpZ25hdHVyZVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMgPSB7IGZvcmV2ZXI6IG9wdGlvbnMgfTtcbiAgfVxuXG4gIHRoaXMuX29yaWdpbmFsVGltZW91dHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRpbWVvdXRzKSk7XG4gIHRoaXMuX3RpbWVvdXRzID0gdGltZW91dHM7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9tYXhSZXRyeVRpbWUgPSBvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cnlUaW1lIHx8IEluZmluaXR5O1xuICB0aGlzLl9mbiA9IG51bGw7XG4gIHRoaXMuX2Vycm9ycyA9IFtdO1xuICB0aGlzLl9hdHRlbXB0cyA9IDE7XG4gIHRoaXMuX29wZXJhdGlvblRpbWVvdXQgPSBudWxsO1xuICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IgPSBudWxsO1xuICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgdGhpcy5fb3BlcmF0aW9uU3RhcnQgPSBudWxsO1xuICB0aGlzLl90aW1lciA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZm9yZXZlcikge1xuICAgIHRoaXMuX2NhY2hlZFRpbWVvdXRzID0gdGhpcy5fdGltZW91dHMuc2xpY2UoMCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmV0cnlPcGVyYXRpb247XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9hdHRlbXB0cyA9IDE7XG4gIHRoaXMuX3RpbWVvdXRzID0gdGhpcy5fb3JpZ2luYWxUaW1lb3V0cy5zbGljZSgwKTtcbn1cblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3RpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gIH1cbiAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgfVxuXG4gIHRoaXMuX3RpbWVvdXRzICAgICAgID0gW107XG4gIHRoaXMuX2NhY2hlZFRpbWVvdXRzID0gbnVsbDtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgfVxuXG4gIGlmICghZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBpZiAoZXJyICYmIGN1cnJlbnRUaW1lIC0gdGhpcy5fb3BlcmF0aW9uU3RhcnQgPj0gdGhpcy5fbWF4UmV0cnlUaW1lKSB7XG4gICAgdGhpcy5fZXJyb3JzLnB1c2goZXJyKTtcbiAgICB0aGlzLl9lcnJvcnMudW5zaGlmdChuZXcgRXJyb3IoJ1JldHJ5T3BlcmF0aW9uIHRpbWVvdXQgb2NjdXJyZWQnKSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhpcy5fZXJyb3JzLnB1c2goZXJyKTtcblxuICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRzLnNoaWZ0KCk7XG4gIGlmICh0aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkVGltZW91dHMpIHtcbiAgICAgIC8vIHJldHJ5IGZvcmV2ZXIsIG9ubHkga2VlcCBsYXN0IGVycm9yXG4gICAgICB0aGlzLl9lcnJvcnMuc3BsaWNlKDAsIHRoaXMuX2Vycm9ycy5sZW5ndGggLSAxKTtcbiAgICAgIHRpbWVvdXQgPSB0aGlzLl9jYWNoZWRUaW1lb3V0cy5zbGljZSgtMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9hdHRlbXB0cysrO1xuXG4gICAgaWYgKHNlbGYuX29wZXJhdGlvblRpbWVvdXRDYikge1xuICAgICAgc2VsZi5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX29wZXJhdGlvblRpbWVvdXRDYihzZWxmLl9hdHRlbXB0cyk7XG4gICAgICB9LCBzZWxmLl9vcGVyYXRpb25UaW1lb3V0KTtcblxuICAgICAgaWYgKHNlbGYuX29wdGlvbnMudW5yZWYpIHtcbiAgICAgICAgICBzZWxmLl90aW1lb3V0LnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5fZm4oc2VsZi5fYXR0ZW1wdHMpO1xuICB9LCB0aW1lb3V0KTtcblxuICBpZiAodGhpcy5fb3B0aW9ucy51bnJlZikge1xuICAgICAgdGhpcy5fdGltZXIudW5yZWYoKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLmF0dGVtcHQgPSBmdW5jdGlvbihmbiwgdGltZW91dE9wcykge1xuICB0aGlzLl9mbiA9IGZuO1xuXG4gIGlmICh0aW1lb3V0T3BzKSB7XG4gICAgaWYgKHRpbWVvdXRPcHMudGltZW91dCkge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uVGltZW91dCA9IHRpbWVvdXRPcHMudGltZW91dDtcbiAgICB9XG4gICAgaWYgKHRpbWVvdXRPcHMuY2IpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYiA9IHRpbWVvdXRPcHMuY2I7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5fb3BlcmF0aW9uVGltZW91dENiKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9vcGVyYXRpb25UaW1lb3V0Q2IoKTtcbiAgICB9LCBzZWxmLl9vcGVyYXRpb25UaW1lb3V0KTtcbiAgfVxuXG4gIHRoaXMuX29wZXJhdGlvblN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgdGhpcy5fZm4odGhpcy5fYXR0ZW1wdHMpO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnRyeSA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnNvbGUubG9nKCdVc2luZyBSZXRyeU9wZXJhdGlvbi50cnkoKSBpcyBkZXByZWNhdGVkJyk7XG4gIHRoaXMuYXR0ZW1wdChmbik7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihmbikge1xuICBjb25zb2xlLmxvZygnVXNpbmcgUmV0cnlPcGVyYXRpb24uc3RhcnQoKSBpcyBkZXByZWNhdGVkJyk7XG4gIHRoaXMuYXR0ZW1wdChmbik7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBSZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lcnJvcnM7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuYXR0ZW1wdHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2F0dGVtcHRzO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLm1haW5FcnJvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNvdW50cyA9IHt9O1xuICB2YXIgbWFpbkVycm9yID0gbnVsbDtcbiAgdmFyIG1haW5FcnJvckNvdW50ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Vycm9ycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlcnJvciA9IHRoaXMuX2Vycm9yc1tpXTtcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgdmFyIGNvdW50ID0gKGNvdW50c1ttZXNzYWdlXSB8fCAwKSArIDE7XG5cbiAgICBjb3VudHNbbWVzc2FnZV0gPSBjb3VudDtcblxuICAgIGlmIChjb3VudCA+PSBtYWluRXJyb3JDb3VudCkge1xuICAgICAgbWFpbkVycm9yID0gZXJyb3I7XG4gICAgICBtYWluRXJyb3JDb3VudCA9IGNvdW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYWluRXJyb3I7XG59O1xuIiwgInZhciBSZXRyeU9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vcmV0cnlfb3BlcmF0aW9uJyk7XG5cbmV4cG9ydHMub3BlcmF0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgdGltZW91dHMgPSBleHBvcnRzLnRpbWVvdXRzKG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCB7XG4gICAgICBmb3JldmVyOiBvcHRpb25zICYmIChvcHRpb25zLmZvcmV2ZXIgfHwgb3B0aW9ucy5yZXRyaWVzID09PSBJbmZpbml0eSksXG4gICAgICB1bnJlZjogb3B0aW9ucyAmJiBvcHRpb25zLnVucmVmLFxuICAgICAgbWF4UmV0cnlUaW1lOiBvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cnlUaW1lXG4gIH0pO1xufTtcblxuZXhwb3J0cy50aW1lb3V0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBbXS5jb25jYXQob3B0aW9ucyk7XG4gIH1cblxuICB2YXIgb3B0cyA9IHtcbiAgICByZXRyaWVzOiAxMCxcbiAgICBmYWN0b3I6IDIsXG4gICAgbWluVGltZW91dDogMSAqIDEwMDAsXG4gICAgbWF4VGltZW91dDogSW5maW5pdHksXG4gICAgcmFuZG9taXplOiBmYWxzZVxuICB9O1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgIG9wdHNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIGlmIChvcHRzLm1pblRpbWVvdXQgPiBvcHRzLm1heFRpbWVvdXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pblRpbWVvdXQgaXMgZ3JlYXRlciB0aGFuIG1heFRpbWVvdXQnKTtcbiAgfVxuXG4gIHZhciB0aW1lb3V0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdHMucmV0cmllczsgaSsrKSB7XG4gICAgdGltZW91dHMucHVzaCh0aGlzLmNyZWF0ZVRpbWVvdXQoaSwgb3B0cykpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JldmVyICYmICF0aW1lb3V0cy5sZW5ndGgpIHtcbiAgICB0aW1lb3V0cy5wdXNoKHRoaXMuY3JlYXRlVGltZW91dChpLCBvcHRzKSk7XG4gIH1cblxuICAvLyBzb3J0IHRoZSBhcnJheSBudW1lcmljYWxseSBhc2NlbmRpbmdcbiAgdGltZW91dHMuc29ydChmdW5jdGlvbihhLGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuXG4gIHJldHVybiB0aW1lb3V0cztcbn07XG5cbmV4cG9ydHMuY3JlYXRlVGltZW91dCA9IGZ1bmN0aW9uKGF0dGVtcHQsIG9wdHMpIHtcbiAgdmFyIHJhbmRvbSA9IChvcHRzLnJhbmRvbWl6ZSlcbiAgICA/IChNYXRoLnJhbmRvbSgpICsgMSlcbiAgICA6IDE7XG5cbiAgdmFyIHRpbWVvdXQgPSBNYXRoLnJvdW5kKHJhbmRvbSAqIE1hdGgubWF4KG9wdHMubWluVGltZW91dCwgMSkgKiBNYXRoLnBvdyhvcHRzLmZhY3RvciwgYXR0ZW1wdCkpO1xuICB0aW1lb3V0ID0gTWF0aC5taW4odGltZW91dCwgb3B0cy5tYXhUaW1lb3V0KTtcblxuICByZXR1cm4gdGltZW91dDtcbn07XG5cbmV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucywgbWV0aG9kcykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgbWV0aG9kcyA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBpZiAoIW1ldGhvZHMpIHtcbiAgICBtZXRob2RzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtZXRob2RzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWV0aG9kICAgPSBtZXRob2RzW2ldO1xuICAgIHZhciBvcmlnaW5hbCA9IG9ialttZXRob2RdO1xuXG4gICAgb2JqW21ldGhvZF0gPSBmdW5jdGlvbiByZXRyeVdyYXBwZXIob3JpZ2luYWwpIHtcbiAgICAgIHZhciBvcCAgICAgICA9IGV4cG9ydHMub3BlcmF0aW9uKG9wdGlvbnMpO1xuICAgICAgdmFyIGFyZ3MgICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG5cbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKG9wLnJldHJ5KGVycikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG9wLm1haW5FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcblxuICAgICAgb3AuYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgb3JpZ2luYWwuYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0uYmluZChvYmosIG9yaWdpbmFsKTtcbiAgICBvYmpbbWV0aG9kXS5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxufTtcbiIsICJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3JldHJ5Jyk7IiwgIid1c2Ugc3RyaWN0JztcbmNvbnN0IHJldHJ5ID0gcmVxdWlyZSgncmV0cnknKTtcblxuY29uc3QgbmV0d29ya0Vycm9yTXNncyA9IFtcblx0J0ZhaWxlZCB0byBmZXRjaCcsIC8vIENocm9tZVxuXHQnTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS4nLCAvLyBGaXJlZm94XG5cdCdUaGUgSW50ZXJuZXQgY29ubmVjdGlvbiBhcHBlYXJzIHRvIGJlIG9mZmxpbmUuJywgLy8gU2FmYXJpXG5cdCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJyAvLyBgY3Jvc3MtZmV0Y2hgXG5dO1xuXG5jbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHRoaXMub3JpZ2luYWxFcnJvciA9IG1lc3NhZ2U7XG5cdFx0XHQoe21lc3NhZ2V9ID0gbWVzc2FnZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMub3JpZ2luYWxFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcblx0XHRcdHRoaXMub3JpZ2luYWxFcnJvci5zdGFjayA9IHRoaXMuc3RhY2s7XG5cdFx0fVxuXG5cdFx0dGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InO1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdH1cbn1cblxuY29uc3QgZGVjb3JhdGVFcnJvcldpdGhDb3VudHMgPSAoZXJyb3IsIGF0dGVtcHROdW1iZXIsIG9wdGlvbnMpID0+IHtcblx0Ly8gTWludXMgMSBmcm9tIGF0dGVtcHROdW1iZXIgYmVjYXVzZSB0aGUgZmlyc3QgYXR0ZW1wdCBkb2VzIG5vdCBjb3VudCBhcyBhIHJldHJ5XG5cdGNvbnN0IHJldHJpZXNMZWZ0ID0gb3B0aW9ucy5yZXRyaWVzIC0gKGF0dGVtcHROdW1iZXIgLSAxKTtcblxuXHRlcnJvci5hdHRlbXB0TnVtYmVyID0gYXR0ZW1wdE51bWJlcjtcblx0ZXJyb3IucmV0cmllc0xlZnQgPSByZXRyaWVzTGVmdDtcblx0cmV0dXJuIGVycm9yO1xufTtcblxuY29uc3QgaXNOZXR3b3JrRXJyb3IgPSBlcnJvck1lc3NhZ2UgPT4gbmV0d29ya0Vycm9yTXNncy5pbmNsdWRlcyhlcnJvck1lc3NhZ2UpO1xuXG5jb25zdCBwUmV0cnkgPSAoaW5wdXQsIG9wdGlvbnMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0b3B0aW9ucyA9IHtcblx0XHRvbkZhaWxlZEF0dGVtcHQ6ICgpID0+IHt9LFxuXHRcdHJldHJpZXM6IDEwLFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcblxuXHRjb25zdCBvcGVyYXRpb24gPSByZXRyeS5vcGVyYXRpb24ob3B0aW9ucyk7XG5cblx0b3BlcmF0aW9uLmF0dGVtcHQoYXN5bmMgYXR0ZW1wdE51bWJlciA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdHJlc29sdmUoYXdhaXQgaW5wdXQoYXR0ZW1wdE51bWJlcikpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuXHRcdFx0XHRyZWplY3QobmV3IFR5cGVFcnJvcihgTm9uLWVycm9yIHdhcyB0aHJvd246IFwiJHtlcnJvcn1cIi4gWW91IHNob3VsZCBvbmx5IHRocm93IGVycm9ycy5gKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGVycm9yIGluc3RhbmNlb2YgQWJvcnRFcnJvcikge1xuXHRcdFx0XHRvcGVyYXRpb24uc3RvcCgpO1xuXHRcdFx0XHRyZWplY3QoZXJyb3Iub3JpZ2luYWxFcnJvcik7XG5cdFx0XHR9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmICFpc05ldHdvcmtFcnJvcihlcnJvci5tZXNzYWdlKSkge1xuXHRcdFx0XHRvcGVyYXRpb24uc3RvcCgpO1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVjb3JhdGVFcnJvcldpdGhDb3VudHMoZXJyb3IsIGF0dGVtcHROdW1iZXIsIG9wdGlvbnMpO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YXdhaXQgb3B0aW9ucy5vbkZhaWxlZEF0dGVtcHQoZXJyb3IpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFvcGVyYXRpb24ucmV0cnkoZXJyb3IpKSB7XG5cdFx0XHRcdFx0cmVqZWN0KG9wZXJhdGlvbi5tYWluRXJyb3IoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcFJldHJ5O1xuLy8gVE9ETzogcmVtb3ZlIHRoaXMgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvblxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBSZXRyeTtcblxubW9kdWxlLmV4cG9ydHMuQWJvcnRFcnJvciA9IEFib3J0RXJyb3I7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIiwgIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gKHByb21pc2UsIG9uRmluYWxseSkgPT4ge1xuXHRvbkZpbmFsbHkgPSBvbkZpbmFsbHkgfHwgKCgpID0+IHt9KTtcblxuXHRyZXR1cm4gcHJvbWlzZS50aGVuKFxuXHRcdHZhbCA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHRcdHJlc29sdmUob25GaW5hbGx5KCkpO1xuXHRcdH0pLnRoZW4oKCkgPT4gdmFsKSxcblx0XHRlcnIgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0XHRyZXNvbHZlKG9uRmluYWxseSgpKTtcblx0XHR9KS50aGVuKCgpID0+IHtcblx0XHRcdHRocm93IGVycjtcblx0XHR9KVxuXHQpO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBGaW5hbGx5ID0gcmVxdWlyZSgncC1maW5hbGx5Jyk7XG5cbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSkge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuXHR9XG59XG5cbmNvbnN0IHBUaW1lb3V0ID0gKHByb21pc2UsIG1pbGxpc2Vjb25kcywgZmFsbGJhY2spID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0aWYgKHR5cGVvZiBtaWxsaXNlY29uZHMgIT09ICdudW1iZXInIHx8IG1pbGxpc2Vjb25kcyA8IDApIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgbWlsbGlzZWNvbmRzYCB0byBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuXHR9XG5cblx0aWYgKG1pbGxpc2Vjb25kcyA9PT0gSW5maW5pdHkpIHtcblx0XHRyZXNvbHZlKHByb21pc2UpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0aWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzb2x2ZShmYWxsYmFjaygpKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBtZXNzYWdlID0gdHlwZW9mIGZhbGxiYWNrID09PSAnc3RyaW5nJyA/IGZhbGxiYWNrIDogYFByb21pc2UgdGltZWQgb3V0IGFmdGVyICR7bWlsbGlzZWNvbmRzfSBtaWxsaXNlY29uZHNgO1xuXHRcdGNvbnN0IHRpbWVvdXRFcnJvciA9IGZhbGxiYWNrIGluc3RhbmNlb2YgRXJyb3IgPyBmYWxsYmFjayA6IG5ldyBUaW1lb3V0RXJyb3IobWVzc2FnZSk7XG5cblx0XHRpZiAodHlwZW9mIHByb21pc2UuY2FuY2VsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRwcm9taXNlLmNhbmNlbCgpO1xuXHRcdH1cblxuXHRcdHJlamVjdCh0aW1lb3V0RXJyb3IpO1xuXHR9LCBtaWxsaXNlY29uZHMpO1xuXG5cdC8vIFRPRE86IFVzZSBuYXRpdmUgYGZpbmFsbHlgIGtleXdvcmQgd2hlbiB0YXJnZXRpbmcgTm9kZS5qcyAxMFxuXHRwRmluYWxseShcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tdGhlblxuXHRcdHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpLFxuXHRcdCgpID0+IHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0fVxuXHQpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcFRpbWVvdXQ7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBUaW1lb3V0O1xuXG5tb2R1bGUuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBQb3J0IG9mIGxvd2VyX2JvdW5kIGZyb20gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2FsZ29yaXRobS9sb3dlcl9ib3VuZFxuLy8gVXNlZCB0byBjb21wdXRlIGluc2VydGlvbiBpbmRleCB0byBrZWVwIHF1ZXVlIHNvcnRlZCBhZnRlciBpbnNlcnRpb25cbmZ1bmN0aW9uIGxvd2VyQm91bmQoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgbGV0IGZpcnN0ID0gMDtcbiAgICBsZXQgY291bnQgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGNvdW50ID4gMCkge1xuICAgICAgICBjb25zdCBzdGVwID0gKGNvdW50IC8gMikgfCAwO1xuICAgICAgICBsZXQgaXQgPSBmaXJzdCArIHN0ZXA7XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2l0XSwgdmFsdWUpIDw9IDApIHtcbiAgICAgICAgICAgIGZpcnN0ID0gKytpdDtcbiAgICAgICAgICAgIGNvdW50IC09IHN0ZXAgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY291bnQgPSBzdGVwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaXJzdDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGxvd2VyQm91bmQ7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBsb3dlcl9ib3VuZF8xID0gcmVxdWlyZShcIi4vbG93ZXItYm91bmRcIik7XG5jbGFzcyBQcmlvcml0eVF1ZXVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB9XG4gICAgZW5xdWV1ZShydW4sIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBwcmlvcml0eTogMCB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHtcbiAgICAgICAgICAgIHByaW9yaXR5OiBvcHRpb25zLnByaW9yaXR5LFxuICAgICAgICAgICAgcnVuXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnNpemUgJiYgdGhpcy5fcXVldWVbdGhpcy5zaXplIC0gMV0ucHJpb3JpdHkgPj0gb3B0aW9ucy5wcmlvcml0eSkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWUucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IGxvd2VyX2JvdW5kXzEuZGVmYXVsdCh0aGlzLl9xdWV1ZSwgZWxlbWVudCwgKGEsIGIpID0+IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KTtcbiAgICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKGluZGV4LCAwLCBlbGVtZW50KTtcbiAgICB9XG4gICAgZGVxdWV1ZSgpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW0ucnVuO1xuICAgIH1cbiAgICBmaWx0ZXIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuZmlsdGVyKChlbGVtZW50KSA9PiBlbGVtZW50LnByaW9yaXR5ID09PSBvcHRpb25zLnByaW9yaXR5KS5tYXAoKGVsZW1lbnQpID0+IGVsZW1lbnQucnVuKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUHJpb3JpdHlRdWV1ZTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudGVtaXR0ZXIzXCIpO1xuY29uc3QgcF90aW1lb3V0XzEgPSByZXF1aXJlKFwicC10aW1lb3V0XCIpO1xuY29uc3QgcHJpb3JpdHlfcXVldWVfMSA9IHJlcXVpcmUoXCIuL3ByaW9yaXR5LXF1ZXVlXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuY29uc3QgZW1wdHkgPSAoKSA9PiB7IH07XG5jb25zdCB0aW1lb3V0RXJyb3IgPSBuZXcgcF90aW1lb3V0XzEuVGltZW91dEVycm9yKCk7XG4vKipcblByb21pc2UgcXVldWUgd2l0aCBjb25jdXJyZW5jeSBjb250cm9sLlxuKi9cbmNsYXNzIFBRdWV1ZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ludGVydmFsQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbEVuZCA9IDA7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eSA9IGVtcHR5O1xuICAgICAgICB0aGlzLl9yZXNvbHZlSWRsZSA9IGVtcHR5O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1hc3NlcnRpb25zXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY2FycnlvdmVyQ29uY3VycmVuY3lDb3VudDogZmFsc2UsIGludGVydmFsQ2FwOiBJbmZpbml0eSwgaW50ZXJ2YWw6IDAsIGNvbmN1cnJlbmN5OiBJbmZpbml0eSwgYXV0b1N0YXJ0OiB0cnVlLCBxdWV1ZUNsYXNzOiBwcmlvcml0eV9xdWV1ZV8xLmRlZmF1bHQgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghKHR5cGVvZiBvcHRpb25zLmludGVydmFsQ2FwID09PSAnbnVtYmVyJyAmJiBvcHRpb25zLmludGVydmFsQ2FwID49IDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBpbnRlcnZhbENhcFxcYCB0byBiZSBhIG51bWJlciBmcm9tIDEgYW5kIHVwLCBnb3QgXFxgJHsoX2IgPSAoX2EgPSBvcHRpb25zLmludGVydmFsQ2FwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyd9XFxgICgke3R5cGVvZiBvcHRpb25zLmludGVydmFsQ2FwfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnRlcnZhbCA9PT0gdW5kZWZpbmVkIHx8ICEoTnVtYmVyLmlzRmluaXRlKG9wdGlvbnMuaW50ZXJ2YWwpICYmIG9wdGlvbnMuaW50ZXJ2YWwgPj0gMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGludGVydmFsXFxgIHRvIGJlIGEgZmluaXRlIG51bWJlciA+PSAwLCBnb3QgXFxgJHsoX2QgPSAoX2MgPSBvcHRpb25zLmludGVydmFsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJyd9XFxgICgke3R5cGVvZiBvcHRpb25zLmludGVydmFsfSlgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50ID0gb3B0aW9ucy5jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50O1xuICAgICAgICB0aGlzLl9pc0ludGVydmFsSWdub3JlZCA9IG9wdGlvbnMuaW50ZXJ2YWxDYXAgPT09IEluZmluaXR5IHx8IG9wdGlvbnMuaW50ZXJ2YWwgPT09IDA7XG4gICAgICAgIHRoaXMuX2ludGVydmFsQ2FwID0gb3B0aW9ucy5pbnRlcnZhbENhcDtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBvcHRpb25zLmludGVydmFsO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBvcHRpb25zLnF1ZXVlQ2xhc3MoKTtcbiAgICAgICAgdGhpcy5fcXVldWVDbGFzcyA9IG9wdGlvbnMucXVldWVDbGFzcztcbiAgICAgICAgdGhpcy5jb25jdXJyZW5jeSA9IG9wdGlvbnMuY29uY3VycmVuY3k7XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX3Rocm93T25UaW1lb3V0ID0gb3B0aW9ucy50aHJvd09uVGltZW91dCA9PT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBvcHRpb25zLmF1dG9TdGFydCA9PT0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBfZG9lc0ludGVydmFsQWxsb3dBbm90aGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNJbnRlcnZhbElnbm9yZWQgfHwgdGhpcy5faW50ZXJ2YWxDb3VudCA8IHRoaXMuX2ludGVydmFsQ2FwO1xuICAgIH1cbiAgICBnZXQgX2RvZXNDb25jdXJyZW50QWxsb3dBbm90aGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50IDwgdGhpcy5fY29uY3VycmVuY3k7XG4gICAgfVxuICAgIF9uZXh0KCkge1xuICAgICAgICB0aGlzLl9wZW5kaW5nQ291bnQtLTtcbiAgICAgICAgdGhpcy5fdHJ5VG9TdGFydEFub3RoZXIoKTtcbiAgICAgICAgdGhpcy5lbWl0KCduZXh0Jyk7XG4gICAgfVxuICAgIF9yZXNvbHZlUHJvbWlzZXMoKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eSgpO1xuICAgICAgICB0aGlzLl9yZXNvbHZlRW1wdHkgPSBlbXB0eTtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUlkbGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVJZGxlID0gZW1wdHk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25SZXN1bWVJbnRlcnZhbCgpIHtcbiAgICAgICAgdGhpcy5fb25JbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplSW50ZXJ2YWxJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLl90aW1lb3V0SWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF9pc0ludGVydmFsUGF1c2VkKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuX2ludGVydmFsRW5kIC0gbm93O1xuICAgICAgICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIEFjdCBhcyB0aGUgaW50ZXJ2YWwgd2FzIGRvbmVcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlc3VtZSBpdCBoZXJlIGJlY2F1c2UgaXQgd2lsbCBiZSByZXN1bWVkIG9uIGxpbmUgMTYwXG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxDb3VudCA9ICh0aGlzLl9jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50KSA/IHRoaXMuX3BlbmRpbmdDb3VudCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBY3QgYXMgdGhlIGludGVydmFsIGlzIHBlbmRpbmdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGltZW91dElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblJlc3VtZUludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfdHJ5VG9TdGFydEFub3RoZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gY2xlYXIgdGhlIGludGVydmFsIChcInBhdXNlXCIpXG4gICAgICAgICAgICAvLyBCZWNhdXNlIHdlIGNhbiByZWRvIGl0IGxhdGVyIChcInJlc3VtZVwiKVxuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVydmFsSWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVQcm9taXNlcygpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbkluaXRpYWxpemVJbnRlcnZhbCA9ICF0aGlzLl9pc0ludGVydmFsUGF1c2VkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZG9lc0ludGVydmFsQWxsb3dBbm90aGVyICYmIHRoaXMuX2RvZXNDb25jdXJyZW50QWxsb3dBbm90aGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9iID0gdGhpcy5fcXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgICAgIGlmICgham9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICBqb2IoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuSW5pdGlhbGl6ZUludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnRlcnZhbElmTmVlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVJbnRlcnZhbElmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNJbnRlcnZhbElnbm9yZWQgfHwgdGhpcy5faW50ZXJ2YWxJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uSW50ZXJ2YWwoKTtcbiAgICAgICAgfSwgdGhpcy5faW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbEVuZCA9IERhdGUubm93KCkgKyB0aGlzLl9pbnRlcnZhbDtcbiAgICB9XG4gICAgX29uSW50ZXJ2YWwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbENvdW50ID09PSAwICYmIHRoaXMuX3BlbmRpbmdDb3VudCA9PT0gMCAmJiB0aGlzLl9pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcnZhbENvdW50ID0gdGhpcy5fY2FycnlvdmVyQ29uY3VycmVuY3lDb3VudCA/IHRoaXMuX3BlbmRpbmdDb3VudCA6IDA7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeGVjdXRlcyBhbGwgcXVldWVkIGZ1bmN0aW9ucyB1bnRpbCBpdCByZWFjaGVzIHRoZSBsaW1pdC5cbiAgICAqL1xuICAgIF9wcm9jZXNzUXVldWUoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICB3aGlsZSAodGhpcy5fdHJ5VG9TdGFydEFub3RoZXIoKSkgeyB9XG4gICAgfVxuICAgIGdldCBjb25jdXJyZW5jeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmN1cnJlbmN5O1xuICAgIH1cbiAgICBzZXQgY29uY3VycmVuY3kobmV3Q29uY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIG5ld0NvbmN1cnJlbmN5ID09PSAnbnVtYmVyJyAmJiBuZXdDb25jdXJyZW5jeSA+PSAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY29uY3VycmVuY3lcXGAgdG8gYmUgYSBudW1iZXIgZnJvbSAxIGFuZCB1cCwgZ290IFxcYCR7bmV3Q29uY3VycmVuY3l9XFxgICgke3R5cGVvZiBuZXdDb25jdXJyZW5jeX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uY3VycmVuY3kgPSBuZXdDb25jdXJyZW5jeTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZHMgYSBzeW5jIG9yIGFzeW5jIHRhc2sgdG8gdGhlIHF1ZXVlLiBBbHdheXMgcmV0dXJucyBhIHByb21pc2UuXG4gICAgKi9cbiAgICBhc3luYyBhZGQoZm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcnVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVydmFsQ291bnQrKztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSAodGhpcy5fdGltZW91dCA9PT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkKSA/IGZuKCkgOiBwX3RpbWVvdXRfMS5kZWZhdWx0KFByb21pc2UucmVzb2x2ZShmbigpKSwgKG9wdGlvbnMudGltZW91dCA9PT0gdW5kZWZpbmVkID8gdGhpcy5fdGltZW91dCA6IG9wdGlvbnMudGltZW91dCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRocm93T25UaW1lb3V0ID09PSB1bmRlZmluZWQgPyB0aGlzLl90aHJvd09uVGltZW91dCA6IG9wdGlvbnMudGhyb3dPblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QodGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGF3YWl0IG9wZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fcXVldWUuZW5xdWV1ZShydW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fdHJ5VG9TdGFydEFub3RoZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnYWRkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBTYW1lIGFzIGAuYWRkKClgLCBidXQgYWNjZXB0cyBhbiBhcnJheSBvZiBzeW5jIG9yIGFzeW5jIGZ1bmN0aW9ucy5cblxuICAgIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGZ1bmN0aW9ucyBhcmUgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBhc3luYyBhZGRBbGwoZnVuY3Rpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChmdW5jdGlvbnMubWFwKGFzeW5jIChmdW5jdGlvbl8pID0+IHRoaXMuYWRkKGZ1bmN0aW9uXywgb3B0aW9ucykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgKG9yIHJlc3VtZSkgZXhlY3V0aW5nIGVucXVldWVkIHRhc2tzIHdpdGhpbiBjb25jdXJyZW5jeSBsaW1pdC4gTm8gbmVlZCB0byBjYWxsIHRoaXMgaWYgcXVldWUgaXMgbm90IHBhdXNlZCAodmlhIGBvcHRpb25zLmF1dG9TdGFydCA9IGZhbHNlYCBvciBieSBgLnBhdXNlKClgIG1ldGhvZC4pXG4gICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBQdXQgcXVldWUgZXhlY3V0aW9uIG9uIGhvbGQuXG4gICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBDbGVhciB0aGUgcXVldWUuXG4gICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgdGhpcy5fcXVldWVDbGFzcygpO1xuICAgIH1cbiAgICAvKipcbiAgICBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLiBVc2VmdWwgaWYgeW91IGZvciBleGFtcGxlIGFkZCBhZGRpdGlvbmFsIGl0ZW1zIGF0IGEgbGF0ZXIgdGltZS5cblxuICAgIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHNldHRsZXMgd2hlbiB0aGUgcXVldWUgYmVjb21lcyBlbXB0eS5cbiAgICAqL1xuICAgIGFzeW5jIG9uRW1wdHkoKSB7XG4gICAgICAgIC8vIEluc3RhbnRseSByZXNvbHZlIGlmIHRoZSBxdWV1ZSBpcyBlbXB0eVxuICAgICAgICBpZiAodGhpcy5fcXVldWUuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUmVzb2x2ZSA9IHRoaXMuX3Jlc29sdmVFbXB0eTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRpZmZlcmVuY2Ugd2l0aCBgLm9uRW1wdHlgIGlzIHRoYXQgYC5vbklkbGVgIGd1YXJhbnRlZXMgdGhhdCBhbGwgd29yayBmcm9tIHRoZSBxdWV1ZSBoYXMgZmluaXNoZWQuIGAub25FbXB0eWAgbWVyZWx5IHNpZ25hbHMgdGhhdCB0aGUgcXVldWUgaXMgZW1wdHksIGJ1dCBpdCBjb3VsZCBtZWFuIHRoYXQgc29tZSBwcm9taXNlcyBoYXZlbid0IGNvbXBsZXRlZCB5ZXQuXG5cbiAgICBAcmV0dXJucyBBIHByb21pc2UgdGhhdCBzZXR0bGVzIHdoZW4gdGhlIHF1ZXVlIGJlY29tZXMgZW1wdHksIGFuZCBhbGwgcHJvbWlzZXMgaGF2ZSBjb21wbGV0ZWQ7IGBxdWV1ZS5zaXplID09PSAwICYmIHF1ZXVlLnBlbmRpbmcgPT09IDBgLlxuICAgICovXG4gICAgYXN5bmMgb25JZGxlKCkge1xuICAgICAgICAvLyBJbnN0YW50bHkgcmVzb2x2ZSBpZiBub25lIHBlbmRpbmcgYW5kIGlmIG5vdGhpbmcgZWxzZSBpcyBxdWV1ZWRcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb3VudCA9PT0gMCAmJiB0aGlzLl9xdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvbHZlID0gdGhpcy5fcmVzb2x2ZUlkbGU7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlSWRsZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2l6ZSBvZiB0aGUgcXVldWUuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFNpemUgb2YgdGhlIHF1ZXVlLCBmaWx0ZXJlZCBieSB0aGUgZ2l2ZW4gb3B0aW9ucy5cblxuICAgIEZvciBleGFtcGxlLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIG51bWJlciBvZiBpdGVtcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlIHdpdGggYSBzcGVjaWZpYyBwcmlvcml0eSBsZXZlbC5cbiAgICAqL1xuICAgIHNpemVCeShvcHRpb25zKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWZuLXJlZmVyZW5jZS1pbi1pdGVyYXRvclxuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuZmlsdGVyKG9wdGlvbnMpLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgTnVtYmVyIG9mIHBlbmRpbmcgcHJvbWlzZXMuXG4gICAgKi9cbiAgICBnZXQgcGVuZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgcXVldWUgaXMgY3VycmVudGx5IHBhdXNlZC5cbiAgICAqL1xuICAgIGdldCBpc1BhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGF1c2VkO1xuICAgIH1cbiAgICBnZXQgdGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdGltZW91dCBmb3IgZnV0dXJlIG9wZXJhdGlvbnMuXG4gICAgKi9cbiAgICBzZXQgdGltZW91dChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG1pbGxpc2Vjb25kcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQUXVldWU7XG4iLCAiLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuY29uc3QgU0VNVkVSX1NQRUNfVkVSU0lPTiA9ICcyLjAuMCdcblxuY29uc3QgTUFYX0xFTkdUSCA9IDI1NlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA5MDA3MTk5MjU0NzQwOTkxXG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbmNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNlxuXG4vLyBNYXggc2FmZSBsZW5ndGggZm9yIGEgYnVpbGQgaWRlbnRpZmllci4gVGhlIG1heCBsZW5ndGggbWludXMgNiBjaGFyYWN0ZXJzIGZvclxuLy8gdGhlIHNob3J0ZXN0IHZlcnNpb24gd2l0aCBhIGJ1aWxkIDAuMC4wK0JVSUxELlxuY29uc3QgTUFYX1NBRkVfQlVJTERfTEVOR1RIID0gTUFYX0xFTkdUSCAtIDZcblxuY29uc3QgUkVMRUFTRV9UWVBFUyA9IFtcbiAgJ21ham9yJyxcbiAgJ3ByZW1ham9yJyxcbiAgJ21pbm9yJyxcbiAgJ3ByZW1pbm9yJyxcbiAgJ3BhdGNoJyxcbiAgJ3ByZXBhdGNoJyxcbiAgJ3ByZXJlbGVhc2UnLFxuXVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTUFYX0xFTkdUSCxcbiAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCxcbiAgTUFYX1NBRkVfQlVJTERfTEVOR1RILFxuICBNQVhfU0FGRV9JTlRFR0VSLFxuICBSRUxFQVNFX1RZUEVTLFxuICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRTogMGIwMDEsXG4gIEZMQUdfTE9PU0U6IDBiMDEwLFxufVxuIiwgImNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiIsICJjb25zdCB7XG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEgsXG4gIE1BWF9TQUZFX0JVSUxEX0xFTkdUSCxcbiAgTUFYX0xFTkdUSCxcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge31cblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbmNvbnN0IHJlID0gZXhwb3J0cy5yZSA9IFtdXG5jb25zdCBzYWZlUmUgPSBleHBvcnRzLnNhZmVSZSA9IFtdXG5jb25zdCBzcmMgPSBleHBvcnRzLnNyYyA9IFtdXG5jb25zdCBzYWZlU3JjID0gZXhwb3J0cy5zYWZlU3JjID0gW11cbmNvbnN0IHQgPSBleHBvcnRzLnQgPSB7fVxubGV0IFIgPSAwXG5cbmNvbnN0IExFVFRFUkRBU0hOVU1CRVIgPSAnW2EtekEtWjAtOS1dJ1xuXG4vLyBSZXBsYWNlIHNvbWUgZ3JlZWR5IHJlZ2V4IHRva2VucyB0byBwcmV2ZW50IHJlZ2V4IGRvcyBpc3N1ZXMuIFRoZXNlIHJlZ2V4IGFyZVxuLy8gdXNlZCBpbnRlcm5hbGx5IHZpYSB0aGUgc2FmZVJlIG9iamVjdCBzaW5jZSBhbGwgaW5wdXRzIGluIHRoaXMgbGlicmFyeSBnZXRcbi8vIG5vcm1hbGl6ZWQgZmlyc3QgdG8gdHJpbSBhbmQgY29sbGFwc2UgYWxsIGV4dHJhIHdoaXRlc3BhY2UuIFRoZSBvcmlnaW5hbFxuLy8gcmVnZXhlcyBhcmUgZXhwb3J0ZWQgZm9yIHVzZXJsYW5kIGNvbnN1bXB0aW9uIGFuZCBsb3dlciBsZXZlbCB1c2FnZS4gQVxuLy8gZnV0dXJlIGJyZWFraW5nIGNoYW5nZSBjb3VsZCBleHBvcnQgdGhlIHNhZmVyIHJlZ2V4IG9ubHkgd2l0aCBhIG5vdGUgdGhhdFxuLy8gYWxsIGlucHV0IHNob3VsZCBoYXZlIGV4dHJhIHdoaXRlc3BhY2UgcmVtb3ZlZC5cbmNvbnN0IHNhZmVSZWdleFJlcGxhY2VtZW50cyA9IFtcbiAgWydcXFxccycsIDFdLFxuICBbJ1xcXFxkJywgTUFYX0xFTkdUSF0sXG4gIFtMRVRURVJEQVNITlVNQkVSLCBNQVhfU0FGRV9CVUlMRF9MRU5HVEhdLFxuXVxuXG5jb25zdCBtYWtlU2FmZVJlZ2V4ID0gKHZhbHVlKSA9PiB7XG4gIGZvciAoY29uc3QgW3Rva2VuLCBtYXhdIG9mIHNhZmVSZWdleFJlcGxhY2VtZW50cykge1xuICAgIHZhbHVlID0gdmFsdWVcbiAgICAgIC5zcGxpdChgJHt0b2tlbn0qYCkuam9pbihgJHt0b2tlbn17MCwke21heH19YClcbiAgICAgIC5zcGxpdChgJHt0b2tlbn0rYCkuam9pbihgJHt0b2tlbn17MSwke21heH19YClcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuY29uc3QgY3JlYXRlVG9rZW4gPSAobmFtZSwgdmFsdWUsIGlzR2xvYmFsKSA9PiB7XG4gIGNvbnN0IHNhZmUgPSBtYWtlU2FmZVJlZ2V4KHZhbHVlKVxuICBjb25zdCBpbmRleCA9IFIrK1xuICBkZWJ1ZyhuYW1lLCBpbmRleCwgdmFsdWUpXG4gIHRbbmFtZV0gPSBpbmRleFxuICBzcmNbaW5kZXhdID0gdmFsdWVcbiAgc2FmZVNyY1tpbmRleF0gPSBzYWZlXG4gIHJlW2luZGV4XSA9IG5ldyBSZWdFeHAodmFsdWUsIGlzR2xvYmFsID8gJ2cnIDogdW5kZWZpbmVkKVxuICBzYWZlUmVbaW5kZXhdID0gbmV3IFJlZ0V4cChzYWZlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnXFxcXGQrJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgYFxcXFxkKlthLXpBLVotXSR7TEVUVEVSREFTSE5VTUJFUn0qYClcblxuLy8gIyMgTWFpbiBWZXJzaW9uXG4vLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTicsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlgKVxuXG5jcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVInLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJywgYCg/OiR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV1cbn18JHtzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl19KWApXG5cbi8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0UnLCBgKD86LSgke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl19KSopKWApXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFTE9PU0UnLCBgKD86LT8oJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXVxufSg/OlxcXFwuJHtzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0pKikpYClcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxESURFTlRJRklFUicsIGAke0xFVFRFUkRBU0hOVU1CRVJ9K2ApXG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhXG4vLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignQlVJTEQnLCBgKD86XFxcXCsoJHtzcmNbdC5CVUlMRElERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LkJVSUxESURFTlRJRklFUl19KSopKWApXG5cbi8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbi8vIEEgbWFpbiB2ZXJzaW9uLCBmb2xsb3dlZCBvcHRpb25hbGx5IGJ5IGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBhbmRcbi8vIGJ1aWxkIG1ldGFkYXRhLlxuXG4vLyBOb3RlIHRoYXQgdGhlIG9ubHkgbWFqb3IsIG1pbm9yLCBwYXRjaCwgYW5kIHByZS1yZWxlYXNlIHNlY3Rpb25zIG9mXG4vLyB0aGUgdmVyc2lvbiBzdHJpbmcgYXJlIGNhcHR1cmluZyBncm91cHMuICBUaGUgYnVpbGQgbWV0YWRhdGEgaXMgbm90IGFcbi8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4vLyBjb21wYXJpc29uLlxuXG5jcmVhdGVUb2tlbignRlVMTFBMQUlOJywgYHY/JHtzcmNbdC5NQUlOVkVSU0lPTl1cbn0ke3NyY1t0LlBSRVJFTEVBU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdGVUxMJywgYF4ke3NyY1t0LkZVTExQTEFJTl19JGApXG5cbi8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cbmNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgYFt2PVxcXFxzXSoke3NyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdXG59JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfT8ke1xuICBzcmNbdC5CVUlMRF19P2ApXG5cbmNyZWF0ZVRva2VuKCdMT09TRScsIGBeJHtzcmNbdC5MT09TRVBMQUlOXX0kYClcblxuY3JlYXRlVG9rZW4oJ0dUTFQnLCAnKCg/Ojx8Pik/PT8pJylcblxuLy8gU29tZXRoaW5nIGxpa2UgXCIyLipcIiBvciBcIjEuMi54XCIuXG4vLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4vLyBPbmx5IHRoZSBmaXJzdCBpdGVtIGlzIHN0cmljdGx5IHJlcXVpcmVkLlxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVJMT09TRScsIGAke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKVxuY3JlYXRlVG9rZW4oJ1hSQU5HRUlERU5USUZJRVInLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTicsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRV19KT8ke1xuICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0VQTEFJTkxPT1NFJywgYFt2PVxcXFxzXSooJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFTE9PU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjW3QuQlVJTERdfT9gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGApPyk/YClcblxuY3JlYXRlVG9rZW4oJ1hSQU5HRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyoke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbmNyZWF0ZVRva2VuKCdDT0VSQ0VQTEFJTicsIGAkeycoXnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCd9JHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pYCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YCArXG4gICAgICAgICAgICAgIGAoPzpcXFxcLihcXFxcZHsxLCR7TUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSH19KSk/YClcbmNyZWF0ZVRva2VuKCdDT0VSQ0UnLCBgJHtzcmNbdC5DT0VSQ0VQTEFJTl19KD86JHxbXlxcXFxkXSlgKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRUZVTEwnLCBzcmNbdC5DT0VSQ0VQTEFJTl0gK1xuICAgICAgICAgICAgICBgKD86JHtzcmNbdC5QUkVSRUxFQVNFXX0pP2AgK1xuICAgICAgICAgICAgICBgKD86JHtzcmNbdC5CVUlMRF19KT9gICtcbiAgICAgICAgICAgICAgYCg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKVxuY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTEZVTEwnLCBzcmNbdC5DT0VSQ0VGVUxMXSwgdHJ1ZSlcblxuLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcbmNyZWF0ZVRva2VuKCdMT05FVElMREUnLCAnKD86fj4/KScpXG5cbmNyZWF0ZVRva2VuKCdUSUxERVRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVUSUxERV19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMudGlsZGVUcmltUmVwbGFjZSA9ICckMX4nXG5cbmNyZWF0ZVRva2VuKCdUSUxERScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ1RJTERFTE9PU0UnLCBgXiR7c3JjW3QuTE9ORVRJTERFXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBDYXJldCByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxuY3JlYXRlVG9rZW4oJ0xPTkVDQVJFVCcsICcoPzpcXFxcXiknKVxuXG5jcmVhdGVUb2tlbignQ0FSRVRUUklNJywgYChcXFxccyopJHtzcmNbdC5MT05FQ0FSRVRdfVxcXFxzK2AsIHRydWUpXG5leHBvcnRzLmNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJ1xuXG5jcmVhdGVUb2tlbignQ0FSRVQnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOXX0kYClcbmNyZWF0ZVRva2VuKCdDQVJFVExPT1NFJywgYF4ke3NyY1t0LkxPTkVDQVJFVF19JHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQSBzaW1wbGUgZ3QvbHQvZXEgdGhpbmcsIG9yIGp1c3QgXCJcIiB0byBpbmRpY2F0ZSBcImFueSB2ZXJzaW9uXCJcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9STE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19KSR8XiRgKVxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1InLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqKCR7c3JjW3QuRlVMTFBMQUlOXX0pJHxeJGApXG5cbi8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4vLyBpdCBtb2RpZmllcywgc28gdGhhdCBgPiAxLjIuM2AgPT0+IGA+MS4yLjNgXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUlRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkdUTFRdXG59XFxcXHMqKCR7c3JjW3QuTE9PU0VQTEFJTl19fCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgLCB0cnVlKVxuZXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJ1xuXG4vLyBTb21ldGhpbmcgbGlrZSBgMS4yLjMgLSAxLjIuNGBcbi8vIE5vdGUgdGhhdCB0aGVzZSBhbGwgdXNlIHRoZSBsb29zZSBmb3JtLCBiZWNhdXNlIHRoZXknbGwgYmVcbi8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbi8vIGxhdGVyLlxuY3JlYXRlVG9rZW4oJ0hZUEhFTlJBTkdFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGBcXFxccystXFxcXHMrYCArXG4gICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKiRgKVxuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0VMT09TRScsIGBeXFxcXHMqKCR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbmNyZWF0ZVRva2VuKCdTVEFSJywgJyg8fD4pPz0/XFxcXHMqXFxcXConKVxuLy8gPj0wLjAuMCBpcyBsaWtlIGEgc3RhclxuY3JlYXRlVG9rZW4oJ0dURTAnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMFxcXFxzKiQnKVxuY3JlYXRlVG9rZW4oJ0dURTBQUkUnLCAnXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMC0wXFxcXHMqJCcpXG4iLCAiLy8gcGFyc2Ugb3V0IGp1c3QgdGhlIG9wdGlvbnMgd2UgY2FyZSBhYm91dFxuY29uc3QgbG9vc2VPcHRpb24gPSBPYmplY3QuZnJlZXplKHsgbG9vc2U6IHRydWUgfSlcbmNvbnN0IGVtcHR5T3B0cyA9IE9iamVjdC5mcmVlemUoeyB9KVxuY29uc3QgcGFyc2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHJldHVybiBlbXB0eU9wdHNcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbG9vc2VPcHRpb25cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIiwgImNvbnN0IG51bWVyaWMgPSAvXlswLTldKyQvXG5jb25zdCBjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4ge1xuICBjb25zdCBhbnVtID0gbnVtZXJpYy50ZXN0KGEpXG4gIGNvbnN0IGJudW0gPSBudW1lcmljLnRlc3QoYilcblxuICBpZiAoYW51bSAmJiBibnVtKSB7XG4gICAgYSA9ICthXG4gICAgYiA9ICtiXG4gIH1cblxuICByZXR1cm4gYSA9PT0gYiA/IDBcbiAgICA6IChhbnVtICYmICFibnVtKSA/IC0xXG4gICAgOiAoYm51bSAmJiAhYW51bSkgPyAxXG4gICAgOiBhIDwgYiA/IC0xXG4gICAgOiAxXG59XG5cbmNvbnN0IHJjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wYXJlSWRlbnRpZmllcnMsXG4gIHJjb21wYXJlSWRlbnRpZmllcnMsXG59XG4iLCAiY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHNhZmVSZTogcmUsIHNhZmVTcmM6IHNyYywgdCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IHsgY29tcGFyZUlkZW50aWZpZXJzIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9pZGVudGlmaWVycycpXG5jbGFzcyBTZW1WZXIge1xuICBjb25zdHJ1Y3RvciAodmVyc2lvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHZlcnNpb24uaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgICByZXR1cm4gdmVyc2lvblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZlcnNpb24uIE11c3QgYmUgYSBzdHJpbmcuIEdvdCB0eXBlIFwiJHt0eXBlb2YgdmVyc2lvbn1cIi5gKVxuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGB2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICR7TUFYX0xFTkdUSH0gY2hhcmFjdGVyc2BcbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2VtVmVyJywgdmVyc2lvbiwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIC8vIHRoaXMgaXNuJ3QgYWN0dWFsbHkgcmVsZXZhbnQgZm9yIHZlcnNpb25zLCBidXQga2VlcCBpdCBzbyB0aGF0IHdlXG4gICAgLy8gZG9uJ3QgcnVuIGludG8gdHJvdWJsZSBwYXNzaW5nIHRoaXMub3B0aW9ucyBhcm91bmQuXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgY29uc3QgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHt2ZXJzaW9ufWApXG4gICAgfVxuXG4gICAgdGhpcy5yYXcgPSB2ZXJzaW9uXG5cbiAgICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICAgIHRoaXMubWFqb3IgPSArbVsxXVxuICAgIHRoaXMubWlub3IgPSArbVsyXVxuICAgIHRoaXMucGF0Y2ggPSArbVszXVxuXG4gICAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXRjaCA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5wYXRjaCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG4gICAgfVxuXG4gICAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gICAgaWYgKCFtWzRdKSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKChpZCkgPT4ge1xuICAgICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICtpZFxuICAgICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWxkID0gbVs1XSA/IG1bNV0uc3BsaXQoJy4nKSA6IFtdXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMudmVyc2lvbiArPSBgLSR7dGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZlcnNpb25cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICBjb21wYXJlIChvdGhlcikge1xuICAgIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcilcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgPT09ICdzdHJpbmcnICYmIG90aGVyID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChvdGhlci52ZXJzaW9uID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcilcbiAgfVxuXG4gIGNvbXBhcmVNYWluIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaClcbiAgICApXG4gIH1cblxuICBjb21wYXJlUHJlIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG4gICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmIG90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGxldCBpID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByZXJlbGVhc2VbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldXG4gICAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYilcbiAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYilcbiAgICAgIH1cbiAgICB9IHdoaWxlICgrK2kpXG4gIH1cblxuICBjb21wYXJlQnVpbGQgKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5idWlsZFtpXVxuICAgICAgY29uc3QgYiA9IG90aGVyLmJ1aWxkW2ldXG4gICAgICBkZWJ1ZygnYnVpbGQgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpIHtcbiAgICBpZiAocmVsZWFzZS5zdGFydHNXaXRoKCdwcmUnKSkge1xuICAgICAgaWYgKCFpZGVudGlmaWVyICYmIGlkZW50aWZpZXJCYXNlID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiBpZGVudGlmaWVyIGlzIGVtcHR5JylcbiAgICAgIH1cbiAgICAgIC8vIEF2b2lkIGFuIGludmFsaWQgc2VtdmVyIHJlc3VsdHNcbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IHIgPSBuZXcgUmVnRXhwKGBeJHt0aGlzLm9wdGlvbnMubG9vc2UgPyBzcmNbdC5QUkVSRUxFQVNFTE9PU0VdIDogc3JjW3QuUFJFUkVMRUFTRV19JGApXG4gICAgICAgIGNvbnN0IG1hdGNoID0gYC0ke2lkZW50aWZpZXJ9YC5tYXRjaChyKVxuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdICE9PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlkZW50aWZpZXI6ICR7aWRlbnRpZmllcn1gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICBjYXNlICdwcmVtYWpvcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllciwgaWRlbnRpZmllckJhc2UpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2ZXJzaW9uICR7dGhpcy5yYXd9IGlzIG5vdCBhIHByZXJlbGVhc2VgKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAgIC8vIE90aGVyd2lzZSBpbmNyZW1lbnQgbWFqb3IuXG4gICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMubWlub3IgIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnBhdGNoICE9PSAwIHx8XG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbWlub3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5taW5vcisrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IDBcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAgIC8vIDEuMi4wLTUgcGF0Y2hlcyB0byAxLjIuMFxuICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5wYXRjaCsrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgICAvLyAxLjAuMCAncHJlJyB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgICAgY2FzZSAncHJlJzoge1xuICAgICAgICBjb25zdCBiYXNlID0gTnVtYmVyKGlkZW50aWZpZXJCYXNlKSA/IDEgOiAwXG5cbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbYmFzZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaSA9IHRoaXMucHJlcmVsZWFzZS5sZW5ndGhcbiAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rK1xuICAgICAgICAgICAgICBpID0gLTJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgICBpZiAoaWRlbnRpZmllciA9PT0gdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKSAmJiBpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogaWRlbnRpZmllciBhbHJlYWR5IGV4aXN0cycpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaChiYXNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS5mb29ibHogb3IgMS4yLjAtYmV0YSBidW1wcyB0byAxLjIuMC1iZXRhLjBcbiAgICAgICAgICBsZXQgcHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCBiYXNlXVxuICAgICAgICAgIGlmIChpZGVudGlmaWVyQmFzZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByZXJlbGVhc2UgPSBbaWRlbnRpZmllcl1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnByZXJlbGVhc2VbMF0sIGlkZW50aWZpZXIpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHByZXJlbGVhc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7cmVsZWFzZX1gKVxuICAgIH1cbiAgICB0aGlzLnJhdyA9IHRoaXMuZm9ybWF0KClcbiAgICBpZiAodGhpcy5idWlsZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmF3ICs9IGArJHt0aGlzLmJ1aWxkLmpvaW4oJy4nKX1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiIsICJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9ICh2ZXJzaW9uLCBvcHRpb25zLCB0aHJvd0Vycm9ycyA9IGZhbHNlKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKCF0aHJvd0Vycm9ycykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdGhyb3cgZXJcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXG4iLCAiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHZhbGlkID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJldHVybiB2ID8gdi52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFxuIiwgImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblxuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcblxuY29uc3QgaW5jID0gKHZlcnNpb24sIHJlbGVhc2UsIG9wdGlvbnMsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKSA9PiB7XG4gIGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXJCYXNlID0gaWRlbnRpZmllclxuICAgIGlkZW50aWZpZXIgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZFxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFNlbVZlcihcbiAgICAgIHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIgPyB2ZXJzaW9uLnZlcnNpb24gOiB2ZXJzaW9uLFxuICAgICAgb3B0aW9uc1xuICAgICkuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIsIGlkZW50aWZpZXJCYXNlKS52ZXJzaW9uXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbmNcbiIsICJjb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UuanMnKVxuXG5jb25zdCBkaWZmID0gKHZlcnNpb24xLCB2ZXJzaW9uMikgPT4ge1xuICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xLCBudWxsLCB0cnVlKVxuICBjb25zdCB2MiA9IHBhcnNlKHZlcnNpb24yLCBudWxsLCB0cnVlKVxuICBjb25zdCBjb21wYXJpc29uID0gdjEuY29tcGFyZSh2MilcblxuICBpZiAoY29tcGFyaXNvbiA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCB2MUhpZ2hlciA9IGNvbXBhcmlzb24gPiAwXG4gIGNvbnN0IGhpZ2hWZXJzaW9uID0gdjFIaWdoZXIgPyB2MSA6IHYyXG4gIGNvbnN0IGxvd1ZlcnNpb24gPSB2MUhpZ2hlciA/IHYyIDogdjFcbiAgY29uc3QgaGlnaEhhc1ByZSA9ICEhaGlnaFZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGhcbiAgY29uc3QgbG93SGFzUHJlID0gISFsb3dWZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoXG5cbiAgaWYgKGxvd0hhc1ByZSAmJiAhaGlnaEhhc1ByZSkge1xuICAgIC8vIEdvaW5nIGZyb20gcHJlcmVsZWFzZSAtPiBubyBwcmVyZWxlYXNlIHJlcXVpcmVzIHNvbWUgc3BlY2lhbCBjYXNpbmdcblxuICAgIC8vIElmIHRoZSBsb3cgdmVyc2lvbiBoYXMgb25seSBhIG1ham9yLCB0aGVuIGl0IHdpbGwgYWx3YXlzIGJlIGEgbWFqb3JcbiAgICAvLyBTb21lIGV4YW1wbGVzOlxuICAgIC8vIDEuMC4wLTEgLT4gMS4wLjBcbiAgICAvLyAxLjAuMC0xIC0+IDEuMS4xXG4gICAgLy8gMS4wLjAtMSAtPiAyLjAuMFxuICAgIGlmICghbG93VmVyc2lvbi5wYXRjaCAmJiAhbG93VmVyc2lvbi5taW5vcikge1xuICAgICAgcmV0dXJuICdtYWpvcidcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbWFpbiBwYXJ0IGhhcyBubyBkaWZmZXJlbmNlXG4gICAgaWYgKGxvd1ZlcnNpb24uY29tcGFyZU1haW4oaGlnaFZlcnNpb24pID09PSAwKSB7XG4gICAgICBpZiAobG93VmVyc2lvbi5taW5vciAmJiAhbG93VmVyc2lvbi5wYXRjaCkge1xuICAgICAgICByZXR1cm4gJ21pbm9yJ1xuICAgICAgfVxuICAgICAgcmV0dXJuICdwYXRjaCdcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgdGhlIGBwcmVgIHByZWZpeCBpZiB3ZSBhcmUgZ29pbmcgdG8gYSBwcmVyZWxlYXNlIHZlcnNpb25cbiAgY29uc3QgcHJlZml4ID0gaGlnaEhhc1ByZSA/ICdwcmUnIDogJydcblxuICBpZiAodjEubWFqb3IgIT09IHYyLm1ham9yKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICdtYWpvcidcbiAgfVxuXG4gIGlmICh2MS5taW5vciAhPT0gdjIubWlub3IpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJ21pbm9yJ1xuICB9XG5cbiAgaWYgKHYxLnBhdGNoICE9PSB2Mi5wYXRjaCkge1xuICAgIHJldHVybiBwcmVmaXggKyAncGF0Y2gnXG4gIH1cblxuICAvLyBoaWdoIGFuZCBsb3cgYXJlIHByZWxlYXNlc1xuICByZXR1cm4gJ3ByZXJlbGVhc2UnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1ham9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvclxubW9kdWxlLmV4cG9ydHMgPSBtYWpvclxuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IG1pbm9yID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vclxubW9kdWxlLmV4cG9ydHMgPSBtaW5vclxuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwgImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBwcmVyZWxlYXNlID0gKHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucylcbiAgcmV0dXJuIChwYXJzZWQgJiYgcGFyc2VkLnByZXJlbGVhc2UubGVuZ3RoKSA/IHBhcnNlZC5wcmVyZWxlYXNlIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBwcmVyZWxlYXNlXG4iLCAiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT5cbiAgbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCAiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCByY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShiLCBhLCBsb29zZSlcbm1vZHVsZS5leHBvcnRzID0gcmNvbXBhcmVcbiIsICJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IGNvbXBhcmVCdWlsZCA9IChhLCBiLCBsb29zZSkgPT4ge1xuICBjb25zdCB2ZXJzaW9uQSA9IG5ldyBTZW1WZXIoYSwgbG9vc2UpXG4gIGNvbnN0IHZlcnNpb25CID0gbmV3IFNlbVZlcihiLCBsb29zZSlcbiAgcmV0dXJuIHZlcnNpb25BLmNvbXBhcmUodmVyc2lvbkIpIHx8IHZlcnNpb25BLmNvbXBhcmVCdWlsZCh2ZXJzaW9uQilcbn1cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUJ1aWxkXG4iLCAiY29uc3QgY29tcGFyZUJ1aWxkID0gcmVxdWlyZSgnLi9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSAobGlzdCwgbG9vc2UpID0+IGxpc3Quc29ydCgoYSwgYikgPT4gY29tcGFyZUJ1aWxkKGEsIGIsIGxvb3NlKSlcbm1vZHVsZS5leHBvcnRzID0gc29ydFxuIiwgImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCByc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSByc29ydFxuIiwgImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3QgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID4gMFxubW9kdWxlLmV4cG9ydHMgPSBndFxuIiwgImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHQgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDwgMFxubW9kdWxlLmV4cG9ydHMgPSBsdFxuIiwgImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGVxXG4iLCAiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBuZXEgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwXG5tb2R1bGUuZXhwb3J0cyA9IG5lcVxuIiwgImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIiwgImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbHRlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGx0ZVxuIiwgImNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5jb25zdCBuZXEgPSByZXF1aXJlKCcuL25lcScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4vZ3QnKVxuY29uc3QgZ3RlID0gcmVxdWlyZSgnLi9ndGUnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuL2x0JylcbmNvbnN0IGx0ZSA9IHJlcXVpcmUoJy4vbHRlJylcblxuY29uc3QgY21wID0gKGEsIG9wLCBiLCBsb29zZSkgPT4ge1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICB9XG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYSA9IGEudmVyc2lvblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICB9XG4gICAgICByZXR1cm4gYSAhPT0gYlxuXG4gICAgY2FzZSAnJzpcbiAgICBjYXNlICc9JzpcbiAgICBjYXNlICc9PSc6XG4gICAgICByZXR1cm4gZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICchPSc6XG4gICAgICByZXR1cm4gbmVxKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+PSc6XG4gICAgICByZXR1cm4gZ3RlKGEsIGIsIGxvb3NlKVxuXG4gICAgY2FzZSAnPCc6XG4gICAgICByZXR1cm4gbHQoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgb3BlcmF0b3I6ICR7b3B9YClcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBjbXBcbiIsICJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuY29uc3QgeyBzYWZlUmU6IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyByZVt0LkNPRVJDRUZVTExdIDogcmVbdC5DT0VSQ0VdKVxuICB9IGVsc2Uge1xuICAgIC8vIEZpbmQgdGhlIHJpZ2h0LW1vc3QgY29lcmNpYmxlIHN0cmluZyB0aGF0IGRvZXMgbm90IHNoYXJlXG4gICAgLy8gYSB0ZXJtaW51cyB3aXRoIGEgbW9yZSBsZWZ0LXdhcmQgY29lcmNpYmxlIHN0cmluZy5cbiAgICAvLyBFZywgJzEuMi4zLjQnIHdhbnRzIHRvIGNvZXJjZSAnMi4zLjQnLCBub3QgJzMuNCcgb3IgJzQnXG4gICAgLy8gV2l0aCBpbmNsdWRlUHJlcmVsZWFzZSBvcHRpb24gc2V0LCAnMS4yLjMuNC1yYycgd2FudHMgdG8gY29lcmNlICcyLjMuNC1yYycsIG5vdCAnMi4zLjQnXG4gICAgLy9cbiAgICAvLyBXYWxrIHRocm91Z2ggdGhlIHN0cmluZyBjaGVja2luZyB3aXRoIGEgL2cgcmVnZXhwXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBpbmRleCBzbyBhcyB0byBwaWNrIHVwIG92ZXJsYXBwaW5nIG1hdGNoZXMuXG4gICAgLy8gU3RvcCB3aGVuIHdlIGdldCBhIG1hdGNoIHRoYXQgZW5kcyBhdCB0aGUgc3RyaW5nIGVuZCwgc2luY2Ugbm9cbiAgICAvLyBjb2VyY2libGUgc3RyaW5nIGNhbiBiZSBtb3JlIHJpZ2h0LXdhcmQgd2l0aG91dCB0aGUgc2FtZSB0ZXJtaW51cy5cbiAgICBjb25zdCBjb2VyY2VSdGxSZWdleCA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyByZVt0LkNPRVJDRVJUTEZVTExdIDogcmVbdC5DT0VSQ0VSVExdXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSBjb2VyY2VSdGxSZWdleC5leGVjKHZlcnNpb24pKSAmJlxuICAgICAgICAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoICE9PSB2ZXJzaW9uLmxlbmd0aClcbiAgICApIHtcbiAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICAgIG5leHQuaW5kZXggKyBuZXh0WzBdLmxlbmd0aCAhPT0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2ggPSBuZXh0XG4gICAgICB9XG4gICAgICBjb2VyY2VSdGxSZWdleC5sYXN0SW5kZXggPSBuZXh0LmluZGV4ICsgbmV4dFsxXS5sZW5ndGggKyBuZXh0WzJdLmxlbmd0aFxuICAgIH1cbiAgICAvLyBsZWF2ZSBpdCBpbiBhIGNsZWFuIHN0YXRlXG4gICAgY29lcmNlUnRsUmVnZXgubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBtYWpvciA9IG1hdGNoWzJdXG4gIGNvbnN0IG1pbm9yID0gbWF0Y2hbM10gfHwgJzAnXG4gIGNvbnN0IHBhdGNoID0gbWF0Y2hbNF0gfHwgJzAnXG4gIGNvbnN0IHByZXJlbGVhc2UgPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmIG1hdGNoWzVdID8gYC0ke21hdGNoWzVdfWAgOiAnJ1xuICBjb25zdCBidWlsZCA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiYgbWF0Y2hbNl0gPyBgKyR7bWF0Y2hbNl19YCA6ICcnXG5cbiAgcmV0dXJuIHBhcnNlKGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSR7cHJlcmVsZWFzZX0ke2J1aWxkfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIiwgImNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWF4ID0gMTAwMFxuICAgIHRoaXMubWFwID0gbmV3IE1hcCgpXG4gIH1cblxuICBnZXQgKGtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tYXAuZ2V0KGtleSlcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGtleSBmcm9tIHRoZSBtYXAgYW5kIGFkZCBpdCB0byB0aGUgZW5kXG4gICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KVxuICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpXG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cblxuICBkZWxldGUgKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5kZWxldGUoa2V5KVxuICB9XG5cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgZGVsZXRlZCA9IHRoaXMuZGVsZXRlKGtleSlcblxuICAgIGlmICghZGVsZXRlZCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiBjYWNoZSBpcyBmdWxsLCBkZWxldGUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbVxuICAgICAgaWYgKHRoaXMubWFwLnNpemUgPj0gdGhpcy5tYXgpIHtcbiAgICAgICAgY29uc3QgZmlyc3RLZXkgPSB0aGlzLm1hcC5rZXlzKCkubmV4dCgpLnZhbHVlXG4gICAgICAgIHRoaXMuZGVsZXRlKGZpcnN0S2V5KVxuICAgICAgfVxuXG4gICAgICB0aGlzLm1hcC5zZXQoa2V5LCB2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsICJjb25zdCBTUEFDRV9DSEFSQUNURVJTID0gL1xccysvZ1xuXG4vLyBob2lzdGVkIGNsYXNzIGZvciBjeWNsaWMgZGVwZW5kZW5jeVxuY2xhc3MgUmFuZ2Uge1xuICBjb25zdHJ1Y3RvciAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgaWYgKFxuICAgICAgICByYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcmFuZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UucmF3LCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICAgIC8vIGp1c3QgcHV0IGl0IGluIHRoZSBzZXQgYW5kIHJldHVyblxuICAgICAgdGhpcy5yYXcgPSByYW5nZS52YWx1ZVxuICAgICAgdGhpcy5zZXQgPSBbW3JhbmdlXV1cbiAgICAgIHRoaXMuZm9ybWF0dGVkID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QgcmVkdWNlIGFsbCB3aGl0ZXNwYWNlIGFzIG11Y2ggYXMgcG9zc2libGUgc28gd2UgZG8gbm90IGhhdmUgdG8gcmVseVxuICAgIC8vIG9uIHBvdGVudGlhbGx5IHNsb3cgcmVnZXhlcyBsaWtlIFxccyouIFRoaXMgaXMgdGhlbiBzdG9yZWQgYW5kIHVzZWQgZm9yXG4gICAgLy8gZnV0dXJlIGVycm9yIG1lc3NhZ2VzIGFzIHdlbGwuXG4gICAgdGhpcy5yYXcgPSByYW5nZS50cmltKCkucmVwbGFjZShTUEFDRV9DSEFSQUNURVJTLCAnICcpXG5cbiAgICAvLyBGaXJzdCwgc3BsaXQgb24gfHxcbiAgICB0aGlzLnNldCA9IHRoaXMucmF3XG4gICAgICAuc3BsaXQoJ3x8JylcbiAgICAgIC8vIG1hcCB0aGUgcmFuZ2UgdG8gYSAyZCBhcnJheSBvZiBjb21wYXJhdG9yc1xuICAgICAgLm1hcChyID0+IHRoaXMucGFyc2VSYW5nZShyLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHt0aGlzLnJhd31gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXQgPSBbZmlyc3RdXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgKiwgdGhlbiB0aGUgcmFuZ2UgaXMganVzdCAqXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSAmJiBpc0FueShjWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBbY11cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXR0ZWQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCByYW5nZSAoKSB7XG4gICAgaWYgKHRoaXMuZm9ybWF0dGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZm9ybWF0dGVkID0gJydcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gJ3x8J1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy5zZXRbaV1cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjb21wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZWQgKz0gJyAnXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVkICs9IGNvbXBzW2tdLnRvU3RyaW5nKCkudHJpbSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgLy8gbWVtb2l6ZSByYW5nZSBwYXJzaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAvLyB0aGlzIGlzIGEgdmVyeSBob3QgcGF0aCwgYW5kIGZ1bGx5IGRldGVybWluaXN0aWMuXG4gICAgY29uc3QgbWVtb09wdHMgPVxuICAgICAgKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJiBGTEFHX0lOQ0xVREVfUFJFUkVMRUFTRSkgfFxuICAgICAgKHRoaXMub3B0aW9ucy5sb29zZSAmJiBGTEFHX0xPT1NFKVxuICAgIGNvbnN0IG1lbW9LZXkgPSBtZW1vT3B0cyArICc6JyArIHJhbmdlXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFxuICAgIH1cblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuXG4gICAgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpXG4gICAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygndGlsZGUgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY2FyZXQgdHJpbScsIHJhbmdlKVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gICAgbGV0IHJhbmdlTGlzdCA9IHJhbmdlXG4gICAgICAuc3BsaXQoJyAnKVxuICAgICAgLm1hcChjb21wID0+IHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLmpvaW4oJyAnKVxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC8vID49MC4wLjAgaXMgZXF1aXZhbGVudCB0byAqXG4gICAgICAubWFwKGNvbXAgPT4gcmVwbGFjZUdURTAoY29tcCwgdGhpcy5vcHRpb25zKSlcblxuICAgIGlmIChsb29zZSkge1xuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICAgIHJhbmdlTGlzdCA9IHJhbmdlTGlzdC5maWx0ZXIoY29tcCA9PiB7XG4gICAgICAgIGRlYnVnKCdsb29zZSBpbnZhbGlkIGZpbHRlcicsIGNvbXAsIHRoaXMub3B0aW9ucylcbiAgICAgICAgcmV0dXJuICEhY29tcC5tYXRjaChyZVt0LkNPTVBBUkFUT1JMT09TRV0pXG4gICAgICB9KVxuICAgIH1cbiAgICBkZWJ1ZygncmFuZ2UgbGlzdCcsIHJhbmdlTGlzdClcblxuICAgIC8vIGlmIGFueSBjb21wYXJhdG9ycyBhcmUgdGhlIG51bGwgc2V0LCB0aGVuIHJlcGxhY2Ugd2l0aCBKVVNUIG51bGwgc2V0XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBjb21wYXJhdG9yLCByZW1vdmUgYW55ICogY29tcGFyYXRvcnNcbiAgICAvLyBhbHNvLCBkb24ndCBpbmNsdWRlIHRoZSBzYW1lIGNvbXBhcmF0b3IgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCByYW5nZU1hcCA9IG5ldyBNYXAoKVxuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2VMaXN0Lm1hcChjb21wID0+IG5ldyBDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgZm9yIChjb25zdCBjb21wIG9mIGNvbXBhcmF0b3JzKSB7XG4gICAgICBpZiAoaXNOdWxsU2V0KGNvbXApKSB7XG4gICAgICAgIHJldHVybiBbY29tcF1cbiAgICAgIH1cbiAgICAgIHJhbmdlTWFwLnNldChjb21wLnZhbHVlLCBjb21wKVxuICAgIH1cbiAgICBpZiAocmFuZ2VNYXAuc2l6ZSA+IDEgJiYgcmFuZ2VNYXAuaGFzKCcnKSkge1xuICAgICAgcmFuZ2VNYXAuZGVsZXRlKCcnKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5yYW5nZU1hcC52YWx1ZXMoKV1cbiAgICBjYWNoZS5zZXQobWVtb0tleSwgcmVzdWx0KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGludGVyc2VjdHMgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNldC5zb21lKCh0aGlzQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzU2F0aXNmaWFibGUodGhpc0NvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICByYW5nZS5zZXQuc29tZSgocmFuZ2VDb21wYXJhdG9ycykgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc1NhdGlzZmlhYmxlKHJhbmdlQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgICAgICB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoKHRoaXNDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KChyYW5nZUNvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbiwgdGhpcy5vcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlXG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2xydWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSgpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4vY29tcGFyYXRvcicpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IHtcbiAgc2FmZVJlOiByZSxcbiAgdCxcbiAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICB0aWxkZVRyaW1SZXBsYWNlLFxuICBjYXJldFRyaW1SZXBsYWNlLFxufSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IHsgRkxBR19JTkNMVURFX1BSRVJFTEVBU0UsIEZMQUdfTE9PU0UgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5jb25zdCBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wLTBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MC4wLjEgLS0+ID49MC4wLjEgPDAuMS4wLTBcbmNvbnN0IHJlcGxhY2VUaWxkZXMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VUaWxkZShjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuLy8gXjAuMC4xIC0tPiA+PTAuMC4xIDwwLjAuMi0wXG4vLyBeMC4xLjAgLS0+ID49MC4xLjAgPDAuMi4wLTBcbmNvbnN0IHJlcGxhY2VDYXJldHMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAuc3BsaXQoL1xccysvKVxuICAgIC5tYXAoKGMpID0+IHJlcGxhY2VDYXJldChjLCBvcHRpb25zKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wXG4gICAgLnNwbGl0KC9cXHMrLylcbiAgICAubWFwKChjKSA9PiByZXBsYWNlWFJhbmdlKGMsIG9wdGlvbnMpKVxuICAgIC5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICBjb25zdCB4TSA9IGlzWChNKVxuICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pXG4gICAgY29uc3QgeHAgPSB4bSB8fCBpc1gocClcbiAgICBjb25zdCBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgIHByID0gJy0wJ1xuICAgICAgfVxuXG4gICAgICByZXQgPSBgJHtndGx0ICsgTX0uJHttfS4ke3B9JHtwcn1gXG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3ByfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KVxuXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuY29uc3QgcmVwbGFjZVN0YXJzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpXG4gIC8vIExvb3NlbmVzcyBpcyBpZ25vcmVkIGhlcmUuICBzdGFyIGlzIGFsd2F5cyBhcyBsb29zZSBhcyBpdCBnZXRzIVxuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAucmVwbGFjZShyZVt0LlNUQVJdLCAnJylcbn1cblxuY29uc3QgcmVwbGFjZUdURTAgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZUdURTAnLCBjb21wLCBvcHRpb25zKVxuICByZXR1cm4gY29tcFxuICAgIC50cmltKClcbiAgICAucmVwbGFjZShyZVtvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gdC5HVEUwUFJFIDogdC5HVEUwXSwgJycpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcGFzc2VkIHRvIHN0cmluZy5yZXBsYWNlKHJlW3QuSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTAgQW55IDMuNC54IHdpbGwgZG9cbi8vIDEuMiAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wXG4vLyBUT0RPIGJ1aWxkP1xuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwcikgPT4ge1xuICBpZiAoaXNYKGZNKSkge1xuICAgIGZyb20gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWChmbSkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uMC4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoaXNYKGZwKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4ke2ZtfS4wJHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH0gZWxzZSBpZiAoZnByKSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX1gXG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGA+PSR7ZnJvbX0ke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfVxuXG4gIGlmIChpc1godE0pKSB7XG4gICAgdG8gPSAnJ1xuICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICB0byA9IGA8JHsrdE0gKyAxfS4wLjAtMGBcbiAgfSBlbHNlIGlmIChpc1godHApKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7K3RtICsgMX0uMC0wYFxuICB9IGVsc2UgaWYgKHRwcikge1xuICAgIHRvID0gYDw9JHt0TX0uJHt0bX0uJHt0cH0tJHt0cHJ9YFxuICB9IGVsc2UgaWYgKGluY1ByKSB7XG4gICAgdG8gPSBgPCR7dE19LiR7dG19LiR7K3RwICsgMX0tMGBcbiAgfSBlbHNlIHtcbiAgICB0byA9IGA8PSR7dG99YFxuICB9XG5cbiAgcmV0dXJuIGAke2Zyb219ICR7dG99YC50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiY29uc3QgQU5ZID0gU3ltYm9sKCdTZW1WZXIgQU5ZJylcbi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBDb21wYXJhdG9yIHtcbiAgc3RhdGljIGdldCBBTlkgKCkge1xuICAgIHJldHVybiBBTllcbiAgfVxuXG4gIGNvbnN0cnVjdG9yIChjb21wLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICAgIHJldHVybiBjb21wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wID0gY29tcC52YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXAgPSBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMucGFyc2UoY29tcClcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uXG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXAnLCB0aGlzKVxuICB9XG5cbiAgcGFyc2UgKGNvbXApIHtcbiAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IG0gPSBjb21wLm1hdGNoKHIpXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY29tcGFyYXRvcjogJHtjb21wfWApXG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRvciA9IG1bMV0gIT09IHVuZGVmaW5lZCA/IG1bMV0gOiAnJ1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgIHRoaXMub3BlcmF0b3IgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICAgIGlmICghbVsyXSkge1xuICAgICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSlcbiAgICB9XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGludGVyc2VjdHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucykudGVzdCh0aGlzLnZhbHVlKVxuICAgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKS50ZXN0KGNvbXAuc2VtdmVyKVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIC8vIFNwZWNpYWwgY2FzZXMgd2hlcmUgbm90aGluZyBjYW4gcG9zc2libHkgYmUgbG93ZXJcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgICAgKHRoaXMudmFsdWUgPT09ICc8MC4wLjAtMCcgfHwgY29tcC52YWx1ZSA9PT0gJzwwLjAuMC0wJykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICAgICh0aGlzLnZhbHVlLnN0YXJ0c1dpdGgoJzwwLjAuMCcpIHx8IGNvbXAudmFsdWUuc3RhcnRzV2l0aCgnPDAuMC4wJykpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBTYW1lIGRpcmVjdGlvbiBpbmNyZWFzaW5nICg+IG9yID49KVxuICAgIGlmICh0aGlzLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSAmJiBjb21wLm9wZXJhdG9yLnN0YXJ0c1dpdGgoJz4nKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gU2FtZSBkaXJlY3Rpb24gZGVjcmVhc2luZyAoPCBvciA8PSlcbiAgICBpZiAodGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIHNhbWUgU2VtVmVyIGFuZCBib3RoIHNpZGVzIGFyZSBpbmNsdXNpdmUgKDw9IG9yID49KVxuICAgIGlmIChcbiAgICAgICh0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5pbmNsdWRlcygnPScpICYmIGNvbXAub3BlcmF0b3IuaW5jbHVkZXMoJz0nKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gb3Bwb3NpdGUgZGlyZWN0aW9ucyBsZXNzIHRoYW5cbiAgICBpZiAoY21wKHRoaXMuc2VtdmVyLCAnPCcsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJlxuICAgICAgdGhpcy5vcGVyYXRvci5zdGFydHNXaXRoKCc+JykgJiYgY29tcC5vcGVyYXRvci5zdGFydHNXaXRoKCc8JykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIG9wcG9zaXRlIGRpcmVjdGlvbnMgZ3JlYXRlciB0aGFuXG4gICAgaWYgKGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgIHRoaXMub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPCcpICYmIGNvbXAub3BlcmF0b3Iuc3RhcnRzV2l0aCgnPicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhcmF0b3JcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7IHNhZmVSZTogcmUsIHQgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2UnKVxuIiwgImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBzYXRpc2ZpZXMgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gcmFuZ2UudGVzdCh2ZXJzaW9uKVxufVxubW9kdWxlLmV4cG9ydHMgPSBzYXRpc2ZpZXNcbiIsICJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCAiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuY29uc3QgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1heCA9IG51bGxcbiAgbGV0IG1heFNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1heFNhdGlzZnlpbmdcbiIsICJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IG1pblNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHZcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW5cbn1cbm1vZHVsZS5leHBvcnRzID0gbWluU2F0aXNmeWluZ1xuIiwgImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5cbmNvbnN0IG1pblZlcnNpb24gPSAocmFuZ2UsIGxvb3NlKSA9PiB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICBsZXQgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBzZXRNaW4gPSBudWxsXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIGNvbnN0IGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgc2V0TWluID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3BlcmF0aW9uOiAke2NvbXBhcmF0b3Iub3BlcmF0b3J9YClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSkge1xuICAgICAgbWludmVyID0gc2V0TWluXG4gICAgfVxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5WZXJzaW9uXG4iLCAiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iLCAiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvcicpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiIsICIvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5jb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbmNvbnN0IGd0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBndHJcbiIsICJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwgImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyLCBvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iLCAiLy8gZ2l2ZW4gYSBzZXQgb2YgdmVyc2lvbnMgYW5kIGEgcmFuZ2UsIGNyZWF0ZSBhIFwic2ltcGxpZmllZFwiIHJhbmdlXG4vLyB0aGF0IGluY2x1ZGVzIHRoZSBzYW1lIHZlcnNpb25zIHRoYXQgdGhlIG9yaWdpbmFsIHJhbmdlIGRvZXNcbi8vIElmIHRoZSBvcmlnaW5hbCByYW5nZSBpcyBzaG9ydGVyIHRoYW4gdGhlIHNpbXBsaWZpZWQgb25lLCByZXR1cm4gdGhhdC5cbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcbm1vZHVsZS5leHBvcnRzID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzZXQgPSBbXVxuICBsZXQgZmlyc3QgPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gdmVyc2lvblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbZmlyc3QsIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIGZpcnN0ID0gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAoZmlyc3QpIHtcbiAgICBzZXQucHVzaChbZmlyc3QsIG51bGxdKVxuICB9XG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIH0gZWxzZSBpZiAoIW1heCAmJiBtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICB9IGVsc2UgaWYgKCFtYXgpIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA+PSR7bWlufWApXG4gICAgfSBlbHNlIGlmIChtaW4gPT09IHZbMF0pIHtcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICAgIH1cbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkID0gcmFuZ2VzLmpvaW4oJyB8fCAnKVxuICBjb25zdCBvcmlnaW5hbCA9IHR5cGVvZiByYW5nZS5yYXcgPT09ICdzdHJpbmcnID8gcmFuZ2UucmF3IDogU3RyaW5nKHJhbmdlKVxuICByZXR1cm4gc2ltcGxpZmllZC5sZW5ndGggPCBvcmlnaW5hbC5sZW5ndGggPyBzaW1wbGlmaWVkIDogcmFuZ2Vcbn1cbiIsICJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1Yikge1xuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgICAgfVxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBtaW5pbXVtVmVyc2lvbldpdGhQcmVSZWxlYXNlID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wLTAnKV1cbmNvbnN0IG1pbmltdW1WZXJzaW9uID0gW25ldyBDb21wYXJhdG9yKCc+PTAuMC4wJyldXG5cbmNvbnN0IHNpbXBsZVN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3ViID09PSBkb20pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgc3ViID0gbWluaW11bVZlcnNpb25XaXRoUHJlUmVsZWFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWIgPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBtaW5pbXVtVmVyc2lvblxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgZ3QgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICB9IGVsc2UgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVxU2V0LmFkZChjLnNlbXZlcilcbiAgICB9XG4gIH1cblxuICBpZiAoZXFTZXQuc2l6ZSA+IDEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSBpZiAoZ3RsdENvbXAgPT09IDAgJiYgKGd0Lm9wZXJhdG9yICE9PSAnPj0nIHx8IGx0Lm9wZXJhdG9yICE9PSAnPD0nKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvLyB3aWxsIGl0ZXJhdGUgb25lIG9yIHplcm8gdGltZXNcbiAgZm9yIChjb25zdCBlcSBvZiBlcVNldCkge1xuICAgIGlmIChndCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcoZ3QpLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAobHQgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGx0KSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgaWYgKCFzYXRpc2ZpZXMoZXEsIFN0cmluZyhjKSwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndC5vcGVyYXRvciA9PT0gJz49JyAmJiAhc2F0aXNmaWVzKGd0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGx0Lm9wZXJhdG9yID09PSAnPD0nICYmICFzYXRpc2ZpZXMobHQuc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChsdCAmJiBoYXNEb21HVCAmJiAhZ3QgJiYgZ3RsdENvbXAgIT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHdlIG5lZWRlZCBhIHByZXJlbGVhc2UgcmFuZ2UgaW4gYSBzcGVjaWZpYyB0dXBsZSwgYnV0IGRpZG4ndCBnZXQgb25lXG4gIC8vIHRoZW4gdGhpcyBpc24ndCBhIHN1YnNldC4gIGVnID49MS4yLjMtcHJlIGlzIG5vdCBhIHN1YnNldCBvZiA+PTEuMC4wLFxuICAvLyBiZWNhdXNlIGl0IGluY2x1ZGVzIHByZXJlbGVhc2VzIGluIHRoZSAxLjIuMyB0dXBsZVxuICBpZiAobmVlZERvbUdUUHJlIHx8IG5lZWREb21MVFByZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPiAwID8gYVxuICAgIDogY29tcCA8IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPicgJiYgYS5vcGVyYXRvciA9PT0gJz49JyA/IGJcbiAgICA6IGFcbn1cblxuLy8gPD0xLjIuMyBpcyBoaWdoZXIgdGhhbiA8MS4yLjNcbmNvbnN0IGxvd2VyTFQgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPCAwID8gYVxuICAgIDogY29tcCA+IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPCcgJiYgYS5vcGVyYXRvciA9PT0gJzw9JyA/IGJcbiAgICA6IGFcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdWJzZXRcbiIsICIvLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBpZGVudGlmaWVycyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvaWRlbnRpZmllcnMnKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXJzZScpXG5jb25zdCB2YWxpZCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3ZhbGlkJylcbmNvbnN0IGNsZWFuID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKVxuY29uc3QgaW5jID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvaW5jJylcbmNvbnN0IGRpZmYgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9kaWZmJylcbmNvbnN0IG1ham9yID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKVxuY29uc3QgbWlub3IgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9taW5vcicpXG5jb25zdCBwYXRjaCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhdGNoJylcbmNvbnN0IHByZXJlbGVhc2UgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlJylcbmNvbnN0IHJjb21wYXJlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcmNvbXBhcmUnKVxuY29uc3QgY29tcGFyZUxvb3NlID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpXG5jb25zdCBjb21wYXJlQnVpbGQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkJylcbmNvbnN0IHNvcnQgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zb3J0JylcbmNvbnN0IHJzb3J0ID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2x0JylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvbmVxJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0ZScpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvY21wJylcbmNvbnN0IGNvZXJjZSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvZXJjZScpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMvc2F0aXNmaWVzJylcbmNvbnN0IHRvQ29tcGFyYXRvcnMgPSByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gcmVxdWlyZSgnLi9yYW5nZXMvbWF4LXNhdGlzZnlpbmcnKVxuY29uc3QgbWluU2F0aXNmeWluZyA9IHJlcXVpcmUoJy4vcmFuZ2VzL21pbi1zYXRpc2Z5aW5nJylcbmNvbnN0IG1pblZlcnNpb24gPSByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpXG5jb25zdCB2YWxpZFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvdmFsaWQnKVxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vcmFuZ2VzL291dHNpZGUnKVxuY29uc3QgZ3RyID0gcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJylcbmNvbnN0IGx0ciA9IHJlcXVpcmUoJy4vcmFuZ2VzL2x0cicpXG5jb25zdCBpbnRlcnNlY3RzID0gcmVxdWlyZSgnLi9yYW5nZXMvaW50ZXJzZWN0cycpXG5jb25zdCBzaW1wbGlmeVJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKVxuY29uc3Qgc3Vic2V0ID0gcmVxdWlyZSgnLi9yYW5nZXMvc3Vic2V0Jylcbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZSxcbiAgdmFsaWQsXG4gIGNsZWFuLFxuICBpbmMsXG4gIGRpZmYsXG4gIG1ham9yLFxuICBtaW5vcixcbiAgcGF0Y2gsXG4gIHByZXJlbGVhc2UsXG4gIGNvbXBhcmUsXG4gIHJjb21wYXJlLFxuICBjb21wYXJlTG9vc2UsXG4gIGNvbXBhcmVCdWlsZCxcbiAgc29ydCxcbiAgcnNvcnQsXG4gIGd0LFxuICBsdCxcbiAgZXEsXG4gIG5lcSxcbiAgZ3RlLFxuICBsdGUsXG4gIGNtcCxcbiAgY29lcmNlLFxuICBDb21wYXJhdG9yLFxuICBSYW5nZSxcbiAgc2F0aXNmaWVzLFxuICB0b0NvbXBhcmF0b3JzLFxuICBtYXhTYXRpc2Z5aW5nLFxuICBtaW5TYXRpc2Z5aW5nLFxuICBtaW5WZXJzaW9uLFxuICB2YWxpZFJhbmdlLFxuICBvdXRzaWRlLFxuICBndHIsXG4gIGx0cixcbiAgaW50ZXJzZWN0cyxcbiAgc2ltcGxpZnlSYW5nZSxcbiAgc3Vic2V0LFxuICBTZW1WZXIsXG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogY29uc3RhbnRzLlNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIFJFTEVBU0VfVFlQRVM6IGNvbnN0YW50cy5SRUxFQVNFX1RZUEVTLFxuICBjb21wYXJlSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogaWRlbnRpZmllcnMucmNvbXBhcmVJZGVudGlmaWVycyxcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFOU0lfQkFDS0dST1VORF9PRkZTRVQgPSAxMDtcblxuY29uc3Qgd3JhcEFuc2kyNTYgPSAob2Zmc2V0ID0gMCkgPT4gY29kZSA9PiBgXFx1MDAxQlskezM4ICsgb2Zmc2V0fTs1OyR7Y29kZX1tYDtcblxuY29uc3Qgd3JhcEFuc2kxNm0gPSAob2Zmc2V0ID0gMCkgPT4gKHJlZCwgZ3JlZW4sIGJsdWUpID0+IGBcXHUwMDFCWyR7MzggKyBvZmZzZXR9OzI7JHtyZWR9OyR7Z3JlZW59OyR7Ymx1ZX1tYDtcblxuZnVuY3Rpb24gYXNzZW1ibGVTdHlsZXMoKSB7XG5cdGNvbnN0IGNvZGVzID0gbmV3IE1hcCgpO1xuXHRjb25zdCBzdHlsZXMgPSB7XG5cdFx0bW9kaWZpZXI6IHtcblx0XHRcdHJlc2V0OiBbMCwgMF0sXG5cdFx0XHQvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG5cdFx0XHRib2xkOiBbMSwgMjJdLFxuXHRcdFx0ZGltOiBbMiwgMjJdLFxuXHRcdFx0aXRhbGljOiBbMywgMjNdLFxuXHRcdFx0dW5kZXJsaW5lOiBbNCwgMjRdLFxuXHRcdFx0b3ZlcmxpbmU6IFs1MywgNTVdLFxuXHRcdFx0aW52ZXJzZTogWzcsIDI3XSxcblx0XHRcdGhpZGRlbjogWzgsIDI4XSxcblx0XHRcdHN0cmlrZXRocm91Z2g6IFs5LCAyOV1cblx0XHR9LFxuXHRcdGNvbG9yOiB7XG5cdFx0XHRibGFjazogWzMwLCAzOV0sXG5cdFx0XHRyZWQ6IFszMSwgMzldLFxuXHRcdFx0Z3JlZW46IFszMiwgMzldLFxuXHRcdFx0eWVsbG93OiBbMzMsIDM5XSxcblx0XHRcdGJsdWU6IFszNCwgMzldLFxuXHRcdFx0bWFnZW50YTogWzM1LCAzOV0sXG5cdFx0XHRjeWFuOiBbMzYsIDM5XSxcblx0XHRcdHdoaXRlOiBbMzcsIDM5XSxcblxuXHRcdFx0Ly8gQnJpZ2h0IGNvbG9yXG5cdFx0XHRibGFja0JyaWdodDogWzkwLCAzOV0sXG5cdFx0XHRyZWRCcmlnaHQ6IFs5MSwgMzldLFxuXHRcdFx0Z3JlZW5CcmlnaHQ6IFs5MiwgMzldLFxuXHRcdFx0eWVsbG93QnJpZ2h0OiBbOTMsIDM5XSxcblx0XHRcdGJsdWVCcmlnaHQ6IFs5NCwgMzldLFxuXHRcdFx0bWFnZW50YUJyaWdodDogWzk1LCAzOV0sXG5cdFx0XHRjeWFuQnJpZ2h0OiBbOTYsIDM5XSxcblx0XHRcdHdoaXRlQnJpZ2h0OiBbOTcsIDM5XVxuXHRcdH0sXG5cdFx0YmdDb2xvcjoge1xuXHRcdFx0YmdCbGFjazogWzQwLCA0OV0sXG5cdFx0XHRiZ1JlZDogWzQxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuOiBbNDIsIDQ5XSxcblx0XHRcdGJnWWVsbG93OiBbNDMsIDQ5XSxcblx0XHRcdGJnQmx1ZTogWzQ0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGE6IFs0NSwgNDldLFxuXHRcdFx0YmdDeWFuOiBbNDYsIDQ5XSxcblx0XHRcdGJnV2hpdGU6IFs0NywgNDldLFxuXG5cdFx0XHQvLyBCcmlnaHQgY29sb3Jcblx0XHRcdGJnQmxhY2tCcmlnaHQ6IFsxMDAsIDQ5XSxcblx0XHRcdGJnUmVkQnJpZ2h0OiBbMTAxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuQnJpZ2h0OiBbMTAyLCA0OV0sXG5cdFx0XHRiZ1llbGxvd0JyaWdodDogWzEwMywgNDldLFxuXHRcdFx0YmdCbHVlQnJpZ2h0OiBbMTA0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGFCcmlnaHQ6IFsxMDUsIDQ5XSxcblx0XHRcdGJnQ3lhbkJyaWdodDogWzEwNiwgNDldLFxuXHRcdFx0YmdXaGl0ZUJyaWdodDogWzEwNywgNDldXG5cdFx0fVxuXHR9O1xuXG5cdC8vIEFsaWFzIGJyaWdodCBibGFjayBhcyBncmF5IChhbmQgZ3JleSlcblx0c3R5bGVzLmNvbG9yLmdyYXkgPSBzdHlsZXMuY29sb3IuYmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5iZ0NvbG9yLmJnR3JheSA9IHN0eWxlcy5iZ0NvbG9yLmJnQmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5jb2xvci5ncmV5ID0gc3R5bGVzLmNvbG9yLmJsYWNrQnJpZ2h0O1xuXHRzdHlsZXMuYmdDb2xvci5iZ0dyZXkgPSBzdHlsZXMuYmdDb2xvci5iZ0JsYWNrQnJpZ2h0O1xuXG5cdGZvciAoY29uc3QgW2dyb3VwTmFtZSwgZ3JvdXBdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHtcblx0XHRmb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlXSBvZiBPYmplY3QuZW50cmllcyhncm91cCkpIHtcblx0XHRcdHN0eWxlc1tzdHlsZU5hbWVdID0ge1xuXHRcdFx0XHRvcGVuOiBgXFx1MDAxQlske3N0eWxlWzBdfW1gLFxuXHRcdFx0XHRjbG9zZTogYFxcdTAwMUJbJHtzdHlsZVsxXX1tYFxuXHRcdFx0fTtcblxuXHRcdFx0Z3JvdXBbc3R5bGVOYW1lXSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG5cdFx0XHRjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcblx0XHRcdHZhbHVlOiBncm91cCxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSk7XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCAnY29kZXMnLCB7XG5cdFx0dmFsdWU6IGNvZGVzLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdH0pO1xuXG5cdHN0eWxlcy5jb2xvci5jbG9zZSA9ICdcXHUwMDFCWzM5bSc7XG5cdHN0eWxlcy5iZ0NvbG9yLmNsb3NlID0gJ1xcdTAwMUJbNDltJztcblxuXHRzdHlsZXMuY29sb3IuYW5zaTI1NiA9IHdyYXBBbnNpMjU2KCk7XG5cdHN0eWxlcy5jb2xvci5hbnNpMTZtID0gd3JhcEFuc2kxNm0oKTtcblx0c3R5bGVzLmJnQ29sb3IuYW5zaTI1NiA9IHdyYXBBbnNpMjU2KEFOU0lfQkFDS0dST1VORF9PRkZTRVQpO1xuXHRzdHlsZXMuYmdDb2xvci5hbnNpMTZtID0gd3JhcEFuc2kxNm0oQU5TSV9CQUNLR1JPVU5EX09GRlNFVCk7XG5cblx0Ly8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vUWl4LS9jb2xvci1jb252ZXJ0L2Jsb2IvM2YwZTBkNGU5MmUyMzU3OTZjY2IxN2Y2ZTg1YzcyMDk0YTY1MWY0OS9jb252ZXJzaW9ucy5qc1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHlsZXMsIHtcblx0XHRyZ2JUb0Fuc2kyNTY6IHtcblx0XHRcdHZhbHVlOiAocmVkLCBncmVlbiwgYmx1ZSkgPT4ge1xuXHRcdFx0XHQvLyBXZSB1c2UgdGhlIGV4dGVuZGVkIGdyZXlzY2FsZSBwYWxldHRlIGhlcmUsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuXHRcdFx0XHQvLyBibGFjayBhbmQgd2hpdGUuIG5vcm1hbCBwYWxldHRlIG9ubHkgaGFzIDQgZ3JleXNjYWxlIHNoYWRlcy5cblx0XHRcdFx0aWYgKHJlZCA9PT0gZ3JlZW4gJiYgZ3JlZW4gPT09IGJsdWUpIHtcblx0XHRcdFx0XHRpZiAocmVkIDwgOCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIDE2O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChyZWQgPiAyNDgpIHtcblx0XHRcdFx0XHRcdHJldHVybiAyMzE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKChyZWQgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gMTYgK1xuXHRcdFx0XHRcdCgzNiAqIE1hdGgucm91bmQocmVkIC8gMjU1ICogNSkpICtcblx0XHRcdFx0XHQoNiAqIE1hdGgucm91bmQoZ3JlZW4gLyAyNTUgKiA1KSkgK1xuXHRcdFx0XHRcdE1hdGgucm91bmQoYmx1ZSAvIDI1NSAqIDUpO1xuXHRcdFx0fSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSxcblx0XHRoZXhUb1JnYjoge1xuXHRcdFx0dmFsdWU6IGhleCA9PiB7XG5cdFx0XHRcdGNvbnN0IG1hdGNoZXMgPSAvKD88Y29sb3JTdHJpbmc+W2EtZlxcZF17Nn18W2EtZlxcZF17M30pL2kuZXhlYyhoZXgudG9TdHJpbmcoMTYpKTtcblx0XHRcdFx0aWYgKCFtYXRjaGVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFswLCAwLCAwXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCB7Y29sb3JTdHJpbmd9ID0gbWF0Y2hlcy5ncm91cHM7XG5cblx0XHRcdFx0aWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PT0gMykge1xuXHRcdFx0XHRcdGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoJycpLm1hcChjaGFyYWN0ZXIgPT4gY2hhcmFjdGVyICsgY2hhcmFjdGVyKS5qb2luKCcnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGludGVnZXIgPSBOdW1iZXIucGFyc2VJbnQoY29sb3JTdHJpbmcsIDE2KTtcblxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdChpbnRlZ2VyID4+IDE2KSAmIDB4RkYsXG5cdFx0XHRcdFx0KGludGVnZXIgPj4gOCkgJiAweEZGLFxuXHRcdFx0XHRcdGludGVnZXIgJiAweEZGXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2Vcblx0XHR9LFxuXHRcdGhleFRvQW5zaTI1Njoge1xuXHRcdFx0dmFsdWU6IGhleCA9PiBzdHlsZXMucmdiVG9BbnNpMjU2KC4uLnN0eWxlcy5oZXhUb1JnYihoZXgpKSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG4vLyBNYWtlIHRoZSBleHBvcnQgaW1tdXRhYmxlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBhc3NlbWJsZVN0eWxlc1xufSk7XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCAiaW1wb3J0IHsgUGx1Z2luLCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBydW5EYWlseU5vdGVTeW50aGVzaXMgZnJvbSAnLi9kYWlseS1ub3RlLXN5bnRoL3J1bi1kYWlseS1ub3RlLXN5bnRoJztcblxuLy8gUmVtZW1iZXIgdG8gcmVuYW1lIHRoZXNlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMhXG5cbmludGVyZmFjZSBNeVBsdWdpblNldHRpbmdzIHtcblx0bXlTZXR0aW5nOiBzdHJpbmc7XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE15UGx1Z2luU2V0dGluZ3MgPSB7XG5cdG15U2V0dGluZzogJ2RlZmF1bHQnXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IE15UGx1Z2luU2V0dGluZ3M7XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4ge1xuXHRcdFx0Ly8gcnVuRGFpbHlOb3RlU3ludGhlc2lzKHRoaXMuYXBwKTtcblx0XHR9KTtcblxuXHRcdC8vIFRoaXMgYWRkcyBhIHNpbXBsZSBjb21tYW5kIHRoYXQgY2FuIGJlIHRyaWdnZXJlZCBhbnl3aGVyZVxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3J1bi1kYWlseS1ub3RlLXN5bnRoZXNpcycsXG5cdFx0XHRuYW1lOiAnUnVuIERhaWx5IE5vdGUgU3ludGhlc2lzJyxcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB7XG5cdFx0XHRcdHJ1bkRhaWx5Tm90ZVN5bnRoZXNpcyh0aGlzLmFwcCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fVxuXG5cdG9udW5sb2FkKCkge1xuXHR9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBURmlsZSwgQXBwLCBOb3RpY2UsIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgZ2V0Tm90ZXNGcm9tRm9sZGVyLCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgc3ludGhlc2l6ZURhaWx5Tm90ZSB9IGZyb20gJy4vc3ludGhlc2l6ZS1kYWlseS1ub3RlJztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcnVuRGFpbHlOb3RlU3ludGhlc2lzKGFwcDogQXBwKSB7XG4gIGNvbnN0IGRhaWx5Tm90ZXMgPSBnZXROb3Rlc0Zyb21Gb2xkZXIoYXBwLCBcIkRhaWx5IE5vdGVzXCIpO1xuICBpZiAoZGFpbHlOb3Rlcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmxvZyhgTm8gZGFpbHkgbm90ZXMgZm91bmQgaW4gRGFpbHkgTm90ZXMgZm9sZGVyLmApO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygnc3YnKTsgLy8gJ3N2JyBsb2NhbGUgZ2l2ZXMgWVlZWS1NTS1ERFxuICBjb25zdCBwYXN0RGFpbHlOb3RlcyA9IGRhaWx5Tm90ZXMuZmlsdGVyKChmaWxlOiBURmlsZSkgPT4gZmlsZS5uYW1lICE9PSBgJHt0b2RheX0ubWRgKTtcbiAgXG4gIC8vIEVuc3VyZSB0aGUgZGlyZWN0b3J5IGV4aXN0c1xuICBjb25zdCBzeW50aERpciA9IFwic3ludGhlc2l6ZWQtbm90ZXNcIjtcbiAgaWYgKCFhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHN5bnRoRGlyKSkge1xuICAgIGF3YWl0IGFwcC52YXVsdC5jcmVhdGVGb2xkZXIoc3ludGhEaXIpO1xuICB9XG5cbiAgcGFzdERhaWx5Tm90ZXMuZm9yRWFjaCgoZmlsZTogVEZpbGUpID0+IHtcbiAgICBhcHAudmF1bHQucmVhZChmaWxlKVxuICAgICAgLnRoZW4oYXN5bmMgKGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRDb250ZW50ID0gYXdhaXQgc3ludGhlc2l6ZURhaWx5Tm90ZShjb250ZW50KTtcbiAgICAgICAgLy8gd3JpdGUgdG8gbmV3IGZpbGUgaW4gc3ludGhlc2l6ZWQtbm90ZXMgZGlyZWN0b3J5XG4gICAgICAgIGNvbnN0IG5ld0ZpbGVOYW1lID0gYCR7c3ludGhEaXJ9LyR7ZmlsZS5uYW1lLnJlcGxhY2UoJy5tZCcsICcnKX0tc3ludGhlc2l6ZWQubWRgO1xuICAgICAgICBjb25zdCBuZXdGaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChuZXdGaWxlTmFtZSk7XG4gICAgICAgIGlmIChuZXdGaWxlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZpbGUgJHtuZXdGaWxlTmFtZX0gYWxyZWFkeSBleGlzdHMuIFNraXBwaW5nLmApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBhcHAudmF1bHQuY3JlYXRlKG5ld0ZpbGVOYW1lLCBwcm9jZXNzZWRDb250ZW50KTtcbiAgICAgICAgbmV3IE5vdGljZShgU3ludGhlc2l6ZWQgZGFpbHkgbm90ZSBjcmVhdGVkOiAke25ld0ZpbGVOYW1lfWApO1xuICAgICAgfSk7XG4gIH0pO1xufSIsICJpbXBvcnQgeyBURmlsZSwgQXBwLCB9IGZyb20gJ29ic2lkaWFuJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRlbXBsYXRlKGFwcDogQXBwLCB0ZW1wbGF0ZU5hbWU6IHN0cmluZyk6IFRGaWxlIHwgbnVsbCB7XG4gIGNvbnN0IHZhdWx0ID0gYXBwLnZhdWx0O1xuICBjb25zdCBmaWxlcyA9IHZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgIC5maWx0ZXIoKGZpbGU6IFRGaWxlKSA9PiBmaWxlLnBhdGguc3RhcnRzV2l0aCgnUmVzb3VyY2VzL1RlbXBsYXRlcy8nKSAmJiBmaWxlLm5hbWUgPT09IHRlbXBsYXRlTmFtZSk7XG4gIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zb2xlLmxvZyhgVGVtcGxhdGUgJHt0ZW1wbGF0ZU5hbWV9IG5vdCBmb3VuZCBpbiBSZXNzb3VyY2VzL1RlbXBsYXRlcy5gKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZmlsZXNbMF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb3Rlc0Zyb21Gb2xkZXIoYXBwOiBBcHAsIGZvbGRlclBhdGg6IHN0cmluZyk6IFRGaWxlW10ge1xuICBjb25zdCB2YXVsdCA9IGFwcC52YXVsdDtcbiAgY29uc3QgYWxsRmlsZXMgPSB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG5cbiAgY29uc3QgZmlsZXMgPSBhbGxGaWxlcy5maWx0ZXIoKGZpbGU6IFRGaWxlKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGZpbGUucGF0aC5zdGFydHNXaXRoKGZvbGRlclBhdGggKyAnLycpO1xuICAgIHJldHVybiBtYXRjaGVzO1xuICB9KTtcblxuICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc29sZS5sb2coYE5vIG5vdGVzIGZvdW5kIGluICR7Zm9sZGVyUGF0aH1gKTtcbiAgfVxuICByZXR1cm4gZmlsZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXR0ZWROb3RlKGFwcDogQXBwLCBjb250ZW50OiBzdHJpbmcsKTogYm9vbGVhbiB7XG4gIHJldHVybiB0cnVlO1xufSIsICJpbXBvcnQgeyBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBjYWxsT2xsYW1hIGZyb20gXCJzcmMvbGliL2xhbmdjaGFpblwiO1xuaW1wb3J0IHsgU1lTVEVNX1BST01QVF9PUkdBTklaRVIgfSBmcm9tIFwiLi9mb3JtYXQtbm90ZVwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3ludGhlc2l6ZURhaWx5Tm90ZShjb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBuZXcgTm90aWNlKFwiU3ludGhlc2l6aW5nIGRhaWx5IG5vdGUuLi5cIik7XG5cbiAgLy8gMS4gSSBuZWVkIHRvIHBhcnNlIHRoZSB0ZXh0IGluc2lkZSBvZiB0aGUgbm90ZSBhbmQgZGVyaXZlIGVudGl0aWVzIHdpdGggdmVjdG9yIGVtYmVkZGluZ3NcbiAgLy8gMi4gZm9yIGV4YW1wbGUsIHB1bGxzOiBcImh5cGVyY29yZSBwcm90b2NvbFwiLCBcInNlY3VyZSBzY3V0dGxlYnV0dFwiLCBcImRpc2NvcmRcIiwgXCJ3b3JrcGxhY2VcIlxuICAvLyAzLiBvbmNlIEkgaGF2ZSB0aGUgZW50aXRpZXMsIEkgY2FuIHVzZSB0aGVtIHRvIGdlbmVyYXRlIHJlbGV2YW50IGNhbGxvdXRzXG5cbiAgY29uc3Qgc3lzdGVtUHJvbXB0ID0gU1lTVEVNX1BST01QVF9PUkdBTklaRVI7XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWxsT2xsYW1hKGNvbnRlbnQsIHtcbiAgICBwcm9tcHQ6IHN5c3RlbVByb21wdCxcbiAgfSk7XG5cbiAgaWYgKCFyZXNwb25zZS50ZXh0KSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHN5bnRoZXNpczogTm8gdGV4dCByZXR1cm5lZFwiKTtcbiAgICBuZXcgTm90aWNlKFwiU3ludGhlc2lzIGZhaWxlZCFcIik7XG4gICAgcmV0dXJuIGNvbnRlbnQ7IC8vIGZhbGxiYWNrIHRvIHJhd1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlLnRleHQ7XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSnNvbk1hcmtkb3duKHMsIHBhcnNlciA9IHBhcnNlUGFydGlhbEpzb24pIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBzID0gcy50cmltKCk7XG4gICAgY29uc3QgZmlyc3RGZW5jZUluZGV4ID0gcy5pbmRleE9mKFwiYGBgXCIpO1xuICAgIGlmIChmaXJzdEZlbmNlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIocyk7XG4gICAgfVxuICAgIGxldCBjb250ZW50QWZ0ZXJGZW5jZSA9IHMuc3Vic3RyaW5nKGZpcnN0RmVuY2VJbmRleCArIDMpO1xuICAgIGlmIChjb250ZW50QWZ0ZXJGZW5jZS5zdGFydHNXaXRoKFwianNvblxcblwiKSkge1xuICAgICAgICBjb250ZW50QWZ0ZXJGZW5jZSA9IGNvbnRlbnRBZnRlckZlbmNlLnN1YnN0cmluZyg1KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udGVudEFmdGVyRmVuY2Uuc3RhcnRzV2l0aChcImpzb25cIikpIHtcbiAgICAgICAgY29udGVudEFmdGVyRmVuY2UgPSBjb250ZW50QWZ0ZXJGZW5jZS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRlbnRBZnRlckZlbmNlLnN0YXJ0c1dpdGgoXCJcXG5cIikpIHtcbiAgICAgICAgY29udGVudEFmdGVyRmVuY2UgPSBjb250ZW50QWZ0ZXJGZW5jZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGNvbnN0IGNsb3NpbmdGZW5jZUluZGV4ID0gY29udGVudEFmdGVyRmVuY2UuaW5kZXhPZihcImBgYFwiKTtcbiAgICBsZXQgZmluYWxDb250ZW50ID0gY29udGVudEFmdGVyRmVuY2U7XG4gICAgaWYgKGNsb3NpbmdGZW5jZUluZGV4ICE9PSAtMSkge1xuICAgICAgICBmaW5hbENvbnRlbnQgPSBjb250ZW50QWZ0ZXJGZW5jZS5zdWJzdHJpbmcoMCwgY2xvc2luZ0ZlbmNlSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyKGZpbmFsQ29udGVudC50cmltKCkpO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9LaWxsaWFuTHVjYXMvb3Blbi1pbnRlcnByZXRlci9ibG9iL21haW4vaW50ZXJwcmV0ZXIvY29yZS9sbG0vdXRpbHMvcGFyc2VfcGFydGlhbF9qc29uLnB5XG4vLyBNSVQgTGljZW5zZVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFydGlhbEpzb24ocykge1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyB1bmRlZmluZWQsIHJldHVybiBudWxsIHRvIGluZGljYXRlIGZhaWx1cmUuXG4gICAgaWYgKHR5cGVvZiBzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uocyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBQYXNzXG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzLlxuICAgIGxldCBuZXdfcyA9IFwiXCI7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBsZXQgaXNJbnNpZGVTdHJpbmcgPSBmYWxzZTtcbiAgICBsZXQgZXNjYXBlZCA9IGZhbHNlO1xuICAgIC8vIFByb2Nlc3MgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBvbmUgYXQgYSB0aW1lLlxuICAgIGZvciAobGV0IGNoYXIgb2Ygcykge1xuICAgICAgICBpZiAoaXNJbnNpZGVTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXCInICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgaXNJbnNpZGVTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwiXFxuXCIgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFyID0gXCJcXFxcblwiOyAvLyBSZXBsYWNlIHRoZSBuZXdsaW5lIGNoYXJhY3RlciB3aXRoIHRoZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgaXNJbnNpZGVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goXCJdXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCJ9XCIgfHwgY2hhciA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2sgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNaXNtYXRjaGVkIGNsb3NpbmcgY2hhcmFjdGVyOyB0aGUgaW5wdXQgaXMgbWFsZm9ybWVkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIHRoZSBwcm9jZXNzZWQgY2hhcmFjdGVyIHRvIHRoZSBuZXcgc3RyaW5nLlxuICAgICAgICBuZXdfcyArPSBjaGFyO1xuICAgIH1cbiAgICAvLyBJZiB3ZSdyZSBzdGlsbCBpbnNpZGUgYSBzdHJpbmcgYXQgdGhlIGVuZCBvZiBwcm9jZXNzaW5nLFxuICAgIC8vIHdlIG5lZWQgdG8gY2xvc2UgdGhlIHN0cmluZy5cbiAgICBpZiAoaXNJbnNpZGVTdHJpbmcpIHtcbiAgICAgICAgbmV3X3MgKz0gJ1wiJztcbiAgICB9XG4gICAgLy8gQ2xvc2UgYW55IHJlbWFpbmluZyBvcGVuIHN0cnVjdHVyZXMgaW4gdGhlIHJldmVyc2Ugb3JkZXIgdGhhdCB0aGV5IHdlcmUgb3BlbmVkLlxuICAgIGZvciAobGV0IGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBuZXdfcyArPSBzdGFja1tpXTtcbiAgICB9XG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSB0aGUgbW9kaWZpZWQgc3RyaW5nIGFzIEpTT04uXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UobmV3X3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgd2Ugc3RpbGwgY2FuJ3QgcGFyc2UgdGhlIHN0cmluZyBhcyBKU09OLCByZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBmYWlsdXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHNuYWtlQ2FzZSBmcm9tIFwiZGVjYW1lbGl6ZVwiO1xuaW1wb3J0IGNhbWVsQ2FzZSBmcm9tIFwiY2FtZWxjYXNlXCI7XG5leHBvcnQgZnVuY3Rpb24ga2V5VG9Kc29uKGtleSwgbWFwKSB7XG4gICAgcmV0dXJuIG1hcD8uW2tleV0gfHwgc25ha2VDYXNlKGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24ga2V5RnJvbUpzb24oa2V5LCBtYXApIHtcbiAgICByZXR1cm4gbWFwPy5ba2V5XSB8fCBjYW1lbENhc2Uoa2V5KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXBLZXlzKGZpZWxkcywgbWFwcGVyLCBtYXApIHtcbiAgICBjb25zdCBtYXBwZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZHMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oZmllbGRzLCBrZXkpKSB7XG4gICAgICAgICAgICBtYXBwZWRbbWFwcGVyKGtleSwgbWFwKV0gPSBmaWVsZHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkO1xufVxuIiwgImltcG9ydCB7IGtleVRvSnNvbiwgbWFwS2V5cyB9IGZyb20gXCIuL21hcF9rZXlzLmpzXCI7XG5mdW5jdGlvbiBzaGFsbG93Q29weShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopID8gWy4uLm9ial0gOiB7IC4uLm9iaiB9O1xufVxuZnVuY3Rpb24gcmVwbGFjZVNlY3JldHMocm9vdCwgc2VjcmV0c01hcCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNoYWxsb3dDb3B5KHJvb3QpO1xuICAgIGZvciAoY29uc3QgW3BhdGgsIHNlY3JldElkXSBvZiBPYmplY3QuZW50cmllcyhzZWNyZXRzTWFwKSkge1xuICAgICAgICBjb25zdCBbbGFzdCwgLi4ucGFydHNSZXZlcnNlXSA9IHBhdGguc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IGN1cnJlbnQgPSByZXN1bHQ7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0c1JldmVyc2UucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFtwYXJ0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50W3BhcnRdID0gc2hhbGxvd0NvcHkoY3VycmVudFtwYXJ0XSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFtsYXN0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjdXJyZW50W2xhc3RdID0ge1xuICAgICAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwic2VjcmV0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IFtzZWNyZXRJZF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEdldCBhIHVuaXF1ZSBuYW1lIGZvciB0aGUgbW9kdWxlLCByYXRoZXIgdGhhbiBwYXJlbnQgY2xhc3MgaW1wbGVtZW50YXRpb25zLlxuICogU2hvdWxkIG5vdCBiZSBzdWJjbGFzc2VkLCBzdWJjbGFzcyBsY19uYW1lIGFib3ZlIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfbGNfdW5pcXVlX25hbWUoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG5zZXJpYWxpemFibGVDbGFzcykge1xuICAgIC8vIFwic3VwZXJcIiBoZXJlIHdvdWxkIHJlZmVyIHRvIHRoZSBwYXJlbnQgY2xhc3Mgb2YgU2VyaWFsaXphYmxlLFxuICAgIC8vIHdoZW4gd2Ugd2FudCB0aGUgcGFyZW50IGNsYXNzIG9mIHRoZSBtb2R1bGUgYWN0dWFsbHkgY2FsbGluZyB0aGlzIG1ldGhvZC5cbiAgICBjb25zdCBwYXJlbnRDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihzZXJpYWxpemFibGVDbGFzcyk7XG4gICAgY29uc3QgbGNOYW1lSXNTdWJjbGFzc2VkID0gdHlwZW9mIHNlcmlhbGl6YWJsZUNsYXNzLmxjX25hbWUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAodHlwZW9mIHBhcmVudENsYXNzLmxjX25hbWUgIT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICAgICAgc2VyaWFsaXphYmxlQ2xhc3MubGNfbmFtZSgpICE9PSBwYXJlbnRDbGFzcy5sY19uYW1lKCkpO1xuICAgIGlmIChsY05hbWVJc1N1YmNsYXNzZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YWJsZUNsYXNzLmxjX25hbWUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemFibGVDbGFzcy5uYW1lO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTZXJpYWxpemFibGUge1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemFibGUuIE92ZXJyaWRlIHRvIHByb3ZpZGUgYW4gYWxpYXMgb3JcbiAgICAgKiB0byBwcmVzZXJ2ZSB0aGUgc2VyaWFsaXplZCBtb2R1bGUgbmFtZSBpbiBtaW5pZmllZCBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBhIHN0YXRpYyBtZXRob2QgdG8gc3VwcG9ydCBsb2FkaW5nIGxvZ2ljLlxuICAgICAqL1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmluYWwgc2VyaWFsaXplZCBpZGVudGlmaWVyIGZvciB0aGUgbW9kdWxlLlxuICAgICAqL1xuICAgIGdldCBsY19pZCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnRoaXMubGNfbmFtZXNwYWNlLFxuICAgICAgICAgICAgZ2V0X2xjX3VuaXF1ZV9uYW1lKHRoaXMuY29uc3RydWN0b3IpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBzZWNyZXRzLCB3aGljaCB3aWxsIGJlIG9taXR0ZWQgZnJvbSBzZXJpYWxpemF0aW9uLlxuICAgICAqIEtleXMgYXJlIHBhdGhzIHRvIHRoZSBzZWNyZXQgaW4gY29uc3RydWN0b3IgYXJncywgZS5nLiBcImZvby5iYXIuYmF6XCIuXG4gICAgICogVmFsdWVzIGFyZSB0aGUgc2VjcmV0IGlkcywgd2hpY2ggd2lsbCBiZSB1c2VkIHdoZW4gZGVzZXJpYWxpemluZy5cbiAgICAgKi9cbiAgICBnZXQgbGNfc2VjcmV0cygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYXAgb2YgYWRkaXRpb25hbCBhdHRyaWJ1dGVzIHRvIG1lcmdlIHdpdGggY29uc3RydWN0b3IgYXJncy5cbiAgICAgKiBLZXlzIGFyZSB0aGUgYXR0cmlidXRlIG5hbWVzLCBlLmcuIFwiZm9vXCIuXG4gICAgICogVmFsdWVzIGFyZSB0aGUgYXR0cmlidXRlIHZhbHVlcywgd2hpY2ggd2lsbCBiZSBzZXJpYWxpemVkLlxuICAgICAqIFRoZXNlIGF0dHJpYnV0ZXMgbmVlZCB0byBiZSBhY2NlcHRlZCBieSB0aGUgY29uc3RydWN0b3IgYXMgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGdldCBsY19hdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1hcCBvZiBhbGlhc2VzIGZvciBjb25zdHJ1Y3RvciBhcmdzLlxuICAgICAqIEtleXMgYXJlIHRoZSBhdHRyaWJ1dGUgbmFtZXMsIGUuZy4gXCJmb29cIi5cbiAgICAgKiBWYWx1ZXMgYXJlIHRoZSBhbGlhcyB0aGF0IHdpbGwgcmVwbGFjZSB0aGUga2V5IGluIHNlcmlhbGl6YXRpb24uXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIGVnLiBtYWtlIGFyZ3VtZW50IG5hbWVzIG1hdGNoIFB5dGhvbi5cbiAgICAgKi9cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYW51YWwgbGlzdCBvZiBrZXlzIHRoYXQgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuXG4gICAgICogSWYgbm90IG92ZXJyaWRkZW4sIGFsbCBmaWVsZHMgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yIHdpbGwgYmUgc2VyaWFsaXplZC5cbiAgICAgKi9cbiAgICBnZXQgbGNfc2VyaWFsaXphYmxlX2tleXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGt3YXJncywgLi4uX2FyZ3MpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmxjX3NlcmlhbGl6YWJsZV9rZXlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubGNfa3dhcmdzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGt3YXJncyB8fCB7fSkuZmlsdGVyKChba2V5XSkgPT4gdGhpcy5sY19zZXJpYWxpemFibGVfa2V5cz8uaW5jbHVkZXMoa2V5KSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sY19rd2FyZ3MgPSBrd2FyZ3MgPz8ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIXRoaXMubGNfc2VyaWFsaXphYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0pTT05Ob3RJbXBsZW1lbnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICB0aGlzLmxjX2t3YXJncyBpbnN0YW5jZW9mIFNlcmlhbGl6YWJsZSB8fFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMubGNfa3dhcmdzICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMubGNfa3dhcmdzKSkge1xuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHN1cHBvcnQgc2VyaWFsaXphdGlvbiBvZiBjbGFzc2VzIHdpdGggYXJnIG5vdCBhIFBPSk9cbiAgICAgICAgICAgIC8vIEknbSBhd2FyZSB0aGUgY2hlY2sgYWJvdmUgaXNuJ3QgYXMgc3RyaWN0IGFzIGl0IGNvdWxkIGJlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0pTT05Ob3RJbXBsZW1lbnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSB7fTtcbiAgICAgICAgY29uc3Qgc2VjcmV0cyA9IHt9O1xuICAgICAgICBjb25zdCBrd2FyZ3MgPSBPYmplY3Qua2V5cyh0aGlzLmxjX2t3YXJncykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBrZXkgaW4gdGhpcyA/IHRoaXNba2V5XSA6IHRoaXMubGNfa3dhcmdzW2tleV07XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8vIGdldCBzZWNyZXRzLCBhdHRyaWJ1dGVzIGFuZCBhbGlhc2VzIGZyb20gYWxsIHN1cGVyY2xhc3Nlc1xuICAgICAgICBmb3IgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7IGN1cnJlbnQ7IGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudCkpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYWxpYXNlcywgUmVmbGVjdC5nZXQoY3VycmVudCwgXCJsY19hbGlhc2VzXCIsIHRoaXMpKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VjcmV0cywgUmVmbGVjdC5nZXQoY3VycmVudCwgXCJsY19zZWNyZXRzXCIsIHRoaXMpKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oa3dhcmdzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX2F0dHJpYnV0ZXNcIiwgdGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluY2x1ZGUgYWxsIHNlY3JldHMgdXNlZCwgZXZlbiBpZiBub3QgaW4ga3dhcmdzLFxuICAgICAgICAvLyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggc2VudGluZWwgdmFsdWUgaW4gcmVwbGFjZVNlY3JldHNcbiAgICAgICAgT2JqZWN0LmtleXMoc2VjcmV0cykuZm9yRWFjaCgoa2V5UGF0aCkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBsZXQgcmVhZCA9IHRoaXM7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgbGV0IHdyaXRlID0ga3dhcmdzO1xuICAgICAgICAgICAgY29uc3QgW2xhc3QsIC4uLnBhcnRzUmV2ZXJzZV0gPSBrZXlQYXRoLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJ0c1JldmVyc2UucmV2ZXJzZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIHJlYWQpIHx8IHJlYWRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIHdyaXRlKSB8fCB3cml0ZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkW2tleV0gPT09IFwib2JqZWN0XCIgJiYgcmVhZFtrZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlYWRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlW2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWFkID0gcmVhZFtrZXldO1xuICAgICAgICAgICAgICAgIHdyaXRlID0gd3JpdGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0IGluIHJlYWQgJiYgcmVhZFtsYXN0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVbbGFzdF0gPSB3cml0ZVtsYXN0XSB8fCByZWFkW2xhc3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgaWQ6IHRoaXMubGNfaWQsXG4gICAgICAgICAgICBrd2FyZ3M6IG1hcEtleXMoT2JqZWN0LmtleXMoc2VjcmV0cykubGVuZ3RoID8gcmVwbGFjZVNlY3JldHMoa3dhcmdzLCBzZWNyZXRzKSA6IGt3YXJncywga2V5VG9Kc29uLCBhbGlhc2VzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9KU09OTm90SW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgIHR5cGU6IFwibm90X2ltcGxlbWVudGVkXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5sY19pZCxcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YUNvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgY29udGVudF9ibG9jayA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBjb250ZW50X2Jsb2NrICE9PSBudWxsICYmXG4gICAgICAgIFwidHlwZVwiIGluIGNvbnRlbnRfYmxvY2sgJiZcbiAgICAgICAgdHlwZW9mIGNvbnRlbnRfYmxvY2sudHlwZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICBcInNvdXJjZV90eXBlXCIgaW4gY29udGVudF9ibG9jayAmJlxuICAgICAgICAoY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJ1cmxcIiB8fFxuICAgICAgICAgICAgY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJiYXNlNjRcIiB8fFxuICAgICAgICAgICAgY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJ0ZXh0XCIgfHxcbiAgICAgICAgICAgIGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwiaWRcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVVJMQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spIHtcbiAgICByZXR1cm4gKGlzRGF0YUNvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSAmJlxuICAgICAgICBjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcInVybFwiICYmXG4gICAgICAgIFwidXJsXCIgaW4gY29udGVudF9ibG9jayAmJlxuICAgICAgICB0eXBlb2YgY29udGVudF9ibG9jay51cmwgPT09IFwic3RyaW5nXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFzZTY0Q29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spIHtcbiAgICByZXR1cm4gKGlzRGF0YUNvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSAmJlxuICAgICAgICBjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcImJhc2U2NFwiICYmXG4gICAgICAgIFwiZGF0YVwiIGluIGNvbnRlbnRfYmxvY2sgJiZcbiAgICAgICAgdHlwZW9mIGNvbnRlbnRfYmxvY2suZGF0YSA9PT0gXCJzdHJpbmdcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpblRleHRDb250ZW50QmxvY2soY29udGVudF9ibG9jaykge1xuICAgIHJldHVybiAoaXNEYXRhQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spICYmXG4gICAgICAgIGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwidGV4dFwiICYmXG4gICAgICAgIFwidGV4dFwiIGluIGNvbnRlbnRfYmxvY2sgJiZcbiAgICAgICAgdHlwZW9mIGNvbnRlbnRfYmxvY2sudGV4dCA9PT0gXCJzdHJpbmdcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNJRENvbnRlbnRCbG9jayhjb250ZW50X2Jsb2NrKSB7XG4gICAgcmV0dXJuIChpc0RhdGFDb250ZW50QmxvY2soY29udGVudF9ibG9jaykgJiZcbiAgICAgICAgY29udGVudF9ibG9jay5zb3VyY2VfdHlwZSA9PT0gXCJpZFwiICYmXG4gICAgICAgIFwiaWRcIiBpbiBjb250ZW50X2Jsb2NrICYmXG4gICAgICAgIHR5cGVvZiBjb250ZW50X2Jsb2NrLmlkID09PSBcInN0cmluZ1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9PcGVuQUlJbWFnZUJsb2NrKGNvbnRlbnRfYmxvY2spIHtcbiAgICBpZiAoaXNEYXRhQ29udGVudEJsb2NrKGNvbnRlbnRfYmxvY2spKSB7XG4gICAgICAgIGlmIChjb250ZW50X2Jsb2NrLnNvdXJjZV90eXBlID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gICAgICAgICAgICAgICAgaW1hZ2VfdXJsOiB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogY29udGVudF9ibG9jay51cmwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRfYmxvY2suc291cmNlX3R5cGUgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICAgIGlmICghY29udGVudF9ibG9jay5taW1lX3R5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaW1lX3R5cGUga2V5IGlzIHJlcXVpcmVkIGZvciBiYXNlNjQgZGF0YS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtaW1lX3R5cGUgPSBjb250ZW50X2Jsb2NrLm1pbWVfdHlwZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZV91cmxcIixcbiAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBgZGF0YToke21pbWVfdHlwZX07YmFzZTY0LCR7Y29udGVudF9ibG9jay5kYXRhfWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc291cmNlIHR5cGUuIE9ubHkgJ3VybCcgYW5kICdiYXNlNjQnIGFyZSBzdXBwb3J0ZWQuXCIpO1xufVxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBDaGF0TW9kZWxQcm92aWRlcnMuIFBhcnNlcyBhIG1pbWUgdHlwZSBpbnRvIGEgdHlwZSwgc3VidHlwZSwgYW5kIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIG1pbWVfdHlwZSAtIFRoZSBtaW1lIHR5cGUgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdHlwZSwgc3VidHlwZSwgYW5kIHBhcmFtZXRlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1pbWVUeXBlKG1pbWVfdHlwZSkge1xuICAgIGNvbnN0IHBhcnRzID0gbWltZV90eXBlLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIi9cIik7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWltZSB0eXBlOiBcIiR7bWltZV90eXBlfVwiIC0gZG9lcyBub3QgbWF0Y2ggdHlwZS9zdWJ0eXBlIGZvcm1hdC5gKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHBhcnRzWzBdLnRyaW0oKTtcbiAgICBjb25zdCBzdWJ0eXBlID0gcGFydHNbMV0udHJpbSgpO1xuICAgIGlmICh0eXBlID09PSBcIlwiIHx8IHN1YnR5cGUgPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1pbWUgdHlwZTogXCIke21pbWVfdHlwZX1cIiAtIHR5cGUgb3Igc3VidHlwZSBpcyBlbXB0eS5gKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1ldGVycyA9IHt9O1xuICAgIGZvciAoY29uc3QgcGFyYW1ldGVyS3ZwIG9mIG1pbWVfdHlwZS5zcGxpdChcIjtcIikuc2xpY2UoMSkpIHtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVyUGFydHMgPSBwYXJhbWV0ZXJLdnAuc3BsaXQoXCI9XCIpO1xuICAgICAgICBpZiAocGFyYW1ldGVyUGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW1ldGVyIHN5bnRheCBpbiBtaW1lIHR5cGU6IFwiJHttaW1lX3R5cGV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gcGFyYW1ldGVyUGFydHNbMF0udHJpbSgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtZXRlclBhcnRzWzFdLnRyaW0oKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtZXRlciBzeW50YXggaW4gbWltZSB0eXBlOiBcIiR7bWltZV90eXBlfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtZXRlcnNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBzdWJ0eXBlLFxuICAgICAgICBwYXJhbWV0ZXJzLFxuICAgIH07XG59XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIENoYXRNb2RlbFByb3ZpZGVycy4gUGFyc2VzIGEgYmFzZTY0IGRhdGEgVVJMIGludG8gYSB0eXBlZCBhcnJheSBvciBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGRhdGFVcmwgLSBUaGUgYmFzZTY0IGRhdGEgVVJMIHRvIHBhcnNlLlxuICogQHBhcmFtIGFzVHlwZWRBcnJheSAtIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBkYXRhIGFzIGEgdHlwZWQgYXJyYXkuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGRhdGEgYW5kIG1pbWUgdHlwZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBkYXRhIFVSTCBpcyBpbnZhbGlkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VCYXNlNjREYXRhVXJsKHsgZGF0YVVybDogZGF0YV91cmwsIGFzVHlwZWRBcnJheSA9IGZhbHNlLCB9KSB7XG4gICAgY29uc3QgZm9ybWF0TWF0Y2ggPSBkYXRhX3VybC5tYXRjaCgvXmRhdGE6KFxcdytcXC9cXHcrKTtiYXNlNjQsKFtBLVphLXowLTkrL10rPSopJC8pO1xuICAgIGxldCBtaW1lX3R5cGU7XG4gICAgaWYgKGZvcm1hdE1hdGNoKSB7XG4gICAgICAgIG1pbWVfdHlwZSA9IGZvcm1hdE1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhc1R5cGVkQXJyYXlcbiAgICAgICAgICAgID8gVWludDhBcnJheS5mcm9tKGF0b2IoZm9ybWF0TWF0Y2hbMl0pLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKVxuICAgICAgICAgICAgOiBmb3JtYXRNYXRjaFsyXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbWVfdHlwZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIENvbnZlcnQgZnJvbSBhIHN0YW5kYXJkIGRhdGEgY29udGVudCBibG9jayB0byBhIHByb3ZpZGVyJ3MgcHJvcHJpZXRhcnkgZGF0YSBjb250ZW50IGJsb2NrIGZvcm1hdC5cbiAqXG4gKiBEb24ndCBvdmVycmlkZSB0aGlzIG1ldGhvZC4gSW5zdGVhZCwgb3ZlcnJpZGUgdGhlIG1vcmUgc3BlY2lmaWMgY29udmVyc2lvbiBtZXRob2RzIGFuZCB1c2UgdGhpc1xuICogbWV0aG9kIHVubW9kaWZpZWQuXG4gKlxuICogQHBhcmFtIGJsb2NrIC0gVGhlIHN0YW5kYXJkIGRhdGEgY29udGVudCBibG9jayB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHByb3ZpZGVyIGRhdGEgY29udGVudCBibG9jay5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIHN0YW5kYXJkIGRhdGEgY29udGVudCBibG9jayB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Qcm92aWRlckNvbnRlbnRCbG9jayhibG9jaywgY29udmVydGVyKSB7XG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIGlmICghY29udmVydGVyLmZyb21TdGFuZGFyZFRleHRCbG9jaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb252ZXJ0ZXIgZm9yICR7Y29udmVydGVyLnByb3ZpZGVyTmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IFxcYGZyb21TdGFuZGFyZFRleHRCbG9ja1xcYCBtZXRob2QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlci5mcm9tU3RhbmRhcmRUZXh0QmxvY2soYmxvY2spO1xuICAgIH1cbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIGlmICghY29udmVydGVyLmZyb21TdGFuZGFyZEltYWdlQmxvY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udmVydGVyIGZvciAke2NvbnZlcnRlci5wcm92aWRlck5hbWV9IGRvZXMgbm90IGltcGxlbWVudCBcXGBmcm9tU3RhbmRhcmRJbWFnZUJsb2NrXFxgIG1ldGhvZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydGVyLmZyb21TdGFuZGFyZEltYWdlQmxvY2soYmxvY2spO1xuICAgIH1cbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJhdWRpb1wiKSB7XG4gICAgICAgIGlmICghY29udmVydGVyLmZyb21TdGFuZGFyZEF1ZGlvQmxvY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udmVydGVyIGZvciAke2NvbnZlcnRlci5wcm92aWRlck5hbWV9IGRvZXMgbm90IGltcGxlbWVudCBcXGBmcm9tU3RhbmRhcmRBdWRpb0Jsb2NrXFxgIG1ldGhvZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydGVyLmZyb21TdGFuZGFyZEF1ZGlvQmxvY2soYmxvY2spO1xuICAgIH1cbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgaWYgKCFjb252ZXJ0ZXIuZnJvbVN0YW5kYXJkRmlsZUJsb2NrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnZlcnRlciBmb3IgJHtjb252ZXJ0ZXIucHJvdmlkZXJOYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgXFxgZnJvbVN0YW5kYXJkRmlsZUJsb2NrXFxgIG1ldGhvZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydGVyLmZyb21TdGFuZGFyZEZpbGVCbG9jayhibG9jayk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvbnZlcnQgY29udGVudCBibG9jayB0eXBlICcke2Jsb2NrLnR5cGV9JyB0byBwcm92aWRlci1zcGVjaWZpYyBmb3JtYXQ6IG5vdCByZWNvZ25pemVkLmApO1xufVxuIiwgImltcG9ydCB7IFNlcmlhbGl6YWJsZSB9IGZyb20gXCIuLi9sb2FkL3NlcmlhbGl6YWJsZS5qc1wiO1xuaW1wb3J0IHsgaXNEYXRhQ29udGVudEJsb2NrLCB9IGZyb20gXCIuL2NvbnRlbnRfYmxvY2tzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDb250ZW50KGZpcnN0Q29udGVudCwgc2Vjb25kQ29udGVudCkge1xuICAgIC8vIElmIGZpcnN0IGNvbnRlbnQgaXMgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGZpcnN0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZmlyc3RDb250ZW50ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Vjb25kQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY29uZENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdENvbnRlbnQgKyBzZWNvbmRDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2Vjb25kQ29udGVudCkgJiZcbiAgICAgICAgICAgIHNlY29uZENvbnRlbnQuc29tZSgoYykgPT4gaXNEYXRhQ29udGVudEJsb2NrKGMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VfdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGZpcnN0Q29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLnNlY29uZENvbnRlbnQsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBmaXJzdENvbnRlbnQgfSwgLi4uc2Vjb25kQ29udGVudF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYm90aCBhcmUgYXJyYXlzXG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2Vjb25kQ29udGVudCkpIHtcbiAgICAgICAgcmV0dXJuIChfbWVyZ2VMaXN0cyhmaXJzdENvbnRlbnQsIHNlY29uZENvbnRlbnQpID8/IFtcbiAgICAgICAgICAgIC4uLmZpcnN0Q29udGVudCxcbiAgICAgICAgICAgIC4uLnNlY29uZENvbnRlbnQsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHNlY29uZENvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdENvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaXJzdENvbnRlbnQpICYmXG4gICAgICAgICAgICBmaXJzdENvbnRlbnQuc29tZSgoYykgPT4gaXNEYXRhQ29udGVudEJsb2NrKGMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5maXJzdENvbnRlbnQsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICAgICAgc291cmNlX3R5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBzZWNvbmRDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5maXJzdENvbnRlbnQsIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHNlY29uZENvbnRlbnQgfV07XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqICdNZXJnZScgdHdvIHN0YXR1c2VzLiBJZiBlaXRoZXIgdmFsdWUgcGFzc2VkIGlzICdlcnJvcicsIGl0IHdpbGwgcmV0dXJuICdlcnJvcicuIEVsc2VcbiAqIGl0IHdpbGwgcmV0dXJuICdzdWNjZXNzJy5cbiAqXG4gKiBAcGFyYW0ge1wic3VjY2Vzc1wiIHwgXCJlcnJvclwiIHwgdW5kZWZpbmVkfSBsZWZ0IFRoZSBleGlzdGluZyB2YWx1ZSB0byAnbWVyZ2UnIHdpdGggdGhlIG5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7XCJzdWNjZXNzXCIgfCBcImVycm9yXCIgfCB1bmRlZmluZWR9IHJpZ2h0IFRoZSBuZXcgdmFsdWUgdG8gJ21lcmdlJyB3aXRoIHRoZSBleGlzdGluZyB2YWx1ZVxuICogQHJldHVybnMge1wic3VjY2Vzc1wiIHwgXCJlcnJvclwifSBUaGUgJ21lcmdlZCcgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VTdGF0dXMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gXCJlcnJvclwiIHx8IHJpZ2h0ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwic3VjY2Vzc1wiO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHN0cmluZ2lmeVdpdGhEZXB0aExpbWl0KG9iaiwgZGVwdGhMaW1pdCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZnVuY3Rpb24gaGVscGVyKG9iaiwgY3VycmVudERlcHRoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudERlcHRoID49IGRlcHRoTGltaXQpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbQXJyYXldXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJbT2JqZWN0XVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubWFwKChpdGVtKSA9PiBoZWxwZXIoaXRlbSwgY3VycmVudERlcHRoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGhlbHBlcihvYmpba2V5XSwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGhlbHBlcihvYmosIDApLCBudWxsLCAyKTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIHR5cGVzIG9mIG1lc3NhZ2VzIGluIGEgY29udmVyc2F0aW9uLiBJdCBpbmNsdWRlc1xuICogcHJvcGVydGllcyBsaWtlIGBjb250ZW50YCwgYG5hbWVgLCBhbmQgYGFkZGl0aW9uYWxfa3dhcmdzYC4gSXQgYWxzb1xuICogaW5jbHVkZXMgbWV0aG9kcyBsaWtlIGB0b0RpY3QoKWAgYW5kIGBfZ2V0VHlwZSgpYC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VNZXNzYWdlIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBcImFkZGl0aW9uYWxfa3dhcmdzXCIsXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogXCJyZXNwb25zZV9tZXRhZGF0YVwiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGV4dCBjb250ZW50IG9mIHRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5jb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50XG4gICAgICAgICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSBcInRleHRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gYy50ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICB9XG4gICAgLyoqIFRoZSB0eXBlIG9mIHRoZSBtZXNzYWdlLiAqL1xuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUeXBlKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmaWVsZHMsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IGt3YXJncyxcbiAgICAgICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YToge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgYWRkaXRpb25hbF9rd2FyZ3MgaXMgcGFzc2VkIGludG8gc3VwZXIoKSBmb3Igc2VyaWFsaXphdGlvblxuICAgICAgICBpZiAoIWZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMuYWRkaXRpb25hbF9rd2FyZ3MgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpZWxkcy5yZXNwb25zZV9tZXRhZGF0YSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMucmVzcG9uc2VfbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwibWVzc2FnZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlLiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBzZW5kZXIgaW4gYSBtdWx0aS11c2VyIGNoYXQuICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEFkZGl0aW9uYWwga2V5d29yZCBhcmd1bWVudHMgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRkaXRpb25hbF9rd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFJlc3BvbnNlIG1ldGFkYXRhLiBGb3IgZXhhbXBsZTogcmVzcG9uc2UgaGVhZGVycywgbG9ncHJvYnMsIHRva2VuIGNvdW50cy4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzcG9uc2VfbWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgbWVzc2FnZS4gVGhpcyBzaG91bGQgaWRlYWxseSBiZVxuICAgICAgICAgKiBwcm92aWRlZCBieSB0aGUgcHJvdmlkZXIvbW9kZWwgd2hpY2ggY3JlYXRlZCB0aGUgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBmaWVsZHMuY29udGVudDtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsX2t3YXJncyA9IGZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncztcbiAgICAgICAgdGhpcy5yZXNwb25zZV9tZXRhZGF0YSA9IGZpZWxkcy5yZXNwb25zZV9tZXRhZGF0YTtcbiAgICAgICAgdGhpcy5pZCA9IGZpZWxkcy5pZDtcbiAgICB9XG4gICAgdG9EaWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZSgpLFxuICAgICAgICAgICAgZGF0YTogdGhpcy50b0pTT04oKVxuICAgICAgICAgICAgICAgIC5rd2FyZ3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJCYXNlTWVzc2FnZVwiO1xuICAgIH1cbiAgICAvLyBDYW4ndCBiZSBwcm90ZWN0ZWQgZm9yIHNpbGx5IHJlYXNvbnNcbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogdGhpcy5yZXNwb25zZV9tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gdGhpcyBwcml2YXRlIG1ldGhvZCBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgSUQgZm9yIHRoZSBydW50aW1lXG4gICAgLy8gdmFsdWUgYXMgd2VsbCBhcyBpbiBsY19rd2FyZ3MgZm9yIHNlcmlhbGlzYXRpb25cbiAgICBfdXBkYXRlSWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pZCA9IHZhbHVlO1xuICAgICAgICAvLyBsY19hdHRyaWJ1dGVzIHdvdWxkbid0IHdvcmsgaGVyZSwgYmVjYXVzZSBqZXN0IGNvbXBhcmVzIHRoZVxuICAgICAgICAvLyB3aG9sZSBvYmplY3RcbiAgICAgICAgdGhpcy5sY19rd2FyZ3MuaWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5sY19uYW1lKCk7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGNvbnNvbGUubG9nXG4gICAgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmludGFibGUgPSBzdHJpbmdpZnlXaXRoRGVwdGhMaW1pdCh0aGlzLl9wcmludGFibGVGaWVsZHMsIE1hdGgubWF4KDQsIGRlcHRoKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLmxjX25hbWUoKX0gJHtwcmludGFibGV9YDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPcGVuQUlUb29sQ2FsbEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZS5ldmVyeSgodikgPT4gdHlwZW9mIHYuaW5kZXggPT09IFwibnVtYmVyXCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VEaWN0cyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5sZWZ0LCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5yaWdodFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4ubGVmdCB9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJpZ2h0KSkge1xuICAgICAgICBpZiAobWVyZ2VkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVyZ2VkW2tleV0gIT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShtZXJnZWRba2V5XSkgIT09IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpZWxkWyR7a2V5fV0gYWxyZWFkeSBleGlzdHMgaW4gdGhlIG1lc3NhZ2UgY2h1bmssIGJ1dCB3aXRoIGEgZGlmZmVyZW50IHR5cGUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lcmdlZFtrZXldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcInR5cGVcIikge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBtZXJnZSAndHlwZScgZmllbGRzXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXJnZWRba2V5XSArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVyZ2VkW2tleV0gPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkobWVyZ2VkW2tleV0pKSB7XG4gICAgICAgICAgICBtZXJnZWRba2V5XSA9IF9tZXJnZURpY3RzKG1lcmdlZFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXJnZWRba2V5XSkpIHtcbiAgICAgICAgICAgIG1lcmdlZFtrZXldID0gX21lcmdlTGlzdHMobWVyZ2VkW2tleV0sIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXJnZWRba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBmaWVsZFske2tleX1dIGFscmVhZHkgZXhpc3RzIGluIHRoaXMgbWVzc2FnZSBjaHVuayBhbmQgdmFsdWUgaGFzIHVuc3VwcG9ydGVkIHR5cGUuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gX21lcmdlTGlzdHMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVmdCA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQgfHwgcmlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBbLi4ubGVmdF07XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiByaWdodCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgXCJpbmRleFwiIGluIGl0ZW0gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgaXRlbS5pbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvTWVyZ2UgPSBtZXJnZWQuZmluZEluZGV4KChsZWZ0SXRlbSkgPT4gbGVmdEl0ZW0uaW5kZXggPT09IGl0ZW0uaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh0b01lcmdlICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRbdG9NZXJnZV0gPSBfbWVyZ2VEaWN0cyhtZXJnZWRbdG9NZXJnZV0sIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBcInRleHRcIiBpbiBpdGVtICYmXG4gICAgICAgICAgICAgICAgaXRlbS50ZXh0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8tb3AgLSBza2lwIGVtcHR5IHRleHQgYmxvY2tzXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gX21lcmdlT2JqKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKCFsZWZ0ICYmICFyaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgdHdvIHVuZGVmaW5lZCBvYmplY3RzLlwiKTtcbiAgICB9XG4gICAgaWYgKCFsZWZ0IHx8ICFyaWdodCkge1xuICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxlZnQgIT09IHR5cGVvZiByaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBtZXJnZSBvYmplY3RzIG9mIGRpZmZlcmVudCB0eXBlcy5cXG5MZWZ0ICR7dHlwZW9mIGxlZnR9XFxuUmlnaHQgJHt0eXBlb2YgcmlnaHR9YCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsZWZ0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaWdodCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gKGxlZnQgKyByaWdodCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobGVmdCkgJiYgQXJyYXkuaXNBcnJheShyaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIF9tZXJnZUxpc3RzKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxlZnQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJpZ2h0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBfbWVyZ2VEaWN0cyhsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IG1lcmdlIG9iamVjdHMgb2YgZGlmZmVyZW50IHR5cGVzLlxcbkxlZnQgJHtsZWZ0fVxcblJpZ2h0ICR7cmlnaHR9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbiAqIG1lc3NhZ2UgY2h1bmtzLiBJdCBpbmNsdWRlcyBhIG1ldGhvZCBgX21lcmdlX2t3YXJnc19kaWN0KClgIGZvciBtZXJnaW5nXG4gKiBhZGRpdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzIGZyb20gYW5vdGhlciBgQmFzZU1lc3NhZ2VDaHVua2AgaW50byB0aGlzXG4gKiBvbmUuIEl0IGFsc28gb3ZlcnJpZGVzIHRoZSBgX19hZGRfXygpYCBtZXRob2QgdG8gc3VwcG9ydCBjb25jYXRlbmF0aW9uXG4gKiBvZiBgQmFzZU1lc3NhZ2VDaHVua2AgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZU1lc3NhZ2VDaHVuayBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfaXNNZXNzYWdlRmllbGRXaXRoUm9sZSh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4LnJvbGUgPT09IFwic3RyaW5nXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCYXNlTWVzc2FnZShtZXNzYWdlTGlrZSkge1xuICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZUxpa2U/Ll9nZXRUeXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCYXNlTWVzc2FnZUNodW5rKG1lc3NhZ2VMaWtlKSB7XG4gICAgcmV0dXJuIChpc0Jhc2VNZXNzYWdlKG1lc3NhZ2VMaWtlKSAmJlxuICAgICAgICB0eXBlb2YgbWVzc2FnZUxpa2UuY29uY2F0ID09PSBcImZ1bmN0aW9uXCIpO1xufVxuIiwgImltcG9ydCB7IEJhc2VNZXNzYWdlLCBCYXNlTWVzc2FnZUNodW5rLCBtZXJnZUNvbnRlbnQsIF9tZXJnZURpY3RzLCBfbWVyZ2VPYmosIF9tZXJnZVN0YXR1cywgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNEaXJlY3RUb29sT3V0cHV0KHgpIHtcbiAgICByZXR1cm4gKHggIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcImxjX2RpcmVjdF90b29sX291dHB1dFwiIGluIHggJiZcbiAgICAgICAgeC5sY19kaXJlY3RfdG9vbF9vdXRwdXQgPT09IHRydWUpO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdG9vbCBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVG9vbE1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlRvb2xNZXNzYWdlXCI7XG4gICAgfVxuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICAvLyBleGNsdWRlIHNuYWtlIGNhc2UgY29udmVyc2lvbiB0byBwYXNjYWwgY2FzZVxuICAgICAgICByZXR1cm4geyB0b29sX2NhbGxfaWQ6IFwidG9vbF9jYWxsX2lkXCIgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCB0b29sX2NhbGxfaWQsIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIG5hbWUsIHRvb2xfY2FsbF9pZDogdG9vbF9jYWxsX2lkIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfZGlyZWN0X3Rvb2xfb3V0cHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhdHVzIG9mIHRoZSB0b29sIGludm9jYXRpb24uXG4gICAgICAgICAqIEB2ZXJzaW9uIDAuMi4xOVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbF9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJ0aWZhY3Qgb2YgdGhlIFRvb2wgZXhlY3V0aW9uIHdoaWNoIGlzIG5vdCBtZWFudCB0byBiZSBzZW50IHRvIHRoZSBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvdWxkIG9ubHkgYmUgc3BlY2lmaWVkIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBtZXNzYWdlIGNvbnRlbnQsIGUuZy4gaWYgb25seVxuICAgICAgICAgKiBhIHN1YnNldCBvZiB0aGUgZnVsbCB0b29sIG91dHB1dCBpcyBiZWluZyBwYXNzZWQgYXMgbWVzc2FnZSBjb250ZW50IGJ1dCB0aGUgZnVsbFxuICAgICAgICAgKiBvdXRwdXQgaXMgbmVlZGVkIGluIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJ0aWZhY3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfaWQgPSBmaWVsZHMudG9vbF9jYWxsX2lkO1xuICAgICAgICB0aGlzLmFydGlmYWN0ID0gZmllbGRzLmFydGlmYWN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGZpZWxkcy5zdGF0dXM7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ0b29sXCI7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luc3RhbmNlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuX2dldFR5cGUoKSA9PT0gXCJ0b29sXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9pZDogdGhpcy50b29sX2NhbGxfaWQsXG4gICAgICAgICAgICBhcnRpZmFjdDogdGhpcy5hcnRpZmFjdCxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIHRvb2wgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciB0b29sIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgVG9vbE1lc3NhZ2VDaHVuayBleHRlbmRzIEJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXR1cyBvZiB0aGUgdG9vbCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAdmVyc2lvbiAwLjIuMTlcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJ0aWZhY3Qgb2YgdGhlIFRvb2wgZXhlY3V0aW9uIHdoaWNoIGlzIG5vdCBtZWFudCB0byBiZSBzZW50IHRvIHRoZSBtb2RlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2hvdWxkIG9ubHkgYmUgc3BlY2lmaWVkIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBtZXNzYWdlIGNvbnRlbnQsIGUuZy4gaWYgb25seVxuICAgICAgICAgKiBhIHN1YnNldCBvZiB0aGUgZnVsbCB0b29sIG91dHB1dCBpcyBiZWluZyBwYXNzZWQgYXMgbWVzc2FnZSBjb250ZW50IGJ1dCB0aGUgZnVsbFxuICAgICAgICAgKiBvdXRwdXQgaXMgbmVlZGVkIGluIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJ0aWZhY3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfaWQgPSBmaWVsZHMudG9vbF9jYWxsX2lkO1xuICAgICAgICB0aGlzLmFydGlmYWN0ID0gZmllbGRzLmFydGlmYWN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGZpZWxkcy5zdGF0dXM7XG4gICAgfVxuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJUb29sTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJ0b29sXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFRvb2xNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgY29udGVudDogbWVyZ2VDb250ZW50KHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogX21lcmdlRGljdHModGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IF9tZXJnZURpY3RzKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIGFydGlmYWN0OiBfbWVyZ2VPYmoodGhpcy5hcnRpZmFjdCwgY2h1bmsuYXJ0aWZhY3QpLFxuICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0aGlzLnRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICAgICAgc3RhdHVzOiBfbWVyZ2VTdGF0dXModGhpcy5zdGF0dXMsIGNodW5rLnN0YXR1cyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRoaXMudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgYXJ0aWZhY3Q6IHRoaXMuYXJ0aWZhY3QsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRUb29sQ2FsbFBhcnNlcihcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5yYXdUb29sQ2FsbHMpIHtcbiAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICBjb25zdCBpbnZhbGlkVG9vbENhbGxzID0gW107XG4gICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiByYXdUb29sQ2FsbHMpIHtcbiAgICAgICAgaWYgKCF0b29sQ2FsbC5mdW5jdGlvbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvbkFyZ3MgPSBKU09OLnBhcnNlKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWUgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogZnVuY3Rpb25BcmdzIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMucHVzaChwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZFRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiTWFsZm9ybWVkIGFyZ3MuXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt0b29sQ2FsbHMsIGludmFsaWRUb29sQ2FsbHNdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVG9vbE1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwidG9vbFwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVG9vbE1lc3NhZ2VDaHVuayh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJ0b29sXCI7XG59XG4iLCAiaW1wb3J0IHsgcGFyc2VQYXJ0aWFsSnNvbiB9IGZyb20gXCIuLi91dGlscy9qc29uLmpzXCI7XG5pbXBvcnQgeyBCYXNlTWVzc2FnZSwgQmFzZU1lc3NhZ2VDaHVuaywgbWVyZ2VDb250ZW50LCBfbWVyZ2VEaWN0cywgX21lcmdlTGlzdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFRvb2xDYWxsUGFyc2VyLCB9IGZyb20gXCIuL3Rvb2wuanNcIjtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBBSSBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQUlNZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICAvLyBleGNsdWRlIHNuYWtlIGNhc2UgY29udmVyc2lvbiB0byBwYXNjYWwgY2FzZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIubGNfYWxpYXNlcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBcImludmFsaWRfdG9vbF9jYWxsc1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBsZXQgaW5pdFBhcmFtcztcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IFtdLFxuICAgICAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IGt3YXJncyA/PyB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0gZmllbGRzO1xuICAgICAgICAgICAgY29uc3QgcmF3VG9vbENhbGxzID0gaW5pdFBhcmFtcy5hZGRpdGlvbmFsX2t3YXJncz8udG9vbF9jYWxscztcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IGluaXRQYXJhbXMudG9vbF9jYWxscztcbiAgICAgICAgICAgIGlmICghKHJhd1Rvb2xDYWxscyA9PSBudWxsKSAmJlxuICAgICAgICAgICAgICAgIHJhd1Rvb2xDYWxscy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgKHRvb2xDYWxscyA9PT0gdW5kZWZpbmVkIHx8IHRvb2xDYWxscy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFtcbiAgICAgICAgICAgICAgICAgICAgXCJOZXcgTGFuZ0NoYWluIHBhY2thZ2VzIGFyZSBhdmFpbGFibGUgdGhhdCBtb3JlIGVmZmljaWVudGx5IGhhbmRsZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInRvb2wgY2FsbGluZy5cXG5cXG5QbGVhc2UgdXBncmFkZSB5b3VyIHBhY2thZ2VzIHRvIHZlcnNpb25zIHRoYXQgc2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWVzc2FnZSB0b29sIGNhbGxzLiBlLmcuLCBgeWFybiBhZGQgQGxhbmdjaGFpbi9hbnRocm9waWNgLFwiLFxuICAgICAgICAgICAgICAgICAgICBcInlhcm4gYWRkIEBsYW5nY2hhaW4vb3BlbmFpYCwgZXRjLlwiLFxuICAgICAgICAgICAgICAgIF0uam9pbihcIiBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIShyYXdUb29sQ2FsbHMgPT0gbnVsbCkgJiYgdG9vbENhbGxzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Rvb2xDYWxscywgaW52YWxpZFRvb2xDYWxsc10gPSBkZWZhdWx0VG9vbENhbGxQYXJzZXIocmF3VG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxzID0gdG9vbENhbGxzID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA9IGludmFsaWRUb29sQ2FsbHMgPz8gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPSBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPz8gW107XG4gICAgICAgICAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID0gaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPz8gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHBhcnNpbmcgZmFpbHNcbiAgICAgICAgICAgICAgICBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBpbml0UGFyYW1zLmludmFsaWRfdG9vbF9jYWxscyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNhZGx5LCBUeXBlU2NyaXB0IG9ubHkgYWxsb3dzIHN1cGVyKCkgY2FsbHMgYXQgcm9vdCBpZiB0aGUgY2xhc3MgaGFzXG4gICAgICAgIC8vIHByb3BlcnRpZXMgd2l0aCBpbml0aWFsaXplcnMsIHNvIHdlIGhhdmUgdG8gY2hlY2sgdHlwZXMgdHdpY2UuXG4gICAgICAgIHN1cGVyKGluaXRQYXJhbXMpO1xuICAgICAgICAvLyBUaGVzZSBhcmUgdHlwZWQgYXMgb3B0aW9uYWwgdG8gYXZvaWQgYnJlYWtpbmcgY2hhbmdlcyBhbmQgYWxsb3cgZm9yIGNhc3RpbmdcbiAgICAgICAgLy8gZnJvbSBCYXNlTWVzc2FnZS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbF9jYWxsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImludmFsaWRfdG9vbF9jYWxsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwcm92aWRlZCwgdG9rZW4gdXNhZ2UgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNzYWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNhZ2VfbWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0UGFyYW1zICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2xfY2FsbHMgPSBpbml0UGFyYW1zLnRvb2xfY2FsbHMgPz8gdGhpcy50b29sX2NhbGxzO1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPVxuICAgICAgICAgICAgICAgIGluaXRQYXJhbXMuaW52YWxpZF90b29sX2NhbGxzID8/IHRoaXMuaW52YWxpZF90b29sX2NhbGxzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXNhZ2VfbWV0YWRhdGEgPSBpbml0UGFyYW1zLnVzYWdlX21ldGFkYXRhO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQUlNZXNzYWdlXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJhaVwiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiB0aGlzLnRvb2xfY2FsbHMsXG4gICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IHRoaXMuaW52YWxpZF90b29sX2NhbGxzLFxuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IHRoaXMudXNhZ2VfbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQUlNZXNzYWdlKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImFpXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBSU1lc3NhZ2VDaHVuayh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJhaVwiO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYW4gQUkgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBBSSBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFJTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGxldCBpbml0UGFyYW1zO1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBmaWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsczogW10sXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRzLnRvb2xfY2FsbF9jaHVua3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsczogZmllbGRzLnRvb2xfY2FsbHMgPz8gW10sXG4gICAgICAgICAgICAgICAgaW52YWxpZF90b29sX2NhbGxzOiBbXSxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBbXSxcbiAgICAgICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogZmllbGRzLnVzYWdlX21ldGFkYXRhICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBmaWVsZHMudXNhZ2VfbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkVG9vbENhbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsQ2h1bmsgb2YgZmllbGRzLnRvb2xfY2FsbF9jaHVua3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXJncyA9IHt9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFyZ3MgPSBwYXJzZVBhcnRpYWxKc29uKHRvb2xDYWxsQ2h1bmsuYXJncyB8fCBcInt9XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkQXJncyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBhcnNlZEFyZ3MgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGFyc2VkQXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB0b29sIGNhbGwgY2h1bmsgYXJncy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbENhbGxDaHVuay5uYW1lID8/IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBwYXJzZWRBcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsQ2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsQ2h1bmsubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHRvb2xDYWxsQ2h1bmsuYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbENodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IFwiTWFsZm9ybWVkIGFyZ3MuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImludmFsaWRfdG9vbF9jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICBpbnZhbGlkX3Rvb2xfY2FsbHM6IGludmFsaWRUb29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IGZpZWxkcy51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gZmllbGRzLnVzYWdlX21ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTYWRseSwgVHlwZVNjcmlwdCBvbmx5IGFsbG93cyBzdXBlcigpIGNhbGxzIGF0IHJvb3QgaWYgdGhlIGNsYXNzIGhhc1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIHdpdGggaW5pdGlhbGl6ZXJzLCBzbyB3ZSBoYXZlIHRvIGNoZWNrIHR5cGVzIHR3aWNlLlxuICAgICAgICBzdXBlcihpbml0UGFyYW1zKTtcbiAgICAgICAgLy8gTXVzdCByZWRlY2xhcmUgdG9vbCBjYWxsIGZpZWxkcyBzaW5jZSB0aGVyZSBpcyBubyBtdWx0aXBsZSBpbmhlcml0YW5jZSBpbiBKUy5cbiAgICAgICAgLy8gVGhlc2UgYXJlIHR5cGVkIGFzIG9wdGlvbmFsIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXMgYW5kIGFsbG93IGZvciBjYXN0aW5nXG4gICAgICAgIC8vIGZyb20gQmFzZU1lc3NhZ2UuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfY2h1bmtzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHByb3ZpZGVkLCB0b2tlbiB1c2FnZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1c2FnZV9tZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvb2xfY2FsbF9jaHVua3MgPVxuICAgICAgICAgICAgaW5pdFBhcmFtcy50b29sX2NhbGxfY2h1bmtzID8/IHRoaXMudG9vbF9jYWxsX2NodW5rcztcbiAgICAgICAgdGhpcy50b29sX2NhbGxzID0gaW5pdFBhcmFtcy50b29sX2NhbGxzID8/IHRoaXMudG9vbF9jYWxscztcbiAgICAgICAgdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPVxuICAgICAgICAgICAgaW5pdFBhcmFtcy5pbnZhbGlkX3Rvb2xfY2FsbHMgPz8gdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHM7XG4gICAgICAgIHRoaXMudXNhZ2VfbWV0YWRhdGEgPSBpbml0UGFyYW1zLnVzYWdlX21ldGFkYXRhO1xuICAgIH1cbiAgICBnZXQgbGNfYWxpYXNlcygpIHtcbiAgICAgICAgLy8gZXhjbHVkZSBzbmFrZSBjYXNlIGNvbnZlcnNpb24gdG8gcGFzY2FsIGNhc2VcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLmxjX2FsaWFzZXMsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIixcbiAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IFwidG9vbF9jYWxsX2NodW5rc1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQUlNZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImFpXCI7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRoaXMudG9vbF9jYWxscyxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IHRoaXMudG9vbF9jYWxsX2NodW5rcyxcbiAgICAgICAgICAgIGludmFsaWRfdG9vbF9jYWxsczogdGhpcy5pbnZhbGlkX3Rvb2xfY2FsbHMsXG4gICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogdGhpcy51c2FnZV9tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkRmllbGRzID0ge1xuICAgICAgICAgICAgY29udGVudDogbWVyZ2VDb250ZW50KHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogX21lcmdlRGljdHModGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IF9tZXJnZURpY3RzKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IFtdLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQgPz8gY2h1bmsuaWQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnRvb2xfY2FsbF9jaHVua3MgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgY2h1bmsudG9vbF9jYWxsX2NodW5rcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByYXdUb29sQ2FsbHMgPSBfbWVyZ2VMaXN0cyh0aGlzLnRvb2xfY2FsbF9jaHVua3MsIGNodW5rLnRvb2xfY2FsbF9jaHVua3MpO1xuICAgICAgICAgICAgaWYgKHJhd1Rvb2xDYWxscyAhPT0gdW5kZWZpbmVkICYmIHJhd1Rvb2xDYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZWRGaWVsZHMudG9vbF9jYWxsX2NodW5rcyA9IHJhd1Rvb2xDYWxscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjaHVuay51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFRva2VuRGV0YWlscyA9IHtcbiAgICAgICAgICAgICAgICAuLi4oKHRoaXMudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86ICh0aGlzLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5hdWRpbyA/PyAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvID8/IDApLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLigodGhpcy51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfcmVhZCAhPT1cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9yZWFkICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlX3JlYWQ6ICh0aGlzLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9yZWFkID8/IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaHVuay51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfcmVhZCA/PyAwKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi4oKHRoaXMudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX2NyZWF0aW9uICE9PVxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/LmlucHV0X3Rva2VuX2RldGFpbHM/LmNhY2hlX2NyZWF0aW9uICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlX2NyZWF0aW9uOiAodGhpcy51c2FnZV9tZXRhZGF0YT8uaW5wdXRfdG9rZW5fZGV0YWlscz8uY2FjaGVfY3JlYXRpb24gPz8gMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNodW5rLnVzYWdlX21ldGFkYXRhPy5pbnB1dF90b2tlbl9kZXRhaWxzPy5jYWNoZV9jcmVhdGlvbiA/PyAwKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRUb2tlbkRldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uKCh0aGlzLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBjaHVuay51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LmF1ZGlvICE9PSB1bmRlZmluZWQpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86ICh0aGlzLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gPz8gMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNodW5rLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8uYXVkaW8gPz8gMCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uKCh0aGlzLnVzYWdlX21ldGFkYXRhPy5vdXRwdXRfdG9rZW5fZGV0YWlscz8ucmVhc29uaW5nICE9PVxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsudXNhZ2VfbWV0YWRhdGE/Lm91dHB1dF90b2tlbl9kZXRhaWxzPy5yZWFzb25pbmcgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpICYmIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uaW5nOiAodGhpcy51c2FnZV9tZXRhZGF0YT8ub3V0cHV0X3Rva2VuX2RldGFpbHM/LnJlYXNvbmluZyA/PyAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2h1bmsudXNhZ2VfbWV0YWRhdGE/Lm91dHB1dF90b2tlbl9kZXRhaWxzPy5yZWFzb25pbmcgPz8gMCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMudXNhZ2VfbWV0YWRhdGEgPz8ge1xuICAgICAgICAgICAgICAgIGlucHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiAwLFxuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGNodW5rLnVzYWdlX21ldGFkYXRhID8/IHtcbiAgICAgICAgICAgICAgICBpbnB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0X3Rva2VuczogMCxcbiAgICAgICAgICAgICAgICB0b3RhbF90b2tlbnM6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdXNhZ2VfbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiBsZWZ0LmlucHV0X3Rva2VucyArIHJpZ2h0LmlucHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiBsZWZ0Lm91dHB1dF90b2tlbnMgKyByaWdodC5vdXRwdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgIHRvdGFsX3Rva2VuczogbGVmdC50b3RhbF90b2tlbnMgKyByaWdodC50b3RhbF90b2tlbnMsXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgYGlucHV0X3Rva2VuX2RldGFpbHNgIC8gYG91dHB1dF90b2tlbl9kZXRhaWxzYCBrZXlzIGluIGNvbWJpbmVkIGZpZWxkc1xuICAgICAgICAgICAgICAgIC8vIHVubGVzcyB0aGVpciB2YWx1ZXMgYXJlIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgLi4uKE9iamVjdC5rZXlzKGlucHV0VG9rZW5EZXRhaWxzKS5sZW5ndGggPiAwICYmIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5fZGV0YWlsczogaW5wdXRUb2tlbkRldGFpbHMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uKE9iamVjdC5rZXlzKG91dHB1dFRva2VuRGV0YWlscykubGVuZ3RoID4gMCAmJiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dF90b2tlbl9kZXRhaWxzOiBvdXRwdXRUb2tlbkRldGFpbHMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29tYmluZWRGaWVsZHMudXNhZ2VfbWV0YWRhdGEgPSB1c2FnZV9tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFJTWVzc2FnZUNodW5rKGNvbWJpbmVkRmllbGRzKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2hhdCBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQ2hhdE1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRNZXNzYWdlXCI7XG4gICAgfVxuICAgIHN0YXRpYyBfY2hhdE1lc3NhZ2VDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIENoYXRNZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHJvbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIHJvbGU6IHJvbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb2xlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm9sZSA9IGZpZWxkcy5yb2xlO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBzdGF0aWMgaXNJbnN0YW5jZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLl9nZXRUeXBlKCkgPT09IFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBnZXQgX3ByaW50YWJsZUZpZWxkcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLl9wcmludGFibGVGaWVsZHMsXG4gICAgICAgICAgICByb2xlOiB0aGlzLnJvbGUsXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBjaGF0IG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgY2hhdCBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIENoYXRNZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdE1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHJvbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIHJvbGU6IHJvbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb2xlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm9sZSA9IGZpZWxkcy5yb2xlO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZ2VuZXJpY1wiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICByb2xlOiB0aGlzLnJvbGUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCA/PyBjaHVuay5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBfcHJpbnRhYmxlRmllbGRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIuX3ByaW50YWJsZUZpZWxkcyxcbiAgICAgICAgICAgIHJvbGU6IHRoaXMucm9sZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDaGF0TWVzc2FnZSh4KSB7XG4gICAgcmV0dXJuIHguX2dldFR5cGUoKSA9PT0gXCJnZW5lcmljXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDaGF0TWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImdlbmVyaWNcIjtcbn1cbiIsICJpbXBvcnQgeyBCYXNlTWVzc2FnZSwgQmFzZU1lc3NhZ2VDaHVuaywgbWVyZ2VDb250ZW50LCBfbWVyZ2VEaWN0cywgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBmdW5jdGlvbiBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25NZXNzYWdlIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJGdW5jdGlvbk1lc3NhZ2VcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgY29udGVudDogZmllbGRzLCBuYW1lOiBuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBmdW5jdGlvbiBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkXG4gKiB3aXRoIG90aGVyIGZ1bmN0aW9uIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25NZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiRnVuY3Rpb25NZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IF9tZXJnZURpY3RzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgICAgIHJlc3BvbnNlX21ldGFkYXRhOiBfbWVyZ2VEaWN0cyh0aGlzLnJlc3BvbnNlX21ldGFkYXRhLCBjaHVuay5yZXNwb25zZV9tZXRhZGF0YSksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgPz8gXCJcIixcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbk1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uTWVzc2FnZUNodW5rKHgpIHtcbiAgICByZXR1cm4geC5fZ2V0VHlwZSgpID09PSBcImZ1bmN0aW9uXCI7XG59XG4iLCAiaW1wb3J0IHsgQmFzZU1lc3NhZ2UsIEJhc2VNZXNzYWdlQ2h1bmssIG1lcmdlQ29udGVudCwgX21lcmdlRGljdHMsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgaHVtYW4gbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEh1bWFuTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSHVtYW5NZXNzYWdlXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJodW1hblwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGt3YXJncyk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY2h1bmsgb2YgYSBodW1hbiBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGhcbiAqIG90aGVyIGh1bWFuIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgSHVtYW5NZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSHVtYW5NZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImh1bWFuXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywga3dhcmdzKTtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHVtYW5NZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgY29udGVudDogbWVyZ2VDb250ZW50KHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogX21lcmdlRGljdHModGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IF9tZXJnZURpY3RzKHRoaXMucmVzcG9uc2VfbWV0YWRhdGEsIGNodW5rLnJlc3BvbnNlX21ldGFkYXRhKSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkID8/IGNodW5rLmlkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNIdW1hbk1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4LmdldFR5cGUoKSA9PT0gXCJodW1hblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSHVtYW5NZXNzYWdlQ2h1bmsoeCkge1xuICAgIHJldHVybiB4LmdldFR5cGUoKSA9PT0gXCJodW1hblwiO1xufVxuIiwgImltcG9ydCB7IEJhc2VNZXNzYWdlLCBCYXNlTWVzc2FnZUNodW5rLCBtZXJnZUNvbnRlbnQsIF9tZXJnZURpY3RzLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbi8qKlxuICogUmVwcmVzZW50cyBhIHN5c3RlbSBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU3lzdGVtTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3lzdGVtTWVzc2FnZVwiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAga3dhcmdzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcywga3dhcmdzKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIHN5c3RlbSBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGhcbiAqIG90aGVyIHN5c3RlbSBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN5c3RlbU1lc3NhZ2VDaHVuayBleHRlbmRzIEJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJTeXN0ZW1NZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcInN5c3RlbVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIGt3YXJncykge1xuICAgICAgICBzdXBlcihmaWVsZHMsIGt3YXJncyk7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFN5c3RlbU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiBtZXJnZUNvbnRlbnQodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBfbWVyZ2VEaWN0cyh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogX21lcmdlRGljdHModGhpcy5yZXNwb25zZV9tZXRhZGF0YSwgY2h1bmsucmVzcG9uc2VfbWV0YWRhdGEpLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQgPz8gY2h1bmsuaWQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N5c3RlbU1lc3NhZ2UoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwic3lzdGVtXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTeXN0ZW1NZXNzYWdlQ2h1bmsoeCkge1xuICAgIHJldHVybiB4Ll9nZXRUeXBlKCkgPT09IFwic3lzdGVtXCI7XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRMYW5nQ2hhaW5FcnJvckZpZWxkcyhlcnJvciwgbGNfZXJyb3JfY29kZSkge1xuICAgIGVycm9yLmxjX2Vycm9yX2NvZGUgPSBsY19lcnJvcl9jb2RlO1xuICAgIGVycm9yLm1lc3NhZ2UgPSBgJHtlcnJvci5tZXNzYWdlfVxcblxcblRyb3VibGVzaG9vdGluZyBVUkw6IGh0dHBzOi8vanMubGFuZ2NoYWluLmNvbS9kb2NzL3Ryb3VibGVzaG9vdGluZy9lcnJvcnMvJHtsY19lcnJvcl9jb2RlfS9cXG5gO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gX2lzVG9vbENhbGwodG9vbENhbGwpIHtcbiAgICByZXR1cm4gISEodG9vbENhbGwgJiZcbiAgICAgICAgdHlwZW9mIHRvb2xDYWxsID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIFwidHlwZVwiIGluIHRvb2xDYWxsICYmXG4gICAgICAgIHRvb2xDYWxsLnR5cGUgPT09IFwidG9vbF9jYWxsXCIpO1xufVxuLyoqXG4gKiBDdXN0b20gZXJyb3IgY2xhc3MgdXNlZCB0byBoYW5kbGUgZXhjZXB0aW9ucyByZWxhdGVkIHRvIHRvb2wgaW5wdXQgcGFyc2luZy5cbiAqIEl0IGV4dGVuZHMgdGhlIGJ1aWx0LWluIGBFcnJvcmAgY2xhc3MgYW5kIGFkZHMgYW4gb3B0aW9uYWwgYG91dHB1dGBcbiAqIHByb3BlcnR5IHRoYXQgY2FuIGhvbGQgdGhlIG91dHB1dCB0aGF0IGNhdXNlZCB0aGUgZXhjZXB0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvdXRwdXQpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgYWRkTGFuZ0NoYWluRXJyb3JGaWVsZHMgfSBmcm9tIFwiLi4vZXJyb3JzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBfaXNUb29sQ2FsbCB9IGZyb20gXCIuLi90b29scy91dGlscy5qc1wiO1xuaW1wb3J0IHsgQUlNZXNzYWdlLCBBSU1lc3NhZ2VDaHVuayB9IGZyb20gXCIuL2FpLmpzXCI7XG5pbXBvcnQgeyBpc0Jhc2VNZXNzYWdlLCBfaXNNZXNzYWdlRmllbGRXaXRoUm9sZSwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBDaGF0TWVzc2FnZSwgQ2hhdE1lc3NhZ2VDaHVuaywgfSBmcm9tIFwiLi9jaGF0LmpzXCI7XG5pbXBvcnQgeyBGdW5jdGlvbk1lc3NhZ2UsIEZ1bmN0aW9uTWVzc2FnZUNodW5rLCB9IGZyb20gXCIuL2Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgeyBIdW1hbk1lc3NhZ2UsIEh1bWFuTWVzc2FnZUNodW5rIH0gZnJvbSBcIi4vaHVtYW4uanNcIjtcbmltcG9ydCB7IFN5c3RlbU1lc3NhZ2UsIFN5c3RlbU1lc3NhZ2VDaHVuayB9IGZyb20gXCIuL3N5c3RlbS5qc1wiO1xuaW1wb3J0IHsgVG9vbE1lc3NhZ2UsIH0gZnJvbSBcIi4vdG9vbC5qc1wiO1xuZnVuY3Rpb24gX2NvZXJjZVRvb2xDYWxsKHRvb2xDYWxsKSB7XG4gICAgaWYgKF9pc1Rvb2xDYWxsKHRvb2xDYWxsKSkge1xuICAgICAgICByZXR1cm4gdG9vbENhbGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0b29sQ2FsbC5pZCA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICB0b29sQ2FsbC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uICE9PSBudWxsICYmXG4gICAgICAgIFwiYXJndW1lbnRzXCIgaW4gdG9vbENhbGwuZnVuY3Rpb24gJiZcbiAgICAgICAgdHlwZW9mIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICBcIm5hbWVcIiBpbiB0b29sQ2FsbC5mdW5jdGlvbiAmJlxuICAgICAgICB0eXBlb2YgdG9vbENhbGwuZnVuY3Rpb24ubmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBIYW5kbGUgT3BlbkFJIHRvb2wgY2FsbCBmb3JtYXRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgIGFyZ3M6IEpTT04ucGFyc2UodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgIG5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogVGhyb3cgYW4gZXJyb3I/XG4gICAgICAgIHJldHVybiB0b29sQ2FsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWRDb25zdHJ1Y3Rvcih4KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB4ICE9IG51bGwgJiZcbiAgICAgICAgeC5sYyA9PT0gMSAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHguaWQpICYmXG4gICAgICAgIHgua3dhcmdzICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHgua3dhcmdzID09PSBcIm9iamVjdFwiKTtcbn1cbmZ1bmN0aW9uIF9jb25zdHJ1Y3RNZXNzYWdlRnJvbVBhcmFtcyhwYXJhbXMpIHtcbiAgICBsZXQgdHlwZTtcbiAgICBsZXQgcmVzdDtcbiAgICAvLyBTdXBwb3J0IHNlcmlhbGl6ZWQgbWVzc2FnZXNcbiAgICBpZiAoaXNTZXJpYWxpemVkQ29uc3RydWN0b3IocGFyYW1zKSkge1xuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBwYXJhbXMuaWQuYXQoLTEpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lID09PSBcIkh1bWFuTWVzc2FnZVwiIHx8IGNsYXNzTmFtZSA9PT0gXCJIdW1hbk1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJ1c2VyXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhc3NOYW1lID09PSBcIkFJTWVzc2FnZVwiIHx8IGNsYXNzTmFtZSA9PT0gXCJBSU1lc3NhZ2VDaHVua1wiKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJhc3Npc3RhbnRcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc05hbWUgPT09IFwiU3lzdGVtTWVzc2FnZVwiIHx8XG4gICAgICAgICAgICBjbGFzc05hbWUgPT09IFwiU3lzdGVtTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcInN5c3RlbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gXCJGdW5jdGlvbk1lc3NhZ2VcIiB8fFxuICAgICAgICAgICAgY2xhc3NOYW1lID09PSBcIkZ1bmN0aW9uTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhc3NOYW1lID09PSBcIlRvb2xNZXNzYWdlXCIgfHxcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9PT0gXCJUb29sTWVzc2FnZUNodW5rXCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcInRvb2xcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSBcInVua25vd25cIjtcbiAgICAgICAgfVxuICAgICAgICByZXN0ID0gcGFyYW1zLmt3YXJncztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZTogZXh0cmFjdGVkVHlwZSwgLi4ub3RoZXJQYXJhbXMgfSA9IHBhcmFtcztcbiAgICAgICAgdHlwZSA9IGV4dHJhY3RlZFR5cGU7XG4gICAgICAgIHJlc3QgPSBvdGhlclBhcmFtcztcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiaHVtYW5cIiB8fCB0eXBlID09PSBcInVzZXJcIikge1xuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZShyZXN0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJhaVwiIHx8IHR5cGUgPT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICAgICAgY29uc3QgeyB0b29sX2NhbGxzOiByYXdUb29sQ2FsbHMsIC4uLm90aGVyIH0gPSByZXN0O1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3VG9vbENhbGxzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2UocmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9vbF9jYWxscyA9IHJhd1Rvb2xDYWxscy5tYXAoX2NvZXJjZVRvb2xDYWxsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2UoeyAuLi5vdGhlciwgdG9vbF9jYWxscyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICByZXR1cm4gbmV3IFN5c3RlbU1lc3NhZ2UocmVzdCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiZGV2ZWxvcGVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTeXN0ZW1NZXNzYWdlKHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczoge1xuICAgICAgICAgICAgICAgIC4uLnJlc3QuYWRkaXRpb25hbF9rd2FyZ3MsXG4gICAgICAgICAgICAgICAgX19vcGVuYWlfcm9sZV9fOiBcImRldmVsb3BlclwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwidG9vbFwiICYmIFwidG9vbF9jYWxsX2lkXCIgaW4gcmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFRvb2xNZXNzYWdlKHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBjb250ZW50OiByZXN0LmNvbnRlbnQsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHJlc3QudG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgbmFtZTogcmVzdC5uYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYWRkTGFuZ0NoYWluRXJyb3JGaWVsZHMobmV3IEVycm9yKGBVbmFibGUgdG8gY29lcmNlIG1lc3NhZ2UgZnJvbSBhcnJheTogb25seSBodW1hbiwgQUksIHN5c3RlbSwgZGV2ZWxvcGVyLCBvciB0b29sIG1lc3NhZ2UgY29lcmNpb24gaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cXG5cXG5SZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShwYXJhbXMsIG51bGwsIDIpfWApLCBcIk1FU1NBR0VfQ09FUkNJT05fRkFJTFVSRVwiKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKG1lc3NhZ2VMaWtlKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlTGlrZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZShtZXNzYWdlTGlrZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQmFzZU1lc3NhZ2UobWVzc2FnZUxpa2UpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlTGlrZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZUxpa2UpKSB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBjb250ZW50XSA9IG1lc3NhZ2VMaWtlO1xuICAgICAgICByZXR1cm4gX2NvbnN0cnVjdE1lc3NhZ2VGcm9tUGFyYW1zKHsgdHlwZSwgY29udGVudCB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzTWVzc2FnZUZpZWxkV2l0aFJvbGUobWVzc2FnZUxpa2UpKSB7XG4gICAgICAgIGNvbnN0IHsgcm9sZTogdHlwZSwgLi4ucmVzdCB9ID0gbWVzc2FnZUxpa2U7XG4gICAgICAgIHJldHVybiBfY29uc3RydWN0TWVzc2FnZUZyb21QYXJhbXMoeyAuLi5yZXN0LCB0eXBlIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9jb25zdHJ1Y3RNZXNzYWdlRnJvbVBhcmFtcyhtZXNzYWdlTGlrZSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgbWVtb3J5IGNsYXNzZXMgdG8gZ2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgY2hhdCBtZXNzYWdlIGhpc3RvcnksIGJhc2VkIG9uIHRoZSBtZXNzYWdlIGNvbnRlbnQgYW5kIHJvbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCdWZmZXJTdHJpbmcobWVzc2FnZXMsIGh1bWFuUHJlZml4ID0gXCJIdW1hblwiLCBhaVByZWZpeCA9IFwiQUlcIikge1xuICAgIGNvbnN0IHN0cmluZ19tZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbSBvZiBtZXNzYWdlcykge1xuICAgICAgICBsZXQgcm9sZTtcbiAgICAgICAgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJodW1hblwiKSB7XG4gICAgICAgICAgICByb2xlID0gaHVtYW5QcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcImFpXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBhaVByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBcIlN5c3RlbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByb2xlID0gXCJGdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBcIlRvb2xcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICByb2xlID0gbS5yb2xlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5zdXBwb3J0ZWQgbWVzc2FnZSB0eXBlOiAke20uX2dldFR5cGUoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lU3RyID0gbS5uYW1lID8gYCR7bS5uYW1lfSwgYCA6IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlYWRhYmxlQ29udGVudCA9IHR5cGVvZiBtLmNvbnRlbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gbS5jb250ZW50XG4gICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG0uY29udGVudCwgbnVsbCwgMik7XG4gICAgICAgIHN0cmluZ19tZXNzYWdlcy5wdXNoKGAke3JvbGV9OiAke25hbWVTdHJ9JHtyZWFkYWJsZUNvbnRlbnR9YCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdfbWVzc2FnZXMuam9pbihcIlxcblwiKTtcbn1cbi8qKlxuICogTWFwcyBtZXNzYWdlcyBmcm9tIGFuIG9sZGVyIGZvcm1hdCAoVjEpIHRvIHRoZSBjdXJyZW50IGBTdG9yZWRNZXNzYWdlYFxuICogZm9ybWF0LiBJZiB0aGUgbWVzc2FnZSBpcyBhbHJlYWR5IGluIHRoZSBgU3RvcmVkTWVzc2FnZWAgZm9ybWF0LCBpdCBpc1xuICogcmV0dXJuZWQgYXMgaXMuIE90aGVyd2lzZSwgaXQgdHJhbnNmb3JtcyB0aGUgVjEgbWVzc2FnZSBpbnRvIGFcbiAqIGBTdG9yZWRNZXNzYWdlYC4gVGhpcyBmdW5jdGlvbiBpcyBpbXBvcnRhbnQgZm9yIG1haW50YWluaW5nXG4gKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgbWVzc2FnZSBmb3JtYXRzLlxuICovXG5mdW5jdGlvbiBtYXBWMU1lc3NhZ2VUb1N0b3JlZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIG1hcHBlciB3aGVuIHdlIGRlcHJlY2F0ZSB0aGUgb2xkIG1lc3NhZ2UgZm9ybWF0LlxuICAgIGlmIChtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHYxTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB2MU1lc3NhZ2UudHlwZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2MU1lc3NhZ2UudGV4dCxcbiAgICAgICAgICAgICAgICByb2xlOiB2MU1lc3NhZ2Uucm9sZSxcbiAgICAgICAgICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXBTdG9yZWRNZXNzYWdlVG9DaGF0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3Qgc3RvcmVkTWVzc2FnZSA9IG1hcFYxTWVzc2FnZVRvU3RvcmVkTWVzc2FnZShtZXNzYWdlKTtcbiAgICBzd2l0Y2ggKHN0b3JlZE1lc3NhZ2UudHlwZSkge1xuICAgICAgICBjYXNlIFwiaHVtYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSHVtYW5NZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJhaVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcInN5c3RlbVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeXN0ZW1NZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgaWYgKHN0b3JlZE1lc3NhZ2UuZGF0YS5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIG11c3QgYmUgZGVmaW5lZCBmb3IgZnVuY3Rpb24gbWVzc2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwidG9vbFwiOlxuICAgICAgICAgICAgaWYgKHN0b3JlZE1lc3NhZ2UuZGF0YS50b29sX2NhbGxfaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvb2wgY2FsbCBJRCBtdXN0IGJlIGRlZmluZWQgZm9yIHRvb2wgbWVzc2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRvb2xNZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJnZW5lcmljXCI6IHtcbiAgICAgICAgICAgIGlmIChzdG9yZWRNZXNzYWdlLmRhdGEucm9sZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9sZSBtdXN0IGJlIGRlZmluZWQgZm9yIGNoYXQgbWVzc2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYXRNZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVuZXhwZWN0ZWQgdHlwZTogJHtzdG9yZWRNZXNzYWdlLnR5cGV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIGBTdG9yZWRNZXNzYWdlYCBpbnN0YW5jZXMgaW50byBhbiBhcnJheSBvZlxuICogYEJhc2VNZXNzYWdlYCBpbnN0YW5jZXMuIEl0IHVzZXMgdGhlIGBtYXBWMU1lc3NhZ2VUb1N0b3JlZE1lc3NhZ2VgXG4gKiBmdW5jdGlvbiB0byBlbnN1cmUgYWxsIG1lc3NhZ2VzIGFyZSBpbiB0aGUgYFN0b3JlZE1lc3NhZ2VgIGZvcm1hdCwgdGhlblxuICogY3JlYXRlcyBuZXcgaW5zdGFuY2VzIG9mIHRoZSBhcHByb3ByaWF0ZSBgQmFzZU1lc3NhZ2VgIHN1YmNsYXNzIGJhc2VkXG4gKiBvbiB0aGUgdHlwZSBvZiBlYWNoIG1lc3NhZ2UuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBwcmVwYXJlIHN0b3JlZFxuICogbWVzc2FnZXMgZm9yIHVzZSBpbiBhIGNoYXQgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFN0b3JlZE1lc3NhZ2VzVG9DaGF0TWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKG1hcFN0b3JlZE1lc3NhZ2VUb0NoYXRNZXNzYWdlKTtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBgQmFzZU1lc3NhZ2VgIGluc3RhbmNlcyBpbnRvIGFuIGFycmF5IG9mXG4gKiBgU3RvcmVkTWVzc2FnZWAgaW5zdGFuY2VzLiBJdCBkb2VzIHRoaXMgYnkgY2FsbGluZyB0aGUgYHRvRGljdGAgbWV0aG9kXG4gKiBvbiBlYWNoIGBCYXNlTWVzc2FnZWAsIHdoaWNoIHJldHVybnMgYSBgU3RvcmVkTWVzc2FnZWAuIFRoaXMgZnVuY3Rpb25cbiAqIGlzIHVzZWQgdG8gcHJlcGFyZSBjaGF0IG1lc3NhZ2VzIGZvciBzdG9yYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwQ2hhdE1lc3NhZ2VzVG9TdG9yZWRNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIHJldHVybiBtZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UudG9EaWN0KCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0NodW5rKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5fZ2V0VHlwZSgpO1xuICAgIGlmICh0eXBlID09PSBcImh1bWFuXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IEh1bWFuTWVzc2FnZUNodW5rKHsgLi4ubWVzc2FnZSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJhaVwiKSB7XG4gICAgICAgIGxldCBhaUNodW5rRmllbGRzID0ge1xuICAgICAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwidG9vbF9jYWxsc1wiIGluIGFpQ2h1bmtGaWVsZHMpIHtcbiAgICAgICAgICAgIGFpQ2h1bmtGaWVsZHMgPSB7XG4gICAgICAgICAgICAgICAgLi4uYWlDaHVua0ZpZWxkcyxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfY2h1bmtzOiBhaUNodW5rRmllbGRzLnRvb2xfY2FsbHM/Lm1hcCgodGMpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRjLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2xfY2FsbF9jaHVua1wiLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBKU09OLnN0cmluZ2lmeSh0Yy5hcmdzKSxcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2VDaHVuayh7IC4uLmFpQ2h1bmtGaWVsZHMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFN5c3RlbU1lc3NhZ2VDaHVuayh7IC4uLm1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25NZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgfVxuICAgIGVsc2UgaWYgKENoYXRNZXNzYWdlLmlzSW5zdGFuY2UobWVzc2FnZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IENoYXRNZXNzYWdlQ2h1bmsoeyAuLi5tZXNzYWdlIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBtZXNzYWdlIHR5cGUuXCIpO1xuICAgIH1cbn1cbiIsICJ2YXIgdXRpbDtcbihmdW5jdGlvbiAodXRpbCkge1xuICAgIHV0aWwuYXNzZXJ0RXF1YWwgPSAodmFsKSA9PiB2YWw7XG4gICAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykgeyB9XG4gICAgdXRpbC5hc3NlcnRJcyA9IGFzc2VydElzO1xuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XG4gICAgdXRpbC5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBvYmpbaXRlbV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAob2JqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfTtcbiAgICB1dGlsLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB1dGlsLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyAodmFsKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5XG4gICAgICAgICAgICAubWFwKCh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkpXG4gICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgIH1cbiAgICB1dGlsLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICAgIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAuLi5zZWNvbmQsIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gICAgICAgIH07XG4gICAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xuY29uc3QgWm9kUGFyc2VkVHlwZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwic3RyaW5nXCIsXG4gICAgXCJuYW5cIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcImRhdGVcIixcbiAgICBcImJpZ2ludFwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwidW5kZWZpbmVkXCIsXG4gICAgXCJudWxsXCIsXG4gICAgXCJhcnJheVwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJ1bmtub3duXCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJuZXZlclwiLFxuICAgIFwibWFwXCIsXG4gICAgXCJzZXRcIixcbl0pO1xuY29uc3QgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN0cmluZztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIGRhdGEuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gICAgfVxufTtcblxuY29uc3QgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcbiAgICBcImludmFsaWRfbGl0ZXJhbFwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3JcIixcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBcImludmFsaWRfYXJndW1lbnRzXCIsXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcbiAgICBcImludmFsaWRfc3RyaW5nXCIsXG4gICAgXCJ0b29fc21hbGxcIixcbiAgICBcInRvb19iaWdcIixcbiAgICBcImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXCIsXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICBcIm5vdF9maW5pdGVcIixcbl0pO1xuY29uc3QgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbmNsYXNzIFpvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3VlcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gW107XG4gICAgICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZXMgPSAoc3VicyA9IFtdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3VlcywgLi4uc3Vic107XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gbmV3LnRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xuICAgIH1cbiAgICBmb3JtYXQoX21hcHBlcikge1xuICAgICAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoaXNzdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnVuaW9uRXJyb3JzLm1hcChwcm9jZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfcmV0dXJuX3R5cGVcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZS5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGVycm9yQXJyYXk6IGFueSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZXJyb3JBcnJheS5fZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IGVycm9yQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnJbZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgICAgIHJldHVybiBmaWVsZEVycm9ycztcbiAgICB9XG4gICAgc3RhdGljIGFzc2VydCh2YWx1ZSkge1xuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFpvZEVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSBab2RFcnJvcjogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG4gICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmlzc3VlcywgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZmxhdHRlbihtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7fTtcbiAgICAgICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKHN1Yi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xuICAgIH1cbiAgICBnZXQgZm9ybUVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICAgIH1cbn1cblpvZEVycm9yLmNyZWF0ZSA9IChpc3N1ZXMpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG5cbmNvbnN0IGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChpc3N1ZS5jb2RlKSB7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZTpcbiAgICAgICAgICAgIGlmIChpc3N1ZS5yZWNlaXZlZCA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJSZXF1aXJlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBFeHBlY3RlZCAke2lzc3VlLmV4cGVjdGVkfSwgcmVjZWl2ZWQgJHtpc3N1ZS5yZWNlaXZlZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBsaXRlcmFsIHZhbHVlLCBleHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KGlzc3VlLmV4cGVjdGVkLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlcil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3I6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgaW5jbHVkZSBcIiR7aXNzdWUudmFsaWRhdGlvbi5pbmNsdWRlc31cImA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9ufWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJzdGFydHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3Qgc3RhcnQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5zdGFydHNXaXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGVuZCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmVuZHNXaXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUudmFsaWRhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkICR7aXNzdWUudmFsaWRhdGlvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19zbWFsbDpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBtb3JlIHRoYW5gfSAke2lzc3VlLm1pbmltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBvdmVyYH0gJHtpc3N1ZS5taW5pbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseSBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgZ3JlYXRlciB0aGFuIGB9JHtpc3N1ZS5taW5pbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHkgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGdyZWF0ZXIgdGhhbiBgfSR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1pbmltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fYmlnOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYHVuZGVyYH0gJHtpc3N1ZS5tYXhpbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEJpZ0ludCBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5YFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvYFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBgc21hbGxlciB0aGFuYH0gJHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWF4aW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmN1c3RvbTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludGVyc2VjdGlvbiByZXN1bHRzIGNvdWxkIG5vdCBiZSBtZXJnZWRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLm11bHRpcGxlT2Z9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfZmluaXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiTnVtYmVyIG11c3QgYmUgZmluaXRlXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlIH07XG59O1xuXG5sZXQgb3ZlcnJpZGVFcnJvck1hcCA9IGVycm9yTWFwO1xuZnVuY3Rpb24gc2V0RXJyb3JNYXAobWFwKSB7XG4gICAgb3ZlcnJpZGVFcnJvck1hcCA9IG1hcDtcbn1cbmZ1bmN0aW9uIGdldEVycm9yTWFwKCkge1xuICAgIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xufVxuXG5jb25zdCBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGgsIC4uLihpc3N1ZURhdGEucGF0aCB8fCBbXSldO1xuICAgIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICB9O1xuICAgIGlmIChpc3N1ZURhdGEubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzc3VlRGF0YS5tZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+ICEhbSlcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IG1hcChmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgIH07XG59O1xuY29uc3QgRU1QVFlfUEFUSCA9IFtdO1xuZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcbiAgICBjb25zdCBvdmVycmlkZU1hcCA9IGdldEVycm9yTWFwKCk7XG4gICAgY29uc3QgaXNzdWUgPSBtYWtlSXNzdWUoe1xuICAgICAgICBpc3N1ZURhdGE6IGlzc3VlRGF0YSxcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCAvLyBjb250ZXh0dWFsIGVycm9yIG1hcCBpcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLCAvLyB0aGVuIHNjaGVtYS1ib3VuZCBtYXAgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBvdmVycmlkZU1hcCwgLy8gdGhlbiBnbG9iYWwgb3ZlcnJpZGUgbWFwXG4gICAgICAgICAgICBvdmVycmlkZU1hcCA9PT0gZXJyb3JNYXAgPyB1bmRlZmluZWQgOiBlcnJvck1hcCwgLy8gdGhlbiBnbG9iYWwgZGVmYXVsdCBtYXBcbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgfSk7XG4gICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaChpc3N1ZSk7XG59XG5jbGFzcyBQYXJzZVN0YXR1cyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcInZhbGlkXCI7XG4gICAgfVxuICAgIGRpcnR5KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJ2YWxpZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcbiAgICB9XG4gICAgYWJvcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImFib3J0ZWRcIjtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IGFycmF5VmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGFycmF5VmFsdWUucHVzaChzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGFycmF5VmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIG1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKGtleS52YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxPYmplY3Rba2V5LnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxPYmplY3QgfTtcbiAgICB9XG59XG5jb25zdCBJTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgc3RhdHVzOiBcImFib3J0ZWRcIixcbn0pO1xuY29uc3QgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcbmNvbnN0IE9LID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWUgfSk7XG5jb25zdCBpc0Fib3J0ZWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xuY29uc3QgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xuY29uc3QgaXNWYWxpZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJ2YWxpZFwiO1xuY29uc3QgaXNBc3luYyA9ICh4KSA9PiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbnZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZSA9PT0gbnVsbCB8fCBtZXNzYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXNzYWdlLm1lc3NhZ2U7XG59KShlcnJvclV0aWwgfHwgKGVycm9yVXRpbCA9IHt9KSk7XG5cbnZhciBfWm9kRW51bV9jYWNoZSwgX1pvZE5hdGl2ZUVudW1fY2FjaGU7XG5jbGFzcyBQYXJzZUlucHV0TGF6eVBhdGgge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgdmFsdWUsIHBhdGgsIGtleSkge1xuICAgICAgICB0aGlzLl9jYWNoZWRQYXRoID0gW107XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVkUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9rZXkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCAuLi50aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIHRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGg7XG4gICAgfVxufVxuY29uc3QgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKGlzVmFsaWQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghY3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgZXJyb3JNYXAsIGludmFsaWRfdHlwZV9lcnJvciwgcmVxdWlyZWRfZXJyb3IsIGRlc2NyaXB0aW9uIH0gPSBwYXJhbXM7XG4gICAgaWYgKGVycm9yTWFwICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZF90eXBlX2Vycm9yXCIgb3IgXCJyZXF1aXJlZF9lcnJvclwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgICB9XG4gICAgaWYgKGVycm9yTWFwKVxuICAgICAgICByZXR1cm4geyBlcnJvck1hcDogZXJyb3JNYXAsIGRlc2NyaXB0aW9uIH07XG4gICAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAoaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGN0eC5kYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiAoX2EgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiByZXF1aXJlZF9lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc3MuY29kZSAhPT0gXCJpbnZhbGlkX3R5cGVcIilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogKF9iID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogaW52YWxpZF90eXBlX2Vycm9yKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxuY2xhc3MgWm9kVHlwZSB7XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBfZ2V0VHlwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIChjdHggfHwge1xuICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBuZXcgUGFyc2VTdGF0dXMoKSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9wYXJzZUFzeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBwYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIFwifnZhbGlkYXRlXCIoZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICgoX2IgPSAoX2EgPSBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIubWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhcImVuY291bnRlcmVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguY29tbW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUFzeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pLnRoZW4oKHJlc3VsdCkgPT4gaXNWYWxpZChyZXN1bHQpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3VlcyxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBhc3luYyBzYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChpc0FzeW5jKG1heWJlQXN5bmNSZXN1bHQpXG4gICAgICAgICAgICA/IG1heWJlQXN5bmNSZXN1bHRcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJlZmluZShjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCk7XG4gICAgICAgICAgICBjb25zdCBzZXRFcnJvciA9ICgpID0+IGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgICAgICAgICAuLi5nZXRJc3N1ZVByb3BlcnRpZXModmFsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZmluZW1lbnQoY2hlY2ssIHJlZmluZW1lbnREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjaGVjayh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHR5cGVvZiByZWZpbmVtZW50RGF0YSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVmaW5lbWVudERhdGEodmFsLCBjdHgpXG4gICAgICAgICAgICAgICAgICAgIDogcmVmaW5lbWVudERhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3JlZmluZW1lbnQocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KHJlZmluZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkZWYpIHtcbiAgICAgICAgLyoqIEFsaWFzIG9mIHNhZmVQYXJzZUFzeW5jICovXG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYztcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpcGUgPSB0aGlzLnBpcGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IHRoaXMuaXNPcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICAgICAgICAgIHZhbGlkYXRlOiAoZGF0YSkgPT4gdGhpc1tcIn52YWxpZGF0ZVwiXShkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGlzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVsbGFibGUoKS5vcHRpb25hbCgpO1xuICAgIH1cbiAgICBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZEFycmF5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG9yKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBhbmQoaW5jb21pbmcpIHtcbiAgICAgICAgcmV0dXJuIFpvZEludGVyc2VjdGlvbi5jcmVhdGUodGhpcywgaW5jb21pbmcsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQoZGVmKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBicmFuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCcmFuZGVkKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaChkZWYpIHtcbiAgICAgICAgY29uc3QgY2F0Y2hWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgVGhpcyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpcGUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmVhZG9ubHkoKSB7XG4gICAgICAgIHJldHVybiBab2RSZWFkb25seS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIGlzT3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGlzTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICAgIH1cbn1cbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgY3VpZDJSZWdleCA9IC9eWzAtOWEtel0rJC87XG5jb25zdCB1bGlkUmVnZXggPSAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kL2k7XG4vLyBjb25zdCB1dWlkUmVnZXggPVxuLy8gICAvXihbYS1mMC05XXs4fS1bYS1mMC05XXs0fS1bMS01XVthLWYwLTldezN9LVthLWYwLTldezR9LVthLWYwLTldezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2k7XG5jb25zdCBuYW5vaWRSZWdleCA9IC9eW2EtejAtOV8tXXsyMX0kL2k7XG5jb25zdCBqd3RSZWdleCA9IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC87XG5jb25zdCBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbi8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MTgxLzE1NTAxNTVcbi8vIG9sZCB2ZXJzaW9uOiB0b28gc2xvdywgZGlkbid0IHN1cHBvcnQgdW5pY29kZVxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaTtcbi8vb2xkIGVtYWlsIHJlZ2V4XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKFtePD4oKVtcXF0uLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXS4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKCg/IS0pKFtePD4oKVtcXF0uLDs6XFxzQFwiXStcXC4pK1tePD4oKVtcXF0uLDs6XFxzQFwiXXsxLH0pW14tPD4oKVtcXF0uLDs6XFxzQFwiXSQvaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSspKil8KFxcXCIuK1xcXCIpKUAoKFxcWygoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcXSl8KFxcW0lQdjY6KChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKVxcXSl8KFtBLVphLXowLTldKFtBLVphLXowLTktXSpbQS1aYS16MC05XSkqKFxcLltBLVphLXpdezIsfSkrKSkkLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXpBLVowLTlcXC5cXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC9cXD1cXD9cXF5cXF9cXGBcXHtcXHxcXH1cXH5cXC1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKD86W2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKnxcIig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKlwiKUAoPzooPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/fFxcWyg/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/fFthLXowLTktXSpbYS16MC05XTooPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMS1cXHg1YVxceDUzLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkrKVxcXSkkL2k7XG5jb25zdCBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXowLTkuISMkJSZcdTIwMTkqKy89P15fYHt8fX4tXStAW2EtejAtOS1dKyg/OlxcLlthLXowLTlcXC1dKykqJC9pO1xuLy8gZnJvbSBodHRwczovL3RoZWtldmluc2NvdHQuY29tL2Vtb2ppcy1pbi1qYXZhc2NyaXB0LyN3cml0aW5nLWEtcmVndWxhci1leHByZXNzaW9uXG5jb25zdCBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG5sZXQgZW1vamlSZWdleDtcbi8vIGZhc3Rlciwgc2ltcGxlciwgc2FmZXJcbmNvbnN0IGlwdjRSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC87XG5jb25zdCBpcHY0Q2lkclJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC8oM1swLTJdfFsxMl0/WzAtOV0pJC87XG4vLyBjb25zdCBpcHY2UmVnZXggPVxuLy8gL14oKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpJC87XG5jb25zdCBpcHY2UmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSkkLztcbmNvbnN0IGlwdjZDaWRyUmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg2MDM5Mi9kZXRlcm1pbmUtaWYtc3RyaW5nLWlzLWluLWJhc2U2NC11c2luZy1qYXZhc2NyaXB0XG5jb25zdCBiYXNlNjRSZWdleCA9IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLztcbi8vIGh0dHBzOi8vYmFzZTY0Lmd1cnUvc3RhbmRhcmRzL2Jhc2U2NHVybFxuY29uc3QgYmFzZTY0dXJsUmVnZXggPSAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC87XG4vLyBzaW1wbGVcbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfWA7XG4vLyBubyBsZWFwIHllYXIgdmFsaWRhdGlvblxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LSgoMFsxMzU3OF18MTB8MTIpLTMxfCgwWzEzLTldfDFbMC0yXSktMzB8KDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVxcXFxkfDJcXFxcZCkpYDtcbi8vIHdpdGggbGVhcCB5ZWFyIHZhbGlkYXRpb25cbmNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xuY29uc3QgZGF0ZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7ZGF0ZVJlZ2V4U291cmNlfSRgKTtcbmZ1bmN0aW9uIHRpbWVSZWdleFNvdXJjZShhcmdzKSB7XG4gICAgbGV0IHNlY29uZHNSZWdleFNvdXJjZSA9IGBbMC01XVxcXFxkYDtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgc2Vjb25kc1JlZ2V4U291cmNlID0gYCR7c2Vjb25kc1JlZ2V4U291cmNlfVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJncy5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9KFxcXFwuXFxcXGQrKT9gO1xuICAgIH1cbiAgICBjb25zdCBzZWNvbmRzUXVhbnRpZmllciA9IGFyZ3MucHJlY2lzaW9uID8gXCIrXCIgOiBcIj9cIjsgLy8gcmVxdWlyZSBzZWNvbmRzIGlmIHByZWNpc2lvbiBpcyBub256ZXJvXG4gICAgcmV0dXJuIGAoWzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZCg6JHtzZWNvbmRzUmVnZXhTb3VyY2V9KSR7c2Vjb25kc1F1YW50aWZpZXJ9YDtcbn1cbmZ1bmN0aW9uIHRpbWVSZWdleChhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVSZWdleFNvdXJjZShhcmdzKX0kYCk7XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDMyMzFcbmZ1bmN0aW9uIGRhdGV0aW1lUmVnZXgoYXJncykge1xuICAgIGxldCByZWdleCA9IGAke2RhdGVSZWdleFNvdXJjZX1UJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9YDtcbiAgICBjb25zdCBvcHRzID0gW107XG4gICAgb3B0cy5wdXNoKGFyZ3MubG9jYWwgPyBgWj9gIDogYFpgKTtcbiAgICBpZiAoYXJncy5vZmZzZXQpXG4gICAgICAgIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pYCk7XG4gICAgcmVnZXggPSBgJHtyZWdleH0oJHtvcHRzLmpvaW4oXCJ8XCIpfSlgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSVAoaXAsIHZlcnNpb24pIHtcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NlJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSldUKGp3dCwgYWxnKSB7XG4gICAgaWYgKCFqd3RSZWdleC50ZXN0KGp3dCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBbaGVhZGVyXSA9IGp3dC5zcGxpdChcIi5cIik7XG4gICAgICAgIC8vIENvbnZlcnQgYmFzZTY0dXJsIHRvIGJhc2U2NFxuICAgICAgICBjb25zdCBiYXNlNjQgPSBoZWFkZXJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8tL2csIFwiK1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL18vZywgXCIvXCIpXG4gICAgICAgICAgICAucGFkRW5kKGhlYWRlci5sZW5ndGggKyAoKDQgLSAoaGVhZGVyLmxlbmd0aCAlIDQpKSAlIDQpLCBcIj1cIik7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBKU09OLnBhcnNlKGF0b2IoYmFzZTY0KSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGVjb2RlZCAhPT0gXCJvYmplY3RcIiB8fCBkZWNvZGVkID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRlY29kZWQudHlwIHx8ICFkZWNvZGVkLmFsZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGFsZyAmJiBkZWNvZGVkLmFsZyAhPT0gYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ2lkcihpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NkNpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibmFub2lkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJuYW5vaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkMlJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2sucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidHJpbVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpbmNsdWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBpbmNsdWRlczogY2hlY2sudmFsdWUsIHBvc2l0aW9uOiBjaGVjay5wb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9Mb3dlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvVXBwZXJDYXNlXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJzdGFydHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuc3RhcnRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5lbmRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBlbmRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGVSZWdleDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidGltZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZHVyYXRpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZHVyYXRpb25SZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImlwXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRJUChpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJqd3RcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEpXVChpbnB1dC5kYXRhLCBjaGVjay5hbGcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiand0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjaWRyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRDaWRyKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY2lkclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlNjR1cmxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbWFpbFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVybChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgZW1vamkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXVpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXVpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIG5hbm9pZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibmFub2lkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkMlwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVsaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBiYXNlNjQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImJhc2U2NFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NHVybChtZXNzYWdlKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgand0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJqd3RcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBpcChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBjaWRyKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjaWRyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgZGF0ZXRpbWUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgIGxvY2FsOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9jYWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImRhdGVcIiwgbWVzc2FnZSB9KTtcbiAgICB9XG4gICAgdGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uKSA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlY2lzaW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGR1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkdXJhdGlvblwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICByZWdleDogcmVnZXgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNsdWRlcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wb3NpdGlvbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImVuZHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4TGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBsZW4sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIGAubWluKDEpYFxuICAgICAqL1xuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgfVxuICAgIHRyaW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0xvd2VyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1VwcGVyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICAgIH1cbiAgICBnZXQgaXNUaW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImR1cmF0aW9uXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbWFpbCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVJMKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1vamkoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1vamlcIik7XG4gICAgfVxuICAgIGdldCBpc1VVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzTkFOT0lEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcIm5hbm9pZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEMigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVUxJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNJUCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpcFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ0lEUigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjaWRyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjR1cmwoKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpO1xuICAgIH1cbiAgICBnZXQgbWluTGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RTdHJpbmcuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2NjQ4NC93aHktZG9lcy1tb2R1bHVzLW9wZXJhdG9yLXJldHVybi1mcmFjdGlvbmFsLW51bWJlci1pbi1qYXZhc2NyaXB0LzMxNzExMDM0IzMxNzExMDM0XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IHBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IHBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyBNYXRoLnBvdygxMCwgZGVjQ291bnQpO1xufVxuY2xhc3MgWm9kTnVtYmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gTnVtYmVyKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZmluaXRlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluaXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYWZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgaXNJbnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHxcbiAgICAgICAgICAgIChjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsLmlzSW50ZWdlcihjaC52YWx1ZSkpKTtcbiAgICB9XG4gICAgZ2V0IGlzRmluaXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbCwgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fFxuICAgICAgICAgICAgICAgIGNoLmtpbmQgPT09IFwiaW50XCIgfHxcbiAgICAgICAgICAgICAgICBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgICB9XG59XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXG4gICAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX2dldEludmFsaWRJbnB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQm9vbGVhbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJvb2xlYW4oaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQm9vbGVhbi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERhdGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBuZXcgRGF0ZShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihpbnB1dC5kYXRhLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkRhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heERhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4RGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluRGF0ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1heERhdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XG4gICAgfVxufVxuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFN5bWJvbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN5bWJvbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kU3ltYm9sLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3ltYm9sLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5kZWZpbmVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFueSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyB0byBwcmV2ZW50IGluc3RhbmNlcyBvZiBvdGhlciBjbGFzc2VzIGZyb20gZXh0ZW5kaW5nIFpvZEFueS4gdGhpcyBjYXVzZXMgaXNzdWVzIHdpdGggY2F0Y2hhbGwgaW4gWm9kT2JqZWN0LlxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmV2ZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbn1cblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b29CaWcgPyBab2RJc3N1ZUNvZGUudG9vX2JpZyA6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgbWluTGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFycmF5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG59XG5jbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEluIG1vc3QgY2FzZXMsIHRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIHVua25vd24gcHJvcGVydGllcyBhcmUgbm93IHNpbGVudGx5IHN0cmlwcGVkLlxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgICAgICAvLyBleHRlbmQ8XG4gICAgICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGUsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+LFxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgICAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT5cbiAgICAgICAgLy8gPihcbiAgICAgICAgLy8gICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgQXVnbWVudGF0aW9uPixcbiAgICAgICAgLy8gICBVbmtub3duS2V5cyxcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQsXG4gICAgICAgIC8vICAgTmV3SW5wdXRcbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAvLyAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC8vICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAvLyAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgIC8vICAgICB9KSxcbiAgICAgICAgLy8gICB9KSBhcyBhbnk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgLmV4dGVuZGAgaW5zdGVhZFxuICAgICAgICAgKiAgKi9cbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gICAgfVxuICAgIF9nZXRDYWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH0pO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmXG4gICAgICAgICAgICB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBpc3N1ZSwgY3R4KS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoX2QgPSBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXNzdGhyb3VnaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxuICAgIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcbiAgICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAvLyAgICk6IFpvZE9iamVjdDxcbiAgICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXG4gICAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxuICAgIC8vICAgPiA9PiB7XG4gICAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgICAuLi5kZWYsXG4gICAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAvLyAgICAgICB9KSxcbiAgICAvLyAgICAgfSkgYXMgYW55O1xuICAgIC8vICAgfTtcbiAgICBleHRlbmQoYXVnbWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICovXG4gICAgbWVyZ2UobWVyZ2luZykge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICAgICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4ubWVyZ2luZy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgLy8gbWVyZ2U8XG4gICAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9LFxuICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH1cbiAgICAvLyA+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0LFxuICAgIC8vICAgTmV3SW5wdXRcbiAgICAvLyA+IHtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gICAgfVxuICAgIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgICAvLyBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXG4gICAgLy8gPiB7XG4gICAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gICAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAgIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgIC8vICAgLy8gKTtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBjYXRjaGFsbChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaWNrKG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKG1hc2spLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb21pdChtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZGVlcFBhcnRpYWwoKSB7XG4gICAgICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgICB9XG4gICAgcGFydGlhbChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWlyZWQobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdGaWVsZCBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGtleW9mKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICAgIH1cbn1cblpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LnN0cmljdENyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RlZi5vcHRpb25zO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBmaXJzdCBpc3N1ZS1mcmVlIHZhbGlkYXRpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpc3N1ZXMgZnJvbSBkaXJ0eSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gaW52YWxpZFxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChvcHRpb25zLm1hcChhc3luYyAob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmICFkaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eSA9IHsgcmVzdWx0LCBjdHg6IGNoaWxkQ3R4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMucHVzaChjaGlsZEN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlydHkucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbn1cblpvZFVuaW9uLmNyZWF0ZSA9ICh0eXBlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgICAgIG9wdGlvbnM6IHR5cGVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IGdldERpc2NyaW1pbmF0b3IgPSAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gW3R5cGUudmFsdWVdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xuICAgICAgICByZXR1cm4gdHlwZS5vcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTmF0aXZlRW51bSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXModHlwZS5lbnVtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZERlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbCkge1xuICAgICAgICByZXR1cm4gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEJyYW5kZWQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RSZWFkb25seSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZENhdGNoKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5jbGFzcyBab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gY3R4LmRhdGFbZGlzY3JpbWluYXRvcl07XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2Rpc2NyaW1pbmF0b3J9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZGlzY3JpbWluYXRvclZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNjcmltaW5hdG9yIHByb3BlcnR5ICR7U3RyaW5nKGRpc2NyaW1pbmF0b3IpfSBoYXMgZHVwbGljYXRlIHZhbHVlICR7U3RyaW5nKHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zTWFwLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XG4gICAgY29uc3QgYVR5cGUgPSBnZXRQYXJzZWRUeXBlKGEpO1xuICAgIGNvbnN0IGJUeXBlID0gZ2V0UGFyc2VkVHlwZShiKTtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGJLZXlzID0gdXRpbC5vYmplY3RLZXlzKGIpO1xuICAgICAgICBjb25zdCBzaGFyZWRLZXlzID0gdXRpbFxuICAgICAgICAgICAgLm9iamVjdEtleXMoYSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1CID0gYltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGl0ZW1BLCBpdGVtQik7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdBcnJheSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmXG4gICAgICAgIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgK2EgPT09ICtiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG59XG5jbGFzcyBab2RJbnRlcnNlY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNBYm9ydGVkKHBhcnNlZExlZnQpIHx8IGlzQWJvcnRlZChwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlVmFsdWVzKHBhcnNlZExlZnQudmFsdWUsIHBhcnNlZFJpZ2h0LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghbWVyZ2VkLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RpcnR5KHBhcnNlZExlZnQpIHx8IGlzRGlydHkocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkudGhlbigoW2xlZnQsIHJpZ2h0XSkgPT4gaGFuZGxlUGFyc2VkKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUGFyc2VkKHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblpvZEludGVyc2VjdGlvbi5jcmVhdGUgPSAobGVmdCwgcmlnaHQsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFR1cGxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXVxuICAgICAgICAgICAgLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpdGVtSW5kZXgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+ICEheCk7IC8vIGZpbHRlciBudWxsc1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xuICAgIH1cbiAgICByZXN0KHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXN0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB6LnR1cGxlKFsgLi4uIF0pXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgaXRlbXM6IHNjaGVtYXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVHVwbGUsXG4gICAgICAgIHJlc3Q6IG51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RSZWNvcmQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBjdHguZGF0YVtrZXldLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgICAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAgICAgIGtleVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogc2Vjb25kLFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAga2V5VHlwZTogWm9kU3RyaW5nLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhzZWNvbmQpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBab2RNYXAgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm1hcCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwgW2luZGV4LCBcImtleVwiXSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE1hcCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFNldCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5TaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNldChlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLmN0eC5kYXRhLnZhbHVlcygpXS5tYXAoKGl0ZW0sIGkpID0+IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50cykgPT4gZmluYWxpemVTZXQoZWxlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWluKG1pblNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhTaXplOiB7IHZhbHVlOiBtYXhTaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpemUoc2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oc2l6ZSwgbWVzc2FnZSkubWF4KHNpemUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RTZXQuY3JlYXRlID0gKHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIG1pblNpemU6IG51bGwsXG4gICAgICAgIG1heFNpemU6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRnVuY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGdldEVycm9yTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwLFxuICAgICAgICAgICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0Vycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZVJldHVybnNJc3N1ZShyZXR1cm5zLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xuICAgICAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IG1lLl9kZWYuYXJnc1xuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlQXJnc0lzc3VlKGFyZ3MsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IGF3YWl0IG1lLl9kZWYucmV0dXJucy5fZGVmLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlQXN5bmMocmVzdWx0LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIE9LKGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IG1lLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRSZXR1cm5zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnMuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuYXJncztcbiAgICB9XG4gICAgcmV0dXJuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICAgIH1cbiAgICBhcmdzKC4uLml0ZW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJuVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGltcGxlbWVudChmdW5jKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICB9XG4gICAgc3RyaWN0SW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGFyZ3MsIHJldHVybnMsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IChhcmdzXG4gICAgICAgICAgICAgICAgPyBhcmdzXG4gICAgICAgICAgICAgICAgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSkpLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RGdW5jdGlvbixcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kTGF6eSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGF6eVNjaGVtYSA9IHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGxhenlTY2hlbWEuX3BhcnNlKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICB9XG59XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XG4gICAgICAgIGdldHRlcjogZ2V0dGVyLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gICAgfVxufVxuWm9kTGl0ZXJhbC5jcmVhdGUgPSAodmFsdWUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5jbGFzcyBab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIF9ab2RFbnVtX2NhY2hlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIFwiZlwiKS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBleHRyYWN0KHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh2YWx1ZXMsIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIC4uLm5ld0RlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4Y2x1ZGUodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSwge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5fWm9kRW51bV9jYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5ab2RFbnVtLmNyZWF0ZSA9IGNyZWF0ZVpvZEVudW07XG5jbGFzcyBab2ROYXRpdmVFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIF9ab2ROYXRpdmVFbnVtX2NhY2hlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRW51bVZhbHVlcyA9IHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiZcbiAgICAgICAgICAgIGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgbmV3IFNldCh1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgfVxufVxuX1pvZE5hdGl2ZUVudW1fY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuWm9kTmF0aXZlRW51bS5jcmVhdGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hdGl2ZUVudW0oe1xuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYXRpdmVFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kUHJvbWlzZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmXG4gICAgICAgICAgICBjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlXG4gICAgICAgICAgICA/IGN0eC5kYXRhXG4gICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kRWZmZWN0cyBleHRlbmRzIFpvZFR5cGUge1xuICAgIGlubmVyVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIHNvdXJjZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzXG4gICAgICAgICAgICA/IHRoaXMuX2RlZi5zY2hlbWEuc291cmNlVHlwZSgpXG4gICAgICAgICAgICA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvY2Vzc2VkKS50aGVuKGFzeW5jIChwcm9jZXNzZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnJlZmluZW1lbnQoYWNjLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaW5uZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzeW5jaHJvbm91cyB0cmFuc2Zvcm0gZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChiYXNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpKS50aGVuKChyZXN1bHQpID0+ICh7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XG4gICAgfVxufVxuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICBlZmZlY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogcHJlcHJvY2VzcyB9LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RPcHRpb25hbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPcHRpb25hbCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPcHRpb25hbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE51bGxhYmxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kTnVsbGFibGUuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBsZXQgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZERlZmF1bHQuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHBhcmFtcy5kZWZhdWx0XG4gICAgICAgICAgICA6ICgpID0+IHBhcmFtcy5kZWZhdWx0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQ2F0Y2ggZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIC8vIG5ld0N0eCBpcyB1c2VkIHRvIG5vdCBjb2xsZWN0IGlzc3VlcyBmcm9tIGlubmVyIHR5cGVzIGluIGN0eFxuICAgICAgICBjb25zdCBuZXdDdHggPSB7XG4gICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhOiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IG5ld0N0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICAgICAgLi4ubmV3Q3R4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmFOIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubmFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbn1cblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNvbnN0IEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xuY2xhc3MgWm9kQnJhbmRlZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxufVxuY2xhc3MgWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkoaW5SZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpblJlc3VsdCA9IHRoaXMuX2RlZi5pbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RQaXBlbGluZSh7XG4gICAgICAgICAgICBpbjogYSxcbiAgICAgICAgICAgIG91dDogYixcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUGlwZWxpbmUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZFJlYWRvbmx5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgY29uc3QgZnJlZXplID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IE9iamVjdC5mcmVlemUoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KVxuICAgICAgICAgICAgPyByZXN1bHQudGhlbigoZGF0YSkgPT4gZnJlZXplKGRhdGEpKVxuICAgICAgICAgICAgOiBmcmVlemUocmVzdWx0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RSZWFkb25seS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICB6LmN1c3RvbSAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGNsZWFuUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgIGNvbnN0IHAgPSB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBwYXJhbXMoZGF0YSlcbiAgICAgICAgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHsgbWVzc2FnZTogcGFyYW1zIH1cbiAgICAgICAgICAgIDogcGFyYW1zO1xuICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgcmV0dXJuIHAyO1xufVxuZnVuY3Rpb24gY3VzdG9tKGNoZWNrLCBfcGFyYW1zID0ge30sIFxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIFBhc3MgYGZhdGFsYCBpbnRvIHRoZSBwYXJhbXMgb2JqZWN0IGluc3RlYWQ6XG4gKlxuICogYGBgdHNcbiAqIHouc3RyaW5nKCkuY3VzdG9tKCh2YWwpID0+IHZhbC5sZW5ndGggPiA1LCB7IGZhdGFsOiBmYWxzZSB9KVxuICogYGBgXG4gKlxuICovXG5mYXRhbCkge1xuICAgIGlmIChjaGVjaylcbiAgICAgICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgciA9IGNoZWNrKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudGhlbigocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gKF9iID0gKF9hID0gcGFyYW1zLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gKF9iID0gKF9hID0gcGFyYW1zLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59XG5jb25zdCBsYXRlID0ge1xuICAgIG9iamVjdDogWm9kT2JqZWN0LmxhenljcmVhdGUsXG59O1xudmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hTlwiXSA9IFwiWm9kTmFOXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGF0ZVwiXSA9IFwiWm9kRGF0ZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZENhdGNoXCJdID0gXCJab2RDYXRjaFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUGlwZWxpbmVcIl0gPSBcIlpvZFBpcGVsaW5lXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVhZG9ubHlcIl0gPSBcIlpvZFJlYWRvbmx5XCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG5jb25zdCBpbnN0YW5jZU9mVHlwZSA9IChcbi8vIGNvbnN0IGluc3RhbmNlT2ZUeXBlID0gPFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuY2xzLCBwYXJhbXMgPSB7XG4gICAgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke2Nscy5uYW1lfWAsXG59KSA9PiBjdXN0b20oKGRhdGEpID0+IGRhdGEgaW5zdGFuY2VvZiBjbHMsIHBhcmFtcyk7XG5jb25zdCBzdHJpbmdUeXBlID0gWm9kU3RyaW5nLmNyZWF0ZTtcbmNvbnN0IG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xuY29uc3QgbmFuVHlwZSA9IFpvZE5hTi5jcmVhdGU7XG5jb25zdCBiaWdJbnRUeXBlID0gWm9kQmlnSW50LmNyZWF0ZTtcbmNvbnN0IGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG5jb25zdCBkYXRlVHlwZSA9IFpvZERhdGUuY3JlYXRlO1xuY29uc3Qgc3ltYm9sVHlwZSA9IFpvZFN5bWJvbC5jcmVhdGU7XG5jb25zdCB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbmNvbnN0IG51bGxUeXBlID0gWm9kTnVsbC5jcmVhdGU7XG5jb25zdCBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG5jb25zdCBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGU7XG5jb25zdCB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xuY29uc3Qgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGU7XG5jb25zdCBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgPSBab2REaXNjcmltaW5hdGVkVW5pb24uY3JlYXRlO1xuY29uc3QgaW50ZXJzZWN0aW9uVHlwZSA9IFpvZEludGVyc2VjdGlvbi5jcmVhdGU7XG5jb25zdCB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG5jb25zdCByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZTtcbmNvbnN0IG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG5jb25zdCBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGU7XG5jb25zdCBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbmNvbnN0IGVudW1UeXBlID0gWm9kRW51bS5jcmVhdGU7XG5jb25zdCBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbmNvbnN0IGVmZmVjdHNUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGU7XG5jb25zdCBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG5jb25zdCBwcmVwcm9jZXNzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3M7XG5jb25zdCBwaXBlbGluZVR5cGUgPSBab2RQaXBlbGluZS5jcmVhdGU7XG5jb25zdCBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IGNvZXJjZSA9IHtcbiAgICBzdHJpbmc6ICgoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIG51bWJlcjogKChhcmcpID0+IFpvZE51bWJlci5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgYm9vbGVhbjogKChhcmcpID0+IFpvZEJvb2xlYW4uY3JlYXRlKHtcbiAgICAgICAgLi4uYXJnLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgfSkpLFxuICAgIGJpZ2ludDogKChhcmcpID0+IFpvZEJpZ0ludC5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgZGF0ZTogKChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxufTtcbmNvbnN0IE5FVkVSID0gSU5WQUxJRDtcblxudmFyIHogPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGRlZmF1bHRFcnJvck1hcDogZXJyb3JNYXAsXG4gICAgc2V0RXJyb3JNYXA6IHNldEVycm9yTWFwLFxuICAgIGdldEVycm9yTWFwOiBnZXRFcnJvck1hcCxcbiAgICBtYWtlSXNzdWU6IG1ha2VJc3N1ZSxcbiAgICBFTVBUWV9QQVRIOiBFTVBUWV9QQVRILFxuICAgIGFkZElzc3VlVG9Db250ZXh0OiBhZGRJc3N1ZVRvQ29udGV4dCxcbiAgICBQYXJzZVN0YXR1czogUGFyc2VTdGF0dXMsXG4gICAgSU5WQUxJRDogSU5WQUxJRCxcbiAgICBESVJUWTogRElSVFksXG4gICAgT0s6IE9LLFxuICAgIGlzQWJvcnRlZDogaXNBYm9ydGVkLFxuICAgIGlzRGlydHk6IGlzRGlydHksXG4gICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICBpc0FzeW5jOiBpc0FzeW5jLFxuICAgIGdldCB1dGlsICgpIHsgcmV0dXJuIHV0aWw7IH0sXG4gICAgZ2V0IG9iamVjdFV0aWwgKCkgeyByZXR1cm4gb2JqZWN0VXRpbDsgfSxcbiAgICBab2RQYXJzZWRUeXBlOiBab2RQYXJzZWRUeXBlLFxuICAgIGdldFBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUsXG4gICAgWm9kVHlwZTogWm9kVHlwZSxcbiAgICBkYXRldGltZVJlZ2V4OiBkYXRldGltZVJlZ2V4LFxuICAgIFpvZFN0cmluZzogWm9kU3RyaW5nLFxuICAgIFpvZE51bWJlcjogWm9kTnVtYmVyLFxuICAgIFpvZEJpZ0ludDogWm9kQmlnSW50LFxuICAgIFpvZEJvb2xlYW46IFpvZEJvb2xlYW4sXG4gICAgWm9kRGF0ZTogWm9kRGF0ZSxcbiAgICBab2RTeW1ib2w6IFpvZFN5bWJvbCxcbiAgICBab2RVbmRlZmluZWQ6IFpvZFVuZGVmaW5lZCxcbiAgICBab2ROdWxsOiBab2ROdWxsLFxuICAgIFpvZEFueTogWm9kQW55LFxuICAgIFpvZFVua25vd246IFpvZFVua25vd24sXG4gICAgWm9kTmV2ZXI6IFpvZE5ldmVyLFxuICAgIFpvZFZvaWQ6IFpvZFZvaWQsXG4gICAgWm9kQXJyYXk6IFpvZEFycmF5LFxuICAgIFpvZE9iamVjdDogWm9kT2JqZWN0LFxuICAgIFpvZFVuaW9uOiBab2RVbmlvbixcbiAgICBab2REaXNjcmltaW5hdGVkVW5pb246IFpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICBab2RJbnRlcnNlY3Rpb246IFpvZEludGVyc2VjdGlvbixcbiAgICBab2RUdXBsZTogWm9kVHVwbGUsXG4gICAgWm9kUmVjb3JkOiBab2RSZWNvcmQsXG4gICAgWm9kTWFwOiBab2RNYXAsXG4gICAgWm9kU2V0OiBab2RTZXQsXG4gICAgWm9kRnVuY3Rpb246IFpvZEZ1bmN0aW9uLFxuICAgIFpvZExhenk6IFpvZExhenksXG4gICAgWm9kTGl0ZXJhbDogWm9kTGl0ZXJhbCxcbiAgICBab2RFbnVtOiBab2RFbnVtLFxuICAgIFpvZE5hdGl2ZUVudW06IFpvZE5hdGl2ZUVudW0sXG4gICAgWm9kUHJvbWlzZTogWm9kUHJvbWlzZSxcbiAgICBab2RFZmZlY3RzOiBab2RFZmZlY3RzLFxuICAgIFpvZFRyYW5zZm9ybWVyOiBab2RFZmZlY3RzLFxuICAgIFpvZE9wdGlvbmFsOiBab2RPcHRpb25hbCxcbiAgICBab2ROdWxsYWJsZTogWm9kTnVsbGFibGUsXG4gICAgWm9kRGVmYXVsdDogWm9kRGVmYXVsdCxcbiAgICBab2RDYXRjaDogWm9kQ2F0Y2gsXG4gICAgWm9kTmFOOiBab2ROYU4sXG4gICAgQlJBTkQ6IEJSQU5ELFxuICAgIFpvZEJyYW5kZWQ6IFpvZEJyYW5kZWQsXG4gICAgWm9kUGlwZWxpbmU6IFpvZFBpcGVsaW5lLFxuICAgIFpvZFJlYWRvbmx5OiBab2RSZWFkb25seSxcbiAgICBjdXN0b206IGN1c3RvbSxcbiAgICBTY2hlbWE6IFpvZFR5cGUsXG4gICAgWm9kU2NoZW1hOiBab2RUeXBlLFxuICAgIGxhdGU6IGxhdGUsXG4gICAgZ2V0IFpvZEZpcnN0UGFydHlUeXBlS2luZCAoKSB7IHJldHVybiBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7IH0sXG4gICAgY29lcmNlOiBjb2VyY2UsXG4gICAgYW55OiBhbnlUeXBlLFxuICAgIGFycmF5OiBhcnJheVR5cGUsXG4gICAgYmlnaW50OiBiaWdJbnRUeXBlLFxuICAgIGJvb2xlYW46IGJvb2xlYW5UeXBlLFxuICAgIGRhdGU6IGRhdGVUeXBlLFxuICAgIGRpc2NyaW1pbmF0ZWRVbmlvbjogZGlzY3JpbWluYXRlZFVuaW9uVHlwZSxcbiAgICBlZmZlY3Q6IGVmZmVjdHNUeXBlLFxuICAgICdlbnVtJzogZW51bVR5cGUsXG4gICAgJ2Z1bmN0aW9uJzogZnVuY3Rpb25UeXBlLFxuICAgICdpbnN0YW5jZW9mJzogaW5zdGFuY2VPZlR5cGUsXG4gICAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb25UeXBlLFxuICAgIGxhenk6IGxhenlUeXBlLFxuICAgIGxpdGVyYWw6IGxpdGVyYWxUeXBlLFxuICAgIG1hcDogbWFwVHlwZSxcbiAgICBuYW46IG5hblR5cGUsXG4gICAgbmF0aXZlRW51bTogbmF0aXZlRW51bVR5cGUsXG4gICAgbmV2ZXI6IG5ldmVyVHlwZSxcbiAgICAnbnVsbCc6IG51bGxUeXBlLFxuICAgIG51bGxhYmxlOiBudWxsYWJsZVR5cGUsXG4gICAgbnVtYmVyOiBudW1iZXJUeXBlLFxuICAgIG9iamVjdDogb2JqZWN0VHlwZSxcbiAgICBvYm9vbGVhbjogb2Jvb2xlYW4sXG4gICAgb251bWJlcjogb251bWJlcixcbiAgICBvcHRpb25hbDogb3B0aW9uYWxUeXBlLFxuICAgIG9zdHJpbmc6IG9zdHJpbmcsXG4gICAgcGlwZWxpbmU6IHBpcGVsaW5lVHlwZSxcbiAgICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzVHlwZSxcbiAgICBwcm9taXNlOiBwcm9taXNlVHlwZSxcbiAgICByZWNvcmQ6IHJlY29yZFR5cGUsXG4gICAgc2V0OiBzZXRUeXBlLFxuICAgIHN0cmljdE9iamVjdDogc3RyaWN0T2JqZWN0VHlwZSxcbiAgICBzdHJpbmc6IHN0cmluZ1R5cGUsXG4gICAgc3ltYm9sOiBzeW1ib2xUeXBlLFxuICAgIHRyYW5zZm9ybWVyOiBlZmZlY3RzVHlwZSxcbiAgICB0dXBsZTogdHVwbGVUeXBlLFxuICAgICd1bmRlZmluZWQnOiB1bmRlZmluZWRUeXBlLFxuICAgIHVuaW9uOiB1bmlvblR5cGUsXG4gICAgdW5rbm93bjogdW5rbm93blR5cGUsXG4gICAgJ3ZvaWQnOiB2b2lkVHlwZSxcbiAgICBORVZFUjogTkVWRVIsXG4gICAgWm9kSXNzdWVDb2RlOiBab2RJc3N1ZUNvZGUsXG4gICAgcXVvdGVsZXNzSnNvbjogcXVvdGVsZXNzSnNvbixcbiAgICBab2RFcnJvcjogWm9kRXJyb3Jcbn0pO1xuXG5leHBvcnQgeyBCUkFORCwgRElSVFksIEVNUFRZX1BBVEgsIElOVkFMSUQsIE5FVkVSLCBPSywgUGFyc2VTdGF0dXMsIFpvZFR5cGUgYXMgU2NoZW1hLCBab2RBbnksIFpvZEFycmF5LCBab2RCaWdJbnQsIFpvZEJvb2xlYW4sIFpvZEJyYW5kZWQsIFpvZENhdGNoLCBab2REYXRlLCBab2REZWZhdWx0LCBab2REaXNjcmltaW5hdGVkVW5pb24sIFpvZEVmZmVjdHMsIFpvZEVudW0sIFpvZEVycm9yLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQsIFpvZEZ1bmN0aW9uLCBab2RJbnRlcnNlY3Rpb24sIFpvZElzc3VlQ29kZSwgWm9kTGF6eSwgWm9kTGl0ZXJhbCwgWm9kTWFwLCBab2ROYU4sIFpvZE5hdGl2ZUVudW0sIFpvZE5ldmVyLCBab2ROdWxsLCBab2ROdWxsYWJsZSwgWm9kTnVtYmVyLCBab2RPYmplY3QsIFpvZE9wdGlvbmFsLCBab2RQYXJzZWRUeXBlLCBab2RQaXBlbGluZSwgWm9kUHJvbWlzZSwgWm9kUmVhZG9ubHksIFpvZFJlY29yZCwgWm9kVHlwZSBhcyBab2RTY2hlbWEsIFpvZFNldCwgWm9kU3RyaW5nLCBab2RTeW1ib2wsIFpvZEVmZmVjdHMgYXMgWm9kVHJhbnNmb3JtZXIsIFpvZFR1cGxlLCBab2RUeXBlLCBab2RVbmRlZmluZWQsIFpvZFVuaW9uLCBab2RVbmtub3duLCBab2RWb2lkLCBhZGRJc3N1ZVRvQ29udGV4dCwgYW55VHlwZSBhcyBhbnksIGFycmF5VHlwZSBhcyBhcnJheSwgYmlnSW50VHlwZSBhcyBiaWdpbnQsIGJvb2xlYW5UeXBlIGFzIGJvb2xlYW4sIGNvZXJjZSwgY3VzdG9tLCBkYXRlVHlwZSBhcyBkYXRlLCBkYXRldGltZVJlZ2V4LCB6IGFzIGRlZmF1bHQsIGVycm9yTWFwIGFzIGRlZmF1bHRFcnJvck1hcCwgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSBhcyBkaXNjcmltaW5hdGVkVW5pb24sIGVmZmVjdHNUeXBlIGFzIGVmZmVjdCwgZW51bVR5cGUgYXMgZW51bSwgZnVuY3Rpb25UeXBlIGFzIGZ1bmN0aW9uLCBnZXRFcnJvck1hcCwgZ2V0UGFyc2VkVHlwZSwgaW5zdGFuY2VPZlR5cGUgYXMgaW5zdGFuY2VvZiwgaW50ZXJzZWN0aW9uVHlwZSBhcyBpbnRlcnNlY3Rpb24sIGlzQWJvcnRlZCwgaXNBc3luYywgaXNEaXJ0eSwgaXNWYWxpZCwgbGF0ZSwgbGF6eVR5cGUgYXMgbGF6eSwgbGl0ZXJhbFR5cGUgYXMgbGl0ZXJhbCwgbWFrZUlzc3VlLCBtYXBUeXBlIGFzIG1hcCwgbmFuVHlwZSBhcyBuYW4sIG5hdGl2ZUVudW1UeXBlIGFzIG5hdGl2ZUVudW0sIG5ldmVyVHlwZSBhcyBuZXZlciwgbnVsbFR5cGUgYXMgbnVsbCwgbnVsbGFibGVUeXBlIGFzIG51bGxhYmxlLCBudW1iZXJUeXBlIGFzIG51bWJlciwgb2JqZWN0VHlwZSBhcyBvYmplY3QsIG9iamVjdFV0aWwsIG9ib29sZWFuLCBvbnVtYmVyLCBvcHRpb25hbFR5cGUgYXMgb3B0aW9uYWwsIG9zdHJpbmcsIHBpcGVsaW5lVHlwZSBhcyBwaXBlbGluZSwgcHJlcHJvY2Vzc1R5cGUgYXMgcHJlcHJvY2VzcywgcHJvbWlzZVR5cGUgYXMgcHJvbWlzZSwgcXVvdGVsZXNzSnNvbiwgcmVjb3JkVHlwZSBhcyByZWNvcmQsIHNldFR5cGUgYXMgc2V0LCBzZXRFcnJvck1hcCwgc3RyaWN0T2JqZWN0VHlwZSBhcyBzdHJpY3RPYmplY3QsIHN0cmluZ1R5cGUgYXMgc3RyaW5nLCBzeW1ib2xUeXBlIGFzIHN5bWJvbCwgZWZmZWN0c1R5cGUgYXMgdHJhbnNmb3JtZXIsIHR1cGxlVHlwZSBhcyB0dXBsZSwgdW5kZWZpbmVkVHlwZSBhcyB1bmRlZmluZWQsIHVuaW9uVHlwZSBhcyB1bmlvbiwgdW5rbm93blR5cGUgYXMgdW5rbm93biwgdXRpbCwgdm9pZFR5cGUgYXMgdm9pZCwgeiB9O1xuIiwgImltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG5pbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgaXNUcmFjZWFibGVGdW5jdGlvbiwgfSBmcm9tIFwibGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlXCI7XG5pbXBvcnQgeyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIFJ1bkxvZywgUnVuTG9nUGF0Y2gsIGlzTG9nU3RyZWFtSGFuZGxlciwgfSBmcm9tIFwiLi4vdHJhY2Vycy9sb2dfc3RyZWFtLmpzXCI7XG5pbXBvcnQgeyBFdmVudFN0cmVhbUNhbGxiYWNrSGFuZGxlciwgaXNTdHJlYW1FdmVudHNIYW5kbGVyLCB9IGZyb20gXCIuLi90cmFjZXJzL2V2ZW50X3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgU2VyaWFsaXphYmxlIH0gZnJvbSBcIi4uL2xvYWQvc2VyaWFsaXphYmxlLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLCBjb25jYXQsIGF0ZWUsIHBpcGVHZW5lcmF0b3JXaXRoU2V0dXAsIEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwLCB9IGZyb20gXCIuLi91dGlscy9zdHJlYW0uanNcIjtcbmltcG9ydCB7IHJhY2VXaXRoU2lnbmFsIH0gZnJvbSBcIi4uL3V0aWxzL3NpZ25hbC5qc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9SRUNVUlNJT05fTElNSVQsIGVuc3VyZUNvbmZpZywgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnLCBtZXJnZUNvbmZpZ3MsIHBhdGNoQ29uZmlnLCBwaWNrUnVubmFibGVDb25maWdLZXlzLCB9IGZyb20gXCIuL2NvbmZpZy5qc1wiO1xuaW1wb3J0IHsgQXN5bmNDYWxsZXIgfSBmcm9tIFwiLi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG5pbXBvcnQgeyBSb290TGlzdGVuZXJzVHJhY2VyIH0gZnJvbSBcIi4uL3RyYWNlcnMvcm9vdF9saXN0ZW5lci5qc1wiO1xuaW1wb3J0IHsgX1Jvb3RFdmVudEZpbHRlciwgaXNSdW5uYWJsZUludGVyZmFjZSB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIH0gZnJvbSBcIi4uL3NpbmdsZXRvbnMvaW5kZXguanNcIjtcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSBcIi4vZ3JhcGguanNcIjtcbmltcG9ydCB7IGNvbnZlcnRUb0h0dHBFdmVudFN0cmVhbSB9IGZyb20gXCIuL3dyYXBwZXJzLmpzXCI7XG5pbXBvcnQgeyBjb25zdW1lQXN5bmNJdGVyYWJsZUluQ29udGV4dCwgY29uc3VtZUl0ZXJhdG9ySW5Db250ZXh0LCBpc0FzeW5jSXRlcmFibGUsIGlzSXRlcmFibGVJdGVyYXRvciwgaXNJdGVyYXRvciwgfSBmcm9tIFwiLi9pdGVyLmpzXCI7XG5pbXBvcnQgeyBfaXNUb29sQ2FsbCwgVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbiB9IGZyb20gXCIuLi90b29scy91dGlscy5qc1wiO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuLyoqXG4gKiBBIFJ1bm5hYmxlIGlzIGEgZ2VuZXJpYyB1bml0IG9mIHdvcmsgdGhhdCBjYW4gYmUgaW52b2tlZCwgYmF0Y2hlZCwgc3RyZWFtZWQsIGFuZC9vclxuICogdHJhbnNmb3JtZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZSBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3J1bm5hYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5hbWUoc3VmZml4KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdGhpcy5uYW1lID8/IHRoaXMuY29uc3RydWN0b3IubGNfbmFtZSgpID8/IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgcmV0dXJuIHN1ZmZpeCA/IGAke25hbWV9JHtzdWZmaXh9YCA6IG5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgYXJndW1lbnRzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBAcGFyYW0ga3dhcmdzXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVCaW5kaW5nIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBhcHBseSB0aGUgYm91bmQgYXJncy5cbiAgICAgKi9cbiAgICBiaW5kKGt3YXJncykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHsgYm91bmQ6IHRoaXMsIGt3YXJncywgY29uZmlnOiB7fSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IFJ1bm5hYmxlIHRoYXQgbWFwcyBhIGxpc3Qgb2YgaW5wdXRzIHRvIGEgbGlzdCBvZiBvdXRwdXRzLFxuICAgICAqIGJ5IGNhbGxpbmcgaW52b2tlKCkgd2l0aCBlYWNoIGlucHV0LlxuICAgICAqL1xuICAgIG1hcCgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlRWFjaCh7IGJvdW5kOiB0aGlzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcmV0cnkgbG9naWMgdG8gYW4gZXhpc3RpbmcgcnVubmFibGUuXG4gICAgICogQHBhcmFtIGt3YXJnc1xuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlUmV0cnkgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIHJldHJ5IGFjY29yZGluZyB0byB0aGUgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICB3aXRoUmV0cnkoZmllbGRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVJldHJ5KHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLFxuICAgICAgICAgICAga3dhcmdzOiB7fSxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBtYXhBdHRlbXB0TnVtYmVyOiBmaWVsZHM/LnN0b3BBZnRlckF0dGVtcHQsXG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGNvbmZpZyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogQHBhcmFtIGNvbmZpZyBOZXcgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIHRvIGF0dGFjaCB0byB0aGUgbmV3IHJ1bm5hYmxlLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlQmluZGluZyB3aXRoIGEgY29uZmlnIG1hdGNoaW5nIHdoYXQncyBwYXNzZWQuXG4gICAgICovXG4gICAgd2l0aENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGt3YXJnczoge30sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcnVubmFibGUgZnJvbSB0aGUgY3VycmVudCBvbmUgdGhhdCB3aWxsIHRyeSBpbnZva2luZ1xuICAgICAqIG90aGVyIHBhc3NlZCBmYWxsYmFjayBydW5uYWJsZXMgaWYgdGhlIGluaXRpYWwgaW52b2NhdGlvbiBmYWlscy5cbiAgICAgKiBAcGFyYW0gZmllbGRzLmZhbGxiYWNrcyBPdGhlciBydW5uYWJsZXMgdG8gY2FsbCBpZiB0aGUgcnVubmFibGUgZXJyb3JzLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlV2l0aEZhbGxiYWNrcy5cbiAgICAgKi9cbiAgICB3aXRoRmFsbGJhY2tzKGZpZWxkcykge1xuICAgICAgICBjb25zdCBmYWxsYmFja3MgPSBBcnJheS5pc0FycmF5KGZpZWxkcykgPyBmaWVsZHMgOiBmaWVsZHMuZmFsbGJhY2tzO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVXaXRoRmFsbGJhY2tzKHtcbiAgICAgICAgICAgIHJ1bm5hYmxlOiB0aGlzLFxuICAgICAgICAgICAgZmFsbGJhY2tzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMsIGxlbmd0aCA9IDApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykgJiYgb3B0aW9ucy5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXNzZWQgXCJvcHRpb25zXCIgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgaW5wdXRzLCBidXQgZ290ICR7b3B0aW9ucy5sZW5ndGh9IG9wdGlvbnMgZm9yICR7bGVuZ3RofSBpbnB1dHNgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWFwKGVuc3VyZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucykgJiYgb3B0aW9ucy5ydW5JZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUHJvdmlkZWQgcnVuSWQgd2lsbCBiZSB1c2VkIG9ubHkgZm9yIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBiYXRjaC5cIik7XG4gICAgICAgICAgICBjb25zdCBzdWJzZXF1ZW50ID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLmZpbHRlcigoW2tleV0pID0+IGtleSAhPT0gXCJydW5JZFwiKSk7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCAoXywgaSkgPT4gZW5zdXJlQ29uZmlnKGkgPT09IDAgPyBvcHRpb25zIDogc3Vic2VxdWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sICgpID0+IGVuc3VyZUNvbmZpZyhvcHRpb25zKSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWF4Q29uY3VycmVuY3kgPSBjb25maWdMaXN0WzBdPy5tYXhDb25jdXJyZW5jeSA/PyBiYXRjaE9wdGlvbnM/Lm1heENvbmN1cnJlbmN5O1xuICAgICAgICBjb25zdCBjYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgbWF4Q29uY3VycmVuY3ksXG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBiYXRjaENhbGxzID0gaW5wdXRzLm1hcCgoaW5wdXQsIGkpID0+IGNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5pbnZva2UoaW5wdXQsIGNvbmZpZ0xpc3RbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChiYXRjaE9wdGlvbnM/LnJldHVybkV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGJhdGNoQ2FsbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN0cmVhbWluZyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IHN1cHBvcnQgc3RyZWFtaW5nIG91dHB1dC5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQgdGhpcy5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gb3V0cHV0IGluIGNodW5rcy5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIEEgcmVhZGFibGUgc3RyZWFtIHRoYXQgaXMgYWxzbyBhbiBpdGVyYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQnVmZmVyIHRoZSBmaXJzdCBzdHJlYW1lZCBjaHVuayB0byBhbGxvdyBmb3IgaW5pdGlhbCBlcnJvcnNcbiAgICAgICAgLy8gdG8gc3VyZmFjZSBpbW1lZGlhdGVseS5cbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy5fc3RyZWFtSXRlcmF0b3IoaW5wdXQsIGNvbmZpZyksXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxuICAgIF9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHJ1bm5hYmxlQ29uZmlnO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5uYWJsZUNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bm5hYmxlQ29uZmlnID0gZW5zdXJlQ29uZmlnKHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IG9wdGlvbnMuY2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgIHRhZ3M6IG9wdGlvbnMudGFncyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBydW5OYW1lOiBvcHRpb25zLnJ1bk5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBvcHRpb25zLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgICByZWN1cnNpb25MaW1pdDogb3B0aW9ucy5yZWN1cnNpb25MaW1pdCxcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogb3B0aW9ucy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgICAgICBydW5JZDogb3B0aW9ucy5ydW5JZCxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxPcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5jYWxsYmFja3M7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy50YWdzO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMubWV0YWRhdGE7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5ydW5OYW1lO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMuY29uZmlndXJhYmxlO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMucmVjdXJzaW9uTGltaXQ7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5tYXhDb25jdXJyZW5jeTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnJ1bklkO1xuICAgICAgICBkZWxldGUgY2FsbE9wdGlvbnMudGltZW91dDtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnNpZ25hbDtcbiAgICAgICAgcmV0dXJuIFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdO1xuICAgIH1cbiAgICBhc3luYyBfY2FsbFdpdGhDb25maWcoZnVuYywgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIGNvbmZpZy5ydW5JZCwgY29uZmlnPy5ydW5UeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBmdW5jLmNhbGwodGhpcywgaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcik7XG4gICAgICAgICAgICBvdXRwdXQgPSBhd2FpdCByYWNlV2l0aFNpZ25hbChwcm9taXNlLCBvcHRpb25zPy5zaWduYWwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdGhhdCBoYW5kbGVzIGJhdGNoaW5nIGFuZCBjb25maWd1cmF0aW9uIGZvciBhIHJ1bm5hYmxlXG4gICAgICogSXQgdGFrZXMgYSBmdW5jdGlvbiwgaW5wdXQgdmFsdWVzLCBhbmQgb3B0aW9uYWwgY29uZmlndXJhdGlvbiwgYW5kXG4gICAgICogcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgZm9yIGVhY2ggaW5wdXQgdmFsdWUuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB2YWx1ZXMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfYmF0Y2hXaXRoQ29uZmlnKGZ1bmMsIGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zTGlzdC5tYXAoZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoYXN5bmMgKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnRSZXMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dHNbaV0sIFwiaW5wdXRcIiksIG9wdGlvbnNMaXN0W2ldLnJ1bklkLCBvcHRpb25zTGlzdFtpXS5ydW5UeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9uc0xpc3RbaV0ucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKSk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uc0xpc3RbaV0ucnVuSWQ7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RhcnRSZXM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IG91dHB1dHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZnVuYy5jYWxsKHRoaXMsIGlucHV0cywgb3B0aW9uc0xpc3QsIHJ1bk1hbmFnZXJzLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgb3V0cHV0cyA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIG9wdGlvbnNMaXN0Py5bMF0/LnNpZ25hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKSkpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0cywgXCJvdXRwdXRcIikpKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHRyYW5zZm9ybSBhbiBJdGVyYXRvciBvZiBJbnB1dCB2YWx1ZXMgaW50byBhbiBJdGVyYXRvciBvZlxuICAgICAqIE91dHB1dCB2YWx1ZXMsIHdpdGggY2FsbGJhY2tzLlxuICAgICAqIFVzZSB0aGlzIHRvIGltcGxlbWVudCBgc3RyZWFtKClgIG9yIGB0cmFuc2Zvcm0oKWAgaW4gUnVubmFibGUgc3ViY2xhc3Nlcy5cbiAgICAgKi9cbiAgICBhc3luYyAqX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoaW5wdXRHZW5lcmF0b3IsIHRyYW5zZm9ybWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBmaW5hbElucHV0O1xuICAgICAgICBsZXQgZmluYWxJbnB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiB3cmFwSW5wdXRGb3JUcmFjaW5nKCkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbElucHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbElucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gY29uY2F0KGZpbmFsSW5wdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVuTWFuYWdlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBpcGUgPSBhd2FpdCBwaXBlR2VuZXJhdG9yV2l0aFNldHVwKHRyYW5zZm9ybWVyLmJpbmQodGhpcyksIHdyYXBJbnB1dEZvclRyYWNpbmcoKSwgYXN5bmMgKCkgPT4gY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCB7IGlucHV0OiBcIlwiIH0sIGNvbmZpZy5ydW5JZCwgY29uZmlnLnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWcucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKSksIG9wdGlvbnM/LnNpZ25hbCwgY29uZmlnKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgICAgICBydW5NYW5hZ2VyID0gcGlwZS5zZXR1cDtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUV2ZW50c0hhbmRsZXIgPSBydW5NYW5hZ2VyPy5oYW5kbGVycy5maW5kKGlzU3RyZWFtRXZlbnRzSGFuZGxlcik7XG4gICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSBwaXBlLm91dHB1dDtcbiAgICAgICAgICAgIGlmIChzdHJlYW1FdmVudHNIYW5kbGVyICE9PSB1bmRlZmluZWQgJiYgcnVuTWFuYWdlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBzdHJlYW1FdmVudHNIYW5kbGVyLnRhcE91dHB1dEl0ZXJhYmxlKHJ1bk1hbmFnZXIucnVuSWQsIGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbUxvZ0hhbmRsZXIgPSBydW5NYW5hZ2VyPy5oYW5kbGVycy5maW5kKGlzTG9nU3RyZWFtSGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoc3RyZWFtTG9nSGFuZGxlciAhPT0gdW5kZWZpbmVkICYmIHJ1bk1hbmFnZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gc3RyZWFtTG9nSGFuZGxlci50YXBPdXRwdXRJdGVyYWJsZShydW5NYW5hZ2VyLnJ1bklkLCBpdGVyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY29uY2F0KGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBfY29lcmNlVG9EaWN0KGZpbmFsSW5wdXQsIFwiaW5wdXRcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoZmluYWxPdXRwdXQgPz8ge30sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgaW5wdXRzOiBfY29lcmNlVG9EaWN0KGZpbmFsSW5wdXQsIFwiaW5wdXRcIikgfSk7XG4gICAgfVxuICAgIGdldEdyYXBoKF8pIHtcbiAgICAgICAgY29uc3QgZ3JhcGggPSBuZXcgR3JhcGgoKTtcbiAgICAgICAgLy8gVE9ETzogQWRkIGlucHV0IHNjaGVtYSBmb3IgcnVubmFibGVzXG4gICAgICAgIGNvbnN0IGlucHV0Tm9kZSA9IGdyYXBoLmFkZE5vZGUoe1xuICAgICAgICAgICAgbmFtZTogYCR7dGhpcy5nZXROYW1lKCl9SW5wdXRgLFxuICAgICAgICAgICAgc2NoZW1hOiB6LmFueSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcnVubmFibGVOb2RlID0gZ3JhcGguYWRkTm9kZSh0aGlzKTtcbiAgICAgICAgLy8gVE9ETzogQWRkIG91dHB1dCBzY2hlbWFzIGZvciBydW5uYWJsZXNcbiAgICAgICAgY29uc3Qgb3V0cHV0Tm9kZSA9IGdyYXBoLmFkZE5vZGUoe1xuICAgICAgICAgICAgbmFtZTogYCR7dGhpcy5nZXROYW1lKCl9T3V0cHV0YCxcbiAgICAgICAgICAgIHNjaGVtYTogei5hbnkoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGdyYXBoLmFkZEVkZ2UoaW5wdXROb2RlLCBydW5uYWJsZU5vZGUpO1xuICAgICAgICBncmFwaC5hZGRFZGdlKHJ1bm5hYmxlTm9kZSwgb3V0cHV0Tm9kZSk7XG4gICAgICAgIHJldHVybiBncmFwaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJ1bm5hYmxlIHNlcXVlbmNlIHRoYXQgcnVucyBlYWNoIGluZGl2aWR1YWwgcnVubmFibGUgaW4gc2VyaWVzLFxuICAgICAqIHBpcGluZyB0aGUgb3V0cHV0IG9mIG9uZSBydW5uYWJsZSBpbnRvIGFub3RoZXIgcnVubmFibGUgb3IgcnVubmFibGUtbGlrZS5cbiAgICAgKiBAcGFyYW0gY29lcmNlYWJsZSBBIHJ1bm5hYmxlLCBmdW5jdGlvbiwgb3Igb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZnVuY3Rpb25zIG9yIHJ1bm5hYmxlcy5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBydW5uYWJsZSBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBwaXBlKGNvZXJjZWFibGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgZmlyc3Q6IHRoaXMsXG4gICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShjb2VyY2VhYmxlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpY2sga2V5cyBmcm9tIHRoZSBkaWN0IG91dHB1dCBvZiB0aGlzIHJ1bm5hYmxlLiBSZXR1cm5zIGEgbmV3IHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIHBpY2soa2V5cykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiB0aGlzLnBpcGUobmV3IFJ1bm5hYmxlUGljayhrZXlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgbmV3IGZpZWxkcyB0byB0aGUgZGljdCBvdXRwdXQgb2YgdGhpcyBydW5uYWJsZS4gUmV0dXJucyBhIG5ldyBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3NpZ24obWFwcGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5waXBlKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIG5ldyBSdW5uYWJsZUFzc2lnbihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBuZXcgUnVubmFibGVNYXAoeyBzdGVwczogbWFwcGluZyB9KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRyYW5zZm9ybSwgd2hpY2ggYnVmZmVycyBpbnB1dCBhbmQgdGhlbiBjYWxscyBzdHJlYW0uXG4gICAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBjYW4gc3RhcnQgcHJvZHVjaW5nIG91dHB1dCB3aGlsZVxuICAgICAqIGlucHV0IGlzIHN0aWxsIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKiBAcGFyYW0gZ2VuZXJhdG9yXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZmluYWxDaHVuaztcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbENodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgYmVzdCBlZmZvcnQgdG8gZ2F0aGVyLCBmb3IgYW55IHR5cGUgdGhhdCBzdXBwb3J0cyBjb25jYXQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtZXRob2Qgc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIGdhdGhlcmluZyBmYWlscy5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBjb25jYXQoZmluYWxDaHVuaywgY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLl9zdHJlYW1JdGVyYXRvcihmaW5hbENodW5rLCBlbnN1cmVDb25maWcob3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gYWxsIG91dHB1dCBmcm9tIGEgcnVubmFibGUsIGFzIHJlcG9ydGVkIHRvIHRoZSBjYWxsYmFjayBzeXN0ZW0uXG4gICAgICogVGhpcyBpbmNsdWRlcyBhbGwgaW5uZXIgcnVucyBvZiBMTE1zLCBSZXRyaWV2ZXJzLCBUb29scywgZXRjLlxuICAgICAqIE91dHB1dCBpcyBzdHJlYW1lZCBhcyBMb2cgb2JqZWN0cywgd2hpY2ggaW5jbHVkZSBhIGxpc3Qgb2ZcbiAgICAgKiBqc29ucGF0Y2ggb3BzIHRoYXQgZGVzY3JpYmUgaG93IHRoZSBzdGF0ZSBvZiB0aGUgcnVuIGhhcyBjaGFuZ2VkIGluIGVhY2hcbiAgICAgKiBzdGVwLCBhbmQgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBydW4uXG4gICAgICogVGhlIGpzb25wYXRjaCBvcHMgY2FuIGJlIGFwcGxpZWQgaW4gb3JkZXIgdG8gY29uc3RydWN0IHN0YXRlLlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIHN0cmVhbU9wdGlvbnNcbiAgICAgKi9cbiAgICBhc3luYyAqc3RyZWFtTG9nKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciA9IG5ldyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgICAgICBfc2NoZW1hRm9ybWF0OiBcIm9yaWdpbmFsXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIHlpZWxkKiB0aGlzLl9zdHJlYW1Mb2coaW5wdXQsIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1Mb2coaW5wdXQsIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2tzIH0gPSBjb25maWc7XG4gICAgICAgIGlmIChjYWxsYmFja3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gW2xvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjYWxsYmFja3MuY29uY2F0KFtsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvcGllZENhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICBjb3BpZWRDYWxsYmFja3MuYWRkSGFuZGxlcihsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIsIHRydWUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gY29waWVkQ2FsbGJhY2tzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtUHJvbWlzZSA9IHRoaXMuc3RyZWFtKGlucHV0LCBjb25maWcpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb25zdW1lUnVubmFibGVTdHJlYW0oKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtID0gYXdhaXQgcnVubmFibGVTdHJlYW1Qcm9taXNlO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcnVubmFibGVTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCIvc3RyZWFtZWRfb3V0cHV0Ly1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLndyaXRlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlU3RyZWFtQ29uc3VtZVByb21pc2UgPSBjb25zdW1lUnVubmFibGVTdHJlYW0oKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgbG9nIG9mIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIGxvZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bm5hYmxlU3RyZWFtQ29uc3VtZVByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24gPT09IFwidjFcIikge1xuICAgICAgICAgICAgc3RyZWFtID0gdGhpcy5fc3RyZWFtRXZlbnRzVjEoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudmVyc2lvbiA9PT0gXCJ2MlwiKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSB0aGlzLl9zdHJlYW1FdmVudHNWMihpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgdmVyc2lvbnMgXCJ2MVwiIGFuZCBcInYyXCIgb2YgdGhlIHNjaGVtYSBhcmUgY3VycmVudGx5IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvSHR0cEV2ZW50U3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Ioc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUV2ZW50c1YyKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50U3RyZWFtZXIgPSBuZXcgRXZlbnRTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJ1bklkID0gY29uZmlnLnJ1bklkID8/IHV1aWR2NCgpO1xuICAgICAgICBjb25maWcucnVuSWQgPSBydW5JZDtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gY29uZmlnLmNhbGxiYWNrcztcbiAgICAgICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2tzID0gW2V2ZW50U3RyZWFtZXJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb25jYXQoZXZlbnRTdHJlYW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb3BpZWRDYWxsYmFja3MgPSBjYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgY29waWVkQ2FsbGJhY2tzLmFkZEhhbmRsZXIoZXZlbnRTdHJlYW1lciwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBjb3BpZWRDYWxsYmFja3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAvLyBDYWxsIHRoZSBydW5uYWJsZSBpbiBzdHJlYW1pbmcgbW9kZSxcbiAgICAgICAgLy8gYWRkIGVhY2ggY2h1bmsgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgICAgICAgY29uc3Qgb3V0ZXJUaGlzID0gdGhpcztcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgc2lnbmFsO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zPy5zaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiYW55XCIgaW4gQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBuYXRpdmUgQWJvcnRTaWduYWwuYW55KCkgaWYgYXZhaWxhYmxlIChOb2RlIDE5KylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwgPSBBYm9ydFNpZ25hbC5hbnkoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBOb2RlIDE4IGFuZCBiZWxvdyAtIGp1c3QgdXNlIHRoZSBwcm92aWRlZCBzaWduYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHdlIHN0aWxsIGFib3J0IG91ciBjb250cm9sbGVyIHdoZW4gdGhlIHBhcmVudCBzaWduYWwgYWJvcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbSA9IGF3YWl0IG91dGVyVGhpcy5zdHJlYW0oaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFwcGVkU3RyZWFtID0gZXZlbnRTdHJlYW1lci50YXBPdXRwdXRJdGVyYWJsZShydW5JZCwgcnVubmFibGVTdHJlYW0pO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgdGFwcGVkU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgaXRlcmF0ZSBzbyB0aGF0IHRoZSBjYWxsYmFjayBoYW5kbGVyIHBpY2tzIHVwIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZXZlbnRTdHJlYW1lci5maW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbUNvbnN1bWVQcm9taXNlID0gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCk7XG4gICAgICAgIGxldCBmaXJzdEV2ZW50U2VudCA9IGZhbHNlO1xuICAgICAgICBsZXQgZmlyc3RFdmVudFJ1bklkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBldmVudFN0cmVhbWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmstYXJvdW5kIGFuIGlzc3VlIHdoZXJlIHRoZSBpbnB1dHMgaW50byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjaGFpbiBhcmUgbm90IGF2YWlsYWJsZSB1bnRpbCB0aGUgZW50aXJlIGlucHV0IGlzIGNvbnN1bWVkLlxuICAgICAgICAgICAgICAgIC8vIEFzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uLCB3ZSdsbCBtb2RpZnkgdGhlIGlucHV0IHRvIGJlIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgd2FzIHBhc3NlZCBpbnRvIHRoZSBjaGFpbi5cbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0RXZlbnRTZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFdmVudFNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEV2ZW50UnVuSWQgPSBldmVudC5ydW5faWQ7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnJ1bl9pZCA9PT0gZmlyc3RFdmVudFJ1bklkICYmIGV2ZW50LmV2ZW50LmVuZHNXaXRoKFwiX2VuZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBlbmQgZXZlbnQgY29ycmVzcG9uZGluZyB0byB0aGUgcm9vdCBydW5uYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb250IGluY2x1ZGUgdGhlIGlucHV0IGluIHRoZSBldmVudCBzaW5jZSBpdCdzIGd1YXJhbnRlZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpcnN0IGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YT8uaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBldmVudC5kYXRhLmlucHV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBhd2FpdCBydW5uYWJsZVN0cmVhbUNvbnN1bWVQcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtRXZlbnRzVjEoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHJ1bkxvZztcbiAgICAgICAgbGV0IGhhc0VuY291bnRlcmVkU3RhcnRFdmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJvb3RUYWdzID0gY29uZmlnLnRhZ3MgPz8gW107XG4gICAgICAgIGNvbnN0IHJvb3RNZXRhZGF0YSA9IGNvbmZpZy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBjb25maWcucnVuTmFtZSA/PyB0aGlzLmdldE5hbWUoKTtcbiAgICAgICAgY29uc3QgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyID0gbmV3IExvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcih7XG4gICAgICAgICAgICAuLi5zdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgICAgIF9zY2hlbWFGb3JtYXQ6IFwic3RyZWFtaW5nX2V2ZW50c1wiLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgcm9vdEV2ZW50RmlsdGVyID0gbmV3IF9Sb290RXZlbnRGaWx0ZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGxvZ1N0cmVhbSA9IHRoaXMuX3N0cmVhbUxvZyhpbnB1dCwgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBjb25maWcpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxvZyBvZiBsb2dTdHJlYW0pIHtcbiAgICAgICAgICAgIGlmICghcnVuTG9nKSB7XG4gICAgICAgICAgICAgICAgcnVuTG9nID0gUnVuTG9nLmZyb21SdW5Mb2dQYXRjaChsb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVuTG9nID0gcnVuTG9nLmNvbmNhdChsb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bkxvZy5zdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBlcnJvcjogXCJzdHJlYW1FdmVudHNcIiBzdGF0ZSBpcyBtaXNzaW5nLiBQbGVhc2Ugb3BlbiBhIGJ1ZyByZXBvcnQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBZaWVsZCB0aGUgc3RhcnQgZXZlbnQgZm9yIHRoZSByb290IHJ1bm5hYmxlIGlmIGl0IGhhc24ndCBiZWVuIHNlZW4uXG4gICAgICAgICAgICAvLyBUaGUgcm9vdCBydW4gaXMgbmV2ZXIgZmlsdGVyZWQgb3V0XG4gICAgICAgICAgICBpZiAoIWhhc0VuY291bnRlcmVkU3RhcnRFdmVudCkge1xuICAgICAgICAgICAgICAgIGhhc0VuY291bnRlcmVkU3RhcnRFdmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB7IC4uLnJ1bkxvZy5zdGF0ZSB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHN0YXRlLmlkLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7c3RhdGUudHlwZX1fc3RhcnRgLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiByb290TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcm9vdFRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiByb290TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFdmVudEZpbHRlci5pbmNsdWRlRXZlbnQoZXZlbnQsIHN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGhzID0gbG9nLm9wc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG9wKSA9PiBvcC5wYXRoLnN0YXJ0c1dpdGgoXCIvbG9ncy9cIikpXG4gICAgICAgICAgICAgICAgLm1hcCgob3ApID0+IG9wLnBhdGguc3BsaXQoXCIvXCIpWzJdKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZHVwZWRQYXRocyA9IFsuLi5uZXcgU2V0KHBhdGhzKV07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgZGVkdXBlZFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0VudHJ5ID0gcnVuTG9nLnN0YXRlLmxvZ3NbcGF0aF07XG4gICAgICAgICAgICAgICAgaWYgKGxvZ0VudHJ5LmVuZF90aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ0VudHJ5LnN0cmVhbWVkX291dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUgPSBcInN0cmVhbVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJzdGFydFwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmVudFR5cGUgPSBcImVuZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVkZSB0aGUgaW5wdXRzIHdpdGggdGhlIHN0YXJ0IGV2ZW50IGlmIHRoZXkgYXJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXN1YWxseSB0aGV5IHdpbGwgTk9UIGJlIGF2YWlsYWJsZSBmb3IgY29tcG9uZW50cyB0aGF0IG9wZXJhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gc3RyZWFtcywgc2luY2UgdGhvc2UgY29tcG9uZW50cyBzdHJlYW0gdGhlIGlucHV0IGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBrbm93IGl0cyBmaW5hbCB2YWx1ZSB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5pbnB1dCA9IGxvZ0VudHJ5LmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudFR5cGUgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ0VudHJ5LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmlucHV0ID0gbG9nRW50cnkuaW5wdXRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEub3V0cHV0ID0gbG9nRW50cnkuZmluYWxfb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudFR5cGUgPT09IFwic3RyZWFtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGxvZ0VudHJ5LnN0cmVhbWVkX291dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVua0NvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGV4YWN0bHkgb25lIGNodW5rIG9mIHN0cmVhbWVkIG91dHB1dCwgZ290ICR7Y2h1bmtDb3VudH0gaW5zdGVhZC4gRW5jb3VudGVyZWQgaW46IFwiJHtsb2dFbnRyeS5uYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHsgY2h1bms6IGxvZ0VudHJ5LnN0cmVhbWVkX291dHB1dFswXSB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgc3RyZWFtLCB3ZSBkb24ndCBuZWVkIGl0IGFueW1vcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZCB0aGlzIGF2b2lkcyBkdXBsaWNhdGVzIGFzIHdlbGwhXG4gICAgICAgICAgICAgICAgICAgIGxvZ0VudHJ5LnN0cmVhbWVkX291dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtsb2dFbnRyeS50eXBlfV8ke2V2ZW50VHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBsb2dFbnRyeS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IGxvZ0VudHJ5LmlkLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiBsb2dFbnRyeS50YWdzLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbG9nRW50cnkubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHdlIHRha2UgY2FyZSBvZiB0aGUgc3RyZWFtaW5nIG91dHB1dCBmcm9tIHRoZSByb290IGNoYWluXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkuXG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBydW5Mb2c7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc3RyZWFtZWRfb3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gc3RhdGUuc3RyZWFtZWRfb3V0cHV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGV4YWN0bHkgb25lIGNodW5rIG9mIHN0cmVhbWVkIG91dHB1dCwgZ290ICR7Y2h1bmtDb3VudH0gaW5zdGVhZC4gRW5jb3VudGVyZWQgaW46IFwiJHtzdGF0ZS5uYW1lfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IGNodW5rOiBzdGF0ZS5zdHJlYW1lZF9vdXRwdXRbMF0gfTtcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgc3RyZWFtLCB3ZSBkb24ndCBuZWVkIGl0IGFueW1vcmUuXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RyZWFtZWRfb3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtzdGF0ZS50eXBlfV9zdHJlYW1gLFxuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHN0YXRlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiByb290VGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJvb3RNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcm9vdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdEV2ZW50RmlsdGVyLmluY2x1ZGVFdmVudChldmVudCwgc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRlID0gcnVuTG9nPy5zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHlpZWxkIHRoZSBlbmQgZXZlbnQgZm9yIHRoZSByb290IHJ1bm5hYmxlLlxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3N0YXRlLnR5cGV9X2VuZGAsXG4gICAgICAgICAgICAgICAgbmFtZTogcm9vdE5hbWUsXG4gICAgICAgICAgICAgICAgcnVuX2lkOiBzdGF0ZS5pZCxcbiAgICAgICAgICAgICAgICB0YWdzOiByb290VGFncyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcm9vdE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBzdGF0ZS5maW5hbF9vdXRwdXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocm9vdEV2ZW50RmlsdGVyLmluY2x1ZGVFdmVudChldmVudCwgc3RhdGUudHlwZSkpXG4gICAgICAgICAgICAgICAgeWllbGQgZXZlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgaXNSdW5uYWJsZSh0aGluZykge1xuICAgICAgICByZXR1cm4gaXNSdW5uYWJsZUludGVyZmFjZSh0aGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgbGlmZWN5Y2xlIGxpc3RlbmVycyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogVGhlIFJ1biBvYmplY3QgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1biwgaW5jbHVkaW5nIGl0cyBpZCxcbiAgICAgKiB0eXBlLCBpbnB1dCwgb3V0cHV0LCBlcnJvciwgc3RhcnRUaW1lLCBlbmRUaW1lLCBhbmQgYW55IHRhZ3Mgb3IgbWV0YWRhdGFcbiAgICAgKiBhZGRlZCB0byB0aGUgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25TdGFydCAtIENhbGxlZCBiZWZvcmUgdGhlIHJ1bm5hYmxlIHN0YXJ0cyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FbmQgLSBDYWxsZWQgYWZ0ZXIgdGhlIHJ1bm5hYmxlIGZpbmlzaGVzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVycm9yIC0gQ2FsbGVkIGlmIHRoZSBydW5uYWJsZSB0aHJvd3MgYW4gZXJyb3IsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICovXG4gICAgd2l0aExpc3RlbmVycyh7IG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUJpbmRpbmcoe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMsXG4gICAgICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICAgICAgY29uZmlnRmFjdG9yaWVzOiBbXG4gICAgICAgICAgICAgICAgKGNvbmZpZykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUm9vdExpc3RlbmVyc1RyYWNlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBydW5uYWJsZSB0byBhIHRvb2wuIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWBcbiAgICAgKiB3aGljaCBjb250YWlucyB0aGUgcnVubmFibGUsIG5hbWUsIGRlc2NyaXB0aW9uIGFuZCBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAdGVtcGxhdGUge1QgZXh0ZW5kcyBSdW5JbnB1dCA9IFJ1bklucHV0fSBSdW5JbnB1dCAtIFRoZSBpbnB1dCB0eXBlIG9mIHRoZSBydW5uYWJsZS4gU2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSBgUnVuSW5wdXRgIHR5cGUgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbZmllbGRzLm5hbWVdIFRoZSBuYW1lIG9mIHRoZSB0b29sLiBJZiBub3QgcHJvdmlkZWQsIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgcnVubmFibGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtmaWVsZHMuZGVzY3JpcHRpb25dIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgdG9vbC4gRmFsbHMgYmFjayB0byB0aGUgZGVzY3JpcHRpb24gb24gdGhlIFpvZCBzY2hlbWEgaWYgbm90IHByb3ZpZGVkLCBvciB1bmRlZmluZWQgaWYgbmVpdGhlciBhcmUgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHt6LlpvZFR5cGU8VD59IFtmaWVsZHMuc2NoZW1hXSBUaGUgWm9kIHNjaGVtYSBmb3IgdGhlIGlucHV0IG9mIHRoZSB0b29sLiBJbmZlcnMgdGhlIFpvZCB0eXBlIGZyb20gdGhlIGlucHV0IHR5cGUgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtSdW5uYWJsZVRvb2xMaWtlPHouWm9kVHlwZTxUPiwgUnVuT3V0cHV0Pn0gQW4gaW5zdGFuY2Ugb2YgYFJ1bm5hYmxlVG9vbExpa2VgIHdoaWNoIGlzIGEgcnVubmFibGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHRvb2wuXG4gICAgICovXG4gICAgYXNUb29sKGZpZWxkcykge1xuICAgICAgICByZXR1cm4gY29udmVydFJ1bm5hYmxlVG9Ub29sKHRoaXMsIGZpZWxkcyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgZGVsZWdhdGVzIGNhbGxzIHRvIGFub3RoZXIgcnVubmFibGUgd2l0aCBhIHNldCBvZiBrd2FyZ3MuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtcbiAqICAgdHlwZSBSdW5uYWJsZUNvbmZpZyxcbiAqICAgUnVubmFibGVMYW1iZGEsXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgZW5oYW5jZVByb2ZpbGUgPSAoXG4gKiAgIHByb2ZpbGU6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gKiAgIGNvbmZpZz86IFJ1bm5hYmxlQ29uZmlnXG4gKiApID0+IHtcbiAqICAgaWYgKGNvbmZpZz8uY29uZmlndXJhYmxlPy5yb2xlKSB7XG4gKiAgICAgcmV0dXJuIHsgLi4ucHJvZmlsZSwgcm9sZTogY29uZmlnLmNvbmZpZ3VyYWJsZS5yb2xlIH07XG4gKiAgIH1cbiAqICAgcmV0dXJuIHByb2ZpbGU7XG4gKiB9O1xuICpcbiAqIGNvbnN0IHJ1bm5hYmxlID0gUnVubmFibGVMYW1iZGEuZnJvbShlbmhhbmNlUHJvZmlsZSk7XG4gKlxuICogLy8gQmluZCBjb25maWd1cmF0aW9uIHRvIHRoZSBydW5uYWJsZSB0byBzZXQgdGhlIHVzZXIncyByb2xlIGR5bmFtaWNhbGx5XG4gKiBjb25zdCBhZG1pblJ1bm5hYmxlID0gcnVubmFibGUuYmluZCh7IGNvbmZpZ3VyYWJsZTogeyByb2xlOiBcIkFkbWluXCIgfSB9KTtcbiAqIGNvbnN0IHVzZXJSdW5uYWJsZSA9IHJ1bm5hYmxlLmJpbmQoeyBjb25maWd1cmFibGU6IHsgcm9sZTogXCJVc2VyXCIgfSB9KTtcbiAqXG4gKiBjb25zdCByZXN1bHQxID0gYXdhaXQgYWRtaW5SdW5uYWJsZS5pbnZva2Uoe1xuICogICBuYW1lOiBcIkFsaWNlXCIsXG4gKiAgIGVtYWlsOiBcImFsaWNlQGV4YW1wbGUuY29tXCJcbiAqIH0pO1xuICpcbiAqIC8vIHsgbmFtZTogXCJBbGljZVwiLCBlbWFpbDogXCJhbGljZUBleGFtcGxlLmNvbVwiLCByb2xlOiBcIkFkbWluXCIgfVxuICpcbiAqIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB1c2VyUnVubmFibGUuaW52b2tlKHtcbiAqICAgbmFtZTogXCJCb2JcIixcbiAqICAgZW1haWw6IFwiYm9iQGV4YW1wbGUuY29tXCJcbiAqIH0pO1xuICpcbiAqIC8vIHsgbmFtZTogXCJCb2JcIiwgZW1haWw6IFwiYm9iQGV4YW1wbGUuY29tXCIsIHJvbGU6IFwiVXNlclwiIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVCaW5kaW5nIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUJpbmRpbmdcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYm91bmRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImt3YXJnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdGYWN0b3JpZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib3VuZCA9IGZpZWxkcy5ib3VuZDtcbiAgICAgICAgdGhpcy5rd2FyZ3MgPSBmaWVsZHMua3dhcmdzO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGZpZWxkcy5jb25maWc7XG4gICAgICAgIHRoaXMuY29uZmlnRmFjdG9yaWVzID0gZmllbGRzLmNvbmZpZ0ZhY3RvcmllcztcbiAgICB9XG4gICAgZ2V0TmFtZShzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuZ2V0TmFtZShzdWZmaXgpO1xuICAgIH1cbiAgICBhc3luYyBfbWVyZ2VDb25maWcoLi4ub3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBtZXJnZUNvbmZpZ3ModGhpcy5jb25maWcsIC4uLm9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbWVyZ2VDb25maWdzKGNvbmZpZywgLi4uKHRoaXMuY29uZmlnRmFjdG9yaWVzXG4gICAgICAgICAgICA/IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY29uZmlnRmFjdG9yaWVzLm1hcChhc3luYyAoY29uZmlnRmFjdG9yeSkgPT4gYXdhaXQgY29uZmlnRmFjdG9yeShjb25maWcpKSlcbiAgICAgICAgICAgIDogW10pKTtcbiAgICB9XG4gICAgYmluZChrd2FyZ3MpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB7IC4uLnRoaXMua3dhcmdzLCAuLi5rd2FyZ3MgfSxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3aXRoQ29uZmlnKGNvbmZpZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Ioe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQsXG4gICAgICAgICAgICBrd2FyZ3M6IHRoaXMua3dhcmdzLFxuICAgICAgICAgICAgY29uZmlnOiB7IC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdpdGhSZXRyeShmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLndpdGhSZXRyeShmaWVsZHMpLFxuICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuaW52b2tlKGlucHV0LCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZyhlbnN1cmVDb25maWcob3B0aW9ucyksIHRoaXMua3dhcmdzKSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMpXG4gICAgICAgICAgICA/IGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChpbmRpdmlkdWFsT3B0aW9uKSA9PiB0aGlzLl9tZXJnZUNvbmZpZyhlbnN1cmVDb25maWcoaW5kaXZpZHVhbE9wdGlvbiksIHRoaXMua3dhcmdzKSkpXG4gICAgICAgICAgICA6IGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKGVuc3VyZUNvbmZpZyhvcHRpb25zKSwgdGhpcy5rd2FyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5iYXRjaChpbnB1dHMsIG1lcmdlZE9wdGlvbnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYm91bmQuX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZyhlbnN1cmVDb25maWcob3B0aW9ucyksIHRoaXMua3dhcmdzKSk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZC5zdHJlYW0oaW5wdXQsIGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKGVuc3VyZUNvbmZpZyhvcHRpb25zKSwgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgYXN5bmMgKnRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuYm91bmQudHJhbnNmb3JtKGdlbmVyYXRvciwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcoZW5zdXJlQ29uZmlnKG9wdGlvbnMpLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBzdHJlYW1FdmVudHMoaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgIGNvbnN0IG91dGVyVGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvciA9IGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCogb3V0ZXJUaGlzLmJvdW5kLnN0cmVhbUV2ZW50cyhpbnB1dCwge1xuICAgICAgICAgICAgICAgIC4uLihhd2FpdCBvdXRlclRoaXMuX21lcmdlQ29uZmlnKGVuc3VyZUNvbmZpZyhvcHRpb25zKSwgb3V0ZXJUaGlzLmt3YXJncykpLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgICAgIH0sIHN0cmVhbU9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3IoZ2VuZXJhdG9yKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNSdW5uYWJsZUJpbmRpbmcoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0aGluZ1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0aGluZy5ib3VuZCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKHRoaW5nLmJvdW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBsaWZlY3ljbGUgbGlzdGVuZXJzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBUaGUgUnVuIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVuLCBpbmNsdWRpbmcgaXRzIGlkLFxuICAgICAqIHR5cGUsIGlucHV0LCBvdXRwdXQsIGVycm9yLCBzdGFydFRpbWUsIGVuZFRpbWUsIGFuZCBhbnkgdGFncyBvciBtZXRhZGF0YVxuICAgICAqIGFkZGVkIHRvIHRoZSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vblN0YXJ0IC0gQ2FsbGVkIGJlZm9yZSB0aGUgcnVubmFibGUgc3RhcnRzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVuZCAtIENhbGxlZCBhZnRlciB0aGUgcnVubmFibGUgZmluaXNoZXMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRXJyb3IgLSBDYWxsZWQgaWYgdGhlIHJ1bm5hYmxlIHRocm93cyBhbiBlcnJvciwgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKi9cbiAgICB3aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUJpbmRpbmcoe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQsXG4gICAgICAgICAgICBrd2FyZ3M6IHRoaXMua3dhcmdzLFxuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGNvbmZpZ0ZhY3RvcmllczogW1xuICAgICAgICAgICAgICAgIChjb25maWcpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJvb3RMaXN0ZW5lcnNUcmFjZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IGRlbGVnYXRlcyBjYWxscyB0byBhbm90aGVyIHJ1bm5hYmxlXG4gKiB3aXRoIGVhY2ggZWxlbWVudCBvZiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgUnVubmFibGVFYWNoLCBSdW5uYWJsZUxhbWJkYSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgdG9VcHBlckNhc2UgPSAoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyA9PiBpbnB1dC50b1VwcGVyQ2FzZSgpO1xuICogY29uc3QgYWRkR3JlZXRpbmcgPSAoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyA9PiBgSGVsbG8sICR7aW5wdXR9IWA7XG4gKlxuICogY29uc3QgdXBwZXJDYXNlTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbSh0b1VwcGVyQ2FzZSk7XG4gKiBjb25zdCBncmVldGluZ0xhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oYWRkR3JlZXRpbmcpO1xuICpcbiAqIGNvbnN0IGNoYWluID0gbmV3IFJ1bm5hYmxlRWFjaCh7XG4gKiAgIGJvdW5kOiB1cHBlckNhc2VMYW1iZGEucGlwZShncmVldGluZ0xhbWJkYSksXG4gKiB9KTtcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbi5pbnZva2UoW1wiYWxpY2VcIiwgXCJib2JcIiwgXCJjYXJvbFwiXSlcbiAqXG4gKiAvLyBbXCJIZWxsbywgQUxJQ0UhXCIsIFwiSGVsbG8sIEJPQiFcIiwgXCJIZWxsbywgQ0FST0whXCJdXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlRWFjaCBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVFYWNoXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJvdW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm91bmQgPSBmaWVsZHMuYm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHRoZSBydW5uYWJsZSB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSBrd2FyZ3MgVGhlIGFyZ3VtZW50cyB0byBiaW5kIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUnVubmFibGVFYWNoYCBjbGFzcyB0aGF0IGlzIGJvdW5kIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgYmluZChrd2FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUVhY2goe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQuYmluZChrd2FyZ3MpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0IGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIGludm9rZShpbnB1dHMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLmJpbmQodGhpcyksIGlucHV0cywgY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbnZva2UgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBpbnB1dCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBfaW52b2tlKGlucHV0cywgY29uZmlnLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmJhdGNoKGlucHV0cywgcGF0Y2hDb25maWcoY29uZmlnLCB7IGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgbGlmZWN5Y2xlIGxpc3RlbmVycyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogVGhlIFJ1biBvYmplY3QgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJ1biwgaW5jbHVkaW5nIGl0cyBpZCxcbiAgICAgKiB0eXBlLCBpbnB1dCwgb3V0cHV0LCBlcnJvciwgc3RhcnRUaW1lLCBlbmRUaW1lLCBhbmQgYW55IHRhZ3Mgb3IgbWV0YWRhdGFcbiAgICAgKiBhZGRlZCB0byB0aGUgcnVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25TdGFydCAtIENhbGxlZCBiZWZvcmUgdGhlIHJ1bm5hYmxlIHN0YXJ0cyBydW5uaW5nLCB3aXRoIHRoZSBSdW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7KHJ1bjogUnVuKSA9PiB2b2lkfSBwYXJhbXMub25FbmQgLSBDYWxsZWQgYWZ0ZXIgdGhlIHJ1bm5hYmxlIGZpbmlzaGVzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVycm9yIC0gQ2FsbGVkIGlmIHRoZSBydW5uYWJsZSB0aHJvd3MgYW4gZXJyb3IsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICovXG4gICAgd2l0aExpc3RlbmVycyh7IG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yLCB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVFYWNoKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLndpdGhMaXN0ZW5lcnMoeyBvblN0YXJ0LCBvbkVuZCwgb25FcnJvciB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBydW5uYWJsZXMgdGhhdCBjYW4gYmUgcmV0cmllZCBhXG4gKiBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlTGFtYmRhLFxuICogICBSdW5uYWJsZVJldHJ5LFxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIC8vIFNpbXVsYXRlIGFuIEFQSSBjYWxsIHRoYXQgZmFpbHNcbiAqIGNvbnN0IHNpbXVsYXRlQXBpQ2FsbCA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAqICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgQVBJIGNhbGwgd2l0aCBpbnB1dDogJHtpbnB1dH1gKTtcbiAqICAgdGhyb3cgbmV3IEVycm9yKFwiQVBJIGNhbGwgZmFpbGVkIGR1ZSB0byBuZXR3b3JrIGlzc3VlXCIpO1xuICogfTtcbiAqXG4gKiBjb25zdCBhcGlDYWxsTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShzaW11bGF0ZUFwaUNhbGwpO1xuICpcbiAqIC8vIEFwcGx5IHJldHJ5IGxvZ2ljIHVzaW5nIHRoZSAud2l0aFJldHJ5KCkgbWV0aG9kXG4gKiBjb25zdCBhcGlDYWxsV2l0aFJldHJ5ID0gYXBpQ2FsbExhbWJkYS53aXRoUmV0cnkoeyBzdG9wQWZ0ZXJBdHRlbXB0OiAzIH0pO1xuICpcbiAqIC8vIEFsdGVybmF0aXZlbHksIGNyZWF0ZSBhIFJ1bm5hYmxlUmV0cnkgaW5zdGFuY2UgbWFudWFsbHlcbiAqIGNvbnN0IG1hbnVhbFJldHJ5ID0gbmV3IFJ1bm5hYmxlUmV0cnkoe1xuICogICBib3VuZDogYXBpQ2FsbExhbWJkYSxcbiAqICAgbWF4QXR0ZW1wdE51bWJlcjogMyxcbiAqICAgY29uZmlnOiB7fSxcbiAqIH0pO1xuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvbiB1c2luZyB0aGUgLndpdGhSZXRyeSgpIG1ldGhvZFxuICogY29uc3QgcmVzID0gYXdhaXQgYXBpQ2FsbFdpdGhSZXRyeVxuICogICAuaW52b2tlKFwiUmVxdWVzdCAxXCIpXG4gKiAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAqICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIGFmdGVyIG11bHRpcGxlIHJldHJpZXM6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICB9KTtcbiAqXG4gKiAvLyBFeGFtcGxlIGludm9jYXRpb24gdXNpbmcgdGhlIG1hbnVhbCByZXRyeSBpbnN0YW5jZVxuICogY29uc3QgcmVzMiA9IGF3YWl0IG1hbnVhbFJldHJ5XG4gKiAgIC5pbnZva2UoXCJSZXF1ZXN0IDJcIilcbiAqICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICogICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgYWZ0ZXIgbXVsdGlwbGUgcmV0cmllczpcIiwgZXJyb3IubWVzc2FnZSk7XG4gKiAgIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVJldHJ5IGV4dGVuZHMgUnVubmFibGVCaW5kaW5nIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVSZXRyeVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4QXR0ZW1wdE51bWJlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogM1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRBdHRlbXB0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAoKSA9PiB7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4QXR0ZW1wdE51bWJlciA9IGZpZWxkcy5tYXhBdHRlbXB0TnVtYmVyID8/IHRoaXMubWF4QXR0ZW1wdE51bWJlcjtcbiAgICAgICAgdGhpcy5vbkZhaWxlZEF0dGVtcHQgPSBmaWVsZHMub25GYWlsZWRBdHRlbXB0ID8/IHRoaXMub25GYWlsZWRBdHRlbXB0O1xuICAgIH1cbiAgICBfcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgY29uc3QgdGFnID0gYXR0ZW1wdCA+IDEgPyBgcmV0cnk6YXR0ZW1wdDoke2F0dGVtcHR9YCA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHBhdGNoQ29uZmlnKGNvbmZpZywgeyBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRhZykgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gcFJldHJ5KChhdHRlbXB0TnVtYmVyKSA9PiBzdXBlci5pbnZva2UoaW5wdXQsIHRoaXMuX3BhdGNoQ29uZmlnRm9yUmV0cnkoYXR0ZW1wdE51bWJlciwgY29uZmlnLCBydW5NYW5hZ2VyKSksIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IChlcnJvcikgPT4gdGhpcy5vbkZhaWxlZEF0dGVtcHQoZXJyb3IsIGlucHV0KSxcbiAgICAgICAgICAgIHJldHJpZXM6IE1hdGgubWF4KHRoaXMubWF4QXR0ZW1wdE51bWJlciAtIDEsIDApLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgaW52b2tlcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0LCBydW4gbWFuYWdlcixcbiAgICAgKiBhbmQgY29uZmlnLiBJdCBoYW5kbGVzIHRoZSByZXRyeSBsb2dpYyBieSBjYXRjaGluZyBhbnkgZXJyb3JzIGFuZFxuICAgICAqIHJlY3Vyc2l2ZWx5IGludm9raW5nIGl0c2VsZiB3aXRoIHRoZSB1cGRhdGVkIGNvbmZpZyBmb3IgdGhlIG5leHQgcmV0cnlcbiAgICAgKiBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgZm9yIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcGFyYW0gcnVuTWFuYWdlciBUaGUgcnVuIG1hbmFnZXIgZm9yIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWcgZm9yIHRoZSBydW5uYWJsZS5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLmJpbmQodGhpcyksIGlucHV0LCBjb25maWcpO1xuICAgIH1cbiAgICBhc3luYyBfYmF0Y2goaW5wdXRzLCBjb25maWdzLCBydW5NYW5hZ2VycywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHNNYXAgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHBSZXRyeShhc3luYyAoYXR0ZW1wdE51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0luZGV4ZXMgPSBpbnB1dHNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoXywgaSkgPT4gaSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaSkgPT4gcmVzdWx0c01hcFtpLnRvU3RyaW5nKCldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzTWFwW2kudG9TdHJpbmcoKV0gaW5zdGFuY2VvZiBFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nSW5wdXRzID0gcmVtYWluaW5nSW5kZXhlcy5tYXAoKGkpID0+IGlucHV0c1tpXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZENvbmZpZ3MgPSByZW1haW5pbmdJbmRleGVzLm1hcCgoaSkgPT4gdGhpcy5fcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0TnVtYmVyLCBjb25maWdzPy5baV0sIHJ1bk1hbmFnZXJzPy5baV0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc3VwZXIuYmF0Y2gocmVtYWluaW5nSW5wdXRzLCBwYXRjaGVkQ29uZmlncywge1xuICAgICAgICAgICAgICAgICAgICAuLi5iYXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkV4Y2VwdGlvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRNYXBJbmRleCA9IHJlbWFpbmluZ0luZGV4ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFeGNlcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RXhjZXB0aW9uID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24uaW5wdXQgPSByZW1haW5pbmdJbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c01hcFtyZXN1bHRNYXBJbmRleC50b1N0cmluZygpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZpcnN0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogKGVycm9yKSA9PiB0aGlzLm9uRmFpbGVkQXR0ZW1wdChlcnJvciwgZXJyb3IuaW5wdXQpLFxuICAgICAgICAgICAgICAgIHJldHJpZXM6IE1hdGgubWF4KHRoaXMubWF4QXR0ZW1wdE51bWJlciAtIDEsIDApLFxuICAgICAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzdWx0c01hcClcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhLCAxMCkgLSBwYXJzZUludChiLCAxMCkpXG4gICAgICAgICAgICAubWFwKChrZXkpID0+IHJlc3VsdHNNYXBbcGFyc2VJbnQoa2V5LCAxMCldKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoV2l0aENvbmZpZyh0aGlzLl9iYXRjaC5iaW5kKHRoaXMpLCBpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNlcXVlbmNlIG9mIHJ1bm5hYmxlcywgd2hlcmUgdGhlIG91dHB1dCBvZiBlYWNoIGlzIHRoZSBpbnB1dCBvZiB0aGUgbmV4dC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHRUZW1wbGF0ZSA9IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcbiAqICAgXCJUZWxsIG1lIGEgam9rZSBhYm91dCB7dG9waWN9XCIsXG4gKiApO1xuICogY29uc3QgY2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW3Byb21wdFRlbXBsYXRlLCBuZXcgQ2hhdE9wZW5BSSh7fSldKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmludm9rZSh7IHRvcGljOiBcImJlYXJzXCIgfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlU2VxdWVuY2UgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlU2VxdWVuY2VcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpcnN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pZGRsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib21pdFNlcXVlbmNlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maXJzdCA9IGZpZWxkcy5maXJzdDtcbiAgICAgICAgdGhpcy5taWRkbGUgPSBmaWVsZHMubWlkZGxlID8/IHRoaXMubWlkZGxlO1xuICAgICAgICB0aGlzLmxhc3QgPSBmaWVsZHMubGFzdDtcbiAgICAgICAgdGhpcy5uYW1lID0gZmllbGRzLm5hbWU7XG4gICAgICAgIHRoaXMub21pdFNlcXVlbmNlVGFncyA9IGZpZWxkcy5vbWl0U2VxdWVuY2VUYWdzID8/IHRoaXMub21pdFNlcXVlbmNlVGFncztcbiAgICB9XG4gICAgZ2V0IHN0ZXBzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlLCB0aGlzLmxhc3RdO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIGNvbmZpZy5ydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5OYW1lKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5ydW5JZDtcbiAgICAgICAgbGV0IG5leHRTdGVwSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFN0ZXBzID0gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdGlhbFN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IGluaXRpYWxTdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gc3RlcC5pbnZva2UobmV4dFN0ZXBJbnB1dCwgcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQodGhpcy5vbWl0U2VxdWVuY2VUYWdzID8gdW5kZWZpbmVkIDogYHNlcTpzdGVwOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIG5leHRTdGVwSW5wdXQgPSBhd2FpdCByYWNlV2l0aFNpZ25hbChwcm9taXNlLCBvcHRpb25zPy5zaWduYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBjYW4ndCBkZXRlY3QgdGhhdCB0aGUgbGFzdCBvdXRwdXQgb2YgdGhlIHNlcXVlbmNlIHJldHVybnMgUnVuT3V0cHV0LCBzbyBjYWxsIGl0IG91dCBvZiB0aGUgbG9vcCBoZXJlXG4gICAgICAgICAgICBpZiAob3B0aW9ucz8uc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWJvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gYXdhaXQgdGhpcy5sYXN0Lmludm9rZShuZXh0U3RlcElucHV0LCBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRoaXMub21pdFNlcXVlbmNlVGFncyA/IHVuZGVmaW5lZCA6IGBzZXE6c3RlcDoke3RoaXMuc3RlcHMubGVuZ3RofWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KGZpbmFsT3V0cHV0LCBcIm91dHB1dFwiKSk7XG4gICAgICAgIHJldHVybiBmaW5hbE91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnTGlzdCA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY29uZmlnTGlzdC5tYXAoZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoYXN5bmMgKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnRSZXMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dHNbaV0sIFwiaW5wdXRcIiksIGNvbmZpZ0xpc3RbaV0ucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZ0xpc3RbaV0ucnVuTmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnTGlzdFtpXS5ydW5JZDtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdGFydFJlcztcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgbmV4dFN0ZXBJbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RlcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5zdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gc3RlcC5iYXRjaChuZXh0U3RlcElucHV0cywgcnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUnVuTWFuYWdlciA9IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRoaXMub21pdFNlcXVlbmNlVGFncyA/IHVuZGVmaW5lZCA6IGBzZXE6c3RlcDoke2kgKyAxfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hDb25maWcoY29uZmlnTGlzdFtqXSwgeyBjYWxsYmFja3M6IGNoaWxkUnVuTWFuYWdlciB9KTtcbiAgICAgICAgICAgICAgICB9KSwgYmF0Y2hPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBuZXh0U3RlcElucHV0cyA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIGNvbmZpZ0xpc3RbMF0/LnNpZ25hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKSkpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QobmV4dFN0ZXBJbnB1dHMsIFwib3V0cHV0XCIpKSkpO1xuICAgICAgICByZXR1cm4gbmV4dFN0ZXBJbnB1dHM7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBydW5JZCwgLi4ub3RoZXJPcHRpb25zIH0gPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCBydW5JZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3RoZXJPcHRpb25zPy5ydW5OYW1lKTtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBbdGhpcy5maXJzdCwgLi4udGhpcy5taWRkbGUsIHRoaXMubGFzdF07XG4gICAgICAgIGxldCBjb25jYXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBsZXQgZmluYWxPdXRwdXQ7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBpbnB1dEdlbmVyYXRvcigpIHtcbiAgICAgICAgICAgIHlpZWxkIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZmluYWxHZW5lcmF0b3IgPSBzdGVwc1swXS50cmFuc2Zvcm0oaW5wdXRHZW5lcmF0b3IoKSwgcGF0Y2hDb25maWcob3RoZXJPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCh0aGlzLm9taXRTZXF1ZW5jZVRhZ3MgPyB1bmRlZmluZWQgOiBgc2VxOnN0ZXA6MWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdGVwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBmaW5hbEdlbmVyYXRvciA9IGF3YWl0IHN0ZXAudHJhbnNmb3JtKGZpbmFsR2VuZXJhdG9yLCBwYXRjaENvbmZpZyhvdGhlck9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCh0aGlzLm9taXRTZXF1ZW5jZVRhZ3MgPyB1bmRlZmluZWQgOiBgc2VxOnN0ZXA6JHtpICsgMX1gKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGZpbmFsR2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIGlmIChjb25jYXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjb25jYXQoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QoZmluYWxPdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICB9XG4gICAgZ2V0R3JhcGgoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBjdXJyZW50TGFzdE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0ZXBzLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGVwR3JhcGggPSBzdGVwLmdldEdyYXBoKGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGVwR3JhcGgudHJpbUZpcnN0Tm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdGVwR3JhcGgudHJpbUxhc3ROb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFwaC5leHRlbmQoc3RlcEdyYXBoKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBGaXJzdE5vZGUgPSBzdGVwR3JhcGguZmlyc3ROb2RlKCk7XG4gICAgICAgICAgICBpZiAoIXN0ZXBGaXJzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1bm5hYmxlICR7c3RlcH0gaGFzIG5vIGZpcnN0IG5vZGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50TGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBncmFwaC5hZGRFZGdlKGN1cnJlbnRMYXN0Tm9kZSwgc3RlcEZpcnN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGFzdE5vZGUgPSBzdGVwR3JhcGgubGFzdE5vZGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBncmFwaDtcbiAgICB9XG4gICAgcGlwZShjb2VyY2VhYmxlKSB7XG4gICAgICAgIGlmIChSdW5uYWJsZVNlcXVlbmNlLmlzUnVubmFibGVTZXF1ZW5jZShjb2VyY2VhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgICAgICBtaWRkbGU6IHRoaXMubWlkZGxlLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICAgICAgICAgICAgY29lcmNlYWJsZS5maXJzdCxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29lcmNlYWJsZS5taWRkbGUsXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgbGFzdDogY29lcmNlYWJsZS5sYXN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSA/PyBjb2VyY2VhYmxlLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QsXG4gICAgICAgICAgICAgICAgbWlkZGxlOiBbLi4udGhpcy5taWRkbGUsIHRoaXMubGFzdF0sXG4gICAgICAgICAgICAgICAgbGFzdDogX2NvZXJjZVRvUnVubmFibGUoY29lcmNlYWJsZSksXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgaXNSdW5uYWJsZVNlcXVlbmNlKHRoaW5nKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nLm1pZGRsZSkgJiYgUnVubmFibGUuaXNSdW5uYWJsZSh0aGluZyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGZyb20oW2ZpcnN0LCAuLi5ydW5uYWJsZXNdLCBuYW1lT3JGaWVsZHMpIHtcbiAgICAgICAgbGV0IGV4dHJhID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZU9yRmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBleHRyYS5uYW1lID0gbmFtZU9yRmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWVPckZpZWxkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHRyYSA9IG5hbWVPckZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlU2VxdWVuY2Uoe1xuICAgICAgICAgICAgLi4uZXh0cmEsXG4gICAgICAgICAgICBmaXJzdDogX2NvZXJjZVRvUnVubmFibGUoZmlyc3QpLFxuICAgICAgICAgICAgbWlkZGxlOiBydW5uYWJsZXMuc2xpY2UoMCwgLTEpLm1hcChfY29lcmNlVG9SdW5uYWJsZSksXG4gICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShydW5uYWJsZXNbcnVubmFibGVzLmxlbmd0aCAtIDFdKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgcnVucyBhIG1hcHBpbmcgb2YgcnVubmFibGVzIGluIHBhcmFsbGVsLFxuICogYW5kIHJldHVybnMgYSBtYXBwaW5nIG9mIHRoZWlyIG91dHB1dHMuXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgbWFwQ2hhaW4gPSBSdW5uYWJsZU1hcC5mcm9tKHtcbiAqICAgam9rZTogUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwiVGVsbCBtZSBhIGpva2UgYWJvdXQge3RvcGljfVwiKS5waXBlKFxuICogICAgIG5ldyBDaGF0QW50aHJvcGljKHt9KSxcbiAqICAgKSxcbiAqICAgcG9lbTogUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKFwid3JpdGUgYSAyLWxpbmUgcG9lbSBhYm91dCB7dG9waWN9XCIpLnBpcGUoXG4gKiAgICAgbmV3IENoYXRBbnRocm9waWMoe30pLFxuICogICApLFxuICogfSk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBtYXBDaGFpbi5pbnZva2UoeyB0b3BpYzogXCJiZWFyXCIgfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlTWFwIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZU1hcFwiO1xuICAgIH1cbiAgICBnZXRTdGVwc0tleXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0ZXBzKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RlcHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGVwcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZHMuc3RlcHMpKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzW2tleV0gPSBfY29lcmNlVG9SdW5uYWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb20oc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZU1hcCh7IHN0ZXBzIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIHtcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICB9LCBjb25maWcucnVuSWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbmZpZz8ucnVuTmFtZSk7XG4gICAgICAgIGRlbGV0ZSBjb25maWcucnVuSWQ7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLnN0ZXBzKS5tYXAoYXN5bmMgKFtrZXksIHJ1bm5hYmxlXSkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gYXdhaXQgcnVubmFibGUuaW52b2tlKGlucHV0LCBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgbWFwOmtleToke2tleX1gKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhY2VXaXRoU2lnbmFsKFByb21pc2UuYWxsKHByb21pc2VzKSwgb3B0aW9ucz8uc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIHNoYWxsb3cgY29weSBzdGVwcyB0byBpZ25vcmUgY2hhbmdlcyB3aGlsZSBpdGVyYXRpbmdcbiAgICAgICAgY29uc3Qgc3RlcHMgPSB7IC4uLnRoaXMuc3RlcHMgfTtcbiAgICAgICAgLy8gZWFjaCBzdGVwIGdldHMgYSBjb3B5IG9mIHRoZSBpbnB1dCBpdGVyYXRvclxuICAgICAgICBjb25zdCBpbnB1dENvcGllcyA9IGF0ZWUoZ2VuZXJhdG9yLCBPYmplY3Qua2V5cyhzdGVwcykubGVuZ3RoKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIGZpcnN0IGl0ZXJhdGlvbiBvZiBlYWNoIG91dHB1dCBpdGVyYXRvclxuICAgICAgICBjb25zdCB0YXNrcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoc3RlcHMpLm1hcCgoW2tleSwgcnVubmFibGVdLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZW4gPSBydW5uYWJsZS50cmFuc2Zvcm0oaW5wdXRDb3BpZXNbaV0sIHBhdGNoQ29uZmlnKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBtYXA6a2V5OiR7a2V5fWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXksIGdlbi5uZXh0KCkudGhlbigocmVzdWx0KSA9PiAoeyBrZXksIGdlbiwgcmVzdWx0IH0pKV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8geWllbGQgY2h1bmtzIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSxcbiAgICAgICAgLy8gc3RhcnRpbmcgbmV3IGl0ZXJhdGlvbnMgYXMgbmVlZGVkLFxuICAgICAgICAvLyB1bnRpbCBhbGwgaXRlcmF0b3JzIGFyZSBkb25lXG4gICAgICAgIHdoaWxlICh0YXNrcy5zaXplKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yYWNlKHRhc2tzLnZhbHVlcygpKTtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCByZXN1bHQsIGdlbiB9ID0gYXdhaXQgcmFjZVdpdGhTaWduYWwocHJvbWlzZSwgb3B0aW9ucz8uc2lnbmFsKTtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgW2tleV06IHJlc3VsdC52YWx1ZSB9O1xuICAgICAgICAgICAgICAgIHRhc2tzLnNldChrZXksIGdlbi5uZXh0KCkudGhlbigocmVzdWx0KSA9PiAoeyBrZXksIGdlbiwgcmVzdWx0IH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCB3cmFwcyBhIHRyYWNlZCBMYW5nU21pdGggZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVRyYWNlYWJsZSBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzVHJhY2VhYmxlRnVuY3Rpb24oZmllbGRzLmZ1bmMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uYWJsZVRyYWNlYWJsZSByZXF1aXJlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgd3JhcHBlZCBpbiB0cmFjZWFibGUgaGlnaGVyLW9yZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgW2NvbmZpZ10gPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCAxKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmZ1bmMocGF0Y2hDb25maWcoY29uZmlnLCB7IGNhbGxiYWNrcyB9KSwgaW5wdXQpO1xuICAgICAgICByZXR1cm4gcmFjZVdpdGhTaWduYWwocHJvbWlzZSwgY29uZmlnPy5zaWduYWwpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtjb25maWddID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgMSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaW52b2tlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGlzQXN5bmNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJdGVyYXRvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gcmVzdWx0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgeWllbGQgc3RhdGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShmdW5jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVUcmFjZWFibGUoeyBmdW5jIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydE5vblRyYWNlYWJsZUZ1bmN0aW9uKGZ1bmMpIHtcbiAgICBpZiAoaXNUcmFjZWFibGVGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5uYWJsZUxhbWJkYSByZXF1aXJlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgbm90IHdyYXBwZWQgaW4gdHJhY2VhYmxlIGhpZ2hlci1vcmRlciBmdW5jdGlvbi4gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLlwiKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCB3cmFwcyBhbiBhcmJpdHJhcnkgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQgeyBSdW5uYWJsZUxhbWJkYSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgYWRkID0gKGlucHV0OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0pID0+IGlucHV0LnggKyBpbnB1dC55O1xuICpcbiAqIGNvbnN0IG11bHRpcGx5ID0gKGlucHV0OiB7IHZhbHVlOiBudW1iZXI7IG11bHRpcGxpZXI6IG51bWJlciB9KSA9PlxuICogICBpbnB1dC52YWx1ZSAqIGlucHV0Lm11bHRpcGxpZXI7XG4gKlxuICogLy8gQ3JlYXRlIHJ1bm5hYmxlcyBmb3IgdGhlIGZ1bmN0aW9uc1xuICogY29uc3QgYWRkTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShhZGQpO1xuICogY29uc3QgbXVsdGlwbHlMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKG11bHRpcGx5KTtcbiAqXG4gKiAvLyBDaGFpbiB0aGUgbGFtYmRhcyBmb3IgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uXG4gKiBjb25zdCBjaGFpbmVkTGFtYmRhID0gYWRkTGFtYmRhLnBpcGUoKHJlc3VsdCkgPT5cbiAqICAgbXVsdGlwbHlMYW1iZGEuaW52b2tlKHsgdmFsdWU6IHJlc3VsdCwgbXVsdGlwbGllcjogMiB9KVxuICogKTtcbiAqXG4gKiAvLyBFeGFtcGxlIGludm9jYXRpb24gb2YgdGhlIGNoYWluZWRMYW1iZGFcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluZWRMYW1iZGEuaW52b2tlKHsgeDogMiwgeTogMyB9KTtcbiAqXG4gKiAvLyBXaWxsIGxvZyBcIjEwXCIgKHNpbmNlICgyICsgMykgKiAyID0gMTApXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlTGFtYmRhIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUxhbWJkYVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgaWYgKGlzVHJhY2VhYmxlRnVuY3Rpb24oZmllbGRzLmZ1bmMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgICAgICAgICByZXR1cm4gUnVubmFibGVUcmFjZWFibGUuZnJvbShmaWVsZHMuZnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnROb25UcmFjZWFibGVGdW5jdGlvbihmaWVsZHMuZnVuYyk7XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShmdW5jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVMYW1iZGEoe1xuICAgICAgICAgICAgZnVuYyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID8/IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZvaWQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMoY2hpbGRDb25maWcpLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IGF3YWl0IHRoaXMuZnVuYyhpbnB1dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0ICYmIFJ1bm5hYmxlLmlzUnVubmFibGUob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZz8ucmVjdXJzaW9uTGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWN1cnNpb24gbGltaXQgcmVhY2hlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBhd2FpdCBvdXRwdXQuaW52b2tlKGlucHV0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IChjaGlsZENvbmZpZy5yZWN1cnNpb25MaW1pdCA/PyBERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCkgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBc3luY0l0ZXJhYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQoY2hpbGRDb25maWcsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY29uY2F0KGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBmaW5hbE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0l0ZXJhYmxlSXRlcmF0b3Iob3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjb25zdW1lSXRlcmF0b3JJbkNvbnRleHQoY2hpbGRDb25maWcsIG91dHB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY29uY2F0KGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBmaW5hbE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLmJpbmQodGhpcyksIGlucHV0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBjb25maWcpIHtcbiAgICAgICAgbGV0IGZpbmFsQ2h1bms7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxDaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIGJlc3QgZWZmb3J0IHRvIGdhdGhlciwgZm9yIGFueSB0eXBlIHRoYXQgc3VwcG9ydHMgY29uY2F0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBjb25jYXQoZmluYWxDaHVuaywgY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY2h1bms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICByZWN1cnNpb25MaW1pdDogKGNvbmZpZz8ucmVjdXJzaW9uTGltaXQgPz8gREVGQVVMVF9SRUNVUlNJT05fTElNSVQpIC0gMSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZvaWQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5ydW5XaXRoQ29uZmlnKHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMoY2hpbGRDb25maWcpLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5mdW5jKGZpbmFsQ2h1bmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGlmIChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjdXJzaW9uIGxpbWl0IHJlYWNoZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgb3V0cHV0LnN0cmVhbShmaW5hbENodW5rLCBjaGlsZENvbmZpZyk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQXN5bmNJdGVyYWJsZShvdXRwdXQpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0KGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNJdGVyYWJsZUl0ZXJhdG9yKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY29uc3VtZUl0ZXJhdG9ySW5Db250ZXh0KGNoaWxkQ29uZmlnLCBvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnPy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBydW5zIGEgbWFwcGluZyBvZiBydW5uYWJsZXMgaW4gcGFyYWxsZWwsXG4gKiBhbmQgcmV0dXJucyBhIG1hcHBpbmcgb2YgdGhlaXIgb3V0cHV0cy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge1xuICogICBSdW5uYWJsZUxhbWJkYSxcbiAqICAgUnVubmFibGVQYXJhbGxlbCxcbiAqIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiBjb25zdCBhZGRZZWFycyA9IChhZ2U6IG51bWJlcik6IG51bWJlciA9PiBhZ2UgKyA1O1xuICogY29uc3QgeWVhcnNUb0ZpZnR5ID0gKGFnZTogbnVtYmVyKTogbnVtYmVyID0+IDUwIC0gYWdlO1xuICogY29uc3QgeWVhcnNUb0h1bmRyZWQgPSAoYWdlOiBudW1iZXIpOiBudW1iZXIgPT4gMTAwIC0gYWdlO1xuICpcbiAqIGNvbnN0IGFkZFllYXJzTGFtYmRhID0gUnVubmFibGVMYW1iZGEuZnJvbShhZGRZZWFycyk7XG4gKiBjb25zdCBtaWxlc3RvbmVGaWZ0eUxhbWJkYSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oeWVhcnNUb0ZpZnR5KTtcbiAqIGNvbnN0IG1pbGVzdG9uZUh1bmRyZWRMYW1iZGEgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKHllYXJzVG9IdW5kcmVkKTtcbiAqXG4gKiAvLyBQaXBlIHdpbGwgY29lcmNlIG9iamVjdHMgaW50byBSdW5uYWJsZVBhcmFsbGVsIGJ5IGRlZmF1bHQsIGJ1dCB3ZVxuICogLy8gZXhwbGljaXRseSBpbnN0YW50aWF0ZSBvbmUgaGVyZSB0byBkZW1vbnN0cmF0ZVxuICogY29uc3Qgc2VxdWVuY2UgPSBhZGRZZWFyc0xhbWJkYS5waXBlKFxuICogICBSdW5uYWJsZVBhcmFsbGVsLmZyb20oe1xuICogICAgIHllYXJzX3RvX2ZpZnR5OiBtaWxlc3RvbmVGaWZ0eUxhbWJkYSxcbiAqICAgICB5ZWFyc190b19odW5kcmVkOiBtaWxlc3RvbmVIdW5kcmVkTGFtYmRhLFxuICogICB9KVxuICogKTtcbiAqXG4gKiAvLyBJbnZva2UgdGhlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgYWdlIGlucHV0XG4gKiBjb25zdCByZXMgPSBzZXF1ZW5jZS5pbnZva2UoMjUpO1xuICpcbiAqIC8vIHsgeWVhcnNfdG9fZmlmdHk6IDI1LCB5ZWFyc190b19odW5kcmVkOiA3NSB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlUGFyYWxsZWwgZXh0ZW5kcyBSdW5uYWJsZU1hcCB7XG59XG4vKipcbiAqIEEgUnVubmFibGUgdGhhdCBjYW4gZmFsbGJhY2sgdG8gb3RoZXIgUnVubmFibGVzIGlmIGl0IGZhaWxzLlxuICogRXh0ZXJuYWwgQVBJcyAoZS5nLiwgQVBJcyBmb3IgYSBsYW5ndWFnZSBtb2RlbCkgbWF5IGF0IHRpbWVzIGV4cGVyaWVuY2VcbiAqIGRlZ3JhZGVkIHBlcmZvcm1hbmNlIG9yIGV2ZW4gZG93bnRpbWUuXG4gKlxuICogSW4gdGhlc2UgY2FzZXMsIGl0IGNhbiBiZSB1c2VmdWwgdG8gaGF2ZSBhIGZhbGxiYWNrIFJ1bm5hYmxlIHRoYXQgY2FuIGJlXG4gKiB1c2VkIGluIHBsYWNlIG9mIHRoZSBvcmlnaW5hbCBSdW5uYWJsZSAoZS5nLiwgZmFsbGJhY2sgdG8gYW5vdGhlciBMTE0gcHJvdmlkZXIpLlxuICpcbiAqIEZhbGxiYWNrcyBjYW4gYmUgZGVmaW5lZCBhdCB0aGUgbGV2ZWwgb2YgYSBzaW5nbGUgUnVubmFibGUsIG9yIGF0IHRoZSBsZXZlbFxuICogb2YgYSBjaGFpbiBvZiBSdW5uYWJsZXMuIEZhbGxiYWNrcyBhcmUgdHJpZWQgaW4gb3JkZXIgdW50aWwgb25lIHN1Y2NlZWRzIG9yXG4gKiBhbGwgZmFpbC5cbiAqXG4gKiBXaGlsZSB5b3UgY2FuIGluc3RhbnRpYXRlIGEgYFJ1bm5hYmxlV2l0aEZhbGxiYWNrc2AgZGlyZWN0bHksIGl0IGlzIHVzdWFsbHlcbiAqIG1vcmUgY29udmVuaWVudCB0byB1c2UgdGhlIGB3aXRoRmFsbGJhY2tzYCBtZXRob2Qgb24gYW4gZXhpc3RpbmcgUnVubmFibGUuXG4gKlxuICogV2hlbiBzdHJlYW1pbmcsIGZhbGxiYWNrcyB3aWxsIG9ubHkgYmUgY2FsbGVkIG9uIGZhaWx1cmVzIGR1cmluZyB0aGUgaW5pdGlhbFxuICogc3RyZWFtIGNyZWF0aW9uLiBFcnJvcnMgdGhhdCBvY2N1ciBhZnRlciBhIHN0cmVhbSBzdGFydHMgd2lsbCBub3QgZmFsbGJhY2tcbiAqIHRvIHRoZSBuZXh0IFJ1bm5hYmxlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBpbXBvcnQge1xuICogICBSdW5uYWJsZUxhbWJkYSxcbiAqICAgUnVubmFibGVXaXRoRmFsbGJhY2tzLFxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3J1bm5hYmxlc1wiO1xuICpcbiAqIGNvbnN0IHByaW1hcnlPcGVyYXRpb24gPSAoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gKiAgIGlmIChpbnB1dCAhPT0gXCJzYWZlXCIpIHtcbiAqICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcmltYXJ5IG9wZXJhdGlvbiBmYWlsZWQgZHVlIHRvIHVuc2FmZSBpbnB1dFwiKTtcbiAqICAgfVxuICogICByZXR1cm4gYFByb2Nlc3NlZDogJHtpbnB1dH1gO1xuICogfTtcbiAqXG4gKiAvLyBEZWZpbmUgYSBmYWxsYmFjayBvcGVyYXRpb24gdGhhdCBwcm9jZXNzZXMgdGhlIGlucHV0IGRpZmZlcmVudGx5XG4gKiBjb25zdCBmYWxsYmFja09wZXJhdGlvbiA9IChpbnB1dDogc3RyaW5nKTogc3RyaW5nID0+XG4gKiAgIGBGYWxsYmFjayBwcm9jZXNzZWQ6ICR7aW5wdXR9YDtcbiAqXG4gKiBjb25zdCBwcmltYXJ5UnVubmFibGUgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKHByaW1hcnlPcGVyYXRpb24pO1xuICogY29uc3QgZmFsbGJhY2tSdW5uYWJsZSA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oZmFsbGJhY2tPcGVyYXRpb24pO1xuICpcbiAqIC8vIEFwcGx5IHRoZSBmYWxsYmFjayBsb2dpYyB1c2luZyB0aGUgLndpdGhGYWxsYmFja3MoKSBtZXRob2RcbiAqIGNvbnN0IHJ1bm5hYmxlV2l0aEZhbGxiYWNrID0gcHJpbWFyeVJ1bm5hYmxlLndpdGhGYWxsYmFja3MoW2ZhbGxiYWNrUnVubmFibGVdKTtcbiAqXG4gKiAvLyBBbHRlcm5hdGl2ZWx5LCBjcmVhdGUgYSBSdW5uYWJsZVdpdGhGYWxsYmFja3MgaW5zdGFuY2UgbWFudWFsbHlcbiAqIGNvbnN0IG1hbnVhbEZhbGxiYWNrQ2hhaW4gPSBuZXcgUnVubmFibGVXaXRoRmFsbGJhY2tzKHtcbiAqICAgcnVubmFibGU6IHByaW1hcnlSdW5uYWJsZSxcbiAqICAgZmFsbGJhY2tzOiBbZmFsbGJhY2tSdW5uYWJsZV0sXG4gKiB9KTtcbiAqXG4gKiAvLyBFeGFtcGxlIGludm9jYXRpb24gdXNpbmcgLndpdGhGYWxsYmFja3MoKVxuICogY29uc3QgcmVzID0gYXdhaXQgcnVubmFibGVXaXRoRmFsbGJhY2tcbiAqICAgLmludm9rZShcInVuc2FmZSBpbnB1dFwiKVxuICogICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gKiAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCBhZnRlciBhbGwgYXR0ZW1wdHM6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICB9KTtcbiAqXG4gKiAvLyBcIkZhbGxiYWNrIHByb2Nlc3NlZDogdW5zYWZlIGlucHV0XCJcbiAqXG4gKiAvLyBFeGFtcGxlIGludm9jYXRpb24gdXNpbmcgbWFudWFsIGluc3RhbnRpYXRpb25cbiAqIGNvbnN0IHJlcyA9IGF3YWl0IG1hbnVhbEZhbGxiYWNrQ2hhaW5cbiAqICAgLmludm9rZShcInNhZmVcIilcbiAqICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICogICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgYWZ0ZXIgYWxsIGF0dGVtcHRzOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAqICAgfSk7XG4gKlxuICogLy8gXCJQcm9jZXNzZWQ6IHNhZmVcIlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVdpdGhGYWxsYmFja3MgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlV2l0aEZhbGxiYWNrc1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5uYWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmYWxsYmFja3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW5uYWJsZSA9IGZpZWxkcy5ydW5uYWJsZTtcbiAgICAgICAgdGhpcy5mYWxsYmFja3MgPSBmaWVsZHMuZmFsbGJhY2tzO1xuICAgIH1cbiAgICAqcnVubmFibGVzKCkge1xuICAgICAgICB5aWVsZCB0aGlzLnJ1bm5hYmxlO1xuICAgICAgICBmb3IgKGNvbnN0IGZhbGxiYWNrIG9mIHRoaXMuZmFsbGJhY2tzKSB7XG4gICAgICAgICAgICB5aWVsZCBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHsgcnVuSWQsIC4uLm90aGVyQ29uZmlnRmllbGRzIH0gPSBjb25maWc7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvdGhlckNvbmZpZ0ZpZWxkcz8ucnVuTmFtZSk7XG4gICAgICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gcGF0Y2hDb25maWcob3RoZXJDb25maWdGaWVsZHMsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhjaGlsZENvbmZpZywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGZpcnN0RXJyb3I7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bm5hYmxlIG9mIHRoaXMucnVubmFibGVzKCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWc/LnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBydW5uYWJsZS5pbnZva2UoaW5wdXQsIGNoaWxkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RFcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXJyb3Igc3RvcmVkIGF0IGVuZCBvZiBmYWxsYmFjay5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGZpcnN0RXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZmlyc3RFcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHsgcnVuSWQsIC4uLm90aGVyQ29uZmlnRmllbGRzIH0gPSBjb25maWc7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvdGhlckNvbmZpZ0ZpZWxkcz8ucnVuTmFtZSk7XG4gICAgICAgIGxldCBmaXJzdEVycm9yO1xuICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bm5hYmxlIG9mIHRoaXMucnVubmFibGVzKCkpIHtcbiAgICAgICAgICAgIGNvbmZpZz8uc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSBwYXRjaENvbmZpZyhvdGhlckNvbmZpZ0ZpZWxkcywge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0cmVhbSA9IGF3YWl0IHJ1bm5hYmxlLnN0cmVhbShpbnB1dCwgY2hpbGRDb25maWcpO1xuICAgICAgICAgICAgICAgIHN0cmVhbSA9IGNvbnN1bWVBc3luY0l0ZXJhYmxlSW5Db250ZXh0KGNoaWxkQ29uZmlnLCBvcmlnaW5hbFN0cmVhbSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBmaXJzdEVycm9yID8/IG5ldyBFcnJvcihcIk5vIGVycm9yIHN0b3JlZCBhdCBlbmQgb2YgZmFsbGJhY2suXCIpO1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgPT09IHVuZGVmaW5lZCA/IG91dHB1dCA6IGNvbmNhdChvdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGJhdGNoT3B0aW9ucz8ucmV0dXJuRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWdMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjb25maWdMaXN0Lm1hcCgoY29uZmlnKSA9PiBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNhbGxiYWNrTWFuYWdlcnMubWFwKGFzeW5jIChjYWxsYmFja01hbmFnZXIsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVN0YXJ0UmVzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXRzW2ldLCBcImlucHV0XCIpLCBjb25maWdMaXN0W2ldLnJ1bklkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWdMaXN0W2ldLnJ1bk5hbWUpO1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZ0xpc3RbaV0ucnVuSWQ7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RhcnRSZXM7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IGZpcnN0RXJyb3I7XG4gICAgICAgIGZvciAoY29uc3QgcnVubmFibGUgb2YgdGhpcy5ydW5uYWJsZXMoKSkge1xuICAgICAgICAgICAgY29uZmlnTGlzdFswXS5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBhd2FpdCBydW5uYWJsZS5iYXRjaChpbnB1dHMsIHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaikgPT4gcGF0Y2hDb25maWcoY29uZmlnTGlzdFtqXSwge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgfSkpLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaSkgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXRzW2ldLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaXJzdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBzdG9yZWQgYXQgZW5kIG9mIGZhbGxiYWNrcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGZpcnN0RXJyb3IpKSk7XG4gICAgICAgIHRocm93IGZpcnN0RXJyb3I7XG4gICAgfVxufVxuLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIGNvbXBpbGVyIG5lZWRzIGhlbHAgZWxpbWluYXRpbmcgRXJyb3IgYXMgYSBSdW5PdXRwdXQgdHlwZVxuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VUb1J1bm5hYmxlKGNvZXJjZWFibGUpIHtcbiAgICBpZiAodHlwZW9mIGNvZXJjZWFibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTGFtYmRhKHsgZnVuYzogY29lcmNlYWJsZSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoUnVubmFibGUuaXNSdW5uYWJsZShjb2VyY2VhYmxlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlYWJsZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoY29lcmNlYWJsZSkgJiYgdHlwZW9mIGNvZXJjZWFibGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcnVubmFibGVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNvZXJjZWFibGUpKSB7XG4gICAgICAgICAgICBydW5uYWJsZXNba2V5XSA9IF9jb2VyY2VUb1J1bm5hYmxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTWFwKHtcbiAgICAgICAgICAgIHN0ZXBzOiBydW5uYWJsZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIFJ1bm5hYmxlLCBmdW5jdGlvbiBvciBvYmplY3QuXFxuSW5zdGVhZCBnb3QgYW4gdW5zdXBwb3J0ZWQgdHlwZS5gKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBhc3NpZ25zIGtleS12YWx1ZSBwYWlycyB0byBpbnB1dHMgb2YgdHlwZSBgUmVjb3JkPHN0cmluZywgdW5rbm93bj5gLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7XG4gKiAgIFJ1bm5hYmxlQXNzaWduLFxuICogICBSdW5uYWJsZUxhbWJkYSxcbiAqICAgUnVubmFibGVQYXJhbGxlbCxcbiAqIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqXG4gKiBjb25zdCBjYWxjdWxhdGVBZ2UgPSAoeDogeyBiaXJ0aFllYXI6IG51bWJlciB9KTogeyBhZ2U6IG51bWJlciB9ID0+IHtcbiAqICAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gKiAgIHJldHVybiB7IGFnZTogY3VycmVudFllYXIgLSB4LmJpcnRoWWVhciB9O1xuICogfTtcbiAqXG4gKiBjb25zdCBjcmVhdGVHcmVldGluZyA9ICh4OiB7IG5hbWU6IHN0cmluZyB9KTogeyBncmVldGluZzogc3RyaW5nIH0gPT4ge1xuICogICByZXR1cm4geyBncmVldGluZzogYEhlbGxvLCAke3gubmFtZX0hYCB9O1xuICogfTtcbiAqXG4gKiBjb25zdCBtYXBwZXIgPSBSdW5uYWJsZVBhcmFsbGVsLmZyb20oe1xuICogICBhZ2Vfc3RlcDogUnVubmFibGVMYW1iZGEuZnJvbShjYWxjdWxhdGVBZ2UpLFxuICogICBncmVldGluZ19zdGVwOiBSdW5uYWJsZUxhbWJkYS5mcm9tKGNyZWF0ZUdyZWV0aW5nKSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHJ1bm5hYmxlQXNzaWduID0gbmV3IFJ1bm5hYmxlQXNzaWduKHsgbWFwcGVyIH0pO1xuICpcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IHJ1bm5hYmxlQXNzaWduLmludm9rZSh7IG5hbWU6IFwiQWxpY2VcIiwgYmlydGhZZWFyOiAxOTkwIH0pO1xuICpcbiAqIC8vIHsgbmFtZTogXCJBbGljZVwiLCBiaXJ0aFllYXI6IDE5OTAsIGFnZV9zdGVwOiB7IGFnZTogMzQgfSwgZ3JlZXRpbmdfc3RlcDogeyBncmVldGluZzogXCJIZWxsbywgQWxpY2UhXCIgfSB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlQXNzaWduIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZUFzc2lnblwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICBpZiAoZmllbGRzIGluc3RhbmNlb2YgUnVubmFibGVNYXApIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBtYXBwZXI6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWFwcGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFwcGVyID0gZmllbGRzLm1hcHBlcjtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlclJlc3VsdCA9IGF3YWl0IHRoaXMubWFwcGVyLmludm9rZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pbnB1dCxcbiAgICAgICAgICAgIC4uLm1hcHBlclJlc3VsdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgbWFwcGVyIGtleXNcbiAgICAgICAgY29uc3QgbWFwcGVyS2V5cyA9IHRoaXMubWFwcGVyLmdldFN0ZXBzS2V5cygpO1xuICAgICAgICAvLyBjcmVhdGUgdHdvIGlucHV0IGdlbnMsIG9uZSBmb3IgdGhlIG1hcHBlciwgb25lIGZvciB0aGUgaW5wdXRcbiAgICAgICAgY29uc3QgW2ZvclBhc3N0aHJvdWdoLCBmb3JNYXBwZXJdID0gYXRlZShnZW5lcmF0b3IpO1xuICAgICAgICAvLyBjcmVhdGUgbWFwcGVyIG91dHB1dCBnZW5cbiAgICAgICAgY29uc3QgbWFwcGVyT3V0cHV0ID0gdGhpcy5tYXBwZXIudHJhbnNmb3JtKGZvck1hcHBlciwgcGF0Y2hDb25maWcob3B0aW9ucywgeyBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCkgfSkpO1xuICAgICAgICAvLyBzdGFydCB0aGUgbWFwcGVyXG4gICAgICAgIGNvbnN0IGZpcnN0TWFwcGVyQ2h1bmtQcm9taXNlID0gbWFwcGVyT3V0cHV0Lm5leHQoKTtcbiAgICAgICAgLy8geWllbGQgdGhlIHBhc3N0aHJvdWdoXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgZm9yUGFzc3Rocm91Z2gpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1bm5hYmxlQXNzaWduIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBvYmplY3RzIGFzIGlucHV0LCBnb3QgJHt0eXBlb2YgY2h1bmt9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhjaHVuaykuZmlsdGVyKChba2V5XSkgPT4gIW1hcHBlcktleXMuaW5jbHVkZXMoa2V5KSkpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGZpbHRlcmVkKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZmlsdGVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8geWllbGQgdGhlIG1hcHBlciBvdXRwdXRcbiAgICAgICAgeWllbGQgKGF3YWl0IGZpcnN0TWFwcGVyQ2h1bmtQcm9taXNlKS52YWx1ZTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBtYXBwZXJPdXRwdXQpIHtcbiAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy50cmFuc2Zvcm0oZ2VuZXJhdG9yKCksIGNvbmZpZyksXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgYXNzaWducyBrZXktdmFsdWUgcGFpcnMgdG8gaW5wdXRzIG9mIHR5cGUgYFJlY29yZDxzdHJpbmcsIHVua25vd24+YC5cbiAqIFVzZWZ1bCBmb3Igc3RyZWFtaW5nLCBjYW4gYmUgYXV0b21hdGljYWxseSBjcmVhdGVkIGFuZCBjaGFpbmVkIGJ5IGNhbGxpbmcgYHJ1bm5hYmxlLnBpY2soKTtgLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IFJ1bm5hYmxlUGljayB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKlxuICogY29uc3QgaW5wdXREYXRhID0ge1xuICogICBuYW1lOiBcIkpvaG5cIixcbiAqICAgYWdlOiAzMCxcbiAqICAgY2l0eTogXCJOZXcgWW9ya1wiLFxuICogICBjb3VudHJ5OiBcIlVTQVwiLFxuICogICBlbWFpbDogXCJqb2huLmRvZUBleGFtcGxlLmNvbVwiLFxuICogICBwaG9uZTogXCIrMTIzNDU2Nzg5MFwiLFxuICogfTtcbiAqXG4gKiBjb25zdCBiYXNpY0luZm9SdW5uYWJsZSA9IG5ldyBSdW5uYWJsZVBpY2soW1wibmFtZVwiLCBcImNpdHlcIl0pO1xuICpcbiAqIC8vIEV4YW1wbGUgaW52b2NhdGlvblxuICogY29uc3QgcmVzID0gYXdhaXQgYmFzaWNJbmZvUnVubmFibGUuaW52b2tlKGlucHV0RGF0YSk7XG4gKlxuICogLy8geyBuYW1lOiAnSm9obicsIGNpdHk6ICdOZXcgWW9yaycgfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVBpY2sgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlUGlja1wiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsga2V5czogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMua2V5cyA9IGZpZWxkcy5rZXlzO1xuICAgIH1cbiAgICBhc3luYyBfcGljayhpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMua2V5cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0W3RoaXMua2V5c107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwaWNrZWQgPSB0aGlzLmtleXNcbiAgICAgICAgICAgICAgICAubWFwKChrZXkpID0+IFtrZXksIGlucHV0W2tleV1dKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHYpID0+IHZbMV0gIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm4gcGlja2VkLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IE9iamVjdC5mcm9tRW50cmllcyhwaWNrZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5fcGljay5iaW5kKHRoaXMpLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGdlbmVyYXRvcikge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgY29uc3QgcGlja2VkID0gYXdhaXQgdGhpcy5fcGljayhjaHVuayk7XG4gICAgICAgICAgICBpZiAocGlja2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBwaWNrZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHZW5lcmF0b3IgPSBuZXcgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgY29uZmlnKSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVubmFibGVUb29sTGlrZSBleHRlbmRzIFJ1bm5hYmxlQmluZGluZyB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlID0gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAgICAgICAgICAgIFJ1bm5hYmxlTGFtYmRhLmZyb20oYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvb2xJbnB1dDtcbiAgICAgICAgICAgICAgICBpZiAoX2lzVG9vbENhbGwoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sSW5wdXQgPSBhd2FpdCB0aGlzLnNjaGVtYS5wYXJzZUFzeW5jKGlucHV0LmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9vbElucHV0UGFyc2luZ0V4Y2VwdGlvbihgUmVjZWl2ZWQgdG9vbCBpbnB1dCBkaWQgbm90IG1hdGNoIGV4cGVjdGVkIHNjaGVtYWAsIEpTT04uc3RyaW5naWZ5KGlucHV0LmFyZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbElucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b29sSW5wdXQ7XG4gICAgICAgICAgICB9KS53aXRoQ29uZmlnKHsgcnVuTmFtZTogYCR7ZmllbGRzLm5hbWV9OnBhcnNlX2lucHV0YCB9KSxcbiAgICAgICAgICAgIGZpZWxkcy5ib3VuZCxcbiAgICAgICAgXSkud2l0aENvbmZpZyh7IHJ1bk5hbWU6IGZpZWxkcy5uYW1lIH0pO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBib3VuZDogc2VxdWVuY2UsXG4gICAgICAgICAgICBjb25maWc6IGZpZWxkcy5jb25maWcgPz8ge30sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjaGVtYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBmaWVsZHMuc2NoZW1hO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVUb29sTGlrZVwiO1xuICAgIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBydW5uYWJsZSBhbmQgYSBab2Qgc2NoZW1hLCBjb252ZXJ0IHRoZSBydW5uYWJsZSB0byBhIHRvb2wuXG4gKlxuICogQHRlbXBsYXRlIFJ1bklucHV0IFRoZSBpbnB1dCB0eXBlIGZvciB0aGUgcnVubmFibGUuXG4gKiBAdGVtcGxhdGUgUnVuT3V0cHV0IFRoZSBvdXRwdXQgdHlwZSBmb3IgdGhlIHJ1bm5hYmxlLlxuICpcbiAqIEBwYXJhbSB7UnVubmFibGU8UnVuSW5wdXQsIFJ1bk91dHB1dD59IHJ1bm5hYmxlIFRoZSBydW5uYWJsZSB0byBjb252ZXJ0IHRvIGEgdG9vbC5cbiAqIEBwYXJhbSBmaWVsZHNcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBbZmllbGRzLm5hbWVdIFRoZSBuYW1lIG9mIHRoZSB0b29sLiBJZiBub3QgcHJvdmlkZWQsIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgcnVubmFibGUuXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gW2ZpZWxkcy5kZXNjcmlwdGlvbl0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSB0b29sLiBGYWxscyBiYWNrIHRvIHRoZSBkZXNjcmlwdGlvbiBvbiB0aGUgWm9kIHNjaGVtYSBpZiBub3QgcHJvdmlkZWQsIG9yIHVuZGVmaW5lZCBpZiBuZWl0aGVyIGFyZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7ei5ab2RUeXBlPFJ1bklucHV0Pn0gW2ZpZWxkcy5zY2hlbWFdIFRoZSBab2Qgc2NoZW1hIGZvciB0aGUgaW5wdXQgb2YgdGhlIHRvb2wuIEluZmVycyB0aGUgWm9kIHR5cGUgZnJvbSB0aGUgaW5wdXQgdHlwZSBvZiB0aGUgcnVubmFibGUuXG4gKiBAcmV0dXJucyB7UnVubmFibGVUb29sTGlrZTx6LlpvZFR5cGU8UnVuSW5wdXQ+LCBSdW5PdXRwdXQ+fSBBbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAgd2hpY2ggaXMgYSBydW5uYWJsZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgdG9vbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSdW5uYWJsZVRvVG9vbChydW5uYWJsZSwgZmllbGRzKSB7XG4gICAgY29uc3QgbmFtZSA9IGZpZWxkcy5uYW1lID8/IHJ1bm5hYmxlLmdldE5hbWUoKTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGZpZWxkcy5kZXNjcmlwdGlvbiA/PyBmaWVsZHMuc2NoZW1hPy5kZXNjcmlwdGlvbjtcbiAgICBpZiAoZmllbGRzLnNjaGVtYS5jb25zdHJ1Y3RvciA9PT0gei5ab2RTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVRvb2xMaWtlKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNjaGVtYTogelxuICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlucHV0OiB6LnN0cmluZygpLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudHJhbnNmb3JtKChpbnB1dCkgPT4gaW5wdXQuaW5wdXQpLFxuICAgICAgICAgICAgYm91bmQ6IHJ1bm5hYmxlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSdW5uYWJsZVRvb2xMaWtlKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIHNjaGVtYTogZmllbGRzLnNjaGVtYSxcbiAgICAgICAgYm91bmQ6IHJ1bm5hYmxlLFxuICAgIH0pO1xufVxuIiwgImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtOF1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwfGZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZikkL2k7IiwgImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7IiwgImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgLy9cbiAgLy8gTm90ZSB0byBmdXR1cmUtc2VsZjogTm8sIHlvdSBjYW4ndCByZW1vdmUgdGhlIGB0b0xvd2VyQ2FzZSgpYCBjYWxsLlxuICAvLyBSRUY6IGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzY3NyNpc3N1ZWNvbW1lbnQtMTc1NzM1MTM1MVxuICByZXR1cm4gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICB2YXIgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7XG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgcmV0dXJuIHV1aWQ7XG59XG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7IiwgIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxuXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKTtcbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCAidmFyIHJhbmRvbVVVSUQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRCAmJiBjcnlwdG8ucmFuZG9tVVVJRC5iaW5kKGNyeXB0byk7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSURcbn07IiwgImltcG9ydCBuYXRpdmUgZnJvbSAnLi9uYXRpdmUuanMnO1xuaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5leHBvcnQgZGVmYXVsdCB2NDsiLCAiaW1wb3J0IHBSZXRyeSBmcm9tIFwicC1yZXRyeVwiO1xuaW1wb3J0IFBRdWV1ZU1vZCBmcm9tIFwicC1xdWV1ZVwiO1xuaW1wb3J0IHsgX2dldEZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCwgLy8gQmFkIFJlcXVlc3RcbiAgICA0MDEsIC8vIFVuYXV0aG9yaXplZFxuICAgIDQwMywgLy8gRm9yYmlkZGVuXG4gICAgNDA0LCAvLyBOb3QgRm91bmRcbiAgICA0MDUsIC8vIE1ldGhvZCBOb3QgQWxsb3dlZFxuICAgIDQwNiwgLy8gTm90IEFjY2VwdGFibGVcbiAgICA0MDcsIC8vIFByb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkXG4gICAgNDA4LCAvLyBSZXF1ZXN0IFRpbWVvdXRcbl07XG5jb25zdCBTVEFUVVNfSUdOT1JFID0gW1xuICAgIDQwOSwgLy8gQ29uZmxpY3Rcbl07XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFzeW5jIGNhbGxzIHdpdGggY29uY3VycmVuY3kgYW5kIHJldHJ5IGxvZ2ljLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBtYWtpbmcgY2FsbHMgdG8gYW55IGtpbmQgb2YgXCJleHBlbnNpdmVcIiBleHRlcm5hbCByZXNvdXJjZSxcbiAqIGJlIGl0IGJlY2F1c2UgaXQncyByYXRlLWxpbWl0ZWQsIHN1YmplY3QgdG8gbmV0d29yayBpc3N1ZXMsIGV0Yy5cbiAqXG4gKiBDb25jdXJyZW50IGNhbGxzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4Q29uY3VycmVuY3lgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHNcbiAqIHRvIGBJbmZpbml0eWAuIFRoaXMgbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBhbGwgY2FsbHMgd2lsbCBiZSBtYWRlIGluIHBhcmFsbGVsLlxuICpcbiAqIFJldHJpZXMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhSZXRyaWVzYCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIDYuIFRoaXNcbiAqIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgZWFjaCBjYWxsIHdpbGwgYmUgcmV0cmllZCB1cCB0byA2IHRpbWVzLCB3aXRoIGFuXG4gKiBleHBvbmVudGlhbCBiYWNrb2ZmIGJldHdlZW4gZWFjaCBhdHRlbXB0LlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNDYWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhSZXRyaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkUmVzcG9uc2VIb29rXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwYXJhbXMubWF4Q29uY3VycmVuY3kgPz8gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IHBhcmFtcy5tYXhSZXRyaWVzID8/IDY7XG4gICAgICAgIHRoaXMuZGVidWcgPSBwYXJhbXMuZGVidWc7XG4gICAgICAgIGlmIChcImRlZmF1bHRcIiBpbiBQUXVldWVNb2QpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZU1vZC5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlTW9kKHsgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3kgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkZhaWxlZFJlc3BvbnNlSG9vayA9IHBhcmFtcz8ub25GYWlsZWRSZXNwb25zZUhvb2s7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbChjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBvbkZhaWxlZFJlc3BvbnNlSG9vayA9IHRoaXMub25GYWlsZWRSZXNwb25zZUhvb2s7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLmFkZCgoKSA9PiBwUmV0cnkoKCkgPT4gY2FsbGFibGUoLi4uYXJncykuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGFzeW5jIG9uRmFpbGVkQXR0ZW1wdChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiVGltZW91dEVycm9yXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkFib3J0RXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyb3I/LnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlPy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoU1RBVFVTX05PX1JFVFJZLmluY2x1ZGVzKCtzdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChTVEFUVVNfSUdOT1JFLmluY2x1ZGVzKCtzdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRmFpbGVkUmVzcG9uc2VIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBvbkZhaWxlZFJlc3BvbnNlSG9vayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkIHdlIGNhbiBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVmYXVsdHMgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGV5J3JlIHF1aXRlIHNlbnNpYmxlLlxuICAgICAgICAgICAgcmV0cmllczogdGhpcy5tYXhSZXRyaWVzLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICB9KSwgeyB0aHJvd09uVGltZW91dDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsV2l0aE9wdGlvbnMob3B0aW9ucywgY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gTm90ZSB0aGlzIGRvZXNuJ3QgY2FuY2VsIHRoZSB1bmRlcmx5aW5nIHJlcXVlc3QsXG4gICAgICAgIC8vIHdoZW4gYXZhaWxhYmxlIHByZWZlciB0byB1c2UgdGhlIHNpZ25hbCBvcHRpb24gb2YgdGhlIHVuZGVybHlpbmcgY2FsbFxuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyksXG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZmV0Y2goLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKCgpID0+IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpKC4uLmFyZ3MpLnRoZW4oKHJlcykgPT4gcmVzLm9rID8gcmVzIDogUHJvbWlzZS5yZWplY3QocmVzKSkpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4uL3V0aWxzL2Vudi5qc1wiO1xuLy8gV3JhcCB0aGUgZGVmYXVsdCBmZXRjaCBjYWxsIGR1ZSB0byBpc3N1ZXMgd2l0aCBpbGxlZ2FsIGludm9jYXRpb25zXG4vLyBpbiBzb21lIGVudmlyb25tZW50czpcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY5ODc2ODU5L3doeS1kb2VzLWJpbmQtZml4LWZhaWxlZC10by1leGVjdXRlLWZldGNoLW9uLXdpbmRvdy1pbGxlZ2FsLWludm9jYXRpb24tZXJyXG4vLyBAdHMtZXhwZWN0LWVycm9yIEJyb2FkIHR5cGluZyB0byBzdXBwb3J0IGEgcmFuZ2Ugb2YgZmV0Y2ggaW1wbGVtZW50YXRpb25zXG5jb25zdCBERUZBVUxUX0ZFVENIX0lNUExFTUVOVEFUSU9OID0gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xuY29uc3QgTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWSA9IFN5bWJvbC5mb3IoXCJsczpmZXRjaF9pbXBsZW1lbnRhdGlvblwiKTtcbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiB1c2VkIGZvciBMYW5nU21pdGggY2FsbHMuXG4gKiBZb3Ugc2hvdWxkIHVzZSB0aGlzIGlmIHlvdSBuZWVkIHRvIHVzZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBmZXRjaFxuICogb3RoZXIgdGhhbiB0aGUgZGVmYXVsdCBnbG9iYWwgKGUuZy4gZm9yIGRlYWxpbmcgd2l0aCBwcm94aWVzKS5cbiAqIEBwYXJhbSBmZXRjaCBUaGUgbmV3IGZldGNoIGZ1bmN0aW5vIHRvIHVzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IG92ZXJyaWRlRmV0Y2hJbXBsZW1lbnRhdGlvbiA9IChmZXRjaCkgPT4ge1xuICAgIGdsb2JhbFRoaXNbTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWV0gPSBmZXRjaDtcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgX2dldEZldGNoSW1wbGVtZW50YXRpb24gPSAoZGVidWcpID0+IHtcbiAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGRlYnVnIHx8IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJERUJVR1wiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFt1cmwsIG9wdGlvbnNdID0gYXJncztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBcdTIxOTIgJHtvcHRpb25zPy5tZXRob2QgfHwgXCJHRVRcIn0gJHt1cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgKGdsb2JhbFRoaXNbTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWV0gPz9cbiAgICAgICAgICAgIERFRkFVTFRfRkVUQ0hfSU1QTEVNRU5UQVRJT04pKC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZGVidWcgfHwgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkRFQlVHXCIpID09PSBcInRydWVcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFx1MjE5MCAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9ICR7cmVzLnVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59O1xuIiwgImV4cG9ydCBmdW5jdGlvbiBpc0xhbmdDaGFpbk1lc3NhZ2UoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubWVzc2FnZSkge1xuICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZT8uX2dldFR5cGUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShtZXNzYWdlKSB7XG4gICAgY29uc3QgY29udmVydGVkID0ge1xuICAgICAgICB0eXBlOiBtZXNzYWdlLl9nZXRUeXBlKCksXG4gICAgICAgIGRhdGE6IHsgY29udGVudDogbWVzc2FnZS5jb250ZW50IH0sXG4gICAgfTtcbiAgICAvLyBDaGVjayBmb3IgcHJlc2VuY2Ugb2Yga2V5cyBpbiBhZGRpdGlvbmFsX2t3YXJnc1xuICAgIGlmIChtZXNzYWdlPy5hZGRpdGlvbmFsX2t3YXJncyAmJlxuICAgICAgICBPYmplY3Qua2V5cyhtZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnZlcnRlZC5kYXRhLmFkZGl0aW9uYWxfa3dhcmdzID0geyAuLi5tZXNzYWdlLmFkZGl0aW9uYWxfa3dhcmdzIH07XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZWQ7XG59XG4iLCAiaW1wb3J0ICogYXMgdXVpZCBmcm9tIFwidXVpZFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFV1aWQoc3RyLCB3aGljaCkge1xuICAgIGlmICghdXVpZC52YWxpZGF0ZShzdHIpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IHdoaWNoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYEludmFsaWQgVVVJRCBmb3IgJHt3aGljaH06ICR7c3RyfWBcbiAgICAgICAgICAgIDogYEludmFsaWQgVVVJRDogJHtzdHJ9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4iLCAiY29uc3Qgd2FybmVkTWVzc2FnZXMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiB3YXJuT25jZShtZXNzYWdlKSB7XG4gICAgaWYgKCF3YXJuZWRNZXNzYWdlc1ttZXNzYWdlXSkge1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHdhcm5lZE1lc3NhZ2VzW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VWZXJzaW9uIH0gZnJvbSBcInNlbXZlclwiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsKGN1cnJlbnRfdmVyc2lvbiwgdGFyZ2V0X3ZlcnNpb24pIHtcbiAgICBjb25zdCBjdXJyZW50ID0gcGFyc2VWZXJzaW9uKGN1cnJlbnRfdmVyc2lvbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGFyc2VWZXJzaW9uKHRhcmdldF92ZXJzaW9uKTtcbiAgICBpZiAoIWN1cnJlbnQgfHwgIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZlcnNpb24gZm9ybWF0LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQuY29tcGFyZSh0YXJnZXQpID49IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQcm9tcHRJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICBpZiAoIWlkZW50aWZpZXIgfHxcbiAgICAgICAgaWRlbnRpZmllci5zcGxpdChcIi9cIikubGVuZ3RoID4gMiB8fFxuICAgICAgICBpZGVudGlmaWVyLnN0YXJ0c1dpdGgoXCIvXCIpIHx8XG4gICAgICAgIGlkZW50aWZpZXIuZW5kc1dpdGgoXCIvXCIpIHx8XG4gICAgICAgIGlkZW50aWZpZXIuc3BsaXQoXCI6XCIpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlkZW50aWZpZXIgZm9ybWF0OiAke2lkZW50aWZpZXJ9YCk7XG4gICAgfVxuICAgIGNvbnN0IFtvd25lck5hbWVQYXJ0LCBjb21taXRQYXJ0XSA9IGlkZW50aWZpZXIuc3BsaXQoXCI6XCIpO1xuICAgIGNvbnN0IGNvbW1pdCA9IGNvbW1pdFBhcnQgfHwgXCJsYXRlc3RcIjtcbiAgICBpZiAob3duZXJOYW1lUGFydC5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBuYW1lXSA9IG93bmVyTmFtZVBhcnQuc3BsaXQoXCIvXCIsIDIpO1xuICAgICAgICBpZiAoIW93bmVyIHx8ICFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW293bmVyLCBuYW1lLCBjb21taXRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFvd25lck5hbWVQYXJ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1wiLVwiLCBvd25lck5hbWVQYXJ0LCBjb21taXRdO1xuICAgIH1cbn1cbiIsICJmdW5jdGlvbiBnZXRFcnJvclN0YWNrVHJhY2UoZSkge1xuICAgIGlmICh0eXBlb2YgZSAhPT0gXCJvYmplY3RcIiB8fCBlID09IG51bGwpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIGUpIHx8IHR5cGVvZiBlLnN0YWNrICE9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBzdGFjayA9IGUuc3RhY2s7XG4gICAgY29uc3QgcHJldkxpbmUgPSBgJHtlfWA7XG4gICAgaWYgKHN0YWNrLnN0YXJ0c1dpdGgocHJldkxpbmUpKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UocHJldkxpbmUubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHN0YWNrLnN0YXJ0c1dpdGgoXCJcXG5cIikpIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByaW50RXJyb3JTdGFja1RyYWNlKGUpIHtcbiAgICBjb25zdCBzdGFjayA9IGdldEVycm9yU3RhY2tUcmFjZShlKTtcbiAgICBpZiAoc3RhY2sgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUuZXJyb3Ioc3RhY2spO1xufVxuLyoqXG4gKiBMYW5nU21pdGhDb25mbGljdEVycm9yXG4gKlxuICogUmVwcmVzZW50cyBhbiBlcnJvciB0aGF0IG9jY3VycyB3aGVuIHRoZXJlJ3MgYSBjb25mbGljdCBkdXJpbmcgYW4gb3BlcmF0aW9uLFxuICogdHlwaWNhbGx5IGNvcnJlc3BvbmRpbmcgdG8gSFRUUCA0MDkgc3RhdHVzIGNvZGUgcmVzcG9uc2VzLlxuICpcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4gYW4gYXR0ZW1wdCB0byBjcmVhdGUgb3IgbW9kaWZ5IGEgcmVzb3VyY2UgY29uZmxpY3RzXG4gKiB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByZXNvdXJjZSBvbiB0aGUgc2VydmVyLiBDb21tb24gc2NlbmFyaW9zIGluY2x1ZGU6XG4gKiAtIEF0dGVtcHRpbmcgdG8gY3JlYXRlIGEgcmVzb3VyY2UgdGhhdCBhbHJlYWR5IGV4aXN0c1xuICogLSBUcnlpbmcgdG8gdXBkYXRlIGEgcmVzb3VyY2UgdGhhdCBoYXMgYmVlbiBtb2RpZmllZCBieSBhbm90aGVyIHByb2Nlc3NcbiAqIC0gVmlvbGF0aW5nIGEgdW5pcXVlbmVzcyBjb25zdHJhaW50IGluIHRoZSBkYXRhXG4gKlxuICogQGV4dGVuZHMgRXJyb3JcbiAqXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgYXdhaXQgY3JlYXRlUHJvamVjdChcImV4aXN0aW5nUHJvamVjdFwiKTtcbiAqIH0gY2F0Y2ggKGVycm9yKSB7XG4gKiAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbmZsaWN0RXJyb3IpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkEgY29uZmxpY3Qgb2NjdXJyZWQ6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICAgIC8vIEhhbmRsZSB0aGUgY29uZmxpY3QsIGUuZy4sIGJ5IHN1Z2dlc3RpbmcgYSBkaWZmZXJlbnQgcHJvamVjdCBuYW1lXG4gKiAgIH0gZWxzZSB7XG4gKiAgICAgLy8gSGFuZGxlIG90aGVyIHR5cGVzIG9mIGVycm9yc1xuICogICB9XG4gKiB9XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBBbHdheXMgc2V0IHRvICdDb25mbGljdEVycm9yJyBmb3IgZWFzeSBpZGVudGlmaWNhdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSBEZXRhaWxlZCBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyBzZXJ2ZXIgcmVzcG9uc2VcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQwOVxuICovXG5leHBvcnQgY2xhc3MgTGFuZ1NtaXRoQ29uZmxpY3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkxhbmdTbWl0aENvbmZsaWN0RXJyb3JcIjtcbiAgICB9XG59XG4vKipcbiAqIFRocm93cyBhbiBhcHByb3ByaWF0ZSBlcnJvciBiYXNlZCBvbiB0aGUgcmVzcG9uc2Ugc3RhdHVzIGFuZCBib2R5LlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBmZXRjaCBSZXNwb25zZSBvYmplY3RcbiAqIEBwYXJhbSBjb250ZXh0IC0gQWRkaXRpb25hbCBjb250ZXh0IHRvIGluY2x1ZGUgaW4gdGhlIGVycm9yIG1lc3NhZ2UgKGUuZy4sIG9wZXJhdGlvbiBiZWluZyBwZXJmb3JtZWQpXG4gKiBAdGhyb3dzIHtMYW5nU21pdGhDb25mbGljdEVycm9yfSBXaGVuIHRoZSByZXNwb25zZSBzdGF0dXMgaXMgNDA5XG4gKiBAdGhyb3dzIHtFcnJvcn0gRm9yIGFsbCBvdGhlciBub24tb2sgcmVzcG9uc2VzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgY29udGV4dCwgY29uc3VtZSkge1xuICAgIC8vIGNvbnN1bWUgdGhlIHJlc3BvbnNlIGJvZHkgdG8gcmVsZWFzZSB0aGUgY29ubmVjdGlvblxuICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgbGV0IGVycm9yQm9keTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgaWYgKGNvbnN1bWUpIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGBGYWlsZWQgdG8gJHtjb250ZXh0fS4gUmVjZWl2ZWQgc3RhdHVzIFske3Jlc3BvbnNlLnN0YXR1c31dOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9LiBTZXJ2ZXIgcmVzcG9uc2U6ICR7ZXJyb3JCb2R5fWA7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgIHRocm93IG5ldyBMYW5nU21pdGhDb25mbGljdEVycm9yKGZ1bGxNZXNzYWdlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGZ1bGxNZXNzYWdlKTtcbn1cbiIsICIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcbnZhciBMSU1JVF9SRVBMQUNFX05PREUgPSBcIlsuLi5dXCI7XG52YXIgQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFID0geyByZXN1bHQ6IFwiW0NpcmN1bGFyXVwiIH07XG52YXIgYXJyID0gW107XG52YXIgcmVwbGFjZXJTdGFjayA9IFtdO1xuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVwdGhMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgIGVkZ2VzTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgIH07XG59XG5mdW5jdGlvbiBlbmNvZGVTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHN0cik7XG59XG4vLyBSZWd1bGFyIHN0cmluZ2lmeVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBtb3JlIGNvbXBsZXggc3RyaW5naWZ5IGlmIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgICBpZiAoIWUubWVzc2FnZT8uaW5jbHVkZXMoXCJDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OXCIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR106IExhbmdTbWl0aCByZWNlaXZlZCB1bnNlcmlhbGl6YWJsZSB2YWx1ZS5cIik7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKFwiW1Vuc2VyaWFsaXphYmxlXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR106IExhbmdTbWl0aCByZWNlaXZlZCBjaXJjdWxhciBKU09OLiBUaGlzIHdpbGwgZGVjcmVhc2UgdHJhY2VyIHBlcmZvcm1hbmNlLlwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKFwiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcocmVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRSZXBsYWNlKHJlcGxhY2UsIHZhbCwgaywgcGFyZW50KSB7XG4gICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKTtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7IHZhbHVlOiByZXBsYWNlIH0pO1xuICAgICAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmVudFtrXSA9IHJlcGxhY2U7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGRlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgfVxufVxuLy8gU3RhYmxlLXN0cmluZ2lmeVxuZnVuY3Rpb24gY29tcGFyZUZ1bmN0aW9uKGEsIGIpIHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKCk7XG4gICAgfVxuICAgIHZhciB0bXAgPSBkZXRlcm1pbmlzdGljRGVjaXJjKG9iaiwgXCJcIiwgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucykgfHwgb2JqO1xuICAgIHZhciByZXM7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXCJbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdXCIpO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgcmVzdG9yZSB0aGUgb2JqZWN0IGFzIGl0IHdhcy5cbiAgICAgICAgd2hpbGUgKGFyci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gYXJyLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNEZWNpcmModmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gICAgZGVwdGggKz0gMTtcbiAgICB2YXIgaTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICAgICAgICAgIHNldFJlcGxhY2UoQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbC50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdCkge1xuICAgICAgICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgZWRnZUluZGV4ICsgMSA+IG9wdGlvbnMuZWRnZXNMaW1pdCkge1xuICAgICAgICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHZhbCk7XG4gICAgICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBvYmplY3QgaW4gdGhlIHJlcXVpcmVkIHdheVxuICAgICAgICAgICAgdmFyIHRtcCA9IHt9O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdG1wW2tleV0gPSB2YWxba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgICAgICAgICAgICAgcGFyZW50W2tdID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICB9XG59XG4vLyB3cmFwcyByZXBsYWNlciBmdW5jdGlvbiB0byBoYW5kbGUgdmFsdWVzIHdlIGNvdWxkbid0IHJlcGxhY2Vcbi8vIGFuZCBtYXJrIHRoZW0gYXMgcmVwbGFjZWQgdmFsdWVcbmZ1bmN0aW9uIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpIHtcbiAgICByZXBsYWNlciA9XG4gICAgICAgIHR5cGVvZiByZXBsYWNlciAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgPyByZXBsYWNlclxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcmVwbGFjZXJTdGFja1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydFsxXSA9PT0ga2V5ICYmIHBhcnRbMF0gPT09IHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJ0WzJdO1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlclN0YWNrLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsKTtcbiAgICB9O1xufVxuIiwgImltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSwgaXNMYW5nQ2hhaW5NZXNzYWdlLCB9IGZyb20gXCIuL3V0aWxzL21lc3NhZ2VzLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRMYW5nQ2hhaW5FbnZWYXJzTWV0YWRhdGEsIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCwgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IF9fdmVyc2lvbl9fIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydFV1aWQgfSBmcm9tIFwiLi91dGlscy9fdXVpZC5qc1wiO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tIFwiLi91dGlscy93YXJuLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVByb21wdElkZW50aWZpZXIgfSBmcm9tIFwiLi91dGlscy9wcm9tcHRzLmpzXCI7XG5pbXBvcnQgeyByYWlzZUZvclN0YXR1cyB9IGZyb20gXCIuL3V0aWxzL2Vycm9yLmpzXCI7XG5pbXBvcnQgeyBfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiB9IGZyb20gXCIuL3NpbmdsZXRvbnMvZmV0Y2guanNcIjtcbmltcG9ydCB7IHNlcmlhbGl6ZSBhcyBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyB9IGZyb20gXCIuL3V0aWxzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlKHJ1bikge1xuICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICBjb25zdCBlbnZWYXJzID0gZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhKCk7XG4gICAgY29uc3QgZXh0cmEgPSBydW4uZXh0cmEgPz8ge307XG4gICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYS5tZXRhZGF0YTtcbiAgICBydW4uZXh0cmEgPSB7XG4gICAgICAgIC4uLmV4dHJhLFxuICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAuLi5ydW50aW1lRW52LFxuICAgICAgICAgICAgLi4uZXh0cmE/LnJ1bnRpbWUsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAuLi5lbnZWYXJzLFxuICAgICAgICAgICAgLi4uKGVudlZhcnMucmV2aXNpb25faWQgfHwgcnVuLnJldmlzaW9uX2lkXG4gICAgICAgICAgICAgICAgPyB7IHJldmlzaW9uX2lkOiBydW4ucmV2aXNpb25faWQgPz8gZW52VmFycy5yZXZpc2lvbl9pZCB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBydW47XG59XG5jb25zdCBnZXRUcmFjaW5nU2FtcGxpbmdSYXRlID0gKGNvbmZpZ1JhdGUpID0+IHtcbiAgICBjb25zdCBzYW1wbGluZ1JhdGVTdHIgPSBjb25maWdSYXRlPy50b1N0cmluZygpID8/XG4gICAgICAgIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJUUkFDSU5HX1NBTVBMSU5HX1JBVEVcIik7XG4gICAgaWYgKHNhbXBsaW5nUmF0ZVN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNhbXBsaW5nUmF0ZSA9IHBhcnNlRmxvYXQoc2FtcGxpbmdSYXRlU3RyKTtcbiAgICBpZiAoc2FtcGxpbmdSYXRlIDwgMCB8fCBzYW1wbGluZ1JhdGUgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTEFOR1NNSVRIX1RSQUNJTkdfU0FNUExJTkdfUkFURSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSBpZiBzZXQuIEdvdDogJHtzYW1wbGluZ1JhdGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBzYW1wbGluZ1JhdGU7XG59O1xuLy8gdXRpbGl0eSBmdW5jdGlvbnNcbmNvbnN0IGlzTG9jYWxob3N0ID0gKHVybCkgPT4ge1xuICAgIGNvbnN0IHN0cmlwcGVkVXJsID0gdXJsLnJlcGxhY2UoXCJodHRwOi8vXCIsIFwiXCIpLnJlcGxhY2UoXCJodHRwczovL1wiLCBcIlwiKTtcbiAgICBjb25zdCBob3N0bmFtZSA9IHN0cmlwcGVkVXJsLnNwbGl0KFwiL1wiKVswXS5zcGxpdChcIjpcIilbMF07XG4gICAgcmV0dXJuIChob3N0bmFtZSA9PT0gXCJsb2NhbGhvc3RcIiB8fCBob3N0bmFtZSA9PT0gXCIxMjcuMC4wLjFcIiB8fCBob3N0bmFtZSA9PT0gXCI6OjFcIik7XG59O1xuYXN5bmMgZnVuY3Rpb24gdG9BcnJheShpdGVyYWJsZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRyaW1RdW90ZXMoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvXlwiKC4qKVwiJC8sIFwiJDFcIilcbiAgICAgICAgLnJlcGxhY2UoL14nKC4qKSckLywgXCIkMVwiKTtcbn1cbmNvbnN0IGhhbmRsZTQyOSA9IGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgIGlmIChyZXNwb25zZT8uc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwicmV0cnktYWZ0ZXJcIikgPz8gXCIzMFwiLCAxMCkgKiAxMDAwO1xuICAgICAgICBpZiAocmV0cnlBZnRlciA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5QWZ0ZXIpKTtcbiAgICAgICAgICAgIC8vIFJldHVybiBkaXJlY3RseSBhZnRlciBjYWxsaW5nIHRoaXMgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGwgYmFjayB0byBleGlzdGluZyBzdGF0dXMgY2hlY2tzXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIF9mb3JtYXRGZWVkYmFja1Njb3JlKHNjb3JlKSB7XG4gICAgaWYgKHR5cGVvZiBzY29yZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvLyBUcnVuY2F0ZSBhdCA0IGRlY2ltYWwgcGxhY2VzXG4gICAgICAgIHJldHVybiBOdW1iZXIoc2NvcmUudG9GaXhlZCg0KSk7XG4gICAgfVxuICAgIHJldHVybiBzY29yZTtcbn1cbmV4cG9ydCBjbGFzcyBBdXRvQmF0Y2hRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIml0ZW1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2l6ZUJ5dGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1swXTtcbiAgICB9XG4gICAgcHVzaChpdGVtKSB7XG4gICAgICAgIGxldCBpdGVtUHJvbWlzZVJlc29sdmU7XG4gICAgICAgIGNvbnN0IGl0ZW1Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgaXRlbVByb21pc2VSZXNvbHZlIGlzIHN5bmNocm9ub3VzIHdpdGggcHJvbWlzZSBjcmVhdGlvbjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UvUHJvbWlzZVxuICAgICAgICAgICAgaXRlbVByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhpdGVtLml0ZW0pLmxlbmd0aDtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIGFjdGlvbjogaXRlbS5hY3Rpb24sXG4gICAgICAgICAgICBwYXlsb2FkOiBpdGVtLml0ZW0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgaXRlbVByb21pc2VSZXNvbHZlOiBpdGVtUHJvbWlzZVJlc29sdmUsXG4gICAgICAgICAgICBpdGVtUHJvbWlzZSxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpemVCeXRlcyArPSBzaXplO1xuICAgICAgICByZXR1cm4gaXRlbVByb21pc2U7XG4gICAgfVxuICAgIHBvcCh1cFRvU2l6ZUJ5dGVzKSB7XG4gICAgICAgIGlmICh1cFRvU2l6ZUJ5dGVzIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIG9mIGJ5dGVzIHRvIHBvcCBvZmYgbWF5IG5vdCBiZSBsZXNzIHRoYW4gMS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9wcGVkID0gW107XG4gICAgICAgIGxldCBwb3BwZWRTaXplQnl0ZXMgPSAwO1xuICAgICAgICAvLyBQb3AgaXRlbXMgdW50aWwgd2UgcmVhY2ggb3IgZXhjZWVkIHRoZSBzaXplIGxpbWl0XG4gICAgICAgIHdoaWxlIChwb3BwZWRTaXplQnl0ZXMgKyAodGhpcy5wZWVrKCk/LnNpemUgPz8gMCkgPCB1cFRvU2l6ZUJ5dGVzICYmXG4gICAgICAgICAgICB0aGlzLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHBvcHBlZC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHBvcHBlZFNpemVCeXRlcyArPSBpdGVtLnNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplQnl0ZXMgLT0gaXRlbS5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gb24gdGhlIHF1ZXVlIHdlIHdlcmUgdW5hYmxlIHRvIHBvcCxcbiAgICAgICAgLy8ganVzdCByZXR1cm4gaXQgYXMgYSBzaW5nbGUgYmF0Y2guXG4gICAgICAgIGlmIChwb3BwZWQubGVuZ3RoID09PSAwICYmIHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHBvcHBlZC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcG9wcGVkU2l6ZUJ5dGVzICs9IGl0ZW0uc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZUJ5dGVzIC09IGl0ZW0uc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcG9wcGVkLm1hcCgoaXQpID0+ICh7IGFjdGlvbjogaXQuYWN0aW9uLCBpdGVtOiBpdC5wYXlsb2FkIH0pKSxcbiAgICAgICAgICAgICgpID0+IHBvcHBlZC5mb3JFYWNoKChpdCkgPT4gaXQuaXRlbVByb21pc2VSZXNvbHZlKCkpLFxuICAgICAgICBdO1xuICAgIH1cbn1cbi8vIDIwIE1CXG5leHBvcnQgY29uc3QgREVGQVVMVF9CQVRDSF9TSVpFX0xJTUlUX0JZVEVTID0gMjBfOTcxXzUyMDtcbmNvbnN0IFNFUlZFUl9JTkZPX1JFUVVFU1RfVElNRU9VVCA9IDI1MDA7XG5leHBvcnQgY2xhc3MgQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndlYlVybFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hJbmdlc3RDYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGltZW91dF9tc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGVuYW50SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhpZGVJbnB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlkZU91dHB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2luZ1NhbXBsZVJhdGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmlsdGVyZWRQb3N0VXVpZHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBTZXQoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoVHJhY2luZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoUXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBBdXRvQmF0Y2hRdWV1ZSgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hUaW1lb3V0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaEFnZ3JlZ2F0aW9uRGVsYXlNc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMjUwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaFNpemVCeXRlc0xpbWl0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZldGNoT3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXR0aW5nc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdTTUlUSF9UUkFDSU5HX0JBQ0tHUk9VTkRcIikgPT09IFwiZmFsc2VcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2VCYXRjaENvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA1XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2VydmVySW5mb1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZ2V0U2VydmVySW5mb1Byb21pc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWFudWFsRmx1c2hNb2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVidWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HU01JVEhfREVCVUdcIikgPT09IFwidHJ1ZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gQ2xpZW50LmdldERlZmF1bHRDbGllbnRDb25maWcoKTtcbiAgICAgICAgdGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUoY29uZmlnLnRyYWNpbmdTYW1wbGluZ1JhdGUpO1xuICAgICAgICB0aGlzLmFwaVVybCA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaVVybCA/PyBkZWZhdWx0Q29uZmlnLmFwaVVybCkgPz8gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuYXBpVXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgdGhpcy5hcGlVcmwgPSB0aGlzLmFwaVVybC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlLZXkgPSB0cmltUXVvdGVzKGNvbmZpZy5hcGlLZXkgPz8gZGVmYXVsdENvbmZpZy5hcGlLZXkpO1xuICAgICAgICB0aGlzLndlYlVybCA9IHRyaW1RdW90ZXMoY29uZmlnLndlYlVybCA/PyBkZWZhdWx0Q29uZmlnLndlYlVybCk7XG4gICAgICAgIGlmICh0aGlzLndlYlVybD8uZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IHRoaXMud2ViVXJsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVvdXRfbXMgPSBjb25maWcudGltZW91dF9tcyA/PyA5MF8wMDA7XG4gICAgICAgIHRoaXMuY2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKHtcbiAgICAgICAgICAgIC4uLihjb25maWcuY2FsbGVyT3B0aW9ucyA/PyB7fSksXG4gICAgICAgICAgICBkZWJ1ZzogY29uZmlnLmRlYnVnID8/IHRoaXMuZGVidWcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYWNlQmF0Y2hDb25jdXJyZW5jeSA9XG4gICAgICAgICAgICBjb25maWcudHJhY2VCYXRjaENvbmN1cnJlbmN5ID8/IHRoaXMudHJhY2VCYXRjaENvbmN1cnJlbmN5O1xuICAgICAgICBpZiAodGhpcy50cmFjZUJhdGNoQ29uY3VycmVuY3kgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFjZSBiYXRjaCBjb25jdXJyZW5jeSBtdXN0IGJlIHBvc2l0aXZlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnID0gY29uZmlnLmRlYnVnID8/IHRoaXMuZGVidWc7XG4gICAgICAgIHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgbWF4UmV0cmllczogMixcbiAgICAgICAgICAgIG1heENvbmN1cnJlbmN5OiB0aGlzLnRyYWNlQmF0Y2hDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIC4uLihjb25maWcuY2FsbGVyT3B0aW9ucyA/PyB7fSksXG4gICAgICAgICAgICBvbkZhaWxlZFJlc3BvbnNlSG9vazogaGFuZGxlNDI5LFxuICAgICAgICAgICAgZGVidWc6IGNvbmZpZy5kZWJ1ZyA/PyB0aGlzLmRlYnVnLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oaWRlSW5wdXRzID1cbiAgICAgICAgICAgIGNvbmZpZy5oaWRlSW5wdXRzID8/IGNvbmZpZy5hbm9ueW1pemVyID8/IGRlZmF1bHRDb25maWcuaGlkZUlucHV0cztcbiAgICAgICAgdGhpcy5oaWRlT3V0cHV0cyA9XG4gICAgICAgICAgICBjb25maWcuaGlkZU91dHB1dHMgPz8gY29uZmlnLmFub255bWl6ZXIgPz8gZGVmYXVsdENvbmZpZy5oaWRlT3V0cHV0cztcbiAgICAgICAgdGhpcy5hdXRvQmF0Y2hUcmFjaW5nID0gY29uZmlnLmF1dG9CYXRjaFRyYWNpbmcgPz8gdGhpcy5hdXRvQmF0Y2hUcmFjaW5nO1xuICAgICAgICB0aGlzLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uID1cbiAgICAgICAgICAgIGNvbmZpZy5ibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbiA/PyB0aGlzLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZUJ5dGVzTGltaXQgPSBjb25maWcuYmF0Y2hTaXplQnl0ZXNMaW1pdDtcbiAgICAgICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBjb25maWcuZmV0Y2hPcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm1hbnVhbEZsdXNoTW9kZSA9IGNvbmZpZy5tYW51YWxGbHVzaE1vZGUgPz8gdGhpcy5tYW51YWxGbHVzaE1vZGU7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q2xpZW50Q29uZmlnKCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiQVBJX0tFWVwiKTtcbiAgICAgICAgY29uc3QgYXBpVXJsID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkVORFBPSU5UXCIpID8/XG4gICAgICAgICAgICBcImh0dHBzOi8vYXBpLnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgY29uc3QgaGlkZUlucHV0cyA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJISURFX0lOUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGNvbnN0IGhpZGVPdXRwdXRzID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkhJREVfT1VUUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcGlVcmw6IGFwaVVybCxcbiAgICAgICAgICAgIGFwaUtleTogYXBpS2V5LFxuICAgICAgICAgICAgd2ViVXJsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoaWRlSW5wdXRzOiBoaWRlSW5wdXRzLFxuICAgICAgICAgICAgaGlkZU91dHB1dHM6IGhpZGVPdXRwdXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRIb3N0VXJsKCkge1xuICAgICAgICBpZiAodGhpcy53ZWJVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xvY2FsaG9zdCh0aGlzLmFwaVVybCkpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjMwMDBcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5lbmRzV2l0aChcIi9hcGkvdjFcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gdGhpcy5hcGlVcmwucmVwbGFjZShcIi9hcGkvdjFcIiwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuaW5jbHVkZXMoXCIvYXBpXCIpICYmXG4gICAgICAgICAgICAhdGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmVuZHNXaXRoKFwiYXBpXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IHRoaXMuYXBpVXJsLnJlcGxhY2UoXCIvYXBpXCIsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5pbmNsdWRlcyhcImRldlwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vZGV2LnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uaW5jbHVkZXMoXCJldVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vZXUuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5pbmNsdWRlcyhcImJldGFcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL2JldGEuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJVc2VyLUFnZW50XCI6IGBsYW5nc21pdGgtanMvJHtfX3ZlcnNpb25fX31gLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBgJHt0aGlzLmFwaUtleX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzSW5wdXRzKGlucHV0cykge1xuICAgICAgICBpZiAodGhpcy5oaWRlSW5wdXRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWRlSW5wdXRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmhpZGVJbnB1dHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZUlucHV0cyhpbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NPdXRwdXRzKG91dHB1dHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZU91dHB1dHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWRlT3V0cHV0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5oaWRlT3V0cHV0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlT3V0cHV0cyhvdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgYXN5bmMgcHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHJ1bikge1xuICAgICAgICBjb25zdCBydW5QYXJhbXMgPSB7IC4uLnJ1biB9O1xuICAgICAgICBpZiAocnVuUGFyYW1zLmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5QYXJhbXMuaW5wdXRzID0gYXdhaXQgdGhpcy5wcm9jZXNzSW5wdXRzKHJ1blBhcmFtcy5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5QYXJhbXMub3V0cHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW5QYXJhbXMub3V0cHV0cyA9IGF3YWl0IHRoaXMucHJvY2Vzc091dHB1dHMocnVuUGFyYW1zLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5QYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRSZXNwb25zZShwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCBwYXJhbXNTdHJpbmcgPSBxdWVyeVBhcmFtcz8udG9TdHJpbmcoKSA/PyBcIlwiO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zU3RyaW5nfWA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgdXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBGYWlsZWQgdG8gZmV0Y2ggJHtwYXRofWApO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9nZXQocGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXRSZXNwb25zZShwYXRoLCBxdWVyeVBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0UGFnaW5hdGVkKHBhdGgsIHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJvZmZzZXRcIikpIHx8IDA7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gTnVtYmVyKHF1ZXJ5UGFyYW1zLmdldChcImxpbWl0XCIpKSB8fCAxMDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoXCJvZmZzZXRcIiwgU3RyaW5nKG9mZnNldCkpO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwibGltaXRcIiwgU3RyaW5nKGxpbWl0KSk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cXVlcnlQYXJhbXN9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgdXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBGYWlsZWQgdG8gZmV0Y2ggJHtwYXRofWApO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybShhd2FpdCByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAgICAgOiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBpdGVtcztcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX2dldEN1cnNvclBhZ2luYXRlZExpc3QocGF0aCwgYm9keSA9IG51bGwsIHJlcXVlc3RNZXRob2QgPSBcIlBPU1RcIiwgZGF0YUtleSA9IFwicnVuc1wiKSB7XG4gICAgICAgIGNvbnN0IGJvZHlQYXJhbXMgPSBib2R5ID8geyAuLi5ib2R5IH0gOiB7fTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9JHtwYXRofWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3RNZXRob2QsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keVBhcmFtcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlQm9keVtkYXRhS2V5XSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgcmVzcG9uc2VCb2R5W2RhdGFLZXldO1xuICAgICAgICAgICAgY29uc3QgY3Vyc29ycyA9IHJlc3BvbnNlQm9keS5jdXJzb3JzO1xuICAgICAgICAgICAgaWYgKCFjdXJzb3JzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1cnNvcnMubmV4dCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keVBhcmFtcy5jdXJzb3IgPSBjdXJzb3JzLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWxsb3dzIG1vY2tpbmcgZm9yIHRlc3RzXG4gICAgX3Nob3VsZFNhbXBsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2luZ1NhbXBsZVJhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlO1xuICAgIH1cbiAgICBfZmlsdGVyRm9yU2FtcGxpbmcocnVucywgcGF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVucztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuIG9mIHJ1bnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuaGFzKHJ1bi5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmVkUG9zdFV1aWRzLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG5ldyBydW5zLCBzYW1wbGUgYXQgdHJhY2UgbGV2ZWwgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3lcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuIG9mIHJ1bnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gcnVuLnRyYWNlX2lkID8/IHJ1bi5pZDtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IG1hZGUgYSBkZWNpc2lvbiBhYm91dCB0aGlzIHRyYWNlLCBmb2xsb3cgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5oYXModHJhY2VJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvciBuZXcgdHJhY2VzLCBhcHBseSBzYW1wbGluZ1xuICAgICAgICAgICAgICAgIGlmIChydW4uaWQgPT09IHRyYWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFNhbXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVkLnB1c2gocnVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuYWRkKHRyYWNlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGlsZCBydW5zIGZvbGxvdyB0aGVpciB0cmFjZSdzIHNhbXBsaW5nIGRlY2lzaW9uXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9nZXRCYXRjaFNpemVMaW1pdEJ5dGVzKCkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICByZXR1cm4gKHRoaXMuYmF0Y2hTaXplQnl0ZXNMaW1pdCA/P1xuICAgICAgICAgICAgc2VydmVySW5mby5iYXRjaF9pbmdlc3RfY29uZmlnPy5zaXplX2xpbWl0X2J5dGVzID8/XG4gICAgICAgICAgICBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVMpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0TXVsdGlQYXJ0U3VwcG9ydCgpIHtcbiAgICAgICAgY29uc3Qgc2VydmVySW5mbyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVNlcnZlckluZm8oKTtcbiAgICAgICAgcmV0dXJuIChzZXJ2ZXJJbmZvLmluc3RhbmNlX2ZsYWdzPy5kYXRhc2V0X2V4YW1wbGVzX211bHRpcGFydF9lbmFibGVkID8/IGZhbHNlKTtcbiAgICB9XG4gICAgZHJhaW5BdXRvQmF0Y2hRdWV1ZShiYXRjaFNpemVMaW1pdCkge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5hdXRvQmF0Y2hRdWV1ZS5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBbYmF0Y2gsIGRvbmVdID0gdGhpcy5hdXRvQmF0Y2hRdWV1ZS5wb3AoYmF0Y2hTaXplTGltaXQpO1xuICAgICAgICAgICAgaWYgKCFiYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYXRjaFByb21pc2UgPSB0aGlzLl9wcm9jZXNzQmF0Y2goYmF0Y2gsIGRvbmUpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChiYXRjaFByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfVxuICAgIGFzeW5jIF9wcm9jZXNzQmF0Y2goYmF0Y2gsIGRvbmUpIHtcbiAgICAgICAgaWYgKCFiYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5nZXN0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHJ1bkNyZWF0ZXM6IGJhdGNoXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcImNyZWF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PiBpdGVtLml0ZW0pLFxuICAgICAgICAgICAgICAgIHJ1blVwZGF0ZXM6IGJhdGNoXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcInVwZGF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PiBpdGVtLml0ZW0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9lbnN1cmVTZXJ2ZXJJbmZvKCk7XG4gICAgICAgICAgICBpZiAoc2VydmVySW5mbz8uYmF0Y2hfaW5nZXN0X2NvbmZpZz8udXNlX211bHRpcGFydF9lbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubXVsdGlwYXJ0SW5nZXN0UnVucyhpbmdlc3RQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5iYXRjaEluZ2VzdFJ1bnMoaW5nZXN0UGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzUnVuT3BlcmF0aW9uKGl0ZW0pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYXV0b0JhdGNoVGltZW91dCk7XG4gICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGl0ZW0uYWN0aW9uID09PSBcImNyZWF0ZVwiKSB7XG4gICAgICAgICAgICBpdGVtLml0ZW0gPSBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlKGl0ZW0uaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbVByb21pc2UgPSB0aGlzLmF1dG9CYXRjaFF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgIGlmICh0aGlzLm1hbnVhbEZsdXNoTW9kZSkge1xuICAgICAgICAgICAgLy8gUmVseSBvbiBtYW51YWwgZmx1c2hpbmcgaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplTGltaXRCeXRlcyA9IGF3YWl0IHRoaXMuX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoUXVldWUuc2l6ZUJ5dGVzID4gc2l6ZUxpbWl0Qnl0ZXMpIHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5kcmFpbkF1dG9CYXRjaFF1ZXVlKHNpemVMaW1pdEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hRdWV1ZS5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLmRyYWluQXV0b0JhdGNoUXVldWUoc2l6ZUxpbWl0Qnl0ZXMpO1xuICAgICAgICAgICAgfSwgdGhpcy5hdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFNlcnZlckluZm8oKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZykoYCR7dGhpcy5hcGlVcmx9L2luZm9gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dChTRVJWRVJfSU5GT19SRVFVRVNUX1RJTUVPVVQpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJnZXQgc2VydmVyIGluZm9cIik7XG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlxcbj09PSBMYW5nU21pdGggU2VydmVyIENvbmZpZ3VyYXRpb24gPT09XFxuXCIgK1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIDIpICtcbiAgICAgICAgICAgICAgICBcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgYXN5bmMgX2Vuc3VyZVNlcnZlckluZm8oKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlcnZlckluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VydmVySW5mbyA9IGF3YWl0IHRoaXMuX2dldFNlcnZlckluZm8oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbV0FSTklOR106IExhbmdTbWl0aCBmYWlsZWQgdG8gZmV0Y2ggaW5mbyBvbiBzdXBwb3J0ZWQgb3BlcmF0aW9ucy4gRmFsbGluZyBiYWNrIHRvIGJhdGNoIG9wZXJhdGlvbnMgYW5kIGRlZmF1bHQgbGltaXRzLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJJbmZvID8/IHt9O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UudGhlbigoc2VydmVySW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlcnZlckluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldFNlcnZlckluZm9Qcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlckluZm87XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHRoaXMuX2dldChcIi9zZXR0aW5nc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXR0aW5ncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBjdXJyZW50IHF1ZXVlZCB0cmFjZXMuXG4gICAgICovXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIGNvbnN0IHNpemVMaW1pdEJ5dGVzID0gYXdhaXQgdGhpcy5fZ2V0QmF0Y2hTaXplTGltaXRCeXRlcygpO1xuICAgICAgICBhd2FpdCB0aGlzLmRyYWluQXV0b0JhdGNoUXVldWUoc2l6ZUxpbWl0Qnl0ZXMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVSdW4ocnVuKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcoW3J1bl0pLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbl9uYW1lID0gcnVuLnByb2plY3RfbmFtZTtcbiAgICAgICAgZGVsZXRlIHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IGF3YWl0IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHtcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZSxcbiAgICAgICAgICAgIC4uLnJ1bixcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHJ1bi5zdGFydF90aW1lID8/IERhdGUubm93KCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hUcmFjaW5nICYmXG4gICAgICAgICAgICBydW5DcmVhdGUudHJhY2VfaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcnVuQ3JlYXRlLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgICAgIGl0ZW06IHJ1bkNyZWF0ZSxcbiAgICAgICAgICAgIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lcmdlZFJ1bkNyZWF0ZVBhcmFtID0gbWVyZ2VSdW50aW1lRW52SW50b1J1bkNyZWF0ZShydW5DcmVhdGUpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9ydW5zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhtZXJnZWRSdW5DcmVhdGVQYXJhbSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIHJ1blwiLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmF0Y2ggaW5nZXN0L3Vwc2VydCBtdWx0aXBsZSBydW5zIGluIHRoZSBMYW5nc21pdGggc3lzdGVtLlxuICAgICAqIEBwYXJhbSBydW5zXG4gICAgICovXG4gICAgYXN5bmMgYmF0Y2hJbmdlc3RSdW5zKHsgcnVuQ3JlYXRlcywgcnVuVXBkYXRlcywgfSkge1xuICAgICAgICBpZiAocnVuQ3JlYXRlcyA9PT0gdW5kZWZpbmVkICYmIHJ1blVwZGF0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IGF3YWl0IFByb21pc2UuYWxsKHJ1bkNyZWF0ZXM/Lm1hcCgoY3JlYXRlKSA9PiB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyhjcmVhdGUpKSA/PyBbXSk7XG4gICAgICAgIGxldCBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IGF3YWl0IFByb21pc2UuYWxsKHJ1blVwZGF0ZXM/Lm1hcCgodXBkYXRlKSA9PiB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh1cGRhdGUpKSA/PyBbXSk7XG4gICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZVBhcmFtcy5sZW5ndGggPiAwICYmIHByZXBhcmVkVXBkYXRlUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJ5SWQgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5yZWR1Y2UoKHBhcmFtcywgcnVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zW3J1bi5pZF0gPSBydW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYWxvbmVVcGRhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZVBhcmFtIG9mIHByZXBhcmVkVXBkYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQgJiYgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZVBhcmFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhbG9uZVVwZGF0ZXMucHVzaCh1cGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBPYmplY3QudmFsdWVzKGNyZWF0ZUJ5SWQpO1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBzdGFuZGFsb25lVXBkYXRlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdCYXRjaCA9IHtcbiAgICAgICAgICAgIHBvc3Q6IHByZXBhcmVkQ3JlYXRlUGFyYW1zLFxuICAgICAgICAgICAgcGF0Y2g6IHByZXBhcmVkVXBkYXRlUGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXJhd0JhdGNoLnBvc3QubGVuZ3RoICYmICFyYXdCYXRjaC5wYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXRjaENodW5rcyA9IHtcbiAgICAgICAgICAgIHBvc3Q6IFtdLFxuICAgICAgICAgICAgcGF0Y2g6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgW1wicG9zdFwiLCBcInBhdGNoXCJdKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hJdGVtcyA9IHJhd0JhdGNoW2tleV0ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbGV0IGJhdGNoSXRlbSA9IGJhdGNoSXRlbXMucG9wKCk7XG4gICAgICAgICAgICB3aGlsZSAoYmF0Y2hJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlIGlzIHdyb25nIGJ1dCB0aGlzIGlzIGEgZGVwcmVjYXRlZCBjb2RlIHBhdGggYW55d2F5XG4gICAgICAgICAgICAgICAgYmF0Y2hDaHVua3Nba2V5XS5wdXNoKGJhdGNoSXRlbSk7XG4gICAgICAgICAgICAgICAgYmF0Y2hJdGVtID0gYmF0Y2hJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmF0Y2hDaHVua3MucG9zdC5sZW5ndGggPiAwIHx8IGJhdGNoQ2h1bmtzLnBhdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Bvc3RCYXRjaEluZ2VzdFJ1bnMoc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoYmF0Y2hDaHVua3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcG9zdEJhdGNoSW5nZXN0UnVucyhib2R5KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5iYXRjaEluZ2VzdENhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vcnVucy9iYXRjaGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJiYXRjaCBjcmVhdGUgcnVuXCIsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCBpbmdlc3QvdXBzZXJ0IG11bHRpcGxlIHJ1bnMgaW4gdGhlIExhbmdzbWl0aCBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHJ1bnNcbiAgICAgKi9cbiAgICBhc3luYyBtdWx0aXBhcnRJbmdlc3RSdW5zKHsgcnVuQ3JlYXRlcywgcnVuVXBkYXRlcywgfSkge1xuICAgICAgICBpZiAocnVuQ3JlYXRlcyA9PT0gdW5kZWZpbmVkICYmIHJ1blVwZGF0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYW5zZm9ybSBhbmQgY29udmVydCB0byBkaWN0c1xuICAgICAgICBjb25zdCBhbGxBdHRhY2htZW50cyA9IHt9O1xuICAgICAgICBsZXQgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjcmVhdGUgb2YgcnVuQ3JlYXRlcyA/PyBbXSkge1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRDcmVhdGUgPSBhd2FpdCB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyhjcmVhdGUpO1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlLmlkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBwcmVwYXJlZENyZWF0ZS5hdHRhY2htZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWxsQXR0YWNobWVudHNbcHJlcGFyZWRDcmVhdGUuaWRdID0gcHJlcGFyZWRDcmVhdGUuYXR0YWNobWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgcHJlcGFyZWRDcmVhdGUuYXR0YWNobWVudHM7XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcy5wdXNoKHByZXBhcmVkQ3JlYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB1cGRhdGUgb2YgcnVuVXBkYXRlcyA/PyBbXSkge1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMucHVzaChhd2FpdCB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh1cGRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXF1aXJlIHRyYWNlX2lkIGFuZCBkb3R0ZWRfb3JkZXJcbiAgICAgICAgY29uc3QgaW52YWxpZFJ1bkNyZWF0ZSA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLmZpbmQoKHJ1bkNyZWF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChydW5DcmVhdGUudHJhY2VfaWQgPT09IHVuZGVmaW5lZCB8fCBydW5DcmVhdGUuZG90dGVkX29yZGVyID09PSB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludmFsaWRSdW5DcmVhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBhcnQgaW5nZXN0IHJlcXVpcmVzIFwidHJhY2VfaWRcIiBhbmQgXCJkb3R0ZWRfb3JkZXJcIiB0byBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIHJ1bmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludmFsaWRSdW5VcGRhdGUgPSBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5maW5kKChydW5VcGRhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocnVuVXBkYXRlLnRyYWNlX2lkID09PSB1bmRlZmluZWQgfHwgcnVuVXBkYXRlLmRvdHRlZF9vcmRlciA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnZhbGlkUnVuVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwYXJ0IGluZ2VzdCByZXF1aXJlcyBcInRyYWNlX2lkXCIgYW5kIFwiZG90dGVkX29yZGVyXCIgdG8gYmUgc2V0IHdoZW4gdXBkYXRpbmcgYSBydW5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21iaW5lIHBvc3QgYW5kIHBhdGNoIGRpY3RzIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZVBhcmFtcy5sZW5ndGggPiAwICYmIHByZXBhcmVkVXBkYXRlUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJ5SWQgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5yZWR1Y2UoKHBhcmFtcywgcnVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zW3J1bi5pZF0gPSBydW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYWxvbmVVcGRhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZVBhcmFtIG9mIHByZXBhcmVkVXBkYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQgJiYgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZVBhcmFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhbG9uZVVwZGF0ZXMucHVzaCh1cGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBPYmplY3QudmFsdWVzKGNyZWF0ZUJ5SWQpO1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBzdGFuZGFsb25lVXBkYXRlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlcGFyZWRDcmVhdGVQYXJhbXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZW5kIHRoZSBydW5zIGluIG11bHRpcGFydCByZXF1ZXN0c1xuICAgICAgICBjb25zdCBhY2N1bXVsYXRlZENvbnRleHQgPSBbXTtcbiAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFttZXRob2QsIHBheWxvYWRzXSBvZiBbXG4gICAgICAgICAgICBbXCJwb3N0XCIsIHByZXBhcmVkQ3JlYXRlUGFyYW1zXSxcbiAgICAgICAgICAgIFtcInBhdGNoXCIsIHByZXBhcmVkVXBkYXRlUGFyYW1zXSxcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcmlnaW5hbFBheWxvYWQgb2YgcGF5bG9hZHMpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IGZpZWxkcyB0byBiZSBzZW50IGFzIHNlcGFyYXRlIHBhcnRzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbnB1dHMsIG91dHB1dHMsIGV2ZW50cywgYXR0YWNobWVudHMsIC4uLnBheWxvYWQgfSA9IG9yaWdpbmFsUGF5bG9hZDtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSB7IGlucHV0cywgb3V0cHV0cywgZXZlbnRzIH07XG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlIHRoZSBtYWluIHJ1biBwYXlsb2FkXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRQYXlsb2FkID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYCR7bWV0aG9kfS4ke3BheWxvYWQuaWR9YCxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbmV3IEJsb2IoW3N0cmluZ2lmaWVkUGF5bG9hZF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGBhcHBsaWNhdGlvbi9qc29uOyBsZW5ndGg9JHtzdHJpbmdpZmllZFBheWxvYWQubGVuZ3RofWAsIC8vIGVuY29kaW5nPWd6aXBcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlIHRoZSBmaWVsZHMgd2UgY29sbGVjdGVkXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRWYWx1ZSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGAke21ldGhvZH0uJHtwYXlsb2FkLmlkfS4ke2tleX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbmV3IEJsb2IoW3N0cmluZ2lmaWVkVmFsdWVdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYGFwcGxpY2F0aW9uL2pzb247IGxlbmd0aD0ke3N0cmluZ2lmaWVkVmFsdWUubGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuY29kZSB0aGUgYXR0YWNobWVudHNcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gYWxsQXR0YWNobWVudHNbcGF5bG9hZC5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRhY2htZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFsbEF0dGFjaG1lbnRzW3BheWxvYWQuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgYXR0YWNobWVudF0gb2YgT2JqZWN0LmVudHJpZXMoYXR0YWNobWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dGFjaG1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb250ZW50VHlwZSwgY29udGVudF0gPSBhdHRhY2htZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBhdHRhY2htZW50Lm1pbWVUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gYXR0YWNobWVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBhdHRhY2htZW50IG5hbWUgZG9lc24ndCBjb250YWluIGEgJy4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgYXR0YWNobWVudCAnJHtuYW1lfScgZm9yIHJ1biAke3BheWxvYWQuaWR9OiBJbnZhbGlkIGF0dGFjaG1lbnQgbmFtZS4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgQXR0YWNobWVudCBuYW1lcyBtdXN0IG5vdCBjb250YWluIHBlcmlvZHMgKCcuJykuIFBsZWFzZSByZW5hbWUgdGhlIGF0dGFjaG1lbnQgYW5kIHRyeSBhZ2Fpbi5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGBhdHRhY2htZW50LiR7cGF5bG9hZC5pZH0uJHtuYW1lfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG5ldyBCbG9iKFtjb250ZW50XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYCR7Y29udGVudFR5cGV9OyBsZW5ndGg9JHtjb250ZW50LmJ5dGVMZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRDb250ZXh0LnB1c2goYHRyYWNlPSR7cGF5bG9hZC50cmFjZV9pZH0saWQ9JHtwYXlsb2FkLmlkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX3NlbmRNdWx0aXBhcnRSZXF1ZXN0KGFjY3VtdWxhdGVkUGFydHMsIGFjY3VtdWxhdGVkQ29udGV4dC5qb2luKFwiOyBcIikpO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZE11bHRpcGFydFJlcXVlc3QocGFydHMsIGNvbnRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBtdWx0aXBhcnQgZm9ybSBkYXRhIG1hbnVhbGx5IHVzaW5nIEJsb2JzXG4gICAgICAgICAgICBjb25zdCBib3VuZGFyeSA9IFwiLS0tLUxhbmdTbWl0aEZvcm1Cb3VuZGFyeVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBmaWVsZCBib3VuZGFyeVxuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBCbG9iKFtgLS0ke2JvdW5kYXJ5fVxcclxcbmBdKSk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IEJsb2IoW1xuICAgICAgICAgICAgICAgICAgICBgQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiJHtwYXJ0Lm5hbWV9XCJcXHJcXG5gLFxuICAgICAgICAgICAgICAgICAgICBgQ29udGVudC1UeXBlOiAke3BhcnQucGF5bG9hZC50eXBlfVxcclxcblxcclxcbmAsXG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHBhcnQucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IEJsb2IoW1wiXFxyXFxuXCJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgZmluYWwgYm91bmRhcnlcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBCbG9iKFtgLS0ke2JvdW5kYXJ5fS0tXFxyXFxuYF0pKTtcbiAgICAgICAgICAgIC8vIENvbWJpbmUgYWxsIGNodW5rcyBpbnRvIGEgc2luZ2xlIEJsb2JcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBuZXcgQmxvYihjaHVua3MpO1xuICAgICAgICAgICAgLy8gQ29udmVydCBCbG9iIHRvIEFycmF5QnVmZmVyIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvbXVsdGlwYXJ0YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBhcnJheUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImluZ2VzdCBtdWx0aXBhcnQgcnVuc1wiLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtlLm1lc3NhZ2UudHJpbSgpfVxcblxcbkNvbnRleHQ6ICR7Y29udGV4dH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVSdW4ocnVuSWQsIHJ1bikge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgaWYgKHJ1bi5pbnB1dHMpIHtcbiAgICAgICAgICAgIHJ1bi5pbnB1dHMgPSBhd2FpdCB0aGlzLnByb2Nlc3NJbnB1dHMocnVuLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bi5vdXRwdXRzKSB7XG4gICAgICAgICAgICBydW4ub3V0cHV0cyA9IGF3YWl0IHRoaXMucHJvY2Vzc091dHB1dHMocnVuLm91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFVudGFuZ2xlIHR5cGVzXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7IC4uLnJ1biwgaWQ6IHJ1bklkIH07XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcoW2RhdGFdLCB0cnVlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hUcmFjaW5nICYmXG4gICAgICAgICAgICBkYXRhLnRyYWNlX2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGRhdGEuZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChydW4uZW5kX3RpbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIGRhdGEucGFyZW50X3J1bl9pZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbiAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm1hbnVhbEZsdXNoTW9kZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgYmF0Y2hlcyBhcyBzb29uIGFzIGEgcm9vdCB0cmFjZSBlbmRzIGFuZCB3YWl0IHRvIGVuc3VyZSB0cmFjZSBmaW5pc2hlc1xuICAgICAgICAgICAgICAgIC8vIGluIHNlcnZlcmxlc3MgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7IGFjdGlvbjogXCJ1cGRhdGVcIiwgaXRlbTogZGF0YSB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7IGFjdGlvbjogXCJ1cGRhdGVcIiwgaXRlbTogZGF0YSB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhydW4pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBydW5cIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSdW4ocnVuSWQsIHsgbG9hZENoaWxkUnVucyB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBsZXQgcnVuID0gYXdhaXQgdGhpcy5fZ2V0KGAvcnVucy8ke3J1bklkfWApO1xuICAgICAgICBpZiAobG9hZENoaWxkUnVucyAmJiBydW4uY2hpbGRfcnVuX2lkcykge1xuICAgICAgICAgICAgcnVuID0gYXdhaXQgdGhpcy5fbG9hZENoaWxkUnVucyhydW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blVybCh7IHJ1bklkLCBydW4sIHByb2plY3RPcHRzLCB9KSB7XG4gICAgICAgIGlmIChydW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHNlc3Npb25JZDtcbiAgICAgICAgICAgIGlmIChydW4uc2Vzc2lvbl9pZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHJ1bi5zZXNzaW9uX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogcHJvamVjdE9wdHM/LnByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0T3B0cz8ucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHRoaXMucmVhZFByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlBST0pFQ1RcIikgfHwgXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gcHJvamVjdC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRlbmFudElkID0gYXdhaXQgdGhpcy5fZ2V0VGVuYW50SWQoKTtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vby8ke3RlbmFudElkfS9wcm9qZWN0cy9wLyR7c2Vzc2lvbklkfS9yLyR7cnVuLmlkfT9wb2xsPXRydWVgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bl8gPSBhd2FpdCB0aGlzLnJlYWRSdW4ocnVuSWQpO1xuICAgICAgICAgICAgaWYgKCFydW5fLmFwcF9wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSdW4gJHtydW5JZH0gaGFzIG5vIGFwcF9wYXRoYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gdGhpcy5nZXRIb3N0VXJsKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7YmFzZVVybH0ke3J1bl8uYXBwX3BhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcnVuSWQgb3IgcnVuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9sb2FkQ2hpbGRSdW5zKHJ1bikge1xuICAgICAgICBjb25zdCBjaGlsZFJ1bnMgPSBhd2FpdCB0b0FycmF5KHRoaXMubGlzdFJ1bnMoeyBpZDogcnVuLmNoaWxkX3J1bl9pZHMgfSkpO1xuICAgICAgICBjb25zdCB0cmVlbWFwID0ge307XG4gICAgICAgIGNvbnN0IHJ1bnMgPSB7fTtcbiAgICAgICAgLy8gVE9ETzogbWFrZSBkb3R0ZWQgb3JkZXIgcmVxdWlyZWQgd2hlbiB0aGUgbWlncmF0aW9uIGZpbmlzaGVzXG4gICAgICAgIGNoaWxkUnVucy5zb3J0KChhLCBiKSA9PiAoYT8uZG90dGVkX29yZGVyID8/IFwiXCIpLmxvY2FsZUNvbXBhcmUoYj8uZG90dGVkX29yZGVyID8/IFwiXCIpKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZFJ1biBvZiBjaGlsZFJ1bnMpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGlsZCBydW4gJHtjaGlsZFJ1bi5pZH0gaGFzIG5vIHBhcmVudGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoY2hpbGRSdW4ucGFyZW50X3J1bl9pZCBpbiB0cmVlbWFwKSkge1xuICAgICAgICAgICAgICAgIHRyZWVtYXBbY2hpbGRSdW4ucGFyZW50X3J1bl9pZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyZWVtYXBbY2hpbGRSdW4ucGFyZW50X3J1bl9pZF0ucHVzaChjaGlsZFJ1bik7XG4gICAgICAgICAgICBydW5zW2NoaWxkUnVuLmlkXSA9IGNoaWxkUnVuO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5jaGlsZF9ydW5zID0gdHJlZW1hcFtydW4uaWRdIHx8IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bklkIGluIHRyZWVtYXApIHtcbiAgICAgICAgICAgIGlmIChydW5JZCAhPT0gcnVuLmlkKSB7XG4gICAgICAgICAgICAgICAgcnVuc1tydW5JZF0uY2hpbGRfcnVucyA9IHRyZWVtYXBbcnVuSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgcnVucyBmcm9tIHRoZSBMYW5nU21pdGggc2VydmVyLlxuICAgICAqIEBwYXJhbSBwcm9qZWN0SWQgLSBUaGUgSUQgb2YgdGhlIHByb2plY3QgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBwcm9qZWN0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0IHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcGFyZW50UnVuSWQgLSBUaGUgSUQgb2YgdGhlIHBhcmVudCBydW4gdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSB0cmFjZUlkIC0gVGhlIElEIG9mIHRoZSB0cmFjZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHJlZmVyZW5jZUV4YW1wbGVJZCAtIFRoZSBJRCBvZiB0aGUgcmVmZXJlbmNlIGV4YW1wbGUgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGlzUm9vdCAtIEluZGljYXRlcyB3aGV0aGVyIHRvIG9ubHkgcmV0dXJuIHJvb3QgcnVucy5cbiAgICAgKiBAcGFyYW0gcnVuVHlwZSAtIFRoZSBydW4gdHlwZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGVycm9yIC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gZmlsdGVyIGJ5IGVycm9yIHJ1bnMuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBydW4gdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSBzdHJpbmcgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBUaGUgZmlsdGVyIHN0cmluZyB0byBhcHBseSB0byB0aGUgcnVuIHNwYW5zLlxuICAgICAqIEBwYXJhbSB0cmFjZUZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IG9uIHRoZSByb290IHJ1biBvZiB0aGUgdHJhY2UuXG4gICAgICogQHBhcmFtIHRyZWVGaWx0ZXIgLSBUaGUgZmlsdGVyIHN0cmluZyB0byBhcHBseSBvbiBvdGhlciBydW5zIGluIHRoZSB0cmFjZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcnVucyB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxSdW4+fSAtIFRoZSBydW5zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIGluIGEgcHJvamVjdFxuICAgICAqIGNvbnN0IHByb2plY3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHsgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBMTE0gYW5kIENoYXQgcnVucyBpbiB0aGUgbGFzdCAyNCBob3Vyc1xuICAgICAqIGNvbnN0IHRvZGF5c0xMTVJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIHN0YXJ0X3RpbWU6IG5ldyBEYXRlKERhdGUubm93KCkgLSAyNCAqIDYwICogNjAgKiAxMDAwKSxcbiAgICAgKiAgIHJ1bl90eXBlOiBcImxsbVwiLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHRyYWNlcyBpbiBhIHByb2plY3RcbiAgICAgKiBjb25zdCByb290UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZXhlY3V0aW9uX29yZGVyOiAxLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHJ1bnMgd2l0aG91dCBlcnJvcnNcbiAgICAgKiBjb25zdCBjb3JyZWN0UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZXJyb3I6IGZhbHNlLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHJ1bnMgYnkgcnVuIElEXG4gICAgICogY29uc3QgcnVuSWRzID0gW1xuICAgICAqICAgXCJhMzYwOTJkMi00YWQ1LTRmYjQtOWMwZC0wZGJhOWEyZWQ4MzZcIixcbiAgICAgKiAgIFwiOTM5OGU2YmUtOTY0Zi00YWE0LThhZTktYWQ3OGNkNGI3MDc0XCIsXG4gICAgICogXTtcbiAgICAgKiBjb25zdCBzZWxlY3RlZFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoeyBydW5faWRzOiBydW5JZHMgfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIFwiY2hhaW5cIiB0eXBlIHJ1bnMgdGhhdCB0b29rIG1vcmUgdGhhbiAxMCBzZWNvbmRzIGFuZCBoYWQgYHRvdGFsX3Rva2Vuc2AgZ3JlYXRlciB0aGFuIDUwMDBcbiAgICAgKiBjb25zdCBjaGFpblJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChlcShydW5fdHlwZSwgXCJjaGFpblwiKSwgZ3QobGF0ZW5jeSwgMTApLCBndCh0b3RhbF90b2tlbnMsIDUwMDApKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgY2FsbGVkIFwiZXh0cmFjdG9yXCIgd2hvc2Ugcm9vdCBvZiB0aGUgdHJhY2Ugd2FzIGFzc2lnbmVkIGZlZWRiYWNrIFwidXNlcl9zY29yZVwiIHNjb3JlIG9mIDFcbiAgICAgKiBjb25zdCBnb29kRXh0cmFjdG9yUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnZXEobmFtZSwgXCJleHRyYWN0b3JcIiknLFxuICAgICAqICAgdHJhY2VGaWx0ZXI6ICdhbmQoZXEoZmVlZGJhY2tfa2V5LCBcInVzZXJfc2NvcmVcIiksIGVxKGZlZWRiYWNrX3Njb3JlLCAxKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIHRoYXQgc3RhcnRlZCBhZnRlciBhIHNwZWNpZmljIHRpbWVzdGFtcCBhbmQgZWl0aGVyIGhhdmUgXCJlcnJvclwiIG5vdCBlcXVhbCB0byBudWxsIG9yIGEgXCJDb3JyZWN0bmVzc1wiIGZlZWRiYWNrIHNjb3JlIGVxdWFsIHRvIDBcbiAgICAgKiBjb25zdCBjb21wbGV4UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKGd0KHN0YXJ0X3RpbWUsIFwiMjAyMy0wNy0xNVQxMjozNDo1NlpcIiksIG9yKG5lcShlcnJvciwgbnVsbCksIGFuZChlcShmZWVkYmFja19rZXksIFwiQ29ycmVjdG5lc3NcIiksIGVxKGZlZWRiYWNrX3Njb3JlLCAwLjApKSkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyB3aGVyZSBgdGFnc2AgaW5jbHVkZSBcImV4cGVyaW1lbnRhbFwiIG9yIFwiYmV0YVwiIGFuZCBgbGF0ZW5jeWAgaXMgZ3JlYXRlciB0aGFuIDIgc2Vjb25kc1xuICAgICAqIGNvbnN0IHRhZ2dlZFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChvcihoYXModGFncywgXCJleHBlcmltZW50YWxcIiksIGhhcyh0YWdzLCBcImJldGFcIikpLCBndChsYXRlbmN5LCAyKSknLFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFzeW5jICpsaXN0UnVucyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIHBhcmVudFJ1bklkLCB0cmFjZUlkLCByZWZlcmVuY2VFeGFtcGxlSWQsIHN0YXJ0VGltZSwgZXhlY3V0aW9uT3JkZXIsIGlzUm9vdCwgcnVuVHlwZSwgZXJyb3IsIGlkLCBxdWVyeSwgZmlsdGVyLCB0cmFjZUZpbHRlciwgdHJlZUZpbHRlciwgbGltaXQsIHNlbGVjdCwgfSA9IHByb3BzO1xuICAgICAgICBsZXQgcHJvamVjdElkcyA9IFtdO1xuICAgICAgICBpZiAocHJvamVjdElkKSB7XG4gICAgICAgICAgICBwcm9qZWN0SWRzID0gQXJyYXkuaXNBcnJheShwcm9qZWN0SWQpID8gcHJvamVjdElkIDogW3Byb2plY3RJZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0TmFtZXMgPSBBcnJheS5pc0FycmF5KHByb2plY3ROYW1lKVxuICAgICAgICAgICAgICAgID8gcHJvamVjdE5hbWVcbiAgICAgICAgICAgICAgICA6IFtwcm9qZWN0TmFtZV07XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0SWRzXyA9IGF3YWl0IFByb21pc2UuYWxsKHByb2plY3ROYW1lcy5tYXAoKG5hbWUpID0+IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogbmFtZSB9KS50aGVuKChwcm9qZWN0KSA9PiBwcm9qZWN0LmlkKSkpO1xuICAgICAgICAgICAgcHJvamVjdElkcy5wdXNoKC4uLnByb2plY3RJZHNfKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0X3NlbGVjdCA9IFtcbiAgICAgICAgICAgIFwiYXBwX3BhdGhcIixcbiAgICAgICAgICAgIFwiY2hpbGRfcnVuX2lkc1wiLFxuICAgICAgICAgICAgXCJjb21wbGV0aW9uX2Nvc3RcIixcbiAgICAgICAgICAgIFwiY29tcGxldGlvbl90b2tlbnNcIixcbiAgICAgICAgICAgIFwiZG90dGVkX29yZGVyXCIsXG4gICAgICAgICAgICBcImVuZF90aW1lXCIsXG4gICAgICAgICAgICBcImVycm9yXCIsXG4gICAgICAgICAgICBcImV2ZW50c1wiLFxuICAgICAgICAgICAgXCJleHRyYVwiLFxuICAgICAgICAgICAgXCJmZWVkYmFja19zdGF0c1wiLFxuICAgICAgICAgICAgXCJmaXJzdF90b2tlbl90aW1lXCIsXG4gICAgICAgICAgICBcImlkXCIsXG4gICAgICAgICAgICBcImlucHV0c1wiLFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICBcIm91dHB1dHNcIixcbiAgICAgICAgICAgIFwicGFyZW50X3J1bl9pZFwiLFxuICAgICAgICAgICAgXCJwYXJlbnRfcnVuX2lkc1wiLFxuICAgICAgICAgICAgXCJwcm9tcHRfY29zdFwiLFxuICAgICAgICAgICAgXCJwcm9tcHRfdG9rZW5zXCIsXG4gICAgICAgICAgICBcInJlZmVyZW5jZV9leGFtcGxlX2lkXCIsXG4gICAgICAgICAgICBcInJ1bl90eXBlXCIsXG4gICAgICAgICAgICBcInNlc3Npb25faWRcIixcbiAgICAgICAgICAgIFwic3RhcnRfdGltZVwiLFxuICAgICAgICAgICAgXCJzdGF0dXNcIixcbiAgICAgICAgICAgIFwidGFnc1wiLFxuICAgICAgICAgICAgXCJ0b3RhbF9jb3N0XCIsXG4gICAgICAgICAgICBcInRvdGFsX3Rva2Vuc1wiLFxuICAgICAgICAgICAgXCJ0cmFjZV9pZFwiLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgc2Vzc2lvbjogcHJvamVjdElkcy5sZW5ndGggPyBwcm9qZWN0SWRzIDogbnVsbCxcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGU6IHJlZmVyZW5jZUV4YW1wbGVJZCxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgdHJhY2VfZmlsdGVyOiB0cmFjZUZpbHRlcixcbiAgICAgICAgICAgIHRyZWVfZmlsdGVyOiB0cmVlRmlsdGVyLFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25PcmRlcixcbiAgICAgICAgICAgIHBhcmVudF9ydW46IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogc3RhcnRUaW1lID8gc3RhcnRUaW1lLnRvSVNPU3RyaW5nKCkgOiBudWxsLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGxpbWl0LFxuICAgICAgICAgICAgdHJhY2U6IHRyYWNlSWQsXG4gICAgICAgICAgICBzZWxlY3Q6IHNlbGVjdCA/IHNlbGVjdCA6IGRlZmF1bHRfc2VsZWN0LFxuICAgICAgICAgICAgaXNfcm9vdDogaXNSb290LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcnVuc1lpZWxkZWQgPSAwO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHJ1bnMgb2YgdGhpcy5fZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdChcIi9ydW5zL3F1ZXJ5XCIsIGJvZHkpKSB7XG4gICAgICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAocnVuc1lpZWxkZWQgPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5zLmxlbmd0aCArIHJ1bnNZaWVsZGVkID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3UnVucyA9IHJ1bnMuc2xpY2UoMCwgbGltaXQgLSBydW5zWWllbGRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiBuZXdSdW5zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVuc1lpZWxkZWQgKz0gcnVucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogcnVucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRSdW5TdGF0cyh7IGlkLCB0cmFjZSwgcGFyZW50UnVuLCBydW5UeXBlLCBwcm9qZWN0TmFtZXMsIHByb2plY3RJZHMsIHJlZmVyZW5jZUV4YW1wbGVJZHMsIHN0YXJ0VGltZSwgZW5kVGltZSwgZXJyb3IsIHF1ZXJ5LCBmaWx0ZXIsIHRyYWNlRmlsdGVyLCB0cmVlRmlsdGVyLCBpc1Jvb3QsIGRhdGFTb3VyY2VUeXBlLCB9KSB7XG4gICAgICAgIGxldCBwcm9qZWN0SWRzXyA9IHByb2plY3RJZHMgfHwgW107XG4gICAgICAgIGlmIChwcm9qZWN0TmFtZXMpIHtcbiAgICAgICAgICAgIHByb2plY3RJZHNfID0gW1xuICAgICAgICAgICAgICAgIC4uLihwcm9qZWN0SWRzIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAuLi4oYXdhaXQgUHJvbWlzZS5hbGwocHJvamVjdE5hbWVzLm1hcCgobmFtZSkgPT4gdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lOiBuYW1lIH0pLnRoZW4oKHByb2plY3QpID0+IHByb2plY3QuaWQpKSkpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB0cmFjZSxcbiAgICAgICAgICAgIHBhcmVudF9ydW46IHBhcmVudFJ1bixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlLFxuICAgICAgICAgICAgc2Vzc2lvbjogcHJvamVjdElkc18sXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZTogcmVmZXJlbmNlRXhhbXBsZUlkcyxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgIGVuZF90aW1lOiBlbmRUaW1lLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHRyYWNlX2ZpbHRlcjogdHJhY2VGaWx0ZXIsXG4gICAgICAgICAgICB0cmVlX2ZpbHRlcjogdHJlZUZpbHRlcixcbiAgICAgICAgICAgIGlzX3Jvb3Q6IGlzUm9vdCxcbiAgICAgICAgICAgIGRhdGFfc291cmNlX3R5cGU6IGRhdGFTb3VyY2VUeXBlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBSZW1vdmUgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHRoZSBwYXlsb2FkXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkUGF5bG9hZCA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhwYXlsb2FkKS5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vcnVucy9zdGF0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmaWx0ZXJlZFBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgc2hhcmVSdW4ocnVuSWQsIHsgc2hhcmVJZCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVJZCB8fCB1dWlkLnY0KCksXG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8ICEoXCJzaGFyZV90b2tlblwiIGluIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtyZXN1bHRbXCJzaGFyZV90b2tlblwiXX0vcmA7XG4gICAgfVxuICAgIGFzeW5jIHVuc2hhcmVSdW4ocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidW5zaGFyZSBydW5cIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSdW5TaGFyZWRMaW5rKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyBsaXN0U2hhcmVkUnVucyhzaGFyZVRva2VuLCB7IHJ1bklkcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChydW5JZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW5JZCBvZiBydW5JZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJpZFwiLCBydW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vcnVucyR7cXVlcnlQYXJhbXN9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJ1bnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBydW5zO1xuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YXNldFNoYXJlZFNjaGVtYShkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaGFyZVNjaGVtYSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2hhcmVTY2hlbWEudXJsID0gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3NoYXJlU2NoZW1hLnNoYXJlX3Rva2VufS9kYDtcbiAgICAgICAgcmV0dXJuIHNoYXJlU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyBzaGFyZURhdGFzZXQoZGF0YXNldElkLCBkYXRhc2V0TmFtZSkge1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBkYXRhc2V0SWQgb3IgZGF0YXNldE5hbWUgbXVzdCBiZSBnaXZlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZCxcbiAgICAgICAgfTtcbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaGFyZVNjaGVtYSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2hhcmVTY2hlbWEudXJsID0gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3NoYXJlU2NoZW1hLnNoYXJlX3Rva2VufS9kYDtcbiAgICAgICAgcmV0dXJuIHNoYXJlU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlRGF0YXNldChkYXRhc2V0SWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidW5zaGFyZSBkYXRhc2V0XCIsIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZWFkU2hhcmVkRGF0YXNldChzaGFyZVRva2VuKSB7XG4gICAgICAgIGFzc2VydFV1aWQoc2hhcmVUb2tlbik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3B1YmxpYy8ke3NoYXJlVG9rZW59L2RhdGFzZXRzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2hhcmVkIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNoYXJlVG9rZW4gVGhlIHNoYXJlIHRva2VuIHRvIGdldCBleGFtcGxlcyBmb3IuIEEgc2hhcmUgdG9rZW4gaXMgdGhlIFVVSUQgKG9yIExhbmdTbWl0aCBVUkwsIGluY2x1ZGluZyBVVUlEKSBnZW5lcmF0ZWQgd2hlbiBleHBsaWNpdGx5IG1hcmtpbmcgYW4gZXhhbXBsZSBhcyBwdWJsaWMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGxpc3RpbmcgdGhlIGV4YW1wbGVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW10gfCB1bmRlZmluZWR9IFtvcHRpb25zLmV4YW1wbGVJZHNdIEEgbGlzdCBvZiBleGFtcGxlIElEcyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RXhhbXBsZVtdPn0gVGhlIHNoYXJlZCBleGFtcGxlcy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0U2hhcmVkRXhhbXBsZXMoc2hhcmVUb2tlbiwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmV4YW1wbGVJZHMpIHtcbiAgICAgICAgICAgIHBhcmFtcy5pZCA9IG9wdGlvbnMuZXhhbXBsZUlkcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB1cmxQYXJhbXMuYXBwZW5kKGtleSwgdikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3B1YmxpYy8ke3NoYXJlVG9rZW59L2V4YW1wbGVzPyR7dXJsUGFyYW1zLnRvU3RyaW5nKCl9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgaWYgKFwiZGV0YWlsXCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBzaGFyZWQgZXhhbXBsZXMuXFxuU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31cXG5NZXNzYWdlOiAke3Jlc3VsdC5kZXRhaWwuam9pbihcIlxcblwiKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3Qgc2hhcmVkIGV4YW1wbGVzOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQubWFwKChleGFtcGxlKSA9PiAoe1xuICAgICAgICAgICAgLi4uZXhhbXBsZSxcbiAgICAgICAgICAgIF9ob3N0VXJsOiB0aGlzLmdldEhvc3RVcmwoKSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVQcm9qZWN0KHsgcHJvamVjdE5hbWUsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCB1cHNlcnQgPSBmYWxzZSwgcHJvamVjdEV4dHJhID0gbnVsbCwgcmVmZXJlbmNlRGF0YXNldElkID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCB1cHNlcnRfID0gdXBzZXJ0ID8gYD91cHNlcnQ9dHJ1ZWAgOiBcIlwiO1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucyR7dXBzZXJ0X31gO1xuICAgICAgICBjb25zdCBleHRyYSA9IHByb2plY3RFeHRyYSB8fCB7fTtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICBleHRyYVtcIm1ldGFkYXRhXCJdID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYm9keVtcInJlZmVyZW5jZV9kYXRhc2V0X2lkXCJdID0gcmVmZXJlbmNlRGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBwcm9qZWN0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVByb2plY3QocHJvamVjdElkLCB7IG5hbWUgPSBudWxsLCBkZXNjcmlwdGlvbiA9IG51bGwsIG1ldGFkYXRhID0gbnVsbCwgcHJvamVjdEV4dHJhID0gbnVsbCwgZW5kVGltZSA9IG51bGwsIH0pIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMvJHtwcm9qZWN0SWR9YDtcbiAgICAgICAgbGV0IGV4dHJhID0gcHJvamVjdEV4dHJhO1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhID0geyAuLi4oZXh0cmEgfHwge30pLCBtZXRhZGF0YSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGVuZF90aW1lOiBlbmRUaW1lID8gbmV3IERhdGUoZW5kVGltZSkudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgcHJvamVjdFwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBoYXNQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgfSkge1xuICAgICAgICAvLyBUT0RPOiBBZGQgYSBoZWFkIHJlcXVlc3RcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gaHR0cHM6Ly91bmRpY2kubm9kZWpzLm9yZy8jLz9pZD1nYXJiYWdlLWNvbGxlY3Rpb25cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBpdCdzIE9LIGFuZCB3ZSdyZSBxdWVyeWluZyBieSBuYW1lLCBuZWVkIHRvIGNoZWNrIHRoZSBsaXN0IGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb2plY3RJZCBxdWVyeWluZ1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIGluY2x1ZGVTdGF0cywgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL3Nlc3Npb25zXCI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7cHJvamVjdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgcHJvamVjdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZVN0YXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpbmNsdWRlX3N0YXRzXCIsIGluY2x1ZGVTdGF0cy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2plY3RbaWQ9JHtwcm9qZWN0SWR9LCBuYW1lPSR7cHJvamVjdE5hbWV9XSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvamVjdFVybCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgaWYgKHByb2plY3RJZCA9PT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2plY3QgPSBhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSB9KTtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhd2FpdCB0aGlzLl9nZXRUZW5hbnRJZCgpO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vcHJvamVjdHMvcC8ke3Byb2plY3QuaWR9YDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGF0YXNldFVybCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhd2FpdCB0aGlzLl9nZXRUZW5hbnRJZCgpO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vZGF0YXNldHMvJHtkYXRhc2V0LmlkfWA7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRUZW5hbnRJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbmFudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgbGltaXQ6IFwiMVwiIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbmFudElkID0gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9qZWN0cyBmb3VuZCB0byByZXNvbHZlIHRlbmFudC5cIik7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0UHJvamVjdHMoeyBwcm9qZWN0SWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIHJlZmVyZW5jZURhdGFzZXRJZCwgcmVmZXJlbmNlRGF0YXNldE5hbWUsIHJlZmVyZW5jZUZyZWUsIG1ldGFkYXRhLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocHJvamVjdElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb2plY3RJZCBvZiBwcm9qZWN0SWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIHByb2plY3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVDb250YWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBuYW1lQ29udGFpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VEYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9kYXRhc2V0XCIsIHJlZmVyZW5jZURhdGFzZXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVmZXJlbmNlRGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoe1xuICAgICAgICAgICAgICAgIGRhdGFzZXROYW1lOiByZWZlcmVuY2VEYXRhc2V0TmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9kYXRhc2V0XCIsIGRhdGFzZXQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VGcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZnJlZVwiLCByZWZlcmVuY2VGcmVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogcHJvamVjdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZF87XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IHByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHByb2plY3RJZF8pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZF99YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgZGVsZXRlIHNlc3Npb24gJHtwcm9qZWN0SWRffSAoJHtwcm9qZWN0TmFtZX0pYCwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZENzdih7IGNzdkZpbGUsIGZpbGVOYW1lLCBpbnB1dEtleXMsIG91dHB1dEtleXMsIGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgbmFtZSwgfSkge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvdXBsb2FkYDtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBjc3ZGaWxlLCBmaWxlTmFtZSk7XG4gICAgICAgIGlucHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImlucHV0X2tleXNcIiwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJvdXRwdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJkYXRhX3R5cGVcIiwgZGF0YVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgdXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBsb2FkIENTVlwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVEYXRhc2V0KG5hbWUsIHsgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCBpbnB1dHNTY2hlbWEsIG91dHB1dHNTY2hlbWEsIG1ldGFkYXRhLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGV4dHJhOiBtZXRhZGF0YSA/IHsgbWV0YWRhdGEgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICBib2R5LmRhdGFfdHlwZSA9IGRhdGFUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dHNTY2hlbWEpIHtcbiAgICAgICAgICAgIGJvZHkuaW5wdXRzX3NjaGVtYV9kZWZpbml0aW9uID0gaW5wdXRzU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXRzU2NoZW1hKSB7XG4gICAgICAgICAgICBib2R5Lm91dHB1dHNfc2NoZW1hX2RlZmluaXRpb24gPSBvdXRwdXRzU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGRhdGFzZXRcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgLy8gbGltaXQgdG8gMSByZXN1bHRcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGxpbWl0OiBcIjFcIiB9KTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7ZGF0YXNldElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgZGF0YXNldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFzZXRbaWQ9JHtkYXRhc2V0SWR9LCBuYW1lPSR7ZGF0YXNldE5hbWV9XSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgaGFzRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgIGUubWVzc2FnZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibm90IGZvdW5kXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkaWZmRGF0YXNldFZlcnNpb25zKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgZnJvbVZlcnNpb24sIHRvVmVyc2lvbiwgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgZnJvbV92ZXJzaW9uOiB0eXBlb2YgZnJvbVZlcnNpb24gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGZyb21WZXJzaW9uXG4gICAgICAgICAgICAgICAgOiBmcm9tVmVyc2lvbi50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdG9fdmVyc2lvbjogdHlwZW9mIHRvVmVyc2lvbiA9PT0gXCJzdHJpbmdcIiA/IHRvVmVyc2lvbiA6IHRvVmVyc2lvbi50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQoYC9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L3ZlcnNpb25zL2RpZmZgLCB1cmxQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0T3BlbmFpRmluZXR1bmluZyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXRSZXNwb25zZShgJHtwYXRofS8ke2RhdGFzZXRJZH0vb3BlbmFpX2Z0YCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldFRleHRcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC5zcGxpdChcIlxcblwiKVxuICAgICAgICAgICAgLm1hcCgobGluZSkgPT4gSlNPTi5wYXJzZShsaW5lKSk7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgICBhc3luYyAqbGlzdERhdGFzZXRzKHsgbGltaXQgPSAxMDAsIG9mZnNldCA9IDAsIGRhdGFzZXRJZHMsIGRhdGFzZXROYW1lLCBkYXRhc2V0TmFtZUNvbnRhaW5zLCBtZXRhZGF0YSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGxpbWl0OiBsaW1pdC50b1N0cmluZygpLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGRhdGFzZXRJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgZGF0YXNldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0TmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIGRhdGFzZXROYW1lQ29udGFpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGRhdGFzZXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChwYXRoLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZGF0YXNldHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgZGF0YXNldFxuICAgICAqIEBwYXJhbSBwcm9wcyBUaGUgZGF0YXNldCBkZXRhaWxzIHRvIHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGRhdGFzZXRcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVEYXRhc2V0KHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgLi4udXBkYXRlIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfZGF0YXNldElkID0gZGF0YXNldElkID8/IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICBhc3NlcnRVdWlkKF9kYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke19kYXRhc2V0SWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIGRhdGFzZXRcIik7XG4gICAgICAgIHJldHVybiAoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHRhZyBvbiBhIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGFnIGlzIGFscmVhZHkgYXNzaWduZWQgdG8gYSBkaWZmZXJlbnQgdmVyc2lvbiBvZiB0aGlzIGRhdGFzZXQsXG4gICAgICogdGhlIHRhZyB3aWxsIGJlIG1vdmVkIHRvIHRoZSBuZXcgdmVyc2lvbi4gVGhlIGFzX29mIHBhcmFtZXRlciBpcyB1c2VkIHRvXG4gICAgICogZGV0ZXJtaW5lIHdoaWNoIHZlcnNpb24gb2YgdGhlIGRhdGFzZXQgdG8gYXBwbHkgdGhlIG5ldyB0YWdzIHRvLlxuICAgICAqXG4gICAgICogSXQgbXVzdCBiZSBhbiBleGFjdCB2ZXJzaW9uIG9mIHRoZSBkYXRhc2V0IHRvIHN1Y2NlZWQuIFlvdSBjYW5cbiAgICAgKiB1c2UgdGhlIFwicmVhZERhdGFzZXRWZXJzaW9uXCIgbWV0aG9kIHRvIGZpbmQgdGhlIGV4YWN0IHZlcnNpb25cbiAgICAgKiB0byBhcHBseSB0aGUgdGFncyB0by5cbiAgICAgKiBAcGFyYW0gcGFyYW1zLmRhdGFzZXRJZCBUaGUgSUQgb2YgdGhlIGRhdGFzZXQgdG8gdXBkYXRlLiBNdXN0IGJlIHByb3ZpZGVkIGlmIFwiZGF0YXNldE5hbWVcIiBpcyBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHBhcmFtcy5kYXRhc2V0TmFtZSBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCB0byB1cGRhdGUuIE11c3QgYmUgcHJvdmlkZWQgaWYgXCJkYXRhc2V0SWRcIiBpcyBub3QgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHBhcmFtcy5hc09mIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGRhdGFzZXQgdG8gYXBwbHkgdGhlIG5ldyB0YWdzIHRvLlxuICAgICAqIEBwYXJhbSBwYXJhbXMudGFnIFRoZSBuZXcgdGFnIHRvIGFwcGx5IHRvIHRoZSBkYXRhc2V0LlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZURhdGFzZXRUYWcocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBhc09mLCB0YWcgfSA9IHByb3BzO1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9kYXRhc2V0SWQgPSBkYXRhc2V0SWQgPz8gKGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KSkuaWQ7XG4gICAgICAgIGFzc2VydFV1aWQoX2RhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7X2RhdGFzZXRJZH0vdGFnc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGFzX29mOiB0eXBlb2YgYXNPZiA9PT0gXCJzdHJpbmdcIiA/IGFzT2YgOiBhc09mLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIGRhdGFzZXQgdGFnc1wiKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZF99YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYGRlbGV0ZSAke3BhdGh9YCk7XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgaW5kZXhEYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgdGFnLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoIWRhdGFzZXRJZF8gJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICYmIGRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRhdGFzZXRJZF8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkX30vaW5kZXhgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJpbmRleCBkYXRhc2V0XCIpO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExldHMgeW91IHJ1biBhIHNpbWlsYXJpdHkgc2VhcmNoIHF1ZXJ5IG9uIGEgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIFJlcXVpcmVzIHRoZSBkYXRhc2V0IHRvIGJlIGluZGV4ZWQuIFBsZWFzZSBzZWUgdGhlIGBpbmRleERhdGFzZXRgIG1ldGhvZCB0byBzZXQgdXAgaW5kZXhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXRzICAgICAgVGhlIGlucHV0IG9uIHdoaWNoIHRvIHJ1biB0aGUgc2ltaWxhcml0eSBzZWFyY2guIE11c3QgaGF2ZSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgc2FtZSBzY2hlbWEgYXMgdGhlIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YXNldElkICAgVGhlIGRhdGFzZXQgdG8gc2VhcmNoIGZvciBzaW1pbGFyIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbWl0ICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBleGFtcGxlcyB0byByZXR1cm4uIFdpbGwgcmV0dXJuIHRoZSB0b3AgYGxpbWl0YCBtb3N0XG4gICAgICogICAgICAgICAgICAgICAgICAgIHNpbWlsYXIgZXhhbXBsZXMgaW4gb3JkZXIgb2YgbW9zdCBzaW1pbGFyIHRvIGxlYXN0IHNpbWlsYXIuIElmIG5vIHNpbWlsYXJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgZXhhbXBsZXMgYXJlIGZvdW5kLCByYW5kb20gZXhhbXBsZXMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgICAgICBBIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgdG8gdGhlIHNlYXJjaC4gT25seSBleGFtcGxlcyB3aWxsIGJlIHJldHVybmVkIHRoYXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggdGhlIGZpbHRlciBzdHJpbmcuIFNvbWUgZXhhbXBsZXMgb2YgZmlsdGVyc1xuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gZXEobWV0YWRhdGEubXlrZXksIFwidmFsdWVcIilcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBhbmQobmVxKG1ldGFkYXRhLm15Lm5lc3RlZC5rZXksIFwidmFsdWVcIiksIG5lcShtZXRhZGF0YS5teWtleSwgXCJ2YWx1ZVwiKSlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBvcihlcShtZXRhZGF0YS5teWtleSwgXCJ2YWx1ZVwiKSwgZXEobWV0YWRhdGEubXlrZXksIFwib3RoZXJ2YWx1ZVwiKSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zICAgICAgICAgICBBIGxpc3Qgb2Ygc2ltaWxhciBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhc2V0X2lkID0gXCIxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDBcIlxuICAgICAqIGlucHV0cyA9IHtcInRleHRcIjogXCJIb3cgbWFueSBwZW9wbGUgbGl2ZSBpbiBCZXJsaW4/XCJ9XG4gICAgICogbGltaXQgPSA1XG4gICAgICogZXhhbXBsZXMgPSBhd2FpdCBjbGllbnQuc2ltaWxhckV4YW1wbGVzKGlucHV0cywgZGF0YXNldF9pZCwgbGltaXQpXG4gICAgICovXG4gICAgYXN5bmMgc2ltaWxhckV4YW1wbGVzKGlucHV0cywgZGF0YXNldElkLCBsaW1pdCwgeyBmaWx0ZXIsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YVtcImZpbHRlclwiXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zZWFyY2hgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJmZXRjaCBzaW1pbGFyIGV4YW1wbGVzXCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHRbXCJleGFtcGxlc1wiXTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRXhhbXBsZShpbnB1dHNPclVwZGF0ZSwgb3V0cHV0cywgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNFeGFtcGxlQ3JlYXRlKGlucHV0c09yVXBkYXRlKSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dHMgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcHJvdmlkZSBvdXRwdXRzIG9yIG9wdGlvbnMgd2hlbiB1c2luZyBFeGFtcGxlQ3JlYXRlIG9iamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YXNldElkXyA9IG91dHB1dHMgPyBvcHRpb25zPy5kYXRhc2V0SWQgOiBpbnB1dHNPclVwZGF0ZS5kYXRhc2V0X2lkO1xuICAgICAgICBjb25zdCBkYXRhc2V0TmFtZV8gPSBvdXRwdXRzXG4gICAgICAgICAgICA/IG9wdGlvbnM/LmRhdGFzZXROYW1lXG4gICAgICAgICAgICA6IGlucHV0c09yVXBkYXRlLmRhdGFzZXRfbmFtZTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lOiBkYXRhc2V0TmFtZV8gfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVkQXRfID0gKG91dHB1dHMgPyBvcHRpb25zPy5jcmVhdGVkQXQgOiBpbnB1dHNPclVwZGF0ZS5jcmVhdGVkX2F0KSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKCFpc0V4YW1wbGVDcmVhdGUoaW5wdXRzT3JVcGRhdGUpKSB7XG4gICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXRzT3JVcGRhdGUsXG4gICAgICAgICAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBjcmVhdGVkQXRfPy50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGlkOiBvcHRpb25zPy5leGFtcGxlSWQsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG9wdGlvbnM/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHNwbGl0OiBvcHRpb25zPy5zcGxpdCxcbiAgICAgICAgICAgICAgICBzb3VyY2VfcnVuX2lkOiBvcHRpb25zPy5zb3VyY2VSdW5JZCxcbiAgICAgICAgICAgICAgICB1c2Vfc291cmNlX3J1bl9pbzogb3B0aW9ucz8udXNlU291cmNlUnVuSU8sXG4gICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHM6IG9wdGlvbnM/LnVzZVNvdXJjZVJ1bkF0dGFjaG1lbnRzLFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBvcHRpb25zPy5hdHRhY2htZW50cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gaW5wdXRzT3JVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWRfLCBbZGF0YV0pO1xuICAgICAgICBjb25zdCBleGFtcGxlID0gYXdhaXQgdGhpcy5yZWFkRXhhbXBsZShyZXNwb25zZS5leGFtcGxlX2lkcz8uWzBdID8/IHV1aWQudjQoKSk7XG4gICAgICAgIHJldHVybiBleGFtcGxlO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlcyhwcm9wc09yVXBsb2Fkcykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wc09yVXBsb2FkcykpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc09yVXBsb2Fkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cGxvYWRzID0gcHJvcHNPclVwbG9hZHM7XG4gICAgICAgICAgICBsZXQgZGF0YXNldElkXyA9IHVwbG9hZHNbMF0uZGF0YXNldF9pZDtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXROYW1lXyA9IHVwbG9hZHNbMF0uZGF0YXNldF9uYW1lO1xuICAgICAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZTogZGF0YXNldE5hbWVfIH0pO1xuICAgICAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWRfLCB1cGxvYWRzKTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzcG9uc2UuZXhhbXBsZV9pZHMubWFwKChpZCkgPT4gdGhpcy5yZWFkRXhhbXBsZShpZCkpKTtcbiAgICAgICAgICAgIHJldHVybiBleGFtcGxlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgbWV0YWRhdGEsIHNwbGl0cywgc291cmNlUnVuSWRzLCB1c2VTb3VyY2VSdW5JT3MsIHVzZVNvdXJjZVJ1bkF0dGFjaG1lbnRzLCBhdHRhY2htZW50cywgZXhhbXBsZUlkcywgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSA9IHByb3BzT3JVcGxvYWRzO1xuICAgICAgICBpZiAoaW5wdXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBpbnB1dHMgd2hlbiB1c2luZyBsZWdhY3kgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgY29uc3QgZGF0YXNldE5hbWVfID0gZGF0YXNldE5hbWU7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZTogZGF0YXNldE5hbWVfIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRXhhbXBsZXMgPSBpbnB1dHMubWFwKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZF8sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzPy5baWR4XSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGE/LltpZHhdLFxuICAgICAgICAgICAgICAgIHNwbGl0OiBzcGxpdHM/LltpZHhdLFxuICAgICAgICAgICAgICAgIGlkOiBleGFtcGxlSWRzPy5baWR4XSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHM/LltpZHhdLFxuICAgICAgICAgICAgICAgIHNvdXJjZV9ydW5faWQ6IHNvdXJjZVJ1bklkcz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5faW86IHVzZVNvdXJjZVJ1bklPcz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHM6IHVzZVNvdXJjZVJ1bkF0dGFjaG1lbnRzPy5baWR4XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3VwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZF8sIGZvcm1hdHRlZEV4YW1wbGVzKTtcbiAgICAgICAgY29uc3QgZXhhbXBsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXNwb25zZS5leGFtcGxlX2lkcy5tYXAoKGlkKSA9PiB0aGlzLnJlYWRFeGFtcGxlKGlkKSkpO1xuICAgICAgICByZXR1cm4gZXhhbXBsZXM7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUxMTUV4YW1wbGUoaW5wdXQsIGdlbmVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0IH0sIHsgb3V0cHV0OiBnZW5lcmF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDaGF0RXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxJbnB1dCA9IGlucHV0Lm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzTGFuZ0NoYWluTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmluYWxPdXRwdXQgPSBpc0xhbmdDaGFpbk1lc3NhZ2UoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA/IGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKGdlbmVyYXRpb25zKVxuICAgICAgICAgICAgOiBnZW5lcmF0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0OiBmaW5hbElucHV0IH0sIHsgb3V0cHV0OiBmaW5hbE91dHB1dCB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEV4YW1wbGUoZXhhbXBsZUlkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZXhhbXBsZUlkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZXhhbXBsZXMvJHtleGFtcGxlSWR9YDtcbiAgICAgICAgY29uc3QgcmF3RXhhbXBsZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICAgICAgY29uc3QgeyBhdHRhY2htZW50X3VybHMsIC4uLnJlc3QgfSA9IHJhd0V4YW1wbGU7XG4gICAgICAgIGNvbnN0IGV4YW1wbGUgPSByZXN0O1xuICAgICAgICBpZiAoYXR0YWNobWVudF91cmxzKSB7XG4gICAgICAgICAgICBleGFtcGxlLmF0dGFjaG1lbnRzID0gT2JqZWN0LmVudHJpZXMoYXR0YWNobWVudF91cmxzKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW2tleS5zbGljZShcImF0dGFjaG1lbnQuXCIubGVuZ3RoKV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNpZ25lZF91cmw6IHZhbHVlLnByZXNpZ25lZF91cmwsXG4gICAgICAgICAgICAgICAgICAgIG1pbWVfdHlwZTogdmFsdWUubWltZV90eXBlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhhbXBsZTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RFeGFtcGxlcyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGV4YW1wbGVJZHMsIGFzT2YsIHNwbGl0cywgaW5saW5lUzNVcmxzLCBtZXRhZGF0YSwgbGltaXQsIG9mZnNldCwgZmlsdGVyLCBpbmNsdWRlQXR0YWNobWVudHMsIH0gPSB7fSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgYSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGRhdGFzZXQ6IGRhdGFzZXRJZF8gfSk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRfdmVyc2lvbiA9IGFzT2ZcbiAgICAgICAgICAgID8gdHlwZW9mIGFzT2YgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGFzT2ZcbiAgICAgICAgICAgICAgICA6IGFzT2Y/LnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGF0YXNldF92ZXJzaW9uKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiYXNfb2ZcIiwgZGF0YXNldF92ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmxpbmVTM1VybHNfID0gaW5saW5lUzNVcmxzID8/IHRydWU7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpbmxpbmVfczNfdXJsc1wiLCBpbmxpbmVTM1VybHNfLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoZXhhbXBsZUlkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBleGFtcGxlSWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNwbGl0IG9mIHNwbGl0cykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzcGxpdHNcIiwgc3BsaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkTWV0YWRhdGEgPSBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgc2VyaWFsaXplZE1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImxpbWl0XCIsIGxpbWl0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm9mZnNldFwiLCBvZmZzZXQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiZmlsdGVyXCIsIGZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVBdHRhY2htZW50cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgW1wiYXR0YWNobWVudF91cmxzXCIsIFwib3V0cHV0c1wiLCBcIm1ldGFkYXRhXCJdLmZvckVhY2goKGZpZWxkKSA9PiBwYXJhbXMuYXBwZW5kKFwic2VsZWN0XCIsIGZpZWxkKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHJhd0V4YW1wbGVzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9leGFtcGxlc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJhd0V4YW1wbGUgb2YgcmF3RXhhbXBsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF0dGFjaG1lbnRfdXJscywgLi4ucmVzdCB9ID0gcmF3RXhhbXBsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBleGFtcGxlID0gcmVzdDtcbiAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudF91cmxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4YW1wbGUuYXR0YWNobWVudHMgPSBPYmplY3QuZW50cmllcyhhdHRhY2htZW50X3VybHMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1trZXkuc2xpY2UoXCJhdHRhY2htZW50LlwiLmxlbmd0aCldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNpZ25lZF91cmw6IHZhbHVlLnByZXNpZ25lZF91cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZV90eXBlOiB2YWx1ZS5taW1lX3R5cGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQgZXhhbXBsZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiBpID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgZGVsZXRlICR7cGF0aH1gKTtcbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVFeGFtcGxlKGV4YW1wbGVJZE9yVXBkYXRlLCB1cGRhdGUpIHtcbiAgICAgICAgbGV0IGV4YW1wbGVJZDtcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgZXhhbXBsZUlkID0gZXhhbXBsZUlkT3JVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGFtcGxlSWQgPSBleGFtcGxlSWRPclVwZGF0ZS5pZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGxldCB1cGRhdGVUb1VzZTtcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgdXBkYXRlVG9Vc2UgPSB7IGlkOiBleGFtcGxlSWQsIC4uLnVwZGF0ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlVG9Vc2UgPSBleGFtcGxlSWRPclVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YXNldElkO1xuICAgICAgICBpZiAodXBkYXRlVG9Vc2UuZGF0YXNldF9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSB1cGRhdGVUb1VzZS5kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUoZXhhbXBsZUlkKTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGV4YW1wbGUuZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCBbdXBkYXRlVG9Vc2VdKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRXhhbXBsZXModXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgbmFpdmVseSBnZXQgZGF0YXNldCBpZCBmcm9tIGZpcnN0IGV4YW1wbGUgYW5kIGFzc3VtZSBpdCB3b3JrcyBmb3IgYWxsXG4gICAgICAgIGxldCBkYXRhc2V0SWQ7XG4gICAgICAgIGlmICh1cGRhdGVbMF0uZGF0YXNldF9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlID0gYXdhaXQgdGhpcy5yZWFkRXhhbXBsZSh1cGRhdGVbMF0uaWQpO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZXhhbXBsZS5kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YXNldElkID0gdXBkYXRlWzBdLmRhdGFzZXRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBkYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGRhdGFzZXQgdmVyc2lvbiBieSBjbG9zZXN0IGRhdGUgb3IgZXhhY3QgdGFnLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgdG8gcmVzb2x2ZSB0aGUgbmVhcmVzdCB2ZXJzaW9uIHRvIGEgZ2l2ZW4gdGltZXN0YW1wIG9yIGZvciBhIGdpdmVuIHRhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSBkYXRhc2V0IHZlcnNpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhc2V0SWQgVGhlIElEIG9mIHRoZSBkYXRhc2V0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGF0YXNldE5hbWUgVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hc09mIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGRhdGFzZXQgdG8gcmV0cmlldmVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50YWcgVGhlIHRhZyBvZiB0aGUgZGF0YXNldCB0byByZXRyaWV2ZVxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhc2V0IHZlcnNpb25cbiAgICAgKi9cbiAgICBhc3luYyByZWFkRGF0YXNldFZlcnNpb24oeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBhc09mLCB0YWcsIH0pIHtcbiAgICAgICAgbGV0IHJlc29sdmVkRGF0YXNldElkO1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIHJlc29sdmVkRGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmVkRGF0YXNldElkID0gZGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQocmVzb2x2ZWREYXRhc2V0SWQpO1xuICAgICAgICBpZiAoKGFzT2YgJiYgdGFnKSB8fCAoIWFzT2YgJiYgIXRhZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4YWN0bHkgb25lIG9mIGFzT2YgYW5kIHRhZyBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAoYXNPZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiYXNfb2ZcIiwgdHlwZW9mIGFzT2YgPT09IFwic3RyaW5nXCIgPyBhc09mIDogYXNPZi50b0lTT1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJ0YWdcIiwgdGFnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke3Jlc29sdmVkRGF0YXNldElkfS92ZXJzaW9uPyR7cGFyYW1zLnRvU3RyaW5nKCl9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMgfSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJyZWFkIGRhdGFzZXQgdmVyc2lvblwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdERhdGFzZXRTcGxpdHMoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBhc09mLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfO1xuICAgICAgICBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXQgbmFtZSBvciBJRFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBjb25zdCBkYXRhc2V0X3ZlcnNpb24gPSBhc09mXG4gICAgICAgICAgICA/IHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBhc09mXG4gICAgICAgICAgICAgICAgOiBhc09mPy50b0lTT1N0cmluZygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRhdGFzZXRfdmVyc2lvbikge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIGRhdGFzZXRfdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQoYC9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L3NwbGl0c2AsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRGF0YXNldFNwbGl0cyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIHNwbGl0TmFtZSwgZXhhbXBsZUlkcywgcmVtb3ZlID0gZmFsc2UsIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF87XG4gICAgICAgIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldCBuYW1lIG9yIElEXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgc3BsaXRfbmFtZTogc3BsaXROYW1lLFxuICAgICAgICAgICAgZXhhbXBsZXM6IGV4YW1wbGVJZHMubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydFV1aWQoaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVtb3ZlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L3NwbGl0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIGRhdGFzZXQgc3BsaXRzXCIsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIExhbmdTbWl0aCB2ZXJzaW9ucywgdXNlIGBldmFsdWF0ZWAgZnJvbSBgbGFuZ3NtaXRoL2V2YWx1YXRpb25gIGluc3RlYWQuXG4gICAgICovXG4gICAgYXN5bmMgZXZhbHVhdGVSdW4ocnVuLCBldmFsdWF0b3IsIHsgc291cmNlSW5mbywgbG9hZENoaWxkUnVucywgcmVmZXJlbmNlRXhhbXBsZSwgfSA9IHsgbG9hZENoaWxkUnVuczogZmFsc2UgfSkge1xuICAgICAgICB3YXJuT25jZShcIlRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgTGFuZ1NtaXRoIHZlcnNpb25zLCB1c2UgYGV2YWx1YXRlYCBmcm9tIGBsYW5nc21pdGgvZXZhbHVhdGlvbmAgaW5zdGVhZC5cIik7XG4gICAgICAgIGxldCBydW5fO1xuICAgICAgICBpZiAodHlwZW9mIHJ1biA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcnVuXyA9IGF3YWl0IHRoaXMucmVhZFJ1bihydW4sIHsgbG9hZENoaWxkUnVucyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcnVuID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBydW4pIHtcbiAgICAgICAgICAgIHJ1bl8gPSBydW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcnVuIHR5cGU6ICR7dHlwZW9mIHJ1bn1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgcnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VFeGFtcGxlID0gYXdhaXQgdGhpcy5yZWFkRXhhbXBsZShydW5fLnJlZmVyZW5jZV9leGFtcGxlX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFja1Jlc3VsdCA9IGF3YWl0IGV2YWx1YXRvci5ldmFsdWF0ZVJ1bihydW5fLCByZWZlcmVuY2VFeGFtcGxlKTtcbiAgICAgICAgY29uc3QgW18sIGZlZWRiYWNrc10gPSBhd2FpdCB0aGlzLl9sb2dFdmFsdWF0aW9uRmVlZGJhY2soZmVlZGJhY2tSZXN1bHQsIHJ1bl8sIHNvdXJjZUluZm8pO1xuICAgICAgICByZXR1cm4gZmVlZGJhY2tzWzBdO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVGZWVkYmFjayhydW5JZCwga2V5LCB7IHNjb3JlLCB2YWx1ZSwgY29ycmVjdGlvbiwgY29tbWVudCwgc291cmNlSW5mbywgZmVlZGJhY2tTb3VyY2VUeXBlID0gXCJhcGlcIiwgc291cmNlUnVuSWQsIGZlZWRiYWNrSWQsIGZlZWRiYWNrQ29uZmlnLCBwcm9qZWN0SWQsIGNvbXBhcmF0aXZlRXhwZXJpbWVudElkLCB9KSB7XG4gICAgICAgIGlmICghcnVuSWQgJiYgIXByb2plY3RJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25lIG9mIHJ1bklkIG9yIHByb2plY3RJZCBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5JZCAmJiBwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIG9mIHJ1bklkIG9yIHByb2plY3RJZCBjYW4gYmUgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2tfc291cmNlID0ge1xuICAgICAgICAgICAgdHlwZTogZmVlZGJhY2tTb3VyY2VUeXBlID8/IFwiYXBpXCIsXG4gICAgICAgICAgICBtZXRhZGF0YTogc291cmNlSW5mbyA/PyB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNvdXJjZVJ1bklkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZT8ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIWZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdKSB7XG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXSA9IHsgcnVuX2lkOiBzb3VyY2VSdW5JZCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZWVkYmFja19zb3VyY2U/Lm1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdPy5ydW5faWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXS5ydW5faWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrID0ge1xuICAgICAgICAgICAgaWQ6IGZlZWRiYWNrSWQgPz8gdXVpZC52NCgpLFxuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHNjb3JlOiBfZm9ybWF0RmVlZGJhY2tTY29yZShzY29yZSksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNvcnJlY3Rpb24sXG4gICAgICAgICAgICBjb21tZW50LFxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlOiBmZWVkYmFja19zb3VyY2UsXG4gICAgICAgICAgICBjb21wYXJhdGl2ZV9leHBlcmltZW50X2lkOiBjb21wYXJhdGl2ZUV4cGVyaW1lbnRJZCxcbiAgICAgICAgICAgIGZlZWRiYWNrQ29uZmlnLFxuICAgICAgICAgICAgc2Vzc2lvbl9pZDogcHJvamVjdElkLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2tgO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZmVlZGJhY2spLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBmZWVkYmFja1wiLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGZlZWRiYWNrO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVGZWVkYmFjayhmZWVkYmFja0lkLCB7IHNjb3JlLCB2YWx1ZSwgY29ycmVjdGlvbiwgY29tbWVudCwgfSkge1xuICAgICAgICBjb25zdCBmZWVkYmFja1VwZGF0ZSA9IHt9O1xuICAgICAgICBpZiAoc2NvcmUgIT09IHVuZGVmaW5lZCAmJiBzY29yZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJzY29yZVwiXSA9IF9mb3JtYXRGZWVkYmFja1Njb3JlKHNjb3JlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJ2YWx1ZVwiXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3JyZWN0aW9uICE9PSB1bmRlZmluZWQgJiYgY29ycmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJjb3JyZWN0aW9uXCJdID0gY29ycmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkICYmIGNvbW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29tbWVudFwiXSA9IGNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja0lkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2svJHtmZWVkYmFja0lkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmZWVkYmFja1VwZGF0ZSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIGZlZWRiYWNrXCIsIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRmVlZGJhY2soZmVlZGJhY2tJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRmVlZGJhY2soZmVlZGJhY2tJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYGRlbGV0ZSAke3BhdGh9YCk7XG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RGZWVkYmFjayh7IHJ1bklkcywgZmVlZGJhY2tLZXlzLCBmZWVkYmFja1NvdXJjZVR5cGVzLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChydW5JZHMpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcInJ1blwiLCBydW5JZHMuam9pbihcIixcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmZWVkYmFja0tleXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGZlZWRiYWNrS2V5cykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImtleVwiLCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmZWVkYmFja1NvdXJjZVR5cGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZmVlZGJhY2tTb3VyY2VUeXBlcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcInNvdXJjZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGZlZWRiYWNrcyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvZmVlZGJhY2tcIiwgcXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZmVlZGJhY2tzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwcmVzaWduZWQgZmVlZGJhY2sgdG9rZW4gYW5kIFVSTC5cbiAgICAgKlxuICAgICAqIFRoZSB0b2tlbiBjYW4gYmUgdXNlZCB0byBhdXRob3JpemUgZmVlZGJhY2sgbWV0cmljcyB3aXRob3V0XG4gICAgICogbmVlZGluZyBhbiBBUEkga2V5LiBUaGlzIGlzIHVzZWZ1bCBmb3IgZ2l2aW5nIGJyb3dzZXItYmFzZWRcbiAgICAgKiBhcHBsaWNhdGlvbnMgdGhlIGFiaWxpdHkgdG8gc3VibWl0IGZlZWRiYWNrIHdpdGhvdXQgbmVlZGluZ1xuICAgICAqIHRvIGV4cG9zZSBhbiBBUEkga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bklkIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEBwYXJhbSBmZWVkYmFja0tleSBUaGUgZmVlZGJhY2sga2V5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmV4cGlyYXRpb24gVGhlIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIHRva2VuLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBGZWVkYmFja0luZ2VzdFRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVByZXNpZ25lZEZlZWRiYWNrVG9rZW4ocnVuSWQsIGZlZWRiYWNrS2V5LCB7IGV4cGlyYXRpb24sIGZlZWRiYWNrQ29uZmlnLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBmZWVkYmFja19rZXk6IGZlZWRiYWNrS2V5LFxuICAgICAgICAgICAgZmVlZGJhY2tfY29uZmlnOiBmZWVkYmFja0NvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV4cGlyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwaXJhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2F0XCJdID0gZXhwaXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV4cGlyYXRpb24/LmhvdXJzIHx8IGV4cGlyYXRpb24/Lm1pbnV0ZXMgfHwgZXhwaXJhdGlvbj8uZGF5cykge1xuICAgICAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2luXCJdID0gZXhwaXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHlbXCJleHBpcmVzX2luXCJdID0ge1xuICAgICAgICAgICAgICAgIGhvdXJzOiAzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9mZWVkYmFjay90b2tlbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNvbXBhcmF0aXZlRXhwZXJpbWVudCh7IG5hbWUsIGV4cGVyaW1lbnRJZHMsIHJlZmVyZW5jZURhdGFzZXRJZCwgY3JlYXRlZEF0LCBkZXNjcmlwdGlvbiwgbWV0YWRhdGEsIGlkLCB9KSB7XG4gICAgICAgIGlmIChleHBlcmltZW50SWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGV4cGVyaW1lbnQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWZlcmVuY2VEYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZURhdGFzZXRJZCA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0SWQ6IGV4cGVyaW1lbnRJZHNbMF0sXG4gICAgICAgICAgICB9KSkucmVmZXJlbmNlX2RhdGFzZXRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWZlcmVuY2VEYXRhc2V0SWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSByZWZlcmVuY2UgZGF0YXNldCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXhwZXJpbWVudF9pZHM6IGV4cGVyaW1lbnRJZHMsXG4gICAgICAgICAgICByZWZlcmVuY2VfZGF0YXNldF9pZDogcmVmZXJlbmNlRGF0YXNldElkLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiAoY3JlYXRlZEF0ID8/IG5ldyBEYXRlKCkpPy50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWV0YWRhdGEpXG4gICAgICAgICAgICBib2R5LmV4dHJhW1wibWV0YWRhdGFcIl0gPSBtZXRhZGF0YTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvY29tcGFyYXRpdmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIHByZXNpZ25lZCBmZWVkYmFjayB0b2tlbnMgZm9yIGEgZ2l2ZW4gcnVuIElELlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcmV0dXJucyBBbiBhc3luYyBpdGVyYWJsZSBvZiBGZWVkYmFja0luZ2VzdFRva2VuIG9iamVjdHMuXG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RQcmVzaWduZWRGZWVkYmFja1Rva2VucyhydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHJ1bl9pZDogcnVuSWQgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdG9rZW5zIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9mZWVkYmFjay90b2tlbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHRva2VucztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2VsZWN0RXZhbFJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICBsZXQgcmVzdWx0c187XG4gICAgICAgIGlmIChcInJlc3VsdHNcIiBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgICByZXN1bHRzXyA9IHJlc3VsdHMucmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgICByZXN1bHRzXyA9IHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzXyA9IFtyZXN1bHRzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0c187XG4gICAgfVxuICAgIGFzeW5jIF9sb2dFdmFsdWF0aW9uRmVlZGJhY2soZXZhbHVhdG9yUmVzcG9uc2UsIHJ1biwgc291cmNlSW5mbykge1xuICAgICAgICBjb25zdCBldmFsUmVzdWx0cyA9IHRoaXMuX3NlbGVjdEV2YWxSZXN1bHRzKGV2YWx1YXRvclJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVzIG9mIGV2YWxSZXN1bHRzKSB7XG4gICAgICAgICAgICBsZXQgc291cmNlSW5mb18gPSBzb3VyY2VJbmZvIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcy5ldmFsdWF0b3JJbmZvKSB7XG4gICAgICAgICAgICAgICAgc291cmNlSW5mb18gPSB7IC4uLnJlcy5ldmFsdWF0b3JJbmZvLCAuLi5zb3VyY2VJbmZvXyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJ1bklkXyA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVzLnRhcmdldFJ1bklkKSB7XG4gICAgICAgICAgICAgICAgcnVuSWRfID0gcmVzLnRhcmdldFJ1bklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnVuKSB7XG4gICAgICAgICAgICAgICAgcnVuSWRfID0gcnVuLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmVlZGJhY2tzLnB1c2goYXdhaXQgdGhpcy5jcmVhdGVGZWVkYmFjayhydW5JZF8sIHJlcy5rZXksIHtcbiAgICAgICAgICAgICAgICBzY29yZTogcmVzLnNjb3JlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXMudmFsdWUsXG4gICAgICAgICAgICAgICAgY29tbWVudDogcmVzLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgY29ycmVjdGlvbjogcmVzLmNvcnJlY3Rpb24sXG4gICAgICAgICAgICAgICAgc291cmNlSW5mbzogc291cmNlSW5mb18sXG4gICAgICAgICAgICAgICAgc291cmNlUnVuSWQ6IHJlcy5zb3VyY2VSdW5JZCxcbiAgICAgICAgICAgICAgICBmZWVkYmFja0NvbmZpZzogcmVzLmZlZWRiYWNrQ29uZmlnLFxuICAgICAgICAgICAgICAgIGZlZWRiYWNrU291cmNlVHlwZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXZhbFJlc3VsdHMsIGZlZWRiYWNrc107XG4gICAgfVxuICAgIGFzeW5jIGxvZ0V2YWx1YXRpb25GZWVkYmFjayhldmFsdWF0b3JSZXNwb25zZSwgcnVuLCBzb3VyY2VJbmZvKSB7XG4gICAgICAgIGNvbnN0IFtyZXN1bHRzXSA9IGF3YWl0IHRoaXMuX2xvZ0V2YWx1YXRpb25GZWVkYmFjayhldmFsdWF0b3JSZXNwb25zZSwgcnVuLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFQSSBmb3IgbWFuYWdpbmcgYW5ub3RhdGlvbiBxdWV1ZXNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMaXN0IHRoZSBhbm5vdGF0aW9uIHF1ZXVlcyBvbiB0aGUgTGFuZ1NtaXRoIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBsaXN0aW5nIGFubm90YXRpb24gcXVldWVzXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVldWVJZHMgLSBUaGUgSURzIG9mIHRoZSBxdWV1ZXMgdG8gZmlsdGVyIGJ5XG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBxdWV1ZSB0byBmaWx0ZXIgYnlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lQ29udGFpbnMgLSBUaGUgc3Vic3RyaW5nIHRoYXQgdGhlIHF1ZXVlIG5hbWUgc2hvdWxkIGNvbnRhaW5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBxdWV1ZXMgdG8gcmV0dXJuXG4gICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igb2YgQW5ub3RhdGlvblF1ZXVlIG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyAqbGlzdEFubm90YXRpb25RdWV1ZXMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcXVldWVJZHMsIG5hbWUsIG5hbWVDb250YWlucywgbGltaXQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHF1ZXVlSWRzKSB7XG4gICAgICAgICAgICBxdWV1ZUlkcy5mb3JFYWNoKChpZCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydFV1aWQoaWQsIGBxdWV1ZUlkc1ske2l9XWApO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZHNcIiwgaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpXG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgaWYgKG5hbWVDb250YWlucylcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJsaW1pdFwiLCAobGltaXQgIT09IHVuZGVmaW5lZCA/IE1hdGgubWluKGxpbWl0LCAxMDApIDogMTAwKS50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBxdWV1ZXMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2Fubm90YXRpb24tcXVldWVzXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBxdWV1ZXM7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgY291bnQgPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFubm90YXRpb24gcXVldWUgb24gdGhlIExhbmdTbWl0aCBBUEkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYW4gYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlc2NyaXB0aW9uIC0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIEFubm90YXRpb25RdWV1ZSBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbm5vdGF0aW9uUXVldWUob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGRlc2NyaXB0aW9uLCBxdWV1ZUlkLCBydWJyaWNJbnN0cnVjdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBpZDogcXVldWVJZCB8fCB1dWlkLnY0KCksXG4gICAgICAgICAgICBydWJyaWNfaW5zdHJ1Y3Rpb25zOiBydWJyaWNJbnN0cnVjdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGJvZHkpLmZpbHRlcigoW18sIHZdKSA9PiB2ICE9PSB1bmRlZmluZWQpKSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIHJlYWRcbiAgICAgKiBAcmV0dXJucyBUaGUgQW5ub3RhdGlvblF1ZXVlV2l0aERldGFpbHMgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgcmVhZEFubm90YXRpb25RdWV1ZShxdWV1ZUlkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInJlYWQgYW5ub3RhdGlvbiBxdWV1ZVwiKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZSB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB1cGRhdGluZyB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmV3IG5hbWUgZm9yIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVzY3JpcHRpb24gLSBUaGUgbmV3IGRlc2NyaXB0aW9uIGZvciB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUFubm90YXRpb25RdWV1ZShxdWV1ZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZGVzY3JpcHRpb24sIHJ1YnJpY0luc3RydWN0aW9ucyB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgcnVicmljX2luc3RydWN0aW9uczogcnVicmljSW5zdHJ1Y3Rpb25zLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZSB0byBkZWxldGVcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVBbm5vdGF0aW9uUXVldWUocXVldWVJZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZGVsZXRlIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBydW5zIHRvIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIHJ1bklkcyAtIFRoZSBJRHMgb2YgdGhlIHJ1bnMgdG8gYmUgYWRkZWQgdG8gdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKi9cbiAgICBhc3luYyBhZGRSdW5zVG9Bbm5vdGF0aW9uUXVldWUocXVldWVJZCwgcnVuSWRzKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9L3J1bnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShydW5JZHMubWFwKChpZCwgaSkgPT4gYXNzZXJ0VXVpZChpZCwgYHJ1bklkc1ske2l9XWApLnRvU3RyaW5nKCkpKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJhZGQgcnVucyB0byBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBydW4gZnJvbSBhbiBhbm5vdGF0aW9uIHF1ZXVlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJ1biB0byByZXRyaWV2ZVxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgUnVuV2l0aEFubm90YXRpb25RdWV1ZUluZm8gb2JqZWN0XG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBydW4gaXMgbm90IGZvdW5kIGF0IHRoZSBnaXZlbiBpbmRleCBvciBmb3Igb3RoZXIgQVBJLXJlbGF0ZWQgZXJyb3JzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UnVuRnJvbUFubm90YXRpb25RdWV1ZShxdWV1ZUlkLCBpbmRleCkge1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gYC9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfS9ydW5gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfSR7YmFzZVVybH0vJHtpbmRleH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZ2V0IHJ1biBmcm9tIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHJ1biBmcm9tIGFuIGFuIGFubm90YXRpb24gcXVldWUuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWUgdG8gZGVsZXRlIHRoZSBydW4gZnJvbVxuICAgICAqIEBwYXJhbSBxdWV1ZVJ1bklkIC0gVGhlIElEIG9mIHRoZSBydW4gdG8gZGVsZXRlIGZyb20gdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVSdW5Gcm9tQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIHF1ZXVlUnVuSWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX0vcnVucy8ke2Fzc2VydFV1aWQocXVldWVSdW5JZCwgXCJxdWV1ZVJ1bklkXCIpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiZGVsZXRlIHJ1biBmcm9tIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2l6ZSBvZiBhbiBhbm5vdGF0aW9uIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2l6ZUZyb21Bbm5vdGF0aW9uUXVldWUocXVldWVJZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfS9zaXplYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImdldCBzaXplIGZyb20gYW5ub3RhdGlvbiBxdWV1ZVwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgdGhpcy5fZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgcmV0dXJuIG93bmVyID09IFwiLVwiIHx8IHNldHRpbmdzLnRlbmFudF9oYW5kbGUgPT09IG93bmVyO1xuICAgIH1cbiAgICBhc3luYyBfb3duZXJDb25mbGljdEVycm9yKGFjdGlvbiwgb3duZXIpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBDYW5ub3QgJHthY3Rpb259IGZvciBhbm90aGVyIHRlbmFudC5cXG5cbiAgICAgIEN1cnJlbnQgdGVuYW50OiAke3NldHRpbmdzLnRlbmFudF9oYW5kbGV9XFxuXG4gICAgICBSZXF1ZXN0ZWQgdGVuYW50OiAke293bmVyfWApO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0TGF0ZXN0Q29tbWl0SGFzaChwcm9tcHRPd25lckFuZE5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2NvbW1pdHMvJHtwcm9tcHRPd25lckFuZE5hbWV9Lz9saW1pdD0kezF9Jm9mZnNldD0kezB9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgY29uc3QgZGV0YWlsID0gdHlwZW9mIGpzb24uZGV0YWlsID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBqc29uLmRldGFpbFxuICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoanNvbi5kZXRhaWwpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEVycm9yICR7cmVzLnN0YXR1c306ICR7cmVzLnN0YXR1c1RleHR9XFxuJHtkZXRhaWx9YCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZXJyb3Iuc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi5jb21taXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbi5jb21taXRzWzBdLmNvbW1pdF9oYXNoO1xuICAgIH1cbiAgICBhc3luYyBfbGlrZU9yVW5saWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIGxpa2UpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vbGlrZXMvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGxpa2U6IGxpa2UgfSksXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgYCR7bGlrZSA/IFwibGlrZVwiIDogXCJ1bmxpa2VcIn0gcHJvbXB0YCk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRQcm9tcHRVcmwocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIGNvbW1pdEhhc2hdID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikpKSB7XG4gICAgICAgICAgICBpZiAoY29tbWl0SGFzaCAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vaHViLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX0vJHtjb21taXRIYXNoLnN1YnN0cmluZygwLCA4KX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9odWIvJHtvd25lcn0vJHtwcm9tcHROYW1lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBpZiAoY29tbWl0SGFzaCAhPT0gXCJsYXRlc3RcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHJvbXB0cy8ke3Byb21wdE5hbWV9LyR7Y29tbWl0SGFzaC5zdWJzdHJpbmcoMCwgOCl9P29yZ2FuaXphdGlvbklkPSR7c2V0dGluZ3MuaWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHJvbXB0cy8ke3Byb21wdE5hbWV9P29yZ2FuaXphdGlvbklkPSR7c2V0dGluZ3MuaWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBwcm9tcHQgPSBhd2FpdCB0aGlzLmdldFByb21wdChwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuICEhcHJvbXB0O1xuICAgIH1cbiAgICBhc3luYyBsaWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgdW5saWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBmYWxzZSk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0Q29tbWl0cyhwcm9tcHRPd25lckFuZE5hbWUpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjb21taXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChgL2NvbW1pdHMvJHtwcm9tcHRPd25lckFuZE5hbWV9L2AsIG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgKHJlcykgPT4gcmVzLmNvbW1pdHMpKSB7XG4gICAgICAgICAgICB5aWVsZCogY29tbWl0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqbGlzdFByb21wdHMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzb3J0X2ZpZWxkXCIsIG9wdGlvbnM/LnNvcnRGaWVsZCA/PyBcInVwZGF0ZWRfYXRcIik7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJzb3J0X2RpcmVjdGlvblwiLCBcImRlc2NcIik7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpc19hcmNoaXZlZFwiLCAoISFvcHRpb25zPy5pc0FyY2hpdmVkKS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzUHVibGljICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpc19wdWJsaWNcIiwgb3B0aW9ucy5pc1B1YmxpYy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucz8ucXVlcnkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJxdWVyeVwiLCBvcHRpb25zLnF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb21wdHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL3JlcG9zXCIsIHBhcmFtcywgKHJlcykgPT4gcmVzLnJlcG9zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb21wdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJvbXB0KHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vcmVwb3MvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImdldCBwcm9tcHRcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdC5yZXBvKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlcG87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc1B1YmxpYyAmJiAhc2V0dGluZ3MudGVuYW50X2hhbmRsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGEgcHVibGljIHByb21wdCB3aXRob3V0IGZpcnN0XFxuXG4gICAgICAgIGNyZWF0aW5nIGEgTGFuZ0NoYWluIEh1YiBoYW5kbGUuIFxuICAgICAgICBZb3UgY2FuIGFkZCBhIGhhbmRsZSBieSBjcmVhdGluZyBhIHB1YmxpYyBwcm9tcHQgYXQ6XFxuXG4gICAgICAgIGh0dHBzOi8vc21pdGgubGFuZ2NoYWluLmNvbS9wcm9tcHRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fb3duZXJDb25mbGljdEVycm9yKFwiY3JlYXRlIGEgcHJvbXB0XCIsIG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcmVwb19oYW5kbGU6IHByb21wdE5hbWUsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8uZGVzY3JpcHRpb24gJiYgeyBkZXNjcmlwdGlvbjogb3B0aW9ucy5kZXNjcmlwdGlvbiB9KSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5yZWFkbWUgJiYgeyByZWFkbWU6IG9wdGlvbnMucmVhZG1lIH0pLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LnRhZ3MgJiYgeyB0YWdzOiBvcHRpb25zLnRhZ3MgfSksXG4gICAgICAgICAgICBpc19wdWJsaWM6ICEhb3B0aW9ucz8uaXNQdWJsaWMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3JlcG9zL2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBwcm9tcHRcIik7XG4gICAgICAgIGNvbnN0IHsgcmVwbyB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVwbztcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ29tbWl0KHByb21wdElkZW50aWZpZXIsIG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLnByb21wdEV4aXN0cyhwcm9tcHRJZGVudGlmaWVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb21wdCBkb2VzIG5vdCBleGlzdCwgeW91IG11c3QgY3JlYXRlIGl0IGZpcnN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIF9dID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCByZXNvbHZlZFBhcmVudENvbW1pdEhhc2ggPSBvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoID09PSBcImxhdGVzdFwiIHx8ICFvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuX2dldExhdGVzdENvbW1pdEhhc2goYCR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gKVxuICAgICAgICAgICAgOiBvcHRpb25zPy5wYXJlbnRDb21taXRIYXNoO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgbWFuaWZlc3Q6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSksXG4gICAgICAgICAgICBwYXJlbnRfY29tbWl0OiByZXNvbHZlZFBhcmVudENvbW1pdEhhc2gsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L2NvbW1pdHMvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBjb21taXRcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb21wdFVybChgJHtvd25lcn0vJHtwcm9tcHROYW1lfSR7cmVzdWx0LmNvbW1pdF9oYXNoID8gYDoke3Jlc3VsdC5jb21taXRfaGFzaH1gIDogXCJcIn1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGV4YW1wbGVzIHdpdGggYXR0YWNobWVudHMgdXNpbmcgbXVsdGlwYXJ0IGZvcm0gZGF0YS5cbiAgICAgKiBAcGFyYW0gdXBkYXRlcyBMaXN0IG9mIEV4YW1wbGVVcGRhdGVXaXRoQXR0YWNobWVudHMgb2JqZWN0cyB0byB1cHNlcnRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHVwZGF0ZSByZXNwb25zZVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBkYXRlcyA9IFtdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwZGF0ZXMpO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGRhdGVzID0gW10pIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fZ2V0TXVsdGlQYXJ0U3VwcG9ydCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBMYW5nU21pdGggZGVwbG95bWVudCBkb2VzIG5vdCBhbGxvdyB1c2luZyB0aGUgbXVsdGlwYXJ0IGV4YW1wbGVzIGVuZHBvaW50LCBwbGVhc2UgdXBncmFkZSB5b3VyIGRlcGxveW1lbnQgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGV4YW1wbGUgb2YgdXBkYXRlcykge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUlkID0gZXhhbXBsZS5pZDtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIG1haW4gZXhhbXBsZSBib2R5XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlQm9keSA9IHtcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5tZXRhZGF0YSAmJiB7IG1ldGFkYXRhOiBleGFtcGxlLm1ldGFkYXRhIH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnNwbGl0ICYmIHsgc3BsaXQ6IGV4YW1wbGUuc3BsaXQgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQWRkIG1haW4gZXhhbXBsZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEV4YW1wbGUgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlQm9keSk7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZEV4YW1wbGVdLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChleGFtcGxlSWQsIGV4YW1wbGVCbG9iKTtcbiAgICAgICAgICAgIC8vIEFkZCBpbnB1dHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRJbnB1dHMgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlLmlucHV0cyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZElucHV0c10sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uaW5wdXRzYCwgaW5wdXRzQmxvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgb3V0cHV0cyBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRPdXRwdXRzID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZE91dHB1dHNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9Lm91dHB1dHNgLCBvdXRwdXRzQmxvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgYXR0YWNobWVudHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBhdHRhY2htZW50XSBvZiBPYmplY3QuZW50cmllcyhleGFtcGxlLmF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgW21pbWVUeXBlLCBkYXRhXSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSA9IGF0dGFjaG1lbnQubWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXR0YWNobWVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRCbG9iID0gbmV3IEJsb2IoW2RhdGFdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgJHttaW1lVHlwZX07IGxlbmd0aD0ke2RhdGEuYnl0ZUxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uYXR0YWNobWVudC4ke25hbWV9YCwgYXR0YWNobWVudEJsb2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleGFtcGxlLmF0dGFjaG1lbnRzX29wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEF0dGFjaG1lbnRzT3BlcmF0aW9ucyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUuYXR0YWNobWVudHNfb3BlcmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudHNPcGVyYXRpb25zQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZEF0dGFjaG1lbnRzT3BlcmF0aW9uc10sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uYXR0YWNobWVudHNfb3BlcmF0aW9uc2AsIGF0dGFjaG1lbnRzT3BlcmF0aW9uc0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJZFRvVXNlID0gZGF0YXNldElkID8/IHVwZGF0ZXNbMF0/LmRhdGFzZXRfaWQ7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbih0aGlzLmRlYnVnKSwgYCR7dGhpcy5hcGlVcmx9L3YxL3BsYXRmb3JtL2RhdGFzZXRzLyR7ZGF0YXNldElkVG9Vc2V9L2V4YW1wbGVzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkIGV4YW1wbGVzIHdpdGggYXR0YWNobWVudHMgdXNpbmcgbXVsdGlwYXJ0IGZvcm0gZGF0YS5cbiAgICAgKiBAcGFyYW0gdXBsb2FkcyBMaXN0IG9mIEV4YW1wbGVVcGxvYWRXaXRoQXR0YWNobWVudHMgb2JqZWN0cyB0byB1cGxvYWRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHVwbG9hZCByZXNwb25zZVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgTGFuZ1NtaXRoIHZlcnNpb25zLCBwbGVhc2UgdXNlIGBjcmVhdGVFeGFtcGxlc2AgaW5zdGVhZFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBsb2FkcyA9IFtdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwbG9hZHMpO1xuICAgIH1cbiAgICBhc3luYyBfdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGxvYWRzID0gW10pIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fZ2V0TXVsdGlQYXJ0U3VwcG9ydCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBMYW5nU21pdGggZGVwbG95bWVudCBkb2VzIG5vdCBhbGxvdyB1c2luZyB0aGUgbXVsdGlwYXJ0IGV4YW1wbGVzIGVuZHBvaW50LCBwbGVhc2UgdXBncmFkZSB5b3VyIGRlcGxveW1lbnQgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGV4YW1wbGUgb2YgdXBsb2Fkcykge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUlkID0gKGV4YW1wbGUuaWQgPz8gdXVpZC52NCgpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB0aGUgbWFpbiBleGFtcGxlIGJvZHlcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVCb2R5ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IGV4YW1wbGUuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5tZXRhZGF0YSAmJiB7IG1ldGFkYXRhOiBleGFtcGxlLm1ldGFkYXRhIH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnNwbGl0ICYmIHsgc3BsaXQ6IGV4YW1wbGUuc3BsaXQgfSksXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUuc291cmNlX3J1bl9pZCAmJiB7IHNvdXJjZV9ydW5faWQ6IGV4YW1wbGUuc291cmNlX3J1bl9pZCB9KSxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS51c2Vfc291cmNlX3J1bl9pbyAmJiB7XG4gICAgICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2lvOiBleGFtcGxlLnVzZV9zb3VyY2VfcnVuX2lvLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzICYmIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHM6IGV4YW1wbGUudXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQWRkIG1haW4gZXhhbXBsZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEV4YW1wbGUgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlQm9keSk7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZEV4YW1wbGVdLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChleGFtcGxlSWQsIGV4YW1wbGVCbG9iKTtcbiAgICAgICAgICAgIC8vIEFkZCBpbnB1dHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRJbnB1dHMgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlLmlucHV0cyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXRzQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZElucHV0c10sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uaW5wdXRzYCwgaW5wdXRzQmxvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgb3V0cHV0cyBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRPdXRwdXRzID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoZXhhbXBsZS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZE91dHB1dHNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9Lm91dHB1dHNgLCBvdXRwdXRzQmxvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgYXR0YWNobWVudHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBhdHRhY2htZW50XSBvZiBPYmplY3QuZW50cmllcyhleGFtcGxlLmF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgW21pbWVUeXBlLCBkYXRhXSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSA9IGF0dGFjaG1lbnQubWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXR0YWNobWVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRCbG9iID0gbmV3IEJsb2IoW2RhdGFdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgJHttaW1lVHlwZX07IGxlbmd0aD0ke2RhdGEuYnl0ZUxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uYXR0YWNobWVudC4ke25hbWV9YCwgYXR0YWNobWVudEJsb2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS92MS9wbGF0Zm9ybS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vZXhhbXBsZXNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGxvYWQgZXhhbXBsZXNcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9tcHQgZG9lcyBub3QgZXhpc3QsIHlvdSBtdXN0IGNyZWF0ZSBpdCBmaXJzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fb3duZXJDb25mbGljdEVycm9yKFwidXBkYXRlIGEgcHJvbXB0XCIsIG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmIChvcHRpb25zPy5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChvcHRpb25zPy5yZWFkbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQucmVhZG1lID0gb3B0aW9ucy5yZWFkbWU7XG4gICAgICAgIGlmIChvcHRpb25zPy50YWdzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXlsb2FkLnRhZ3MgPSBvcHRpb25zLnRhZ3M7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc1B1YmxpYyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5pc19wdWJsaWMgPSBvcHRpb25zLmlzUHVibGljO1xuICAgICAgICBpZiAob3B0aW9ucz8uaXNBcmNoaXZlZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5pc19hcmNoaXZlZCA9IG9wdGlvbnMuaXNBcmNoaXZlZDtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcGF5bG9hZCBpcyBlbXB0eVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGF5bG9hZCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCB1cGRhdGUgb3B0aW9ucyBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24odGhpcy5kZWJ1ZyksIGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBwcm9tcHRcIik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGRvZXMgbm90IGV4aXN0LCB5b3UgbXVzdCBjcmVhdGUgaXQgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuX293bmVyQ29uZmxpY3RFcnJvcihcImRlbGV0ZSBhIHByb21wdFwiLCBvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vcmVwb3MvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBwdWxsUHJvbXB0Q29tbWl0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBjb21taXRIYXNoXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpLCBgJHt0aGlzLmFwaVVybH0vY29tbWl0cy8ke293bmVyfS8ke3Byb21wdE5hbWV9LyR7Y29tbWl0SGFzaH0ke29wdGlvbnM/LmluY2x1ZGVNb2RlbCA/IFwiP2luY2x1ZGVfbW9kZWw9dHJ1ZVwiIDogXCJcIn1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwicHVsbCBwcm9tcHQgY29tbWl0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvd25lcixcbiAgICAgICAgICAgIHJlcG86IHByb21wdE5hbWUsXG4gICAgICAgICAgICBjb21taXRfaGFzaDogcmVzdWx0LmNvbW1pdF9oYXNoLFxuICAgICAgICAgICAgbWFuaWZlc3Q6IHJlc3VsdC5tYW5pZmVzdCxcbiAgICAgICAgICAgIGV4YW1wbGVzOiByZXN1bHQuZXhhbXBsZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgdXNlIGBpbXBvcnQgeyBwdWxsIH0gZnJvbSBcImxhbmdjaGFpbi9odWJcImAgaW5zdGVhZC5cbiAgICAgKiBVc2luZyB0aGlzIG1ldGhvZCBkaXJlY3RseSByZXR1cm5zIHRoZSBKU09OIHN0cmluZyBvZiB0aGUgcHJvbXB0IHJhdGhlciB0aGFuIGEgTGFuZ0NoYWluIG9iamVjdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF9wdWxsUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0T2JqZWN0ID0gYXdhaXQgdGhpcy5wdWxsUHJvbXB0Q29tbWl0KHByb21wdElkZW50aWZpZXIsIHtcbiAgICAgICAgICAgIGluY2x1ZGVNb2RlbDogb3B0aW9ucz8uaW5jbHVkZU1vZGVsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gSlNPTi5zdHJpbmdpZnkocHJvbXB0T2JqZWN0Lm1hbmlmZXN0KTtcbiAgICAgICAgcmV0dXJuIHByb21wdDtcbiAgICB9XG4gICAgYXN5bmMgcHVzaFByb21wdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvciB1cGRhdGUgcHJvbXB0IG1ldGFkYXRhXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLnByb21wdEV4aXN0cyhwcm9tcHRJZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgT2JqZWN0LmtleXMob3B0aW9ucykuc29tZSgoa2V5KSA9PiBrZXkgIT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVQcm9tcHQocHJvbXB0SWRlbnRpZmllciwge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogb3B0aW9ucz8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJlYWRtZTogb3B0aW9ucz8ucmVhZG1lLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiBvcHRpb25zPy50YWdzLFxuICAgICAgICAgICAgICAgICAgICBpc1B1YmxpYzogb3B0aW9ucz8uaXNQdWJsaWMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnM/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHJlYWRtZTogb3B0aW9ucz8ucmVhZG1lLFxuICAgICAgICAgICAgICAgIHRhZ3M6IG9wdGlvbnM/LnRhZ3MsXG4gICAgICAgICAgICAgICAgaXNQdWJsaWM6IG9wdGlvbnM/LmlzUHVibGljLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zPy5vYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRQcm9tcHRVcmwocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgY29tbWl0IHdpdGggdGhlIG5ldyBtYW5pZmVzdFxuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmNyZWF0ZUNvbW1pdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zPy5vYmplY3QsIHtcbiAgICAgICAgICAgIHBhcmVudENvbW1pdEhhc2g6IG9wdGlvbnM/LnBhcmVudENvbW1pdEhhc2gsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZSBhIHB1YmxpYyBkYXRhc2V0IHRvIHlvdXIgb3duIGxhbmdzbWl0aCB0ZW5hbnQuXG4gICAgICogVGhpcyBvcGVyYXRpb24gaXMgaWRlbXBvdGVudC4gSWYgeW91IGFscmVhZHkgaGF2ZSBhIGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgZG8gbm90aGluZy5cbiAgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuT3JVcmwgVGhlIHRva2VuIG9mIHRoZSBwdWJsaWMgZGF0YXNldCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgY2xvbmluZyB0aGUgZGF0YXNldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlQXBpVXJsXSBUaGUgVVJMIG9mIHRoZSBsYW5nc21pdGggc2VydmVyIHdoZXJlIHRoZSBkYXRhIGlzIGhvc3RlZC4gRGVmYXVsdHMgdG8gdGhlIEFQSSBVUkwgb2YgeW91ciBjdXJyZW50IGNsaWVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGF0YXNldE5hbWVdIFRoZSBuYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGNyZWF0ZSBpbiB5b3VyIHRlbmFudC4gRGVmYXVsdHMgdG8gdGhlIG5hbWUgb2YgdGhlIHB1YmxpYyBkYXRhc2V0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGNsb25lUHVibGljRGF0YXNldCh0b2tlbk9yVXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBzb3VyY2VBcGlVcmwgPSB0aGlzLmFwaVVybCwgZGF0YXNldE5hbWUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IFtwYXJzZWRBcGlVcmwsIHRva2VuVXVpZF0gPSB0aGlzLnBhcnNlVG9rZW5PclVybCh0b2tlbk9yVXJsLCBzb3VyY2VBcGlVcmwpO1xuICAgICAgICBjb25zdCBzb3VyY2VDbGllbnQgPSBuZXcgQ2xpZW50KHtcbiAgICAgICAgICAgIGFwaVVybDogcGFyc2VkQXBpVXJsLFxuICAgICAgICAgICAgLy8gUGxhY2Vob2xkZXIgQVBJIGtleSBub3QgbmVlZGVkIGFueW1vcmUgaW4gbW9zdCBjYXNlcywgYnV0XG4gICAgICAgICAgICAvLyBzb21lIHByaXZhdGUgZGVwbG95bWVudHMgbWF5IGhhdmUgQVBJIGtleS1iYXNlZCByYXRlIGxpbWl0aW5nXG4gICAgICAgICAgICAvLyB0aGF0IHdvdWxkIGNhdXNlIHRoaXMgdG8gZmFpbCBpZiB3ZSBwcm92aWRlIG5vIHZhbHVlLlxuICAgICAgICAgICAgYXBpS2V5OiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkcyA9IGF3YWl0IHNvdXJjZUNsaWVudC5yZWFkU2hhcmVkRGF0YXNldCh0b2tlblV1aWQpO1xuICAgICAgICBjb25zdCBmaW5hbERhdGFzZXROYW1lID0gZGF0YXNldE5hbWUgfHwgZHMubmFtZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChhd2FpdCB0aGlzLmhhc0RhdGFzZXQoeyBkYXRhc2V0SWQ6IGZpbmFsRGF0YXNldE5hbWUgfSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRGF0YXNldCAke2ZpbmFsRGF0YXNldE5hbWV9IGFscmVhZHkgZXhpc3RzIGluIHlvdXIgdGVuYW50LiBTa2lwcGluZy5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIC8vIGAuaGFzRGF0YXNldGAgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZGF0YXNldCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICAgIC8vIG5vLW9wIGluIHRoYXQgY2FzZVxuICAgICAgICB9XG4gICAgICAgIC8vIEZldGNoIGV4YW1wbGVzIGZpcnN0LCB0aGVuIGNyZWF0ZSB0aGUgZGF0YXNldFxuICAgICAgICBjb25zdCBleGFtcGxlcyA9IGF3YWl0IHNvdXJjZUNsaWVudC5saXN0U2hhcmVkRXhhbXBsZXModG9rZW5VdWlkKTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMuY3JlYXRlRGF0YXNldChmaW5hbERhdGFzZXROYW1lLCB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZHMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBkYXRhVHlwZTogZHMuZGF0YV90eXBlIHx8IFwia3ZcIixcbiAgICAgICAgICAgIGlucHV0c1NjaGVtYTogZHMuaW5wdXRzX3NjaGVtYV9kZWZpbml0aW9uID8/IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG91dHB1dHNTY2hlbWE6IGRzLm91dHB1dHNfc2NoZW1hX2RlZmluaXRpb24gPz8gdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlRXhhbXBsZXMoe1xuICAgICAgICAgICAgICAgIGlucHV0czogZXhhbXBsZXMubWFwKChlKSA9PiBlLmlucHV0cyksXG4gICAgICAgICAgICAgICAgb3V0cHV0czogZXhhbXBsZXMuZmxhdE1hcCgoZSkgPT4gKGUub3V0cHV0cyA/IFtlLm91dHB1dHNdIDogW10pKSxcbiAgICAgICAgICAgICAgICBkYXRhc2V0SWQ6IGRhdGFzZXQuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgY3JlYXRpbmcgZGF0YXNldCAke2ZpbmFsRGF0YXNldE5hbWV9LiBgICtcbiAgICAgICAgICAgICAgICBcIllvdSBzaG91bGQgZGVsZXRlIGl0IG1hbnVhbGx5LlwiKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VUb2tlbk9yVXJsKHVybE9yVG9rZW4sIGFwaVVybCwgbnVtUGFydHMgPSAyLCBraW5kID0gXCJkYXRhc2V0XCIpIHtcbiAgICAgICAgLy8gVHJ5IHBhcnNpbmcgYXMgVVVJRFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZCh1cmxPclRva2VuKTsgLy8gV2lsbCB0aHJvdyBpZiBpdCdzIG5vdCBhIFVVSUQuXG4gICAgICAgICAgICByZXR1cm4gW2FwaVVybCwgdXJsT3JUb2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIC8vIG5vLW9wIGlmIGl0J3Mgbm90IGEgdXVpZFxuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIGFzIFVSTFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmxPclRva2VuKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhQYXJ0cyA9IHBhcnNlZFVybC5wYXRobmFtZVxuICAgICAgICAgICAgICAgIC5zcGxpdChcIi9cIilcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0ICE9PSBcIlwiKTtcbiAgICAgICAgICAgIGlmIChwYXRoUGFydHMubGVuZ3RoID49IG51bVBhcnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5VdWlkID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSBudW1QYXJ0c107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthcGlVcmwsIHRva2VuVXVpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljICR7a2luZH0gVVJMOiAke3VybE9yVG9rZW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljICR7a2luZH0gVVJMIG9yIHRva2VuOiAke3VybE9yVG9rZW59YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXdhaXRzIGFsbCBwZW5kaW5nIHRyYWNlIGJhdGNoZXMuIFVzZWZ1bCBmb3IgZW52aXJvbm1lbnRzIHdoZXJlXG4gICAgICogeW91IG5lZWQgdG8gYmUgc3VyZSB0aGF0IGFsbCB0cmFjaW5nIHJlcXVlc3RzIGZpbmlzaCBiZWZvcmUgZXhlY3V0aW9uIGVuZHMsXG4gICAgICogc3VjaCBhcyBzZXJ2ZXJsZXNzIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcImxhbmdzbWl0aFwiO1xuICAgICAqXG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgICAqXG4gICAgICogdHJ5IHtcbiAgICAgKiAgIC8vIFRyYWNpbmcgaGFwcGVucyBoZXJlXG4gICAgICogICAuLi5cbiAgICAgKiB9IGZpbmFsbHkge1xuICAgICAqICAgYXdhaXQgY2xpZW50LmF3YWl0UGVuZGluZ1RyYWNlQmF0Y2hlcygpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYWxsIGN1cnJlbnRseSBwZW5kaW5nIHRyYWNlcyBoYXZlIHNlbnQuXG4gICAgICovXG4gICAgYXdhaXRQZW5kaW5nVHJhY2VCYXRjaGVzKCkge1xuICAgICAgICBpZiAodGhpcy5tYW51YWxGbHVzaE1vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOSU5HXTogV2hlbiB0cmFjaW5nIGluIG1hbnVhbCBmbHVzaCBtb2RlLCB5b3UgbXVzdCBjYWxsIGBhd2FpdCBjbGllbnQuZmx1c2goKWAgbWFudWFsbHkgdG8gc3VibWl0IHRyYWNlIGJhdGNoZXMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAuLi50aGlzLmF1dG9CYXRjaFF1ZXVlLml0ZW1zLm1hcCgoeyBpdGVtUHJvbWlzZSB9KSA9PiBpdGVtUHJvbWlzZSksXG4gICAgICAgICAgICB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyLnF1ZXVlLm9uSWRsZSgpLFxuICAgICAgICBdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0V4YW1wbGVDcmVhdGUoaW5wdXQpIHtcbiAgICByZXR1cm4gXCJkYXRhc2V0X2lkXCIgaW4gaW5wdXQgfHwgXCJkYXRhc2V0X25hbWVcIiBpbiBpbnB1dDtcbn1cbiIsICJleHBvcnQgeyBDbGllbnQsIH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5leHBvcnQgeyBSdW5UcmVlIH0gZnJvbSBcIi4vcnVuX3RyZWVzLmpzXCI7XG5leHBvcnQgeyBvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi9zaW5nbGV0b25zL2ZldGNoLmpzXCI7XG4vLyBVcGRhdGUgdXNpbmcgeWFybiBidW1wLXZlcnNpb25cbmV4cG9ydCBjb25zdCBfX3ZlcnNpb25fXyA9IFwiMC4zLjI1XCI7XG4iLCAiLy8gSW5saW5lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mbGV4ZGluZXNoL2Jyb3dzZXItb3Itbm9kZVxuaW1wb3J0IHsgX192ZXJzaW9uX18gfSBmcm9tIFwiLi4vaW5kZXguanNcIjtcbmxldCBnbG9iYWxFbnY7XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0IGNvbnN0IGlzV2ViV29ya2VyID0gKCkgPT4gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkRlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXCI7XG5leHBvcnQgY29uc3QgaXNKc0RvbSA9ICgpID0+ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYW1lID09PSBcIm5vZGVqc1wiKSB8fFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTm9kZS5qc1wiKSB8fFxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpKSk7XG4vLyBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uIHByb3ZpZGVzIGEgYERlbm9gIGdsb2JhbCBvYmplY3Rcbi8vIHdpdGhvdXQgYHZlcnNpb25gIHByb3BlcnR5XG5leHBvcnQgY29uc3QgaXNEZW5vID0gKCkgPT4gdHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCI7XG4vLyBNYXJrIG5vdC1hcy1ub2RlIGlmIGluIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb25cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAoKSA9PiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICFpc0Rlbm8oKTtcbmV4cG9ydCBjb25zdCBnZXRFbnYgPSAoKSA9PiB7XG4gICAgaWYgKGdsb2JhbEVudikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsRW52O1xuICAgIH1cbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJicm93c2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwibm9kZVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1dlYldvcmtlcigpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwid2Vid29ya2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSnNEb20oKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImpzZG9tXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVubygpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwiZGVub1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJvdGhlclwiO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsRW52O1xufTtcbmxldCBydW50aW1lRW52aXJvbm1lbnQ7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50KCkge1xuICAgIGlmIChydW50aW1lRW52aXJvbm1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbnYgPSBnZXRFbnYoKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZUVudiA9IGdldFNoYXMoKTtcbiAgICAgICAgcnVudGltZUVudmlyb25tZW50ID0ge1xuICAgICAgICAgICAgbGlicmFyeTogXCJsYW5nc21pdGhcIixcbiAgICAgICAgICAgIHJ1bnRpbWU6IGVudixcbiAgICAgICAgICAgIHNkazogXCJsYW5nc21pdGgtanNcIixcbiAgICAgICAgICAgIHNka192ZXJzaW9uOiBfX3ZlcnNpb25fXyxcbiAgICAgICAgICAgIC4uLnJlbGVhc2VFbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgTGFuZ0NoYWluLXNwZWNpZmljIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBTZW5zaXRpdmUga2V5cyAoY29udGFpbmluZyB0aGUgd29yZCBcImtleVwiLCBcInRva2VuXCIsIG9yIFwic2VjcmV0XCIpIGhhdmUgdGhlaXIgdmFsdWVzIHJlZGFjdGVkIGZvciBzZWN1cml0eS5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqICAtIEEgcmVjb3JkIG9mIExhbmdDaGFpbi1zcGVjaWZpYyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nQ2hhaW5FbnZWYXJzKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHx8IHt9O1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhbGxFbnZWYXJzKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJMQU5HQ0hBSU5fXCIpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZW52VmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZW52VmFycykge1xuICAgICAgICBpZiAoKGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpIHx8XG4gICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNlY3JldFwiKSB8fFxuICAgICAgICAgICAga2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0b2tlblwiKSkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlbnZWYXJzW2tleV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW52VmFyc1trZXldO1xuICAgICAgICAgICAgZW52VmFyc1trZXldID1cbiAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCAyKSArIFwiKlwiLnJlcGVhdCh2YWx1ZS5sZW5ndGggLSA0KSArIHZhbHVlLnNsaWNlKC0yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nQ2hhaW4tc3BlY2lmaWMgbWV0YWRhdGEgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ0NoYWluLXNwZWNpZmljIG1ldGFkYXRhIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBhbGxFbnZWYXJzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSB8fCB7fTtcbiAgICBjb25zdCBlbnZWYXJzID0ge307XG4gICAgY29uc3QgZXhjbHVkZWQgPSBbXG4gICAgICAgIFwiTEFOR0NIQUlOX0FQSV9LRVlcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9QUk9KRUNUXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1NFU1NJT05cIixcbiAgICAgICAgXCJMQU5HU01JVEhfQVBJX0tFWVwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9FTkRQT0lOVFwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR1NNSVRIX1BST0pFQ1RcIixcbiAgICAgICAgXCJMQU5HU01JVEhfU0VTU0lPTlwiLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRW52VmFycykpIHtcbiAgICAgICAgaWYgKChrZXkuc3RhcnRzV2l0aChcIkxBTkdDSEFJTl9cIikgfHwga2V5LnN0YXJ0c1dpdGgoXCJMQU5HU01JVEhfXCIpKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhZXhjbHVkZWQuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzZWNyZXRcIikgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkxBTkdDSEFJTl9SRVZJU0lPTl9JRFwiKSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1tcInJldmlzaW9uX2lkXCJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gb3BlcmF0ZSBpbiBhIHZhcmlldHkgb2YgSlMgZW52aXJvbm1lbnRzLFxuICogaW5jbHVkaW5nIE5vZGUuanMsIERlbm8sIGJyb3dzZXJzLCBldGMuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWR9XG4gKiAgLSBBIHJlY29yZCBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaWYgYXZhaWxhYmxlLlxuICogIC0gYHVuZGVmaW5lZGAgaWYgdGhlIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgb3IgYWxsb3dzIGFjY2VzcyB0byBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwcm9jZXNzLmVudikucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBicm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzLCB3ZSBtYXkgbm90IGhhdmUgZGlyZWN0IGFjY2VzcyB0byBlbnYgdmFyaWFibGVzXG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgb3IgYW55IG90aGVyIGZhbGxiYWNrIGFzIHJlcXVpcmVkLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDYXRjaCBhbnkgZXJyb3JzIHRoYXQgbWlnaHQgb2NjdXIgd2hpbGUgdHJ5aW5nIHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9od2NoYXNlMTcvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIHJldHVybiAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShgTEFOR1NNSVRIXyR7bmFtZX1gKSB8fFxuICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGBMQU5HQ0hBSU5fJHtuYW1lfWApKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICBwcm9jZXNzLmVudltuYW1lXSA9IHZhbHVlO1xuICAgIH1cbn1cbmxldCBjYWNoZWRDb21taXRTSEFzO1xuLyoqXG4gKiBHZXQgdGhlIEdpdCBjb21taXQgU0hBIGZyb20gY29tbW9uIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogdXNlZCBieSBkaWZmZXJlbnQgQ0kvQ0QgcGxhdGZvcm1zLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIEdpdCBjb21taXQgU0hBIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFzKCkge1xuICAgIGlmIChjYWNoZWRDb21taXRTSEFzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZENvbW1pdFNIQXM7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbl9yZWxlYXNlX2VudnMgPSBbXG4gICAgICAgIFwiVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiTkVYVF9QVUJMSUNfVkVSQ0VMX0dJVF9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ09NTUlUX1JFRlwiLFxuICAgICAgICBcIlJFTkRFUl9HSVRfQ09NTUlUXCIsXG4gICAgICAgIFwiQ0lfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIkNJUkNMRV9TSEExXCIsXG4gICAgICAgIFwiQ0ZfUEFHRVNfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIlJFQUNUX0FQUF9HSVRfU0hBXCIsXG4gICAgICAgIFwiU09VUkNFX1ZFUlNJT05cIixcbiAgICAgICAgXCJHSVRIVUJfU0hBXCIsXG4gICAgICAgIFwiVFJBVklTX0NPTU1JVFwiLFxuICAgICAgICBcIkdJVF9DT01NSVRcIixcbiAgICAgICAgXCJCVUlMRF9WQ1NfTlVNQkVSXCIsXG4gICAgICAgIFwiYmFtYm9vX3BsYW5SZXBvc2l0b3J5X3JldmlzaW9uXCIsXG4gICAgICAgIFwiQnVpbGQuU291cmNlVmVyc2lvblwiLFxuICAgICAgICBcIkJJVEJVQ0tFVF9DT01NSVRcIixcbiAgICAgICAgXCJEUk9ORV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiU0VNQVBIT1JFX0dJVF9TSEFcIixcbiAgICAgICAgXCJCVUlMREtJVEVfQ09NTUlUXCIsXG4gICAgXTtcbiAgICBjb25zdCBzaGFzID0ge307XG4gICAgZm9yIChjb25zdCBlbnYgb2YgY29tbW9uX3JlbGVhc2VfZW52cykge1xuICAgICAgICBjb25zdCBlbnZWYXIgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKGVudik7XG4gICAgICAgIGlmIChlbnZWYXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2hhc1tlbnZdID0gZW52VmFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlZENvbW1pdFNIQXMgPSBzaGFzO1xuICAgIHJldHVybiBzaGFzO1xufVxuIiwgImltcG9ydCB7IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbmV4cG9ydCBjb25zdCBpc1RyYWNpbmdFbmFibGVkID0gKHRyYWNpbmdFbmFibGVkKSA9PiB7XG4gICAgaWYgKHRyYWNpbmdFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNpbmdFbmFibGVkO1xuICAgIH1cbiAgICBjb25zdCBlbnZWYXJzID0gW1wiVFJBQ0lOR19WMlwiLCBcIlRSQUNJTkdcIl07XG4gICAgcmV0dXJuICEhZW52VmFycy5maW5kKChlbnZWYXIpID0+IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoZW52VmFyKSA9PT0gXCJ0cnVlXCIpO1xufTtcbiIsICJleHBvcnQgY29uc3QgX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSA9IFN5bWJvbC5mb3IoXCJsYzpjb250ZXh0X3ZhcmlhYmxlc1wiKTtcbiIsICJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRSdW50aW1lRW52aXJvbm1lbnQsIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmltcG9ydCB7IGlzVHJhY2luZ0VuYWJsZWQgfSBmcm9tIFwiLi9lbnYuanNcIjtcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSBcIi4vdXRpbHMvd2Fybi5qc1wiO1xuaW1wb3J0IHsgX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSB9IGZyb20gXCIuL3NpbmdsZXRvbnMvY29uc3RhbnRzLmpzXCI7XG5mdW5jdGlvbiBzdHJpcE5vbkFscGhhbnVtZXJpYyhpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bLTouXS9nLCBcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChlcG9jaCwgcnVuSWQsIGV4ZWN1dGlvbk9yZGVyID0gMSkge1xuICAgIC8vIERhdGUgb25seSBoYXMgbWlsbGlzZWNvbmQgcHJlY2lzaW9uLCBzbyB3ZSB1c2UgdGhlIG1pY3Jvc2Vjb25kcyB0byBicmVha1xuICAgIC8vIHBvc3NpYmxlIHRpZXMsIGF2b2lkaW5nIGluY29ycmVjdCBydW4gb3JkZXJcbiAgICBjb25zdCBwYWRkZWRPcmRlciA9IGV4ZWN1dGlvbk9yZGVyLnRvRml4ZWQoMCkuc2xpY2UoMCwgMykucGFkU3RhcnQoMywgXCIwXCIpO1xuICAgIHJldHVybiAoc3RyaXBOb25BbHBoYW51bWVyaWMoYCR7bmV3IERhdGUoZXBvY2gpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgLTEpfSR7cGFkZGVkT3JkZXJ9WmApICsgcnVuSWQpO1xufVxuLyoqXG4gKiBCYWdnYWdlIGhlYWRlciBpbmZvcm1hdGlvblxuICovXG5jbGFzcyBCYWdnYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSwgdGFncywgcHJvamVjdF9uYW1lKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJvamVjdF9uYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5wcm9qZWN0X25hbWUgPSBwcm9qZWN0X25hbWU7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGVhZGVyKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuICAgICAgICBsZXQgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgbGV0IHRhZ3MgPSBbXTtcbiAgICAgICAgbGV0IHByb2plY3RfbmFtZTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB1cmlWYWx1ZV0gPSBpdGVtLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHVyaVZhbHVlKTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwibGFuZ3NtaXRoLW1ldGFkYXRhXCIpIHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImxhbmdzbWl0aC10YWdzXCIpIHtcbiAgICAgICAgICAgICAgICB0YWdzID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImxhbmdzbWl0aC1wcm9qZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0X25hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJhZ2dhZ2UobWV0YWRhdGEsIHRhZ3MsIHByb2plY3RfbmFtZSk7XG4gICAgfVxuICAgIHRvSGVhZGVyKCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSAmJiBPYmplY3Qua2V5cyh0aGlzLm1ldGFkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBsYW5nc21pdGgtbWV0YWRhdGE9JHtlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkodGhpcy5tZXRhZGF0YSkpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRhZ3MgJiYgdGhpcy50YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYGxhbmdzbWl0aC10YWdzPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMudGFncy5qb2luKFwiLFwiKSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdF9uYW1lKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBsYW5nc21pdGgtcHJvamVjdD0ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLnByb2plY3RfbmFtZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zLmpvaW4oXCIsXCIpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdW5UcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbENvbmZpZykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bl90eXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3RfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJlbnRfcnVuXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoaWxkX3J1bnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhcnRfdGltZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmRfdGltZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleHRyYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcmlhbGl6ZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmZXJlbmNlX2V4YW1wbGVfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV2ZW50c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjZV9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb3R0ZWRfb3JkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2luZ0VuYWJsZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhlY3V0aW9uX29yZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoaWxkX2V4ZWN1dGlvbl9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNobWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBydW4uXG4gICAgICAgICAqIEVhY2ggZW50cnkgaXMgYSB0dXBsZSBvZiBbbWltZV90eXBlLCBieXRlc11cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF0dGFjaG1lbnRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHlvdSBwYXNzIGluIGEgcnVuIHRyZWUgZGlyZWN0bHksIHJldHVybiBhIHNoYWxsb3cgY2xvbmVcbiAgICAgICAgaWYgKGlzUnVuVHJlZShvcmlnaW5hbENvbmZpZykpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyAuLi5vcmlnaW5hbENvbmZpZyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gUnVuVHJlZS5nZXREZWZhdWx0Q29uZmlnKCk7XG4gICAgICAgIGNvbnN0IHsgbWV0YWRhdGEsIC4uLmNvbmZpZyB9ID0gb3JpZ2luYWxDb25maWc7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGNvbmZpZy5jbGllbnQgPz8gUnVuVHJlZS5nZXRTaGFyZWRDbGllbnQoKTtcbiAgICAgICAgY29uc3QgZGVkdXBlZE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5jb25maWc/LmV4dHJhPy5tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uZmlnLmV4dHJhID0geyAuLi5jb25maWcuZXh0cmEsIG1ldGFkYXRhOiBkZWR1cGVkTWV0YWRhdGEgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IC4uLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZywgY2xpZW50IH0pO1xuICAgICAgICBpZiAoIXRoaXMudHJhY2VfaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudF9ydW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlX2lkID0gdGhpcy5wYXJlbnRfcnVuLnRyYWNlX2lkID8/IHRoaXMuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlX2lkID0gdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4ZWN1dGlvbl9vcmRlciA/Pz0gMTtcbiAgICAgICAgdGhpcy5jaGlsZF9leGVjdXRpb25fb3JkZXIgPz89IDE7XG4gICAgICAgIGlmICghdGhpcy5kb3R0ZWRfb3JkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREb3R0ZWRPcmRlciA9IGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KHRoaXMuc3RhcnRfdGltZSwgdGhpcy5pZCwgdGhpcy5leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMuZG90dGVkX29yZGVyID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcnVuLmRvdHRlZF9vcmRlciArIFwiLlwiICsgY3VycmVudERvdHRlZE9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3R0ZWRfb3JkZXIgPSBjdXJyZW50RG90dGVkT3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdXVpZC52NCgpLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwiY2hhaW5cIixcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlBST0pFQ1RcIikgPz9cbiAgICAgICAgICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1NFU1NJT05cIikgPz8gLy8gVE9ETzogRGVwcmVjYXRlXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGFwaV91cmw6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIikgPz8gXCJodHRwOi8vbG9jYWxob3N0OjE5ODRcIixcbiAgICAgICAgICAgIGFwaV9rZXk6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fQVBJX0tFWVwiKSxcbiAgICAgICAgICAgIGNhbGxlcl9vcHRpb25zOiB7fSxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB7fSxcbiAgICAgICAgICAgIGlucHV0czoge30sXG4gICAgICAgICAgICBleHRyYToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaGFyZWRDbGllbnQoKSB7XG4gICAgICAgIGlmICghUnVuVHJlZS5zaGFyZWRDbGllbnQpIHtcbiAgICAgICAgICAgIFJ1blRyZWUuc2hhcmVkQ2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSdW5UcmVlLnNoYXJlZENsaWVudDtcbiAgICB9XG4gICAgY3JlYXRlQ2hpbGQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IHRoaXMuY2hpbGRfZXhlY3V0aW9uX29yZGVyICsgMTtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiB0aGlzLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZDogdGhpcy50cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcjogY2hpbGRfZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBjaGlsZF9leGVjdXRpb25fb3JkZXIsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDb3B5IGNvbnRleHQgdmFycyBvdmVyIGludG8gdGhlIG5ldyBydW4gdHJlZS5cbiAgICAgICAgaWYgKF9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkgaW4gdGhpcykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNoaWxkW19MQ19DT05URVhUX1ZBUklBQkxFU19LRVldID1cbiAgICAgICAgICAgICAgICB0aGlzW19MQ19DT05URVhUX1ZBUklBQkxFU19LRVldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IExDX0NISUxEID0gU3ltYm9sLmZvcihcImxjOmNoaWxkX2NvbmZpZ1wiKTtcbiAgICAgICAgY29uc3QgcHJlc2VudENvbmZpZyA9IGNvbmZpZy5leHRyYT8uW0xDX0NISUxEXSA/P1xuICAgICAgICAgICAgdGhpcy5leHRyYVtMQ19DSElMRF07XG4gICAgICAgIC8vIHRyYWNpbmcgZm9yIExhbmdDaGFpbiBpcyBkZWZpbmVkIGJ5IHRoZSBfcGFyZW50UnVuSWQgYW5kIHJ1bk1hcCBvZiB0aGUgdHJhY2VyXG4gICAgICAgIGlmIChpc1J1bm5hYmxlQ29uZmlnTGlrZShwcmVzZW50Q29uZmlnKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3Q29uZmlnID0geyAuLi5wcmVzZW50Q29uZmlnIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBpc0NhbGxiYWNrTWFuYWdlckxpa2UobmV3Q29uZmlnLmNhbGxiYWNrcylcbiAgICAgICAgICAgICAgICA/IG5ld0NvbmZpZy5jYWxsYmFja3MuY29weT8uKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhcmVudCBydW4gaWRcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNhbGxiYWNrcywgeyBfcGFyZW50UnVuSWQ6IGNoaWxkLmlkIH0pO1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgcG9wdWxhdGUgaWYgd2UncmUgaW4gYSBuZXdlciBMQy5KUyB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLmhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgID8uZmluZChpc0xhbmdDaGFpblRyYWNlckxpa2UpXG4gICAgICAgICAgICAgICAgICAgID8udXBkYXRlRnJvbVJ1blRyZWU/LihjaGlsZCk7XG4gICAgICAgICAgICAgICAgbmV3Q29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLmV4dHJhW0xDX0NISUxEXSA9IG5ld0NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wYWdhdGUgY2hpbGRfZXhlY3V0aW9uX29yZGVyIHVwd2FyZHNcbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsICYmICF2aXNpdGVkLmhhcyhjdXJyZW50LmlkKSkge1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoY3VycmVudC5pZCk7XG4gICAgICAgICAgICBjdXJyZW50LmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IE1hdGgubWF4KGN1cnJlbnQuY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBjaGlsZF9leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50X3J1bjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkX3J1bnMucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgYXN5bmMgZW5kKG91dHB1dHMsIGVycm9yLCBlbmRUaW1lID0gRGF0ZS5ub3coKSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gdGhpcy5vdXRwdXRzID8/IG91dHB1dHM7XG4gICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLmVycm9yID8/IGVycm9yO1xuICAgICAgICB0aGlzLmVuZF90aW1lID0gdGhpcy5lbmRfdGltZSA/PyBlbmRUaW1lO1xuICAgICAgICBpZiAobWV0YWRhdGEgJiYgT2JqZWN0LmtleXMobWV0YWRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmEgPSB0aGlzLmV4dHJhXG4gICAgICAgICAgICAgICAgPyB7IC4uLnRoaXMuZXh0cmEsIG1ldGFkYXRhOiB7IC4uLnRoaXMuZXh0cmEubWV0YWRhdGEsIC4uLm1ldGFkYXRhIH0gfVxuICAgICAgICAgICAgICAgIDogeyBtZXRhZGF0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb252ZXJ0VG9DcmVhdGUocnVuLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBydW5FeHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICAgICAgaWYgKCFydW5FeHRyYS5ydW50aW1lKSB7XG4gICAgICAgICAgICBydW5FeHRyYS5ydW50aW1lID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bnRpbWVFbnYpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHJ1bnRpbWVFbnYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW5FeHRyYS5ydW50aW1lW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWVba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRfcnVucztcbiAgICAgICAgbGV0IHBhcmVudF9ydW5faWQ7XG4gICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgY2hpbGRfcnVucyA9IHJ1bi5jaGlsZF9ydW5zLm1hcCgoY2hpbGRfcnVuKSA9PiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUoY2hpbGRfcnVuLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zKSk7XG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50X3J1bl9pZCA9IHJ1bi5wYXJlbnRfcnVuPy5pZDtcbiAgICAgICAgICAgIGNoaWxkX3J1bnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZXJzaXN0ZWRSdW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuLm5hbWUsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSxcbiAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bi5yZWZlcmVuY2VfZXhhbXBsZV9pZCxcbiAgICAgICAgICAgIGV4dHJhOiBydW5FeHRyYSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHJ1bi5zZXJpYWxpemVkLFxuICAgICAgICAgICAgZXJyb3I6IHJ1bi5lcnJvcixcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHM6IHJ1bi5vdXRwdXRzLFxuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiBydW4ucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogY2hpbGRfcnVucyxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudF9ydW5faWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogcnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBydW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MsXG4gICAgICAgICAgICBhdHRhY2htZW50czogcnVuLmF0dGFjaG1lbnRzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGVyc2lzdGVkUnVuO1xuICAgIH1cbiAgICBhc3luYyBwb3N0UnVuKGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydW50aW1lRW52ID0gZ2V0UnVudGltZUVudmlyb25tZW50KCk7XG4gICAgICAgICAgICBjb25zdCBydW5DcmVhdGUgPSBhd2FpdCB0aGlzLl9jb252ZXJ0VG9DcmVhdGUodGhpcywgcnVudGltZUVudiwgdHJ1ZSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5jcmVhdGVSdW4ocnVuQ3JlYXRlKTtcbiAgICAgICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgICAgIHdhcm5PbmNlKFwiUG9zdGluZyB3aXRoIGV4Y2x1ZGVDaGlsZFJ1bnM9ZmFsc2UgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXCIpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGRSdW4gb2YgdGhpcy5jaGlsZF9ydW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNoaWxkUnVuLnBvc3RSdW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHBvc3RSdW4gZm9yIHJ1biAke3RoaXMuaWR9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXRjaFJ1bigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1blVwZGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBlbmRfdGltZTogdGhpcy5lbmRfdGltZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5lcnJvcixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cyxcbiAgICAgICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiB0aGlzLnBhcmVudF9ydW4/LmlkLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiB0aGlzLnJlZmVyZW5jZV9leGFtcGxlX2lkLFxuICAgICAgICAgICAgICAgIGV4dHJhOiB0aGlzLmV4dHJhLFxuICAgICAgICAgICAgICAgIGV2ZW50czogdGhpcy5ldmVudHMsXG4gICAgICAgICAgICAgICAgZG90dGVkX29yZGVyOiB0aGlzLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgICAgICB0cmFjZV9pZDogdGhpcy50cmFjZV9pZCxcbiAgICAgICAgICAgICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IHRoaXMuYXR0YWNobWVudHMsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4odGhpcy5pZCwgcnVuVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHBhdGNoUnVuIGZvciBydW4gJHt0aGlzLmlkfWAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUodGhpcywgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCB0byB0aGUgcnVuIHRyZWUuXG4gICAgICogQHBhcmFtIGV2ZW50IC0gQSBzaW5nbGUgZXZlbnQgb3Igc3RyaW5nIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJldmVudFwiLFxuICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBldmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICAgICAgdGltZTogZXZlbnQudGltZSA/PyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJ1bm5hYmxlQ29uZmlnKHBhcmVudENvbmZpZywgcHJvcHMpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYW5kbGUgdGhlIGNhbGxiYWNrIG1hbmFnZXIgY2FzZSBmb3Igbm93XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlciA9IHBhcmVudENvbmZpZz8uY2FsbGJhY2tzO1xuICAgICAgICBsZXQgcGFyZW50UnVuO1xuICAgICAgICBsZXQgcHJvamVjdE5hbWU7XG4gICAgICAgIGxldCBjbGllbnQ7XG4gICAgICAgIGxldCB0cmFjaW5nRW5hYmxlZCA9IGlzVHJhY2luZ0VuYWJsZWQoKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UnVuSWQgPSBjYWxsYmFja01hbmFnZXI/LmdldFBhcmVudFJ1bklkPy4oKSA/PyBcIlwiO1xuICAgICAgICAgICAgY29uc3QgbGFuZ0NoYWluVHJhY2VyID0gY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVycz8uZmluZCgoaGFuZGxlcikgPT4gaGFuZGxlcj8ubmFtZSA9PSBcImxhbmdjaGFpbl90cmFjZXJcIik7XG4gICAgICAgICAgICBwYXJlbnRSdW4gPSBsYW5nQ2hhaW5UcmFjZXI/LmdldFJ1bj8uKHBhcmVudFJ1bklkKTtcbiAgICAgICAgICAgIHByb2plY3ROYW1lID0gbGFuZ0NoYWluVHJhY2VyPy5wcm9qZWN0TmFtZTtcbiAgICAgICAgICAgIGNsaWVudCA9IGxhbmdDaGFpblRyYWNlcj8uY2xpZW50O1xuICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQgPSB0cmFjaW5nRW5hYmxlZCB8fCAhIWxhbmdDaGFpblRyYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudFJ1bikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBwcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1blRyZWUgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICBuYW1lOiBwYXJlbnRSdW4ubmFtZSxcbiAgICAgICAgICAgIGlkOiBwYXJlbnRSdW4uaWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogcGFyZW50UnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBwYXJlbnRSdW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQsXG4gICAgICAgICAgICBwcm9qZWN0X25hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgdGFnczogW1xuICAgICAgICAgICAgICAgIC4uLm5ldyBTZXQoKHBhcmVudFJ1bj8udGFncyA/PyBbXSkuY29uY2F0KHBhcmVudENvbmZpZz8udGFncyA/PyBbXSkpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyZW50UnVuPy5leHRyYT8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcmVudENvbmZpZz8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyZW50UnVuVHJlZS5jcmVhdGVDaGlsZChwcm9wcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRG90dGVkT3JkZXIoZG90dGVkT3JkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUhlYWRlcnMoeyBcImxhbmdzbWl0aC10cmFjZVwiOiBkb3R0ZWRPcmRlciB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZWFkZXJzKGhlYWRlcnMsIGluaGVyaXRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHJhd0hlYWRlcnMgPSBcImdldFwiIGluIGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMuZ2V0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIFwibGFuZ3NtaXRoLXRyYWNlXCI6IGhlYWRlcnMuZ2V0KFwibGFuZ3NtaXRoLXRyYWNlXCIpLFxuICAgICAgICAgICAgICAgIGJhZ2dhZ2U6IGhlYWRlcnMuZ2V0KFwiYmFnZ2FnZVwiKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogaGVhZGVycztcbiAgICAgICAgY29uc3QgaGVhZGVyVHJhY2UgPSByYXdIZWFkZXJzW1wibGFuZ3NtaXRoLXRyYWNlXCJdO1xuICAgICAgICBpZiAoIWhlYWRlclRyYWNlIHx8IHR5cGVvZiBoZWFkZXJUcmFjZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBhcmVudERvdHRlZE9yZGVyID0gaGVhZGVyVHJhY2UudHJpbSgpO1xuICAgICAgICBjb25zdCBwYXJzZWREb3R0ZWRPcmRlciA9IHBhcmVudERvdHRlZE9yZGVyLnNwbGl0KFwiLlwiKS5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtzdHJUaW1lLCB1dWlkXSA9IHBhcnQuc3BsaXQoXCJaXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RyVGltZSwgdGltZTogRGF0ZS5wYXJzZShzdHJUaW1lICsgXCJaXCIpLCB1dWlkIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFjZUlkID0gcGFyc2VkRG90dGVkT3JkZXJbMF0udXVpZDtcbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgLi4uaW5oZXJpdEFyZ3MsXG4gICAgICAgICAgICBuYW1lOiBpbmhlcml0QXJncz8uW1wibmFtZVwiXSA/PyBcInBhcmVudFwiLFxuICAgICAgICAgICAgcnVuX3R5cGU6IGluaGVyaXRBcmdzPy5bXCJydW5fdHlwZVwiXSA/PyBcImNoYWluXCIsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBpbmhlcml0QXJncz8uW1wic3RhcnRfdGltZVwiXSA/PyBEYXRlLm5vdygpLFxuICAgICAgICAgICAgaWQ6IHBhcnNlZERvdHRlZE9yZGVyLmF0KC0xKT8udXVpZCxcbiAgICAgICAgICAgIHRyYWNlX2lkOiB0cmFjZUlkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBwYXJlbnREb3R0ZWRPcmRlcixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJhd0hlYWRlcnNbXCJiYWdnYWdlXCJdICYmIHR5cGVvZiByYXdIZWFkZXJzW1wiYmFnZ2FnZVwiXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgYmFnZ2FnZSA9IEJhZ2dhZ2UuZnJvbUhlYWRlcihyYXdIZWFkZXJzW1wiYmFnZ2FnZVwiXSk7XG4gICAgICAgICAgICBjb25maWcubWV0YWRhdGEgPSBiYWdnYWdlLm1ldGFkYXRhO1xuICAgICAgICAgICAgY29uZmlnLnRhZ3MgPSBiYWdnYWdlLnRhZ3M7XG4gICAgICAgICAgICBjb25maWcucHJvamVjdF9uYW1lID0gYmFnZ2FnZS5wcm9qZWN0X25hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSdW5UcmVlKGNvbmZpZyk7XG4gICAgfVxuICAgIHRvSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIFwibGFuZ3NtaXRoLXRyYWNlXCI6IHRoaXMuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgYmFnZ2FnZTogbmV3IEJhZ2dhZ2UodGhpcy5leHRyYT8ubWV0YWRhdGEsIHRoaXMudGFncywgdGhpcy5wcm9qZWN0X25hbWUpLnRvSGVhZGVyKCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUnVuVHJlZSwgXCJzaGFyZWRDbGllbnRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBudWxsXG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpc1J1blRyZWUoeCkge1xuICAgIHJldHVybiAoeCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiB4LmNyZWF0ZUNoaWxkID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIHgucG9zdFJ1biA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGlzTGFuZ0NoYWluVHJhY2VyTGlrZSh4KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB4ICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHgubmFtZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICB4Lm5hbWUgPT09IFwibGFuZ2NoYWluX3RyYWNlclwiKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZSh4KSB7XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHgpICYmIHguc29tZSgoY2FsbGJhY2spID0+IGlzTGFuZ0NoYWluVHJhY2VyTGlrZShjYWxsYmFjaykpKTtcbn1cbmZ1bmN0aW9uIGlzQ2FsbGJhY2tNYW5hZ2VyTGlrZSh4KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB4ICE9IG51bGwgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh4LmhhbmRsZXJzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSdW5uYWJsZUNvbmZpZ0xpa2UoeCkge1xuICAgIC8vIENoZWNrIHRoYXQgaXQncyBhbiBvYmplY3Qgd2l0aCBhIGNhbGxiYWNrcyBhcmdcbiAgICAvLyB0aGF0IGhhcyBlaXRoZXIgYSBDYWxsYmFja01hbmFnZXJMaWtlIG9iamVjdCB3aXRoIGEgbGFuZ2NoYWluIHRyYWNlciB3aXRoaW4gaXRcbiAgICAvLyBvciBhbiBhcnJheSB3aXRoIGEgTGFuZ0NoYWluVHJhY2VyTGlrZSBvYmplY3Qgd2l0aGluIGl0XG4gICAgcmV0dXJuICh4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIHguY2FsbGJhY2tzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIC8vIENhbGxiYWNrIG1hbmFnZXIgd2l0aCBhIGxhbmdjaGFpbiB0cmFjZXJcbiAgICAgICAgKGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZSh4LmNhbGxiYWNrcz8uaGFuZGxlcnMpIHx8XG4gICAgICAgICAgICAvLyBPciBpdCdzIGFuIGFycmF5IHdpdGggYSBMYW5nQ2hhaW5UcmFjZXJMaWtlIG9iamVjdCB3aXRoaW4gaXRcbiAgICAgICAgICAgIGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZSh4LmNhbGxiYWNrcykpKTtcbn1cbiIsICJpbXBvcnQgeyBpc1J1blRyZWUgfSBmcm9tIFwiLi4vcnVuX3RyZWVzLmpzXCI7XG5jbGFzcyBNb2NrQXN5bmNMb2NhbFN0b3JhZ2Uge1xuICAgIGdldFN0b3JlKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBydW4oXywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuY29uc3QgVFJBQ0lOR19BTFNfS0VZID0gU3ltYm9sLmZvcihcImxzOnRyYWNpbmdfYXN5bmNfbG9jYWxfc3RvcmFnZVwiKTtcbmNvbnN0IG1vY2tBc3luY0xvY2FsU3RvcmFnZSA9IG5ldyBNb2NrQXN5bmNMb2NhbFN0b3JhZ2UoKTtcbmNsYXNzIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXIge1xuICAgIGdldEluc3RhbmNlKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldID8/IG1vY2tBc3luY0xvY2FsU3RvcmFnZTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGlmIChnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlcigpO1xuLyoqXG4gKiBSZXR1cm4gdGhlIGN1cnJlbnQgcnVuIHRyZWUgZnJvbSB3aXRoaW4gYSB0cmFjZWFibGUtd3JhcHBlZCBmdW5jdGlvbi5cbiAqIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgY2FsbGVkIG91dHNpZGUgb2YgYSB0cmFjZWFibGUgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybnMgVGhlIHJ1biB0cmVlIGZvciB0aGUgZ2l2ZW4gY29udGV4dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRSdW5UcmVlID0gKCkgPT4ge1xuICAgIGNvbnN0IHJ1blRyZWUgPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLmdldEluc3RhbmNlKCkuZ2V0U3RvcmUoKTtcbiAgICBpZiAoIWlzUnVuVHJlZShydW5UcmVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoW1xuICAgICAgICAgICAgXCJDb3VsZCBub3QgZ2V0IHRoZSBjdXJyZW50IHJ1biB0cmVlLlwiLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIFwiUGxlYXNlIG1ha2Ugc3VyZSB5b3UgYXJlIGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aGluIGEgdHJhY2VhYmxlIGZ1bmN0aW9uIGFuZCB0aGF0IHRyYWNpbmcgaXMgZW5hYmxlZC5cIixcbiAgICAgICAgXS5qb2luKFwiXFxuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1blRyZWU7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiB3aXRoUnVuVHJlZShydW5UcmVlLCBmbikge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLmdldEluc3RhbmNlKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc3RvcmFnZS5ydW4ocnVuVHJlZSwgKCkgPT4gdm9pZCBQcm9taXNlLnJlc29sdmUoZm4oKSkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBST09UID0gU3ltYm9sLmZvcihcImxhbmdzbWl0aDp0cmFjZWFibGU6cm9vdFwiKTtcbmV4cG9ydCBmdW5jdGlvbiBpc1RyYWNlYWJsZUZ1bmN0aW9uKHhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiAmJiBcImxhbmdzbWl0aDp0cmFjZWFibGVcIiBpbiB4O1xufVxuIiwgIi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgeyBQYXRjaEVycm9yLCBfZGVlcENsb25lLCBpc0ludGVnZXIsIHVuZXNjYXBlUGF0aENvbXBvbmVudCwgaGFzVW5kZWZpbmVkLCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbmV4cG9ydCBjb25zdCBKc29uUGF0Y2hFcnJvciA9IFBhdGNoRXJyb3I7XG5leHBvcnQgY29uc3QgZGVlcENsb25lID0gX2RlZXBDbG9uZTtcbi8qIFdlIHVzZSBhIEphdmFzY3JpcHQgaGFzaCB0byBzdG9yZSBlYWNoXG4gZnVuY3Rpb24uIEVhY2ggaGFzaCBlbnRyeSAocHJvcGVydHkpIHVzZXNcbiB0aGUgb3BlcmF0aW9uIGlkZW50aWZpZXJzIHNwZWNpZmllZCBpbiByZmM2OTAyLlxuIEluIHRoaXMgd2F5LCB3ZSBjYW4gbWFwIGVhY2ggcGF0Y2ggb3BlcmF0aW9uXG4gdG8gaXRzIGRlZGljYXRlZCBmdW5jdGlvbiBpbiBlZmZpY2llbnQgd2F5LlxuICovXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIG9iamVjdCAqL1xuY29uc3Qgb2JqT3BzID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICBtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIC8qIGluIGNhc2UgbW92ZSB0YXJnZXQgb3ZlcndyaXRlcyBhbiBleGlzdGluZyB2YWx1ZSxcbiAgICAgICAgcmV0dXJuIHRoZSByZW1vdmVkIHZhbHVlLCB0aGlzIGNhbiBiZSB0YXhpbmcgcGVyZm9ybWFuY2Utd2lzZSxcbiAgICAgICAgYW5kIGlzIHBvdGVudGlhbGx5IHVubmVlZGVkICovXG4gICAgICAgIGxldCByZW1vdmVkID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMucGF0aCk7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICByZW1vdmVkID0gX2RlZXBDbG9uZShyZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5mcm9tLFxuICAgICAgICB9KS5yZW1vdmVkO1xuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgY29weTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZVRvQ29weSA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLmZyb20pO1xuICAgICAgICAvLyBlbmZvcmNlIGNvcHkgYnkgdmFsdWUgc28gZnVydGhlciBvcGVyYXRpb25zIGRvbid0IGFmZmVjdCBzb3VyY2UgKHNlZSBpc3N1ZSAjMTc3KVxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZSh2YWx1ZVRvQ29weSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCB0ZXN0OiBfYXJlRXF1YWxzKG9ialtrZXldLCB0aGlzLnZhbHVlKSB9O1xuICAgIH0sXG4gICAgX2dldDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG59O1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBhcnJheS4gTWFueSBhcmUgdGhlIHNhbWUgYXMgZm9yIHRoZSBvYmplY3QgKi9cbnZhciBhcnJPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoaXNJbnRlZ2VyKGkpKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKGksIDAsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYXJyYXkgcHJvcHNcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBtYXkgYmUgbmVlZGVkIHdoZW4gdXNpbmcgJy0nIGluIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgaW5kZXg6IGkgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWRMaXN0ID0gYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkTGlzdFswXSB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBhcnJbaV07XG4gICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogb2JqT3BzLm1vdmUsXG4gICAgY29weTogb2JqT3BzLmNvcHksXG4gICAgdGVzdDogb2JqT3BzLnRlc3QsXG4gICAgX2dldDogb2JqT3BzLl9nZXQsXG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIGEgSlNPTiBkb2N1bWVudCBieSBhIEpTT04gcG9pbnRlci5cbiAqIFJldHVybnMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tXG4gKiBAcGFyYW0gcG9pbnRlciBhbiBlc2NhcGVkIEpTT04gcG9pbnRlclxuICogQHJldHVybiBUaGUgcmV0cmlldmVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgcG9pbnRlcikge1xuICAgIGlmIChwb2ludGVyID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbiA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBwb2ludGVyIH07XG4gICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGdldE9yaWdpbmFsRGVzdGluYXRpb24pO1xuICAgIHJldHVybiBnZXRPcmlnaW5hbERlc3RpbmF0aW9uLnZhbHVlO1xufVxuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIG9wZXJhdGlvbi5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIGFuZCBgb3BlcmF0aW9uYCBvYmplY3RzIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cbiAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGF2b2lkIHRvdWNoaW5nIHlvdXIgdmFsdWVzLCBjbG9uZSB0aGVtOlxuICogYGpzb25wYXRjaC5hcHBseU9wZXJhdGlvbihkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUob3BlcmF0aW9uKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbiwgdmFsaWRhdGVPcGVyYXRpb24gPSBmYWxzZSwgbXV0YXRlRG9jdW1lbnQgPSB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZSwgaW5kZXggPSAwKSB7XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBvcGVyYXRpb24ucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iob3BlcmF0aW9uLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBST09UIE9QRVJBVElPTlMgKi9cbiAgICBpZiAob3BlcmF0aW9uLnBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgbGV0IHJldHVyblZhbHVlID0geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7IC8vZG9jdW1lbnQgd2UgcmVtb3ZlZFxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIgfHwgb3BlcmF0aW9uLm9wID09PSBcImNvcHlcIikge1xuICAgICAgICAgICAgLy8gaXQncyBhIG1vdmUgb3IgY29weSB0byByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBvcGVyYXRpb24uZnJvbSk7IC8vIGdldCB0aGUgdmFsdWUgYnkganNvbi1wb2ludGVyIGluIGBmcm9tYCBmaWVsZFxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBvcnQgcmVtb3ZlZCBpdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnRlc3QgPSBfYXJlRXF1YWxzKGRvY3VtZW50LCBvcGVyYXRpb24udmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsIFwiVEVTVF9PUEVSQVRJT05fRkFJTEVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICAvLyBhIHJlbW92ZSBvbiByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIl9nZXRcIikge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBiYWQgb3BlcmF0aW9uICovXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLyogRU5EIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IF9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBvcGVyYXRpb24ucGF0aCB8fCBcIlwiO1xuICAgICAgICBjb25zdCBrZXlzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvYmogPSBkb2N1bWVudDtcbiAgICAgICAgbGV0IHQgPSAxOyAvL3NraXAgZW1wdHkgZWxlbWVudCAtIGh0dHA6Ly9qc3BlcmYuY29tL3RvLXNoaWZ0LW9yLW5vdC10by1zaGlmdFxuICAgICAgICBsZXQgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGxldCBleGlzdGluZ1BhdGhGcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgbGV0IHZhbGlkYXRlRnVuY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdGVPcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW3RdO1xuICAgICAgICAgICAgaWYgKGtleSAmJiBrZXkuaW5kZXhPZihcIn5cIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB1bmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zICYmXG4gICAgICAgICAgICAgICAgKGtleSA9PSBcIl9fcHJvdG9fX1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIChrZXkgPT0gXCJwcm90b3R5cGVcIiAmJiB0ID4gMCAmJiBrZXlzW3QgLSAxXSA9PSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJKU09OLVBhdGNoOiBtb2RpZnlpbmcgYF9fcHJvdG9fX2Agb3IgYGNvbnN0cnVjdG9yL3Byb3RvdHlwZWAgcHJvcCBpcyBiYW5uZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGlmIHRoaXMgd2FzIG9uIHB1cnBvc2UsIHBsZWFzZSBzZXQgYGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnNgIGZsYWcgZmFsc2UgYW5kIHBhc3MgaXQgdG8gdGhpcyBmdW5jdGlvbi4gTW9yZSBpbmZvIGluIGZhc3QtanNvbi1wYXRjaCBSRUFETUVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBrZXlzLnNsaWNlKDAsIHQpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gb2JqLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiAhaXNJbnRlZ2VyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkV4cGVjdGVkIGFuIHVuc2lnbmVkIGJhc2UtMTAgaW50ZWdlciB2YWx1ZSwgbWFraW5nIHRoZSBuZXcgcmVmZXJlbmNlZCB2YWx1ZSB0aGUgYXJyYXkgZWxlbWVudCB3aXRoIHRoZSB6ZXJvLWJhc2VkIGluZGV4XCIsIFwiT1BFUkFUSU9OX1BBVEhfSUxMRUdBTF9BUlJBWV9JTkRFWFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gb25seSBwYXJzZSBrZXkgd2hlbiBpdCdzIGFuIGludGVnZXIgZm9yIGBhcnIucHJvcGAgdG8gd29ya1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ludGVnZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gfn5rZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiBvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgJiYga2V5ID4gb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGhlIHNwZWNpZmllZCBpbmRleCBNVVNUIE5PVCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcIiwgXCJPUEVSQVRJT05fVkFMVUVfT1VUX09GX0JPVU5EU1wiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBhcnJPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBrZXlzIGluIHRoZSBwYXRoLCBidXQgdGhlIG5leHQgdmFsdWUgaXNuJ3QgYSBub24tbnVsbCBvYmplY3QsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUgZXJyb3IgaW5zdGVhZCBvZiBpdGVyYXRpbmcgYWdhaW4uXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgdCA8IGxlbiAmJiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQXBwbHkgYSBmdWxsIEpTT04gUGF0Y2ggYXJyYXkgb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBwYXRjaC5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIG9iamVjdCBhbmQgYHBhdGNoYCAtIGl0IGdldHMgdGhlIHZhbHVlcyBieSByZWZlcmVuY2UuXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcbiAqIGBqc29ucGF0Y2guYXBwbHlQYXRjaChkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUocGF0Y2gpKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIHBhdGNoIFRoZSBwYXRjaCB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIHBhdGNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50ID0gdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWUpIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheVwiLCBcIlNFUVVFTkNFX05PVF9BTl9BUlJBWVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gX2RlZXBDbG9uZShkb2N1bWVudCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkocGF0Y2gubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcGF0Y2gubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG11dGF0ZURvY3VtZW50IGFyZ3VtZW50IGJlY2F1c2UgaWYgaXQgd2FzIHRydWUsIHdlIGFscmVhZHkgZGVlcCBjbG9uZWQgdGhlIG9iamVjdCwgd2UnbGwganVzdCBwYXNzIGB0cnVlYFxuICAgICAgICByZXN1bHRzW2ldID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHBhdGNoW2ldLCB2YWxpZGF0ZU9wZXJhdGlvbiwgdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucywgaSk7XG4gICAgICAgIGRvY3VtZW50ID0gcmVzdWx0c1tpXS5uZXdEb2N1bWVudDsgLy8gaW4gY2FzZSByb290IHdhcyByZXBsYWNlZFxuICAgIH1cbiAgICByZXN1bHRzLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHVwZGF0ZWQgZG9jdW1lbnQuXG4gKiBTdWl0YWJsZSBhcyBhIHJlZHVjZXIuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcmV0dXJuIFRoZSB1cGRhdGVkIGRvY3VtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlZHVjZXIoZG9jdW1lbnQsIG9wZXJhdGlvbiwgaW5kZXgpIHtcbiAgICBjb25zdCBvcGVyYXRpb25SZXN1bHQgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uKTtcbiAgICBpZiAob3BlcmF0aW9uUmVzdWx0LnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGZhaWxlZCB0ZXN0XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25SZXN1bHQubmV3RG9jdW1lbnQ7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvbiAtIG9wZXJhdGlvbiBvYmplY3QgKHBhdGNoKVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4aXN0aW5nUGF0aEZyYWdtZW50XSAtIGNvbWVzIGFsb25nIHdpdGggYGRvY3VtZW50YFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdG9yKG9wZXJhdGlvbiwgaW5kZXgsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCkge1xuICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9uICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgIG9wZXJhdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KG9wZXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGlzIG5vdCBhbiBvYmplY3RcIiwgXCJPUEVSQVRJT05fTk9UX0FOX09CSkVDVFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvYmpPcHNbb3BlcmF0aW9uLm9wXSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wZXJhdGlvbi5wYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgaXMgbm90IGEgc3RyaW5nXCIsIFwiT1BFUkFUSU9OX1BBVEhfSU5WQUxJRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmluZGV4T2YoXCIvXCIpICE9PSAwICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gcGF0aHMgdGhhdCBhcmVuJ3QgZW1wdHkgc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIFwiL1wiXG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBtdXN0IHN0YXJ0IHdpdGggXCIvXCInLCBcIk9QRVJBVElPTl9QQVRIX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSAmJlxuICAgICAgICB0eXBlb2Ygb3BlcmF0aW9uLmZyb20gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9GUk9NX1JFUVVJUkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpICYmXG4gICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9WQUxVRV9SRVFVSVJFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgfHxcbiAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwidGVzdFwiKSAmJlxuICAgICAgICBoYXNVbmRlZmluZWQob3BlcmF0aW9uLnZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucylcIiwgXCJPUEVSQVRJT05fVkFMVUVfQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PSBcImFkZFwiKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExlbiA9IG9wZXJhdGlvbi5wYXRoLnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXRoTGVuID0gZXhpc3RpbmdQYXRoRnJhZ21lbnQuc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4gKyAxICYmIHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIGFuIGBhZGRgIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfQ0FOTk9UX0FERFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiIHx8XG4gICAgICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwiX2dldFwiKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnBhdGggIT09IGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhdCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdFwiLCBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBvcDogXCJfZ2V0XCIsXG4gICAgICAgICAgICAgICAgcGF0aDogb3BlcmF0aW9uLmZyb20sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShbZXhpc3RpbmdWYWx1ZV0sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBmcm9tIGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0XCIsIFwiT1BFUkFUSU9OX0ZST01fVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgc2VxdWVuY2Ugb2Ygb3BlcmF0aW9ucy4gSWYgYGRvY3VtZW50YCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoZSBzZXF1ZW5jZSBpcyBhZGRpdGlvbmFsbHkgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9iamVjdCBkb2N1bWVudC5cbiAqIElmIGVycm9yIGlzIGVuY291bnRlcmVkLCByZXR1cm5zIGEgSnNvblBhdGNoRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0gc2VxdWVuY2VcbiAqIEBwYXJhbSBkb2N1bWVudFxuICogQHJldHVybnMge0pzb25QYXRjaEVycm9yfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5XCIsIFwiU0VRVUVOQ0VfTk9UX0FOX0FSUkFZXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgLy9jbG9uZSBkb2N1bWVudCBhbmQgc2VxdWVuY2Ugc28gdGhhdCB3ZSBjYW4gc2FmZWx5IHRyeSBhcHBseWluZyBvcGVyYXRpb25zXG4gICAgICAgICAgICBhcHBseVBhdGNoKF9kZWVwQ2xvbmUoZG9jdW1lbnQpLCBfZGVlcENsb25lKHNlcXVlbmNlKSwgZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvciA9IGV4dGVybmFsVmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvcihzZXF1ZW5jZVtpXSwgaSwgZG9jdW1lbnQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBKc29uUGF0Y2hFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Zhc3QtZGVlcC1lcXVhbFxuLy8gTUlUIExpY2Vuc2Vcbi8vIENvcHlyaWdodCAoYykgMjAxNyBFdmdlbnkgUG9iZXJlemtpblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5leHBvcnQgZnVuY3Rpb24gX2FyZUVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBhcnJBID0gQXJyYXkuaXNBcnJheShhKSwgYXJyQiA9IEFycmF5LmlzQXJyYXkoYiksIGksIGxlbmd0aCwga2V5O1xuICAgICAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgICAgIGlmICghX2FyZUVxdWFscyhhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckEgIT0gYXJyQilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGtleXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFba2V5XSwgYltrZXldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG4iLCAiLy8gQHRzLW5vY2hlY2tcbi8vIElubGluZWQgYmVjYXVzZSBvZiBFU00gaW1wb3J0IGlzc3Vlc1xuLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXG4gKiAoYykgMjAxNy0yMDIyIEpvYWNoaW0gV2VzdGVyXG4gKiBNSVQgbGljZW5zZWRcbiAqL1xuY29uc3QgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24gX29iamVjdEtleXMob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGtleXNba10gPSBcIlwiICsgaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIGkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG4vKipcbiAqIERlZXBseSBjbG9uZSB0aGUgb2JqZWN0LlxuICogaHR0cHM6Ly9qc3BlcmYuY29tL2RlZXAtY29weS12cy1qc29uLXN0cmluZ2lmeS1qc29uLXBhcnNlLzI1IChyZWN1cnNpdmVEZWVwQ29weSlcbiAqIEBwYXJhbSAge2FueX0gb2JqIHZhbHVlIHRvIGNsb25lXG4gKiBAcmV0dXJuIHthbnl9IGNsb25lZCBvYmpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWVwQ2xvbmUob2JqKSB7XG4gICAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpOyAvL0Zhc3RlciB0aGFuIEVTNSBjbG9uZSAtIGh0dHA6Ly9qc3BlcmYuY29tL2RlZXAtY2xvbmluZy1vZi1vYmplY3RzLzVcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vdGhpcyBpcyBob3cgSlNPTi5zdHJpbmdpZnkgYmVoYXZlcyBmb3IgYXJyYXkgaXRlbXNcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvYmo7IC8vbm8gbmVlZCB0byBjbG9uZSBwcmltaXRpdmVzXG4gICAgfVxufVxuLy8zeCBmYXN0ZXIgdGhhbiBjYWNoZWQgL15cXGQrJC8udGVzdChzdHIpXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKHN0cikge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBjaGFyQ29kZTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuICogQHBhcmFtIHBhdGggVGhlIHJhdyBwb2ludGVyXG4gKiBAcmV0dXJuIHRoZSBFc2NhcGVkIHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmluZGV4T2YoXCIvXCIpID09PSAtMSAmJiBwYXRoLmluZGV4T2YoXCJ+XCIpID09PSAtMSlcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xufVxuLyoqXG4gKiBVbmVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuICogQHBhcmFtIHBhdGggVGhlIGVzY2FwZWQgcG9pbnRlclxuICogQHJldHVybiBUaGUgdW5lc2NhcGVkIHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopIHtcbiAgICBsZXQgZm91bmQ7XG4gICAgZm9yIChsZXQga2V5IGluIHJvb3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHJvb3QsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChyb290W2tleV0gPT09IG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyBcIi9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByb290W2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3Rba2V5XSwgb2JqKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgXCIvXCIgKyBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aChyb290LCBvYmopIHtcbiAgICBpZiAocm9vdCA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBcIi9cIjtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaik7XG4gICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IG5vdCBmb3VuZCBpbiByb290XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYC8ke3BhdGh9YDtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgY2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbnkgdW5kZWZpbmVkIHZhbHVlcyBpbnNpZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNVbmRlZmluZWQob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaktleXMgPSBfb2JqZWN0S2V5cyhvYmopO1xuICAgICAgICAgICAgY29uc3Qgb2JqS2V5c0xlbmd0aCA9IG9iaktleXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtvYmpLZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbbWVzc2FnZV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXJncykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBhcmdzW2tleV0gPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYXJnc1trZXldLCBudWxsLCAyKVxuICAgICAgICAgICAgOiBhcmdzW2tleV07IC8vIHByZXR0eSBwcmludFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChgJHtrZXl9OiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlUGFydHMuam9pbihcIlxcblwiKTtcbn1cbmV4cG9ydCBjbGFzcyBQYXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUpIHtcbiAgICAgICAgc3VwZXIocGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgeyBuYW1lLCBpbmRleCwgb3BlcmF0aW9uLCB0cmVlIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5kZXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcGVyYXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJlZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJlZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW4sIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgzNDIzNTlcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgIi8vIEB0cy1ub2NoZWNrXG4vLyBJbmxpbmVkIGJlY2F1c2Ugb2YgRVNNIGltcG9ydCBpc3N1ZXNcbi8qIVxuICogaHR0cHM6Ly9naXRodWIuY29tL1N0YXJjb3VudGVyLUphY2svSlNPTi1QYXRjaFxuICogKGMpIDIwMTMtMjAyMSBKb2FjaGltIFdlc3RlclxuICogTUlUIGxpY2Vuc2VcbiAqL1xuaW1wb3J0IHsgX2RlZXBDbG9uZSwgX29iamVjdEtleXMsIGVzY2FwZVBhdGhDb21wb25lbnQsIGhhc093blByb3BlcnR5LCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbmltcG9ydCB7IGFwcGx5UGF0Y2ggfSBmcm9tIFwiLi9jb3JlLmpzXCI7XG52YXIgYmVmb3JlRGljdCA9IG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBNaXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvYmpcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib2JzZXJ2ZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgIH1cbn1cbmNsYXNzIE9ic2VydmVySW5mbyB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9ic2VydmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ic2VydmVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldE1pcnJvcihvYmopIHtcbiAgICByZXR1cm4gYmVmb3JlRGljdC5nZXQob2JqKTtcbn1cbmZ1bmN0aW9uIGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG1pcnJvci5vYnNlcnZlcnMuZ2V0KGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKSB7XG4gICAgbWlycm9yLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIuY2FsbGJhY2spO1xufVxuLyoqXG4gKiBEZXRhY2ggYW4gb2JzZXJ2ZXIgZnJvbSBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVub2JzZXJ2ZShyb290LCBvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSgpO1xufVxuLyoqXG4gKiBPYnNlcnZlcyBjaGFuZ2VzIG1hZGUgdG8gYW4gb2JqZWN0LCB3aGljaCBjYW4gdGhlbiBiZSByZXRyaWV2ZWQgdXNpbmcgZ2VuZXJhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmUob2JqLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXRjaGVzID0gW107XG4gICAgdmFyIG9ic2VydmVyO1xuICAgIHZhciBtaXJyb3IgPSBnZXRNaXJyb3Iob2JqKTtcbiAgICBpZiAoIW1pcnJvcikge1xuICAgICAgICBtaXJyb3IgPSBuZXcgTWlycm9yKG9iaik7XG4gICAgICAgIGJlZm9yZURpY3Quc2V0KG9iaiwgbWlycm9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmVySW5mbyA9IGdldE9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIGNhbGxiYWNrKTtcbiAgICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlckluZm8gJiYgb2JzZXJ2ZXJJbmZvLm9ic2VydmVyO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IHt9O1xuICAgIG1pcnJvci52YWx1ZSA9IF9kZWVwQ2xvbmUob2JqKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgb2JzZXJ2ZXIuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IG51bGw7XG4gICAgICAgIHZhciBkaXJ0eUNoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZmFzdENoZWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9ic2VydmVyLm5leHQpO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IHNldFRpbWVvdXQoZGlydHlDaGVjayk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvL25vdCBOb2RlXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZhc3RDaGVjayk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZhc3RDaGVjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZXIucGF0Y2hlcyA9IHBhdGNoZXM7XG4gICAgb2JzZXJ2ZXIub2JqZWN0ID0gb2JqO1xuICAgIG9ic2VydmVyLnVub2JzZXJ2ZSA9ICgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGUob2JzZXJ2ZXIpO1xuICAgICAgICBjbGVhclRpbWVvdXQob2JzZXJ2ZXIubmV4dCk7XG4gICAgICAgIHJlbW92ZU9ic2VydmVyRnJvbU1pcnJvcihtaXJyb3IsIG9ic2VydmVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZmFzdENoZWNrKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmYXN0Q2hlY2spO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZmFzdENoZWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbWlycm9yLm9ic2VydmVycy5zZXQoY2FsbGJhY2ssIG5ldyBPYnNlcnZlckluZm8oY2FsbGJhY2ssIG9ic2VydmVyKSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBhcnJheSBvZiBwYXRjaGVzIGZyb20gYW4gb2JzZXJ2ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlKG9ic2VydmVyLCBpbnZlcnRpYmxlID0gZmFsc2UpIHtcbiAgICB2YXIgbWlycm9yID0gYmVmb3JlRGljdC5nZXQob2JzZXJ2ZXIub2JqZWN0KTtcbiAgICBfZ2VuZXJhdGUobWlycm9yLnZhbHVlLCBvYnNlcnZlci5vYmplY3QsIG9ic2VydmVyLnBhdGNoZXMsIFwiXCIsIGludmVydGlibGUpO1xuICAgIGlmIChvYnNlcnZlci5wYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICBhcHBseVBhdGNoKG1pcnJvci52YWx1ZSwgb2JzZXJ2ZXIucGF0Y2hlcyk7XG4gICAgfVxuICAgIHZhciB0ZW1wID0gb2JzZXJ2ZXIucGF0Y2hlcztcbiAgICBpZiAodGVtcC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9ic2VydmVyLnBhdGNoZXMgPSBbXTtcbiAgICAgICAgaWYgKG9ic2VydmVyLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jYWxsYmFjayh0ZW1wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVtcDtcbn1cbi8vIERpcnR5IGNoZWNrIGlmIG9iaiBpcyBkaWZmZXJlbnQgZnJvbSBtaXJyb3IsIGdlbmVyYXRlIHBhdGNoZXMgYW5kIHVwZGF0ZSBtaXJyb3JcbmZ1bmN0aW9uIF9nZW5lcmF0ZShtaXJyb3IsIG9iaiwgcGF0Y2hlcywgcGF0aCwgaW52ZXJ0aWJsZSkge1xuICAgIGlmIChvYmogPT09IG1pcnJvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICB9XG4gICAgdmFyIG5ld0tleXMgPSBfb2JqZWN0S2V5cyhvYmopO1xuICAgIHZhciBvbGRLZXlzID0gX29iamVjdEtleXMobWlycm9yKTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBkZWxldGVkID0gZmFsc2U7XG4gICAgLy9pZiBldmVyIFwibW92ZVwiIG9wZXJhdGlvbiBpcyBpbXBsZW1lbnRlZCBoZXJlLCBtYWtlIHN1cmUgdGhpcyB0ZXN0IHJ1bnMgT0s6IFwic2hvdWxkIG5vdCBnZW5lcmF0ZSB0aGUgc2FtZSBwYXRjaCB0d2ljZSAobW92ZSlcIlxuICAgIGZvciAodmFyIHQgPSBvbGRLZXlzLmxlbmd0aCAtIDE7IHQgPj0gMDsgdC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvbGRLZXlzW3RdO1xuICAgICAgICB2YXIgb2xkVmFsID0gbWlycm9yW2tleV07XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkgJiZcbiAgICAgICAgICAgICEob2JqW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9sZFZhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvYmopID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdWYWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsID09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBvbGRWYWwgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBuZXdWYWwgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIG5ld1ZhbCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvbGRWYWwpID09PSBBcnJheS5pc0FycmF5KG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICBfZ2VuZXJhdGUob2xkVmFsLCBuZXdWYWwsIHBhdGNoZXMsIHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSwgaW52ZXJ0aWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkVmFsICE9PSBuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF9kZWVwQ2xvbmUob2xkVmFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZShuZXdWYWwpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaXJyb3IpID09PSBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwidGVzdFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoICsgXCIvXCIgKyBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfZGVlcENsb25lKG9sZFZhbCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7IC8vIHByb3BlcnR5IGhhcyBiZWVuIGRlbGV0ZWRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbnZlcnRpYmxlKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwidGVzdFwiLCBwYXRoLCB2YWx1ZTogbWlycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHsgb3A6IFwicmVwbGFjZVwiLCBwYXRoLCB2YWx1ZTogb2JqIH0pO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkZWxldGVkICYmIG5ld0tleXMubGVuZ3RoID09IG9sZEtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBuZXdLZXlzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBuZXdLZXlzW3RdO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KG1pcnJvciwga2V5KSAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGggKyBcIi9cIiArIGVzY2FwZVBhdGhDb21wb25lbnQoa2V5KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZShvYmpba2V5XSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIHBhdGNoZXMgZnJvbSB0aGUgZGlmZmVyZW5jZXMgaW4gdHdvIG9iamVjdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmUodHJlZTEsIHRyZWUyLCBpbnZlcnRpYmxlID0gZmFsc2UpIHtcbiAgICB2YXIgcGF0Y2hlcyA9IFtdO1xuICAgIF9nZW5lcmF0ZSh0cmVlMSwgdHJlZTIsIHBhdGNoZXMsIFwiXCIsIGludmVydGlibGUpO1xuICAgIHJldHVybiBwYXRjaGVzO1xufVxuIiwgImV4cG9ydCAqIGZyb20gXCIuL3NyYy9jb3JlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zcmMvZHVwbGV4LmpzXCI7XG5leHBvcnQgeyBQYXRjaEVycm9yIGFzIEpzb25QYXRjaEVycm9yLCBfZGVlcENsb25lIGFzIGRlZXBDbG9uZSwgZXNjYXBlUGF0aENvbXBvbmVudCwgdW5lc2NhcGVQYXRoQ29tcG9uZW50LCB9IGZyb20gXCIuL3NyYy9oZWxwZXJzLmpzXCI7XG4vKipcbiAqIERlZmF1bHQgZXhwb3J0IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4vc3JjL2NvcmUuanNcIjtcbmltcG9ydCB7IFBhdGNoRXJyb3IgYXMgSnNvblBhdGNoRXJyb3IsIF9kZWVwQ2xvbmUgYXMgZGVlcENsb25lLCBlc2NhcGVQYXRoQ29tcG9uZW50LCB1bmVzY2FwZVBhdGhDb21wb25lbnQsIH0gZnJvbSBcIi4vc3JjL2hlbHBlcnMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICAuLi5jb3JlLFxuICAgIC8vIC4uLmR1cGxleCxcbiAgICBKc29uUGF0Y2hFcnJvcixcbiAgICBkZWVwQ2xvbmUsXG4gICAgZXNjYXBlUGF0aENvbXBvbmVudCxcbiAgICB1bmVzY2FwZVBhdGhDb21wb25lbnQsXG59O1xuIiwgImV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnQgY29uc3QgaXNXZWJXb3JrZXIgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcIjtcbmV4cG9ydCBjb25zdCBpc0pzRG9tID0gKCkgPT4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hbWUgPT09IFwibm9kZWpzXCIpIHx8XG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJOb2RlLmpzXCIpIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwianNkb21cIikpKTtcbi8vIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gcHJvdmlkZXMgYSBgRGVub2AgZ2xvYmFsIG9iamVjdFxuLy8gd2l0aG91dCBgdmVyc2lvbmAgcHJvcGVydHlcbmV4cG9ydCBjb25zdCBpc0Rlbm8gPSAoKSA9PiB0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICgpID0+IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgIWlzRGVubygpO1xuZXhwb3J0IGNvbnN0IGdldEVudiA9ICgpID0+IHtcbiAgICBsZXQgZW52O1xuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBlbnYgPSBcImJyb3dzZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOb2RlKCkpIHtcbiAgICAgICAgZW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzV2ViV29ya2VyKCkpIHtcbiAgICAgICAgZW52ID0gXCJ3ZWJ3b3JrZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNKc0RvbSgpKSB7XG4gICAgICAgIGVudiA9IFwianNkb21cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZW5vKCkpIHtcbiAgICAgICAgZW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBlbnY7XG59O1xubGV0IHJ1bnRpbWVFbnZpcm9ubWVudDtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSdW50aW1lRW52aXJvbm1lbnQoKSB7XG4gICAgaWYgKHJ1bnRpbWVFbnZpcm9ubWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IGdldEVudigpO1xuICAgICAgICBydW50aW1lRW52aXJvbm1lbnQgPSB7XG4gICAgICAgICAgICBsaWJyYXJ5OiBcImxhbmdjaGFpbi1qc1wiLFxuICAgICAgICAgICAgcnVudGltZTogZW52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcnVudGltZUVudmlyb25tZW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIC8vIENlcnRhaW4gRGVubyBzZXR1cHMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5IHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGFuZ2NoYWluLWFpL2xhbmdjaGFpbmpzL2lzc3Vlcy8xNDEyXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLmVudj8uW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGVubygpKSB7XG4gICAgICAgICAgICByZXR1cm4gRGVubz8uZW52LmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4iLCAiaW1wb3J0ICogYXMgdXVpZCBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgU2VyaWFsaXphYmxlLCBnZXRfbGNfdW5pcXVlX25hbWUsIH0gZnJvbSBcIi4uL2xvYWQvc2VyaWFsaXphYmxlLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4uL3V0aWxzL2Vudi5qc1wiO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHByb3ZpZGVzIGEgc2V0IG9mIG9wdGlvbmFsIG1ldGhvZHMgdGhhdCBjYW4gYmVcbiAqIG92ZXJyaWRkZW4gaW4gZGVyaXZlZCBjbGFzc2VzIHRvIGhhbmRsZSB2YXJpb3VzIGV2ZW50cyBkdXJpbmcgdGhlXG4gKiBleGVjdXRpb24gb2YgYSBMYW5nQ2hhaW4gYXBwbGljYXRpb24uXG4gKi9cbmNsYXNzIEJhc2VDYWxsYmFja0hhbmRsZXJNZXRob2RzQ2xhc3Mge1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxiYWNrSGFuZGxlclByZWZlcnNTdHJlYW1pbmcoeCkge1xuICAgIHJldHVybiBcImxjX3ByZWZlcl9zdHJlYW1pbmdcIiBpbiB4ICYmIHgubGNfcHJlZmVyX3N0cmVhbWluZztcbn1cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgY2FsbGJhY2sgaGFuZGxlcnMgaW4gdGhlIExhbmdDaGFpblxuICogZnJhbWV3b3JrLiBJdCBwcm92aWRlcyBhIHNldCBvZiBvcHRpb25hbCBtZXRob2RzIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW5cbiAqIGluIGRlcml2ZWQgY2xhc3NlcyB0byBoYW5kbGUgdmFyaW91cyBldmVudHMgZHVyaW5nIHRoZSBleGVjdXRpb24gb2YgYVxuICogTGFuZ0NoYWluIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIEJhc2VDYWxsYmFja0hhbmRsZXJNZXRob2RzQ2xhc3Mge1xuICAgIGdldCBsY19uYW1lc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcImNhbGxiYWNrc1wiLCB0aGlzLm5hbWVdO1xuICAgIH1cbiAgICBnZXQgbGNfc2VjcmV0cygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGxjX2F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbGNfc2VyaWFsaXphYmxlX2tleXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBzZXJpYWxpemFibGUuIE92ZXJyaWRlIHRvIHByb3ZpZGUgYW4gYWxpYXMgb3JcbiAgICAgKiB0byBwcmVzZXJ2ZSB0aGUgc2VyaWFsaXplZCBtb2R1bGUgbmFtZSBpbiBtaW5pZmllZCBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBhIHN0YXRpYyBtZXRob2QgdG8gc3VwcG9ydCBsb2FkaW5nIGxvZ2ljLlxuICAgICAqL1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZmluYWwgc2VyaWFsaXplZCBpZGVudGlmaWVyIGZvciB0aGUgbW9kdWxlLlxuICAgICAqL1xuICAgIGdldCBsY19pZCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLnRoaXMubGNfbmFtZXNwYWNlLFxuICAgICAgICAgICAgZ2V0X2xjX3VuaXF1ZV9uYW1lKHRoaXMuY29uc3RydWN0b3IpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19rd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlTExNXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlQ2hhaW5cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVBZ2VudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZVJldHJpZXZlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUN1c3RvbUV2ZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmFpc2VFcnJvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF3YWl0SGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fQ0FMTEJBQ0tTX0JBQ0tHUk9VTkRcIikgPT09IFwiZmFsc2VcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sY19rd2FyZ3MgPSBpbnB1dCB8fCB7fTtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUxMTSA9IGlucHV0Lmlnbm9yZUxMTSA/PyB0aGlzLmlnbm9yZUxMTTtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQ2hhaW4gPSBpbnB1dC5pZ25vcmVDaGFpbiA/PyB0aGlzLmlnbm9yZUNoYWluO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVBZ2VudCA9IGlucHV0Lmlnbm9yZUFnZW50ID8/IHRoaXMuaWdub3JlQWdlbnQ7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZVJldHJpZXZlciA9IGlucHV0Lmlnbm9yZVJldHJpZXZlciA/PyB0aGlzLmlnbm9yZVJldHJpZXZlcjtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlQ3VzdG9tRXZlbnQgPVxuICAgICAgICAgICAgICAgIGlucHV0Lmlnbm9yZUN1c3RvbUV2ZW50ID8/IHRoaXMuaWdub3JlQ3VzdG9tRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IgPSBpbnB1dC5yYWlzZUVycm9yID8/IHRoaXMucmFpc2VFcnJvcjtcbiAgICAgICAgICAgIHRoaXMuYXdhaXRIYW5kbGVycyA9XG4gICAgICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yIHx8IChpbnB1dC5fYXdhaXRIYW5kbGVyID8/IHRoaXMuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBTZXJpYWxpemFibGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICB0b0pTT05Ob3RJbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZS5wcm90b3R5cGUudG9KU09OTm90SW1wbGVtZW50ZWQuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21NZXRob2RzKG1ldGhvZHMpIHtcbiAgICAgICAgY2xhc3MgSGFuZGxlciBleHRlbmRzIEJhc2VDYWxsYmFja0hhbmRsZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHV1aWQudjQoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgbWV0aG9kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIYW5kbGVyKCk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGlzQmFzZUNhbGxiYWNrSGFuZGxlciA9ICh4KSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2tIYW5kbGVyID0geDtcbiAgICByZXR1cm4gKGNhbGxiYWNrSGFuZGxlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBjYWxsYmFja0hhbmRsZXIuY29weSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiBjYWxsYmFja0hhbmRsZXIubmFtZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICB0eXBlb2YgY2FsbGJhY2tIYW5kbGVyLmF3YWl0SGFuZGxlcnMgPT09IFwiYm9vbGVhblwiKTtcbn07XG4iLCAiaW1wb3J0IHsgQmFzZUNhbGxiYWNrSGFuZGxlciwgfSBmcm9tIFwiLi4vY2FsbGJhY2tzL2Jhc2UuanNcIjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuZnVuY3Rpb24gc3RyaXBOb25BbHBoYW51bWVyaWMoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvWy06Ll0vZywgXCJcIik7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChlcG9jaCwgcnVuSWQsIGV4ZWN1dGlvbk9yZGVyKSB7XG4gICAgY29uc3QgcGFkZGVkT3JkZXIgPSBleGVjdXRpb25PcmRlci50b0ZpeGVkKDApLnNsaWNlKDAsIDMpLnBhZFN0YXJ0KDMsIFwiMFwiKTtcbiAgICByZXR1cm4gKHN0cmlwTm9uQWxwaGFudW1lcmljKGAke25ldyBEYXRlKGVwb2NoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIC0xKX0ke3BhZGRlZE9yZGVyfVpgKSArIHJ1bklkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2VUcmFjZXIoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeC5fYWRkUnVuVG9SdW5NYXAgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydCBjbGFzcyBCYXNlVHJhY2VyIGV4dGVuZHMgQmFzZUNhbGxiYWNrSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoX2ZpZWxkcykge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5NYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0cmluZ2lmeUVycm9yKGVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlICsgKGVycm9yPy5zdGFjayA/IGBcXG5cXG4ke2Vycm9yLnN0YWNrfWAgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2Vycm9yfWA7XG4gICAgfVxuICAgIF9hZGRDaGlsZFJ1bihwYXJlbnRSdW4sIGNoaWxkUnVuKSB7XG4gICAgICAgIHBhcmVudFJ1bi5jaGlsZF9ydW5zLnB1c2goY2hpbGRSdW4pO1xuICAgIH1cbiAgICBfYWRkUnVuVG9SdW5NYXAocnVuKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREb3R0ZWRPcmRlciA9IGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KHJ1bi5zdGFydF90aW1lLCBydW4uaWQsIHJ1bi5leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICBjb25zdCBzdG9yZWRSdW4gPSB7IC4uLnJ1biB9O1xuICAgICAgICBpZiAoc3RvcmVkUnVuLnBhcmVudF9ydW5faWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50UnVuID0gdGhpcy5ydW5NYXAuZ2V0KHN0b3JlZFJ1bi5wYXJlbnRfcnVuX2lkKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRDaGlsZFJ1bihwYXJlbnRSdW4sIHN0b3JlZFJ1bik7XG4gICAgICAgICAgICAgICAgcGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IE1hdGgubWF4KHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIsIHN0b3JlZFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICAgICAgICAgIHN0b3JlZFJ1bi50cmFjZV9pZCA9IHBhcmVudFJ1bi50cmFjZV9pZDtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50UnVuLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZFJ1bi5kb3R0ZWRfb3JkZXIgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSdW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERvdHRlZE9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIG5hdHVyYWxseSBmb3IgY2FsbGJhY2tzIGFkZGVkIHdpdGhpbiBhIHJ1blxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKGBQYXJlbnQgcnVuIHdpdGggVVVJRCAke3N0b3JlZFJ1bi5wYXJlbnRfcnVuX2lkfSBoYXMgbm8gZG90dGVkIG9yZGVyLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBuYXR1cmFsbHkgZm9yIGNhbGxiYWNrcyBhZGRlZCB3aXRoaW4gYSBydW5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgICAgIC8vICAgYFBhcmVudCBydW4gd2l0aCBVVUlEICR7c3RvcmVkUnVuLnBhcmVudF9ydW5faWR9IG5vdCBmb3VuZC5gXG4gICAgICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0b3JlZFJ1bi50cmFjZV9pZCA9IHN0b3JlZFJ1bi5pZDtcbiAgICAgICAgICAgIHN0b3JlZFJ1bi5kb3R0ZWRfb3JkZXIgPSBjdXJyZW50RG90dGVkT3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ydW5NYXAuc2V0KHN0b3JlZFJ1bi5pZCwgc3RvcmVkUnVuKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlZFJ1bjtcbiAgICB9XG4gICAgYXN5bmMgX2VuZFRyYWNlKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSBydW4ucGFyZW50X3J1bl9pZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucnVuTWFwLmdldChydW4ucGFyZW50X3J1bl9pZCk7XG4gICAgICAgIGlmIChwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgIHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIgPSBNYXRoLm1heChwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBydW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdFJ1bihydW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucnVuTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuVXBkYXRlPy4ocnVuKTtcbiAgICB9XG4gICAgX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1biA9IHBhcmVudFJ1bklkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ydW5NYXAuZ2V0KHBhcmVudFJ1bklkKTtcbiAgICAgICAgLy8gSWYgYSBydW4gaGFzIG5vIHBhcmVudCB0aGVuIGV4ZWN1dGlvbiBvcmRlciBpcyAxXG4gICAgICAgIGlmICghcGFyZW50UnVuKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgYWRkIGEgcnVuIHRvIHRoZSBydW4gbWFwIGZvciBMTE0gc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JMTE1TdGFydChsbG0sIHByb21wdHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvbl9vcmRlciA9IHRoaXMuX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGZpbmFsRXh0cmFQYXJhbXMgPSBtZXRhZGF0YVxuICAgICAgICAgICAgPyB7IC4uLmV4dHJhUGFyYW1zLCBtZXRhZGF0YSB9XG4gICAgICAgICAgICA6IGV4dHJhUGFyYW1zO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IGxsbS5pZFtsbG0uaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBsbG0sXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0czogeyBwcm9tcHRzIH0sXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwibGxtXCIsXG4gICAgICAgICAgICBleHRyYTogZmluYWxFeHRyYVBhcmFtcyA/PyB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW5Ub1J1bk1hcChydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1TdGFydChsbG0sIHByb21wdHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvckxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuQ3JlYXRlPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTVN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIGNoYXQgbW9kZWwgc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBmaW5hbEV4dHJhUGFyYW1zID0gbWV0YWRhdGFcbiAgICAgICAgICAgID8geyAuLi5leHRyYVBhcmFtcywgbWV0YWRhdGEgfVxuICAgICAgICAgICAgOiBleHRyYVBhcmFtcztcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBsbG0uaWRbbGxtLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogbGxtLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgbWVzc2FnZXMgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgICAgICAgIGV4dHJhOiBmaW5hbEV4dHJhUGFyYW1zID8/IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYXRNb2RlbFN0YXJ0KGxsbSwgbWVzc2FnZXMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvckNoYXRNb2RlbFN0YXJ0KGxsbSwgbWVzc2FnZXMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1bkNyZWF0ZT8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVuZChvdXRwdXQsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBleHRyYVBhcmFtcykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBMTE0gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSBvdXRwdXQ7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgcnVuLmV4dHJhID0geyAuLi5ydW4uZXh0cmEsIC4uLmV4dHJhUGFyYW1zIH07XG4gICAgICAgIGF3YWl0IHRoaXMub25MTE1FbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FcnJvcihlcnJvciwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGV4dHJhUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIExMTSBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bi5leHRyYSA9IHsgLi4ucnVuLmV4dHJhLCAuLi5leHRyYVBhcmFtcyB9O1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIGFkZCBhIHJ1biB0byB0aGUgcnVuIG1hcCBmb3IgY2hhaW4gc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIHJ1blR5cGUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBjaGFpbi5pZFtjaGFpbi5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGNoYWluLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlID8/IFwiY2hhaW5cIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkUnVuVG9SdW5NYXAocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBydW5UeXBlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCkgPz9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJ1bkZvckNoYWluU3RhcnQoY2hhaW4sIGlucHV0cywgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgcnVuVHlwZSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5TdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRW5kKG91dHB1dHMsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoYWluIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0gX2NvZXJjZVRvRGljdChvdXRwdXRzLCBcIm91dHB1dFwiKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa3dhcmdzPy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuLmlucHV0cyA9IF9jb2VyY2VUb0RpY3Qoa3dhcmdzLmlucHV0cywgXCJpbnB1dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLm9uQ2hhaW5FbmQ/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVycm9yKGVycm9yLCBydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGFpbiBydW4gdG8gZW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrd2FyZ3M/LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gX2NvZXJjZVRvRGljdChrd2FyZ3MuaW5wdXRzLCBcImlucHV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMub25DaGFpbkVycm9yPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIHRvb2wgc3RhcnQgZXZlbnRzLlxuICAgICAqIFRoaXMgbXVzdCBzb21ldGltZXMgYmUgZG9uZSBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQsIHNvIHdlIGV4cG9zZSBpdCBhcyBhIHNlcGFyYXRlIG1ldGhvZCBoZXJlLlxuICAgICAqL1xuICAgIF9jcmVhdGVSdW5Gb3JUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyB0b29sLmlkW3Rvb2wuaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB0b29sLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgaW5wdXQgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSdW5Ub1J1bk1hcChydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yVG9vbFN0YXJ0KHRvb2wsIGlucHV0LCBydW5JZCwgcGFyZW50UnVuSWQsIHRhZ3MsIG1ldGFkYXRhLCBuYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJ1bkNyZWF0ZT8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInRvb2xcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0geyBvdXRwdXQgfTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uVG9vbEVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnJvciwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRvb2wgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50UnVuID0gcnVuO1xuICAgICAgICBhZ2VudFJ1bi5hY3Rpb25zID0gYWdlbnRSdW4uYWN0aW9ucyB8fCBbXTtcbiAgICAgICAgYWdlbnRSdW4uYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIGFnZW50UnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWdlbnRfYWN0aW9uXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgYWN0aW9uIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQWdlbnRBY3Rpb24/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEVuZChhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImFnZW50X2VuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IGFjdGlvbiB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkFnZW50RW5kPy4ocnVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhZGQgYSBydW4gdG8gdGhlIHJ1biBtYXAgZm9yIHJldHJpZXZlciBzdGFydCBldmVudHMuXG4gICAgICogVGhpcyBtdXN0IHNvbWV0aW1lcyBiZSBkb25lIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICogd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZCwgc28gd2UgZXhwb3NlIGl0IGFzIGEgc2VwYXJhdGUgbWV0aG9kIGhlcmUuXG4gICAgICovXG4gICAgX2NyZWF0ZVJ1bkZvclJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyByZXRyaWV2ZXIuaWRbcmV0cmlldmVyLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogcmV0cmlldmVyLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgcXVlcnkgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwicmV0cmlldmVyXCIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGV4dHJhOiBtZXRhZGF0YSA/IHsgbWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFJ1blRvUnVuTWFwKHJ1bik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlclN0YXJ0KHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKSA/P1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUnVuRm9yUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SdW5DcmVhdGU/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUmV0cmlldmVyU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFbmQoZG9jdW1lbnRzLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInJldHJpZXZlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXRyaWV2ZXIgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4ub3V0cHV0cyA9IHsgZG9jdW1lbnRzIH07XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJldHJpZXZlckVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVycm9yKGVycm9yLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInJldHJpZXZlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXRyaWV2ZXIgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25SZXRyaWV2ZXJFcnJvcj8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRleHQodGV4dCwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJjaGFpblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IHRleHQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25UZXh0Py4ocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNTmV3VG9rZW4odG9rZW4sIGlkeCwgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGZpZWxkcykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJydW5JZFwiIHByb3ZpZGVkIHRvIFwiaGFuZGxlTExNTmV3VG9rZW5cIiBjYWxsYmFjay5gKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJuZXdfdG9rZW5cIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGt3YXJnczogeyB0b2tlbiwgaWR4LCBjaHVuazogZmllbGRzPy5jaHVuayB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTU5ld1Rva2VuPy4ocnVuLCB0b2tlbiwgeyBjaHVuazogZmllbGRzPy5jaHVuayB9KTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHN0eWxlcyBmcm9tIFwiYW5zaS1zdHlsZXNcIjtcbmltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5mdW5jdGlvbiB3cmFwKHN0eWxlLCB0ZXh0KSB7XG4gICAgcmV0dXJuIGAke3N0eWxlLm9wZW59JHt0ZXh0fSR7c3R5bGUuY2xvc2V9YDtcbn1cbmZ1bmN0aW9uIHRyeUpzb25TdHJpbmdpZnkob2JqLCBmYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JtYXRLVk1hcEl0ZW0odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyeUpzb25TdHJpbmdpZnkodmFsdWUsIHZhbHVlLnRvU3RyaW5nKCkpO1xufVxuZnVuY3Rpb24gZWxhcHNlZChydW4pIHtcbiAgICBpZiAoIXJ1bi5lbmRfdGltZSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgY29uc3QgZWxhcHNlZCA9IHJ1bi5lbmRfdGltZSAtIHJ1bi5zdGFydF90aW1lO1xuICAgIGlmIChlbGFwc2VkIDwgMTAwMCkge1xuICAgICAgICByZXR1cm4gYCR7ZWxhcHNlZH1tc2A7XG4gICAgfVxuICAgIHJldHVybiBgJHsoZWxhcHNlZCAvIDEwMDApLnRvRml4ZWQoMil9c2A7XG59XG5jb25zdCB7IGNvbG9yIH0gPSBzdHlsZXM7XG4vKipcbiAqIEEgdHJhY2VyIHRoYXQgbG9ncyBhbGwgZXZlbnRzIHRvIHRoZSBjb25zb2xlLiBJdCBleHRlbmRzIGZyb20gdGhlXG4gKiBgQmFzZVRyYWNlcmAgY2xhc3MgYW5kIG92ZXJyaWRlcyBpdHMgbWV0aG9kcyB0byBwcm92aWRlIGN1c3RvbSBsb2dnaW5nXG4gKiBmdW5jdGlvbmFsaXR5LlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqXG4gKiBjb25zdCBsbG0gPSBuZXcgQ2hhdEFudGhyb3BpYyh7XG4gKiAgIHRlbXBlcmF0dXJlOiAwLFxuICogICB0YWdzOiBbXCJleGFtcGxlXCIsIFwiY2FsbGJhY2tzXCIsIFwiY29uc3RydWN0b3JcIl0sXG4gKiAgIGNhbGxiYWNrczogW25ldyBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyKCldLFxuICogfSk7XG4gKlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwiY29uc29sZV9jYWxsYmFja19oYW5kbGVyXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHBlcnNpc3QgdGhlIHJ1bi4gSW4gdGhpcyBjYXNlLCBpdCBzaW1wbHkgcmV0dXJucyBhXG4gICAgICogcmVzb2x2ZWQgcHJvbWlzZSBhcyB0aGVyZSdzIG5vIHBlcnNpc3RlbmNlIGxvZ2ljLlxuICAgICAqIEBwYXJhbSBfcnVuIFRoZSBydW4gdG8gcGVyc2lzdC5cbiAgICAgKiBAcmV0dXJucyBBIHJlc29sdmVkIHByb21pc2UuXG4gICAgICovXG4gICAgcGVyc2lzdFJ1bihfcnVuKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLy8gdXRpbGl0eSBtZXRob2RzXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IGFsbCB0aGUgcGFyZW50IHJ1bnMgb2YgYSBnaXZlbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcnVuIHdob3NlIHBhcmVudHMgYXJlIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBwYXJlbnQgcnVucy5cbiAgICAgKi9cbiAgICBnZXRQYXJlbnRzKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50UnVuID0gcnVuO1xuICAgICAgICB3aGlsZSAoY3VycmVudFJ1bi5wYXJlbnRfcnVuX2lkKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnJ1bk1hcC5nZXQoY3VycmVudFJ1bi5wYXJlbnRfcnVuX2lkKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UnVuID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVuJ3MgbGluZWFnZSwgd2hpY2hcbiAgICAgKiBpcyB1c2VkIGluIGxvZ2dpbmcuXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcnVuIHdob3NlIGxpbmVhZ2UgaXMgdG8gYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBydW4ncyBsaW5lYWdlLlxuICAgICAqL1xuICAgIGdldEJyZWFkY3J1bWJzKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRzID0gdGhpcy5nZXRQYXJlbnRzKHJ1bikucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBbLi4ucGFyZW50cywgcnVuXVxuICAgICAgICAgICAgLm1hcCgocGFyZW50LCBpLCBhcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBgJHtwYXJlbnQuZXhlY3V0aW9uX29yZGVyfToke3BhcmVudC5ydW5fdHlwZX06JHtwYXJlbnQubmFtZX1gO1xuICAgICAgICAgICAgcmV0dXJuIGkgPT09IGFyci5sZW5ndGggLSAxID8gd3JhcChzdHlsZXMuYm9sZCwgbmFtZSkgOiBuYW1lO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oXCIgPiBcIik7XG4gICAgICAgIHJldHVybiB3cmFwKGNvbG9yLmdyZXksIHN0cmluZyk7XG4gICAgfVxuICAgIC8vIGxvZ2dpbmcgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYSBjaGFpbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgY2hhaW4gcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uQ2hhaW5TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIltjaGFpbi9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIENoYWluIHJ1biB3aXRoIGlucHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmlucHV0cywgXCJbaW5wdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYSBjaGFpbiBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgY2hhaW4gcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkNoYWluRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbY2hhaW4vZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBDaGFpbiBydW4gd2l0aCBvdXRwdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4ub3V0cHV0cywgXCJbb3V0cHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGEgY2hhaW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIGNoYWluIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkNoYWluRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW2NoYWluL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gQ2hhaW4gcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGFuIExMTSBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgTExNIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkxMTVN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IFwicHJvbXB0c1wiIGluIHJ1bi5pbnB1dHNcbiAgICAgICAgICAgID8geyBwcm9tcHRzOiBydW4uaW5wdXRzLnByb21wdHMubWFwKChwKSA9PiBwLnRyaW0oKSkgfVxuICAgICAgICAgICAgOiBydW4uaW5wdXRzO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIltsbG0vc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBMTE0gcnVuIHdpdGggaW5wdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShpbnB1dHMsIFwiW2lucHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGFuIExMTSBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgTExNIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25MTE1FbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIltsbG0vZW5kXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gRXhpdGluZyBMTE0gcnVuIHdpdGggb3V0cHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLm91dHB1dHMsIFwiW3Jlc3BvbnNlXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYW4gTExNIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBMTE0gcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uTExNRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW2xsbS9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIExMTSBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgc3RhcnQgb2YgYSB0b29sIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSB0b29sIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblRvb2xTdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmdyZWVuLCBcIlt0b29sL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgVG9vbCBydW4gd2l0aCBpbnB1dDogXCIke2Zvcm1hdEtWTWFwSXRlbShydW4uaW5wdXRzLmlucHV0KX1cImApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhIHRvb2wgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHRvb2wgcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblRvb2xFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5jeWFuLCBcIlt0b29sL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgVG9vbCBydW4gd2l0aCBvdXRwdXQ6IFwiJHtmb3JtYXRLVk1hcEl0ZW0ocnVuLm91dHB1dHM/Lm91dHB1dCl9XCJgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYSB0b29sIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSB0b29sIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblRvb2xFcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbdG9vbC9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIFRvb2wgcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGEgcmV0cmlldmVyIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSByZXRyaWV2ZXIgcnVuIHRoYXQgaGFzIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uUmV0cmlldmVyU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbcmV0cmlldmVyL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgUmV0cmlldmVyIHJ1biB3aXRoIGlucHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmlucHV0cywgXCJbaW5wdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYSByZXRyaWV2ZXIgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJldHJpZXZlciBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uUmV0cmlldmVyRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbcmV0cmlldmVyL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgUmV0cmlldmVyIHJ1biB3aXRoIG91dHB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5vdXRwdXRzLCBcIltvdXRwdXRzXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIGFueSBlcnJvcnMgb2YgYSByZXRyaWV2ZXIgcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJldHJpZXZlciBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25SZXRyaWV2ZXJFcnJvcihydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLnJlZCwgXCJbcmV0cmlldmVyL2Vycm9yXVwiKX0gWyR7Y3J1bWJzfV0gWyR7ZWxhcHNlZChydW4pfV0gUmV0cmlldmVyIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBhY3Rpb24gc2VsZWN0ZWQgYnkgdGhlIGFnZW50LlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJ1biBpbiB3aGljaCB0aGUgYWdlbnQgYWN0aW9uIG9jY3VycmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkFnZW50QWN0aW9uKHJ1bikge1xuICAgICAgICBjb25zdCBhZ2VudFJ1biA9IHJ1bjtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmJsdWUsIFwiW2FnZW50L2FjdGlvbl1cIil9IFske2NydW1ic31dIEFnZW50IHNlbGVjdGVkIGFjdGlvbjogJHt0cnlKc29uU3RyaW5naWZ5KGFnZW50UnVuLmFjdGlvbnNbYWdlbnRSdW4uYWN0aW9ucy5sZW5ndGggLSAxXSwgXCJbYWN0aW9uXVwiKX1gKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcImxhbmdzbWl0aFwiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbmxldCBjbGllbnQ7XG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdExhbmdDaGFpbkNsaWVudFNpbmdsZXRvbiA9ICgpID0+IHtcbiAgICBpZiAoY2xpZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY2xpZW50UGFyYW1zID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9DQUxMQkFDS1NfQkFDS0dST1VORFwiKSA9PT0gXCJmYWxzZVwiXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAvLyBMYW5nU21pdGggaGFzIGl0cyBvd24gYmFja2dyb3VuZGluZyBzeXN0ZW1cbiAgICAgICAgICAgICAgICBibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge307XG4gICAgICAgIGNsaWVudCA9IG5ldyBDbGllbnQoY2xpZW50UGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudDtcbn07XG5leHBvcnQgY29uc3Qgc2V0RGVmYXVsdExhbmdDaGFpbkNsaWVudFNpbmdsZXRvbiA9IChuZXdDbGllbnQpID0+IHtcbiAgICBjbGllbnQgPSBuZXdDbGllbnQ7XG59O1xuIiwgImltcG9ydCB7IFJ1blRyZWUgfSBmcm9tIFwibGFuZ3NtaXRoL3J1bl90cmVlc1wiO1xuaW1wb3J0IHsgZ2V0Q3VycmVudFJ1blRyZWUgfSBmcm9tIFwibGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRSdW50aW1lRW52aXJvbm1lbnQgfSBmcm9tIFwiLi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdExhbmdDaGFpbkNsaWVudFNpbmdsZXRvbiB9IGZyb20gXCIuLi9zaW5nbGV0b25zL3RyYWNlci5qc1wiO1xuZXhwb3J0IGNsYXNzIExhbmdDaGFpblRyYWNlciBleHRlbmRzIEJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwibGFuZ2NoYWluX3RyYWNlclwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0TmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGFtcGxlSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgZXhhbXBsZUlkLCBwcm9qZWN0TmFtZSwgY2xpZW50IH0gPSBmaWVsZHM7XG4gICAgICAgIHRoaXMucHJvamVjdE5hbWUgPVxuICAgICAgICAgICAgcHJvamVjdE5hbWUgPz9cbiAgICAgICAgICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1BST0pFQ1RcIikgPz9cbiAgICAgICAgICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1NFU1NJT05cIik7XG4gICAgICAgIHRoaXMuZXhhbXBsZUlkID0gZXhhbXBsZUlkO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudCA/PyBnZXREZWZhdWx0TGFuZ0NoYWluQ2xpZW50U2luZ2xldG9uKCk7XG4gICAgICAgIGNvbnN0IHRyYWNlYWJsZVRyZWUgPSBMYW5nQ2hhaW5UcmFjZXIuZ2V0VHJhY2VhYmxlUnVuVHJlZSgpO1xuICAgICAgICBpZiAodHJhY2VhYmxlVHJlZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tUnVuVHJlZSh0cmFjZWFibGVUcmVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY29udmVydFRvQ3JlYXRlKHJ1biwgZXhhbXBsZV9pZCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucnVuLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICAuLi5ydW4uZXh0cmEsXG4gICAgICAgICAgICAgICAgcnVudGltZTogYXdhaXQgZ2V0UnVudGltZUVudmlyb25tZW50KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRfcnVuczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiB0aGlzLnByb2plY3ROYW1lLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bi5wYXJlbnRfcnVuX2lkID8gdW5kZWZpbmVkIDogZXhhbXBsZV9pZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcGVyc2lzdFJ1bihfcnVuKSB7IH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgY29uc3QgcGVyc2lzdGVkUnVuID0gYXdhaXQgdGhpcy5fY29udmVydFRvQ3JlYXRlKHJ1biwgdGhpcy5leGFtcGxlSWQpO1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5jcmVhdGVSdW4ocGVyc2lzdGVkUnVuKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blVwZGF0ZSA9IHtcbiAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICBlcnJvcjogcnVuLmVycm9yLFxuICAgICAgICAgICAgb3V0cHV0czogcnVuLm91dHB1dHMsXG4gICAgICAgICAgICBldmVudHM6IHJ1bi5ldmVudHMsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICB0cmFjZV9pZDogcnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBydW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcnVuLnBhcmVudF9ydW5faWQsXG4gICAgICAgICAgICBleHRyYTogcnVuLmV4dHJhLFxuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiB0aGlzLnByb2plY3ROYW1lLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4ocnVuLmlkLCBydW5VcGRhdGUpO1xuICAgIH1cbiAgICBnZXRSdW4oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuTWFwLmdldChpZCk7XG4gICAgfVxuICAgIHVwZGF0ZUZyb21SdW5UcmVlKHJ1blRyZWUpIHtcbiAgICAgICAgbGV0IHJvb3RSdW4gPSBydW5UcmVlO1xuICAgICAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICB3aGlsZSAocm9vdFJ1bi5wYXJlbnRfcnVuKSB7XG4gICAgICAgICAgICBpZiAodmlzaXRlZC5oYXMocm9vdFJ1bi5pZCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChyb290UnVuLmlkKTtcbiAgICAgICAgICAgIGlmICghcm9vdFJ1bi5wYXJlbnRfcnVuKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcm9vdFJ1biA9IHJvb3RSdW4ucGFyZW50X3J1bjtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkLmNsZWFyKCk7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW3Jvb3RSdW5dO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQgfHwgdmlzaXRlZC5oYXMoY3VycmVudC5pZCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChjdXJyZW50LmlkKTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVHlwZXMgb2YgcHJvcGVydHkgJ2V2ZW50cycgYXJlIGluY29tcGF0aWJsZS5cbiAgICAgICAgICAgIHRoaXMucnVuTWFwLnNldChjdXJyZW50LmlkLCBjdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmNoaWxkX3J1bnMpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKC4uLmN1cnJlbnQuY2hpbGRfcnVucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnQgPSBydW5UcmVlLmNsaWVudCA/PyB0aGlzLmNsaWVudDtcbiAgICAgICAgdGhpcy5wcm9qZWN0TmFtZSA9IHJ1blRyZWUucHJvamVjdF9uYW1lID8/IHRoaXMucHJvamVjdE5hbWU7XG4gICAgICAgIHRoaXMuZXhhbXBsZUlkID0gcnVuVHJlZS5yZWZlcmVuY2VfZXhhbXBsZV9pZCA/PyB0aGlzLmV4YW1wbGVJZDtcbiAgICB9XG4gICAgY29udmVydFRvUnVuVHJlZShpZCkge1xuICAgICAgICBjb25zdCBydW5UcmVlTWFwID0ge307XG4gICAgICAgIGNvbnN0IHJ1blRyZWVMaXN0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2lkLCBydW5dIG9mIHRoaXMucnVuTWFwKSB7XG4gICAgICAgICAgICAvLyBieSBjb252ZXJ0aW5nIHRoZSBydW4gbWFwIHRvIGEgcnVuIHRyZWUsIHdlIGFyZSBkb2luZyBhIGNvcHlcbiAgICAgICAgICAgIC8vIHRodXMsIGFueSBtdXRhdGlvbiBwZXJmb3JtZWQgb24gdGhlIHJ1biB0cmVlIHdpbGwgbm90IGJlIHJlZmxlY3RlZFxuICAgICAgICAgICAgLy8gYmFjayBpbiB0aGUgcnVuIG1hcFxuICAgICAgICAgICAgLy8gVE9ETzogU3RvcCB1c2luZyBgdGhpcy5ydW5NYXBgIGluIGZhdm91ciBvZiBMYW5nU21pdGgncyBgUnVuVHJlZWBcbiAgICAgICAgICAgIGNvbnN0IHJ1blRyZWUgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAgICAgLi4ucnVuLFxuICAgICAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgICAgIHBhcmVudF9ydW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAvLyBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcHJvamVjdF9uYW1lOiB0aGlzLnByb2plY3ROYW1lLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiB0aGlzLmV4YW1wbGVJZCxcbiAgICAgICAgICAgICAgICB0cmFjaW5nRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcnVuVHJlZU1hcFtpZF0gPSBydW5UcmVlO1xuICAgICAgICAgICAgcnVuVHJlZUxpc3QucHVzaChbaWQsIHJ1bi5kb3R0ZWRfb3JkZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBydW5UcmVlTGlzdC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFbMV0gfHwgIWJbMV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICByZXR1cm4gYVsxXS5sb2NhbGVDb21wYXJlKGJbMV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBbaWRdIG9mIHJ1blRyZWVMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQoaWQpO1xuICAgICAgICAgICAgY29uc3QgcnVuVHJlZSA9IHJ1blRyZWVNYXBbaWRdO1xuICAgICAgICAgICAgaWYgKCFydW4gfHwgIXJ1blRyZWUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocnVuLnBhcmVudF9ydW5faWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRSdW5UcmVlID0gcnVuVHJlZU1hcFtydW4ucGFyZW50X3J1bl9pZF07XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFJ1blRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UnVuVHJlZS5jaGlsZF9ydW5zLnB1c2gocnVuVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIHJ1blRyZWUucGFyZW50X3J1biA9IHBhcmVudFJ1blRyZWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5UcmVlTWFwW2lkXTtcbiAgICB9XG4gICAgc3RhdGljIGdldFRyYWNlYWJsZVJ1blRyZWUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q3VycmVudFJ1blRyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCBQUXVldWVNb2QgZnJvbSBcInAtcXVldWVcIjtcbmltcG9ydCB7IGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgfSBmcm9tIFwiLi9hc3luY19sb2NhbF9zdG9yYWdlL2dsb2JhbHMuanNcIjtcbmxldCBxdWV1ZTtcbi8qKlxuICogQ3JlYXRlcyBhIHF1ZXVlIHVzaW5nIHRoZSBwLXF1ZXVlIGxpYnJhcnkuIFRoZSBxdWV1ZSBpcyBjb25maWd1cmVkIHRvXG4gKiBhdXRvLXN0YXJ0IGFuZCBoYXMgYSBjb25jdXJyZW5jeSBvZiAxLCBtZWFuaW5nIGl0IHdpbGwgcHJvY2VzcyB0YXNrc1xuICogb25lIGF0IGEgdGltZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUXVldWUoKSB7XG4gICAgY29uc3QgUFF1ZXVlID0gXCJkZWZhdWx0XCIgaW4gUFF1ZXVlTW9kID8gUFF1ZXVlTW9kLmRlZmF1bHQgOiBQUXVldWVNb2Q7XG4gICAgcmV0dXJuIG5ldyBQUXVldWUoe1xuICAgICAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgICAgIGNvbmN1cnJlbmN5OiAxLFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFF1ZXVlKCkge1xuICAgIGlmICh0eXBlb2YgcXVldWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcXVldWUgPSBjcmVhdGVRdWV1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcXVldWU7XG59XG4vKipcbiAqIENvbnN1bWUgYSBwcm9taXNlLCBlaXRoZXIgYWRkaW5nIGl0IHRvIHRoZSBxdWV1ZSBvciB3YWl0aW5nIGZvciBpdCB0byByZXNvbHZlXG4gKiBAcGFyYW0gcHJvbWlzZUZuIFByb21pc2UgdG8gY29uc3VtZVxuICogQHBhcmFtIHdhaXQgV2hldGhlciB0byB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIG9yIHJlc29sdmUgaW1tZWRpYXRlbHlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVDYWxsYmFjayhwcm9taXNlRm4sIHdhaXQpIHtcbiAgICBpZiAod2FpdCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBDbGVhciBjb25maWcgc2luY2UgY2FsbGJhY2tzIGFyZSBub3QgcGFydCBvZiB0aGUgcm9vdCBydW5cbiAgICAgICAgLy8gQXZvaWQgdXNpbmcgZ2xvYmFsIHNpbmdsZXRvbiBkdWUgdG8gY2lyY3VsdWFyIGRlcGVuZGVuY3kgaXNzdWVzXG4gICAgICAgIGNvbnN0IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSBnZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKCk7XG4gICAgICAgIGlmIChhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UucnVuKHVuZGVmaW5lZCwgYXN5bmMgKCkgPT4gcHJvbWlzZUZuKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZUZuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHF1ZXVlID0gZ2V0UXVldWUoKTtcbiAgICAgICAgdm9pZCBxdWV1ZS5hZGQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9IGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGlmIChhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlLnJ1bih1bmRlZmluZWQsIGFzeW5jICgpID0+IHByb21pc2VGbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHByb21pc2VGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFdhaXRzIGZvciBhbGwgcHJvbWlzZXMgaW4gdGhlIHF1ZXVlIHRvIHJlc29sdmUuIElmIHRoZSBxdWV1ZSBpc1xuICogdW5kZWZpbmVkLCBpdCBpbW1lZGlhdGVseSByZXNvbHZlcyBhIHByb21pc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhd2FpdEFsbENhbGxiYWNrcygpIHtcbiAgICByZXR1cm4gdHlwZW9mIHF1ZXVlICE9PSBcInVuZGVmaW5lZFwiID8gcXVldWUub25JZGxlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbn1cbiIsICJleHBvcnQgY29uc3QgVFJBQ0lOR19BTFNfS0VZID0gU3ltYm9sLmZvcihcImxzOnRyYWNpbmdfYXN5bmNfbG9jYWxfc3RvcmFnZVwiKTtcbmV4cG9ydCBjb25zdCBfQ09OVEVYVF9WQVJJQUJMRVNfS0VZID0gU3ltYm9sLmZvcihcImxjOmNvbnRleHRfdmFyaWFibGVzXCIpO1xuZXhwb3J0IGNvbnN0IHNldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcbiAgICBnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPSBpbnN0YW5jZTtcbn07XG5leHBvcnQgY29uc3QgZ2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9ICgpID0+IHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldO1xufTtcbiIsICJpbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4vZW52LmpzXCI7XG5leHBvcnQgY29uc3QgaXNUcmFjaW5nRW5hYmxlZCA9ICh0cmFjaW5nRW5hYmxlZCkgPT4ge1xuICAgIGlmICh0cmFjaW5nRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nRW5hYmxlZDtcbiAgICB9XG4gICAgY29uc3QgZW52VmFycyA9IFtcbiAgICAgICAgXCJMQU5HU01JVEhfVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR1NNSVRIX1RSQUNJTkdcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR1wiLFxuICAgIF07XG4gICAgcmV0dXJuICEhZW52VmFycy5maW5kKChlbnZWYXIpID0+IGdldEVudmlyb25tZW50VmFyaWFibGUoZW52VmFyKSA9PT0gXCJ0cnVlXCIpO1xufTtcbiIsICJpbXBvcnQgeyBpc1J1blRyZWUsIFJ1blRyZWUgfSBmcm9tIFwibGFuZ3NtaXRoL3J1bl90cmVlc1wiO1xuaW1wb3J0IHsgX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSwgZ2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSwgfSBmcm9tIFwiLi9nbG9iYWxzLmpzXCI7XG4vKipcbiAqIFNldCBhIGNvbnRleHQgdmFyaWFibGUuIENvbnRleHQgdmFyaWFibGVzIGFyZSBzY29wZWQgdG8gYW55XG4gKiBjaGlsZCBydW5uYWJsZXMgY2FsbGVkIGJ5IHRoZSBjdXJyZW50IHJ1bm5hYmxlLCBvciBnbG9iYWxseSBpZiBzZXQgb3V0c2lkZVxuICogb2YgYW55IHJ1bm5hYmxlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgQXN5bmNMb2NhbFN0b3JhZ2UsXG4gKiBpbmNsdWRpbmcgTm9kZS5qcywgRGVubywgYW5kIENsb3VkZmxhcmUgV29ya2Vycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFJ1bm5hYmxlTGFtYmRhIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbiAqIGltcG9ydCB7XG4gKiAgIGdldENvbnRleHRWYXJpYWJsZSxcbiAqICAgc2V0Q29udGV4dFZhcmlhYmxlXG4gKiB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvY29udGV4dFwiO1xuICpcbiAqIGNvbnN0IG5lc3RlZCA9IFJ1bm5hYmxlTGFtYmRhLmZyb20oKCkgPT4ge1xuICogICAvLyBcImJhclwiIGJlY2F1c2UgaXQgd2FzIHNldCBieSBhIHBhcmVudFxuICogICBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqICAgLy8gT3ZlcnJpZGUgdG8gXCJiYXpcIiwgYnV0IG9ubHkgZm9yIGNoaWxkIHJ1bm5hYmxlc1xuICogICBzZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIiwgXCJiYXpcIik7XG4gKlxuICogICAvLyBOb3cgXCJiYXpcIiwgYnV0IG9ubHkgZm9yIGNoaWxkIHJ1bm5hYmxlc1xuICogICByZXR1cm4gZ2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIpO1xuICogfSk7XG4gKlxuICogY29uc3QgcnVubmFibGUgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKGFzeW5jICgpID0+IHtcbiAqICAgLy8gU2V0IGEgY29udGV4dCB2YXJpYWJsZSBuYW1lZCBcImZvb1wiXG4gKiAgIHNldENvbnRleHRWYXJpYWJsZShcImZvb1wiLCBcImJhclwiKTtcbiAqXG4gKiAgIGNvbnN0IHJlcyA9IGF3YWl0IG5lc3RlZC5pbnZva2Uoe30pO1xuICpcbiAqICAgLy8gU3RpbGwgXCJiYXJcIiBzaW5jZSBjaGlsZCBjaGFuZ2VzIGRvIG5vdCBhZmZlY3QgcGFyZW50c1xuICogICBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqICAgcmV0dXJuIHJlcztcbiAqIH0pO1xuICpcbiAqIC8vIHVuZGVmaW5lZCwgYmVjYXVzZSBjb250ZXh0IHZhcmlhYmxlIGhhcyBub3QgYmVlbiBzZXQgeWV0XG4gKiBjb25zb2xlLmxvZyhnZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIikpO1xuICpcbiAqIC8vIEZpbmFsIHJldHVybiB2YWx1ZSBpcyBcImJhelwiXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBydW5uYWJsZS5pbnZva2Uoe30pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNvbnRleHQgdmFyaWFibGUuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiBzZXRDb250ZXh0VmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICAvLyBBdm9pZCB1c2luZyBnbG9iYWwgc2luZ2xldG9uIGR1ZSB0byBjaXJjdWx1YXIgZGVwZW5kZW5jeSBpc3N1ZXNcbiAgICBjb25zdCBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlID0gZ2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSgpO1xuICAgIGlmIChhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBlcnJvcjogR2xvYmFsIHNoYXJlZCBhc3luYyBsb2NhbCBzdG9yYWdlIGluc3RhbmNlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC5gKTtcbiAgICB9XG4gICAgY29uc3QgcnVuVHJlZSA9IGFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UuZ2V0U3RvcmUoKTtcbiAgICBjb25zdCBjb250ZXh0VmFycyA9IHsgLi4ucnVuVHJlZT8uW19DT05URVhUX1ZBUklBQkxFU19LRVldIH07XG4gICAgY29udGV4dFZhcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICBsZXQgbmV3VmFsdWUgPSB7fTtcbiAgICBpZiAoaXNSdW5UcmVlKHJ1blRyZWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3IFJ1blRyZWUocnVuVHJlZSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbmV3VmFsdWVbX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV0gPSBjb250ZXh0VmFycztcbiAgICBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlLmVudGVyV2l0aChuZXdWYWx1ZSk7XG59XG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYSBwcmV2aW91c2x5IHNldCBjb250ZXh0IHZhcmlhYmxlLiBDb250ZXh0IHZhcmlhYmxlc1xuICogYXJlIHNjb3BlZCB0byBhbnkgY2hpbGQgcnVubmFibGVzIGNhbGxlZCBieSB0aGUgY3VycmVudCBydW5uYWJsZSxcbiAqIG9yIGdsb2JhbGx5IGlmIHNldCBvdXRzaWRlIG9mIGFueSBydW5uYWJsZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IEFzeW5jTG9jYWxTdG9yYWdlLFxuICogaW5jbHVkaW5nIE5vZGUuanMsIERlbm8sIGFuZCBDbG91ZGZsYXJlIFdvcmtlcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSdW5uYWJsZUxhbWJkYSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcnVubmFibGVzXCI7XG4gKiBpbXBvcnQge1xuICogICBnZXRDb250ZXh0VmFyaWFibGUsXG4gKiAgIHNldENvbnRleHRWYXJpYWJsZVxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL2NvbnRleHRcIjtcbiAqXG4gKiBjb25zdCBuZXN0ZWQgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKCgpID0+IHtcbiAqICAgLy8gXCJiYXJcIiBiZWNhdXNlIGl0IHdhcyBzZXQgYnkgYSBwYXJlbnRcbiAqICAgY29uc29sZS5sb2coZ2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIpKTtcbiAqXG4gKiAgIC8vIE92ZXJyaWRlIHRvIFwiYmF6XCIsIGJ1dCBvbmx5IGZvciBjaGlsZCBydW5uYWJsZXNcbiAqICAgc2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIsIFwiYmF6XCIpO1xuICpcbiAqICAgLy8gTm93IFwiYmF6XCIsIGJ1dCBvbmx5IGZvciBjaGlsZCBydW5uYWJsZXNcbiAqICAgcmV0dXJuIGdldENvbnRleHRWYXJpYWJsZShcImZvb1wiKTtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHJ1bm5hYmxlID0gUnVubmFibGVMYW1iZGEuZnJvbShhc3luYyAoKSA9PiB7XG4gKiAgIC8vIFNldCBhIGNvbnRleHQgdmFyaWFibGUgbmFtZWQgXCJmb29cIlxuICogICBzZXRDb250ZXh0VmFyaWFibGUoXCJmb29cIiwgXCJiYXJcIik7XG4gKlxuICogICBjb25zdCByZXMgPSBhd2FpdCBuZXN0ZWQuaW52b2tlKHt9KTtcbiAqXG4gKiAgIC8vIFN0aWxsIFwiYmFyXCIgc2luY2UgY2hpbGQgY2hhbmdlcyBkbyBub3QgYWZmZWN0IHBhcmVudHNcbiAqICAgY29uc29sZS5sb2coZ2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIpKTtcbiAqXG4gKiAgIHJldHVybiByZXM7XG4gKiB9KTtcbiAqXG4gKiAvLyB1bmRlZmluZWQsIGJlY2F1c2UgY29udGV4dCB2YXJpYWJsZSBoYXMgbm90IGJlZW4gc2V0IHlldFxuICogY29uc29sZS5sb2coZ2V0Q29udGV4dFZhcmlhYmxlKFwiZm9vXCIpKTtcbiAqXG4gKiAvLyBGaW5hbCByZXR1cm4gdmFsdWUgaXMgXCJiYXpcIlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgcnVubmFibGUuaW52b2tlKHt9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjb250ZXh0IHZhcmlhYmxlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRleHRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQXZvaWQgdXNpbmcgZ2xvYmFsIHNpbmdsZXRvbiBkdWUgdG8gY2lyY3VsdWFyIGRlcGVuZGVuY3kgaXNzdWVzXG4gICAgY29uc3QgYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9IGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UoKTtcbiAgICBpZiAoYXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHJ1blRyZWUgPSBhc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlLmdldFN0b3JlKCk7XG4gICAgcmV0dXJuIHJ1blRyZWU/LltfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXT8uW25hbWVdO1xufVxuY29uc3QgTENfQ09ORklHVVJFX0hPT0tTX0tFWSA9IFN5bWJvbChcImxjOmNvbmZpZ3VyZV9ob29rc1wiKTtcbmV4cG9ydCBjb25zdCBfZ2V0Q29uZmlndXJlSG9va3MgPSAoKSA9PiBnZXRDb250ZXh0VmFyaWFibGUoTENfQ09ORklHVVJFX0hPT0tTX0tFWSkgfHwgW107XG4vKipcbiAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgY29uZmlndXJlIGhvb2sgdG8gYXV0b21hdGljYWxseSBhZGQgY2FsbGJhY2sgaGFuZGxlcnMgdG8gYWxsIHJ1bnMuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIHVzZSB0aGlzOlxuICpcbiAqIDEuIFVzaW5nIGEgY29udGV4dCB2YXJpYWJsZTpcbiAqICAgIC0gU2V0IGBjb250ZXh0VmFyYCB0byBzcGVjaWZ5IHRoZSB2YXJpYWJsZSBuYW1lXG4gKiAgICAtIFVzZSBgc2V0Q29udGV4dFZhcmlhYmxlKClgIHRvIHN0b3JlIHlvdXIgaGFuZGxlciBpbnN0YW5jZVxuICpcbiAqIDIuIFVzaW5nIGFuIGVudmlyb25tZW50IHZhcmlhYmxlOlxuICogICAgLSBTZXQgYm90aCBgZW52VmFyYCBhbmQgYGhhbmRsZXJDbGFzc2BcbiAqICAgIC0gVGhlIGhhbmRsZXIgd2lsbCBiZSBpbnN0YW50aWF0ZWQgd2hlbiB0aGUgZW52IHZhciBpcyBzZXQgdG8gXCJ0cnVlXCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIE1ldGhvZCAxOiBVc2luZyBjb250ZXh0IHZhcmlhYmxlXG4gKiBpbXBvcnQge1xuICogICByZWdpc3RlckNvbmZpZ3VyZUhvb2ssXG4gKiAgIHNldENvbnRleHRWYXJpYWJsZVxuICogfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL2NvbnRleHRcIjtcbiAqXG4gKiBjb25zdCB0cmFjZXIgPSBuZXcgTXlDYWxsYmFja0hhbmRsZXIoKTtcbiAqIHJlZ2lzdGVyQ29uZmlndXJlSG9vayh7XG4gKiAgIGNvbnRleHRWYXI6IFwibXlfdHJhY2VyXCIsXG4gKiB9KTtcbiAqIHNldENvbnRleHRWYXJpYWJsZShcIm15X3RyYWNlclwiLCB0cmFjZXIpO1xuICpcbiAqIC8vIC4uLnJ1biBjb2RlIGhlcmVcbiAqXG4gKiAvLyBNZXRob2QgMjogVXNpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIHJlZ2lzdGVyQ29uZmlndXJlSG9vayh7XG4gKiAgIGhhbmRsZXJDbGFzczogTXlDYWxsYmFja0hhbmRsZXIsXG4gKiAgIGVudlZhcjogXCJNWV9UUkFDRVJfRU5BQkxFRFwiLFxuICogfSk7XG4gKiBwcm9jZXNzLmVudi5NWV9UUkFDRVJfRU5BQkxFRCA9IFwidHJ1ZVwiO1xuICpcbiAqIC8vIC4uLnJ1biBjb2RlIGhlcmVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBob29rXG4gKiBAcGFyYW0gY29uZmlnLmNvbnRleHRWYXIgTmFtZSBvZiB0aGUgY29udGV4dCB2YXJpYWJsZSBjb250YWluaW5nIHRoZSBoYW5kbGVyIGluc3RhbmNlXG4gKiBAcGFyYW0gY29uZmlnLmluaGVyaXRhYmxlIFdoZXRoZXIgY2hpbGQgcnVucyBzaG91bGQgaW5oZXJpdCB0aGlzIGhhbmRsZXJcbiAqIEBwYXJhbSBjb25maWcuaGFuZGxlckNsYXNzIE9wdGlvbmFsIGNhbGxiYWNrIGhhbmRsZXIgY2xhc3MgKHJlcXVpcmVkIGlmIHVzaW5nIGVudlZhcilcbiAqIEBwYXJhbSBjb25maWcuZW52VmFyIE9wdGlvbmFsIGVudmlyb25tZW50IHZhcmlhYmxlIG5hbWUgdG8gY29udHJvbCBoYW5kbGVyIGFjdGl2YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyQ29uZmlndXJlSG9vayA9IChjb25maWcpID0+IHtcbiAgICBpZiAoY29uZmlnLmVudlZhciAmJiAhY29uZmlnLmhhbmRsZXJDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJZiBlbnZWYXIgaXMgc2V0LCBoYW5kbGVyQ2xhc3MgbXVzdCBhbHNvIGJlIHNldCB0byBhIG5vbi1Ob25lIHZhbHVlLlwiKTtcbiAgICB9XG4gICAgc2V0Q29udGV4dFZhcmlhYmxlKExDX0NPTkZJR1VSRV9IT09LU19LRVksIFsuLi5fZ2V0Q29uZmlndXJlSG9va3MoKSwgY29uZmlnXSk7XG59O1xuIiwgImltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBCYXNlQ2FsbGJhY2tIYW5kbGVyLCBpc0Jhc2VDYWxsYmFja0hhbmRsZXIsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgQ29uc29sZUNhbGxiYWNrSGFuZGxlciB9IGZyb20gXCIuLi90cmFjZXJzL2NvbnNvbGUuanNcIjtcbmltcG9ydCB7IGdldEJ1ZmZlclN0cmluZyB9IGZyb20gXCIuLi9tZXNzYWdlcy91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IExhbmdDaGFpblRyYWNlciwgfSBmcm9tIFwiLi4vdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmpzXCI7XG5pbXBvcnQgeyBjb25zdW1lQ2FsbGJhY2sgfSBmcm9tIFwiLi9wcm9taXNlcy5qc1wiO1xuaW1wb3J0IHsgaXNUcmFjaW5nRW5hYmxlZCB9IGZyb20gXCIuLi91dGlscy9jYWxsYmFja3MuanNcIjtcbmltcG9ydCB7IGlzQmFzZVRyYWNlciB9IGZyb20gXCIuLi90cmFjZXJzL2Jhc2UuanNcIjtcbmltcG9ydCB7IGdldENvbnRleHRWYXJpYWJsZSwgX2dldENvbmZpZ3VyZUhvb2tzLCB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2FzeW5jX2xvY2FsX3N0b3JhZ2UvY29udGV4dC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2FsbGJhY2tDb25maWdBcmcoYXJnKSB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHwgXCJuYW1lXCIgaW4gYXJnKSB7XG4gICAgICAgIHJldHVybiB7IGNhbGxiYWNrczogYXJnIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbn1cbi8qKlxuICogTWFuYWdlIGNhbGxiYWNrcyBmcm9tIGRpZmZlcmVudCBjb21wb25lbnRzIG9mIExhbmdDaGFpbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIHNldEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRIYW5kbGVycyhbaGFuZGxlcl0pO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcnVuIG1hbmFnZXIgaW4gTGFuZ0NoYWluLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHJ1bklkLCBoYW5kbGVycywgaW5oZXJpdGFibGVIYW5kbGVycywgdGFncywgaW5oZXJpdGFibGVUYWdzLCBtZXRhZGF0YSwgaW5oZXJpdGFibGVNZXRhZGF0YSwgX3BhcmVudFJ1bklkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBydW5JZFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGhhbmRsZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZUhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmhlcml0YWJsZUhhbmRsZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0YWdzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlVGFnc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZU1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBpbmhlcml0YWJsZU1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGFyZW50UnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IF9wYXJlbnRSdW5JZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudFJ1bklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50UnVuSWQ7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRleHQodGV4dCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVUZXh0Py4odGV4dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVGV4dDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBkYXRhLCBfcnVuSWQsIF90YWdzLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9tZXRhZGF0YSkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDdXN0b21FdmVudD8uKGV2ZW50TmFtZSwgZGF0YSwgdGhpcy5ydW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDdXN0b21FdmVudDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuLyoqXG4gKiBNYW5hZ2VzIGNhbGxiYWNrcyBmb3IgcmV0cmlldmVyIHJ1bnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JSZXRyaWV2ZXJSdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgZ2V0Q2hpbGQodGFnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5ydW5JZCk7XG4gICAgICAgIG1hbmFnZXIuc2V0SGFuZGxlcnModGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzKTtcbiAgICAgICAgbWFuYWdlci5hZGRUYWdzKHRoaXMuaW5oZXJpdGFibGVUYWdzKTtcbiAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEpO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZFRhZ3MoW3RhZ10sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRW5kKGRvY3VtZW50cykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVSZXRyaWV2ZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVJldHJpZXZlckVuZD8uKGRvY3VtZW50cywgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlUmV0cmlldmVyYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJFcnJvcihlcnIpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlUmV0cmlldmVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVSZXRyaWV2ZXJFcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJFcnJvcjogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlckZvckxMTVJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBhc3luYyBoYW5kbGVMTE1OZXdUb2tlbih0b2tlbiwgaWR4LCBfcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGZpZWxkcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTU5ld1Rva2VuPy4odG9rZW4sIGlkeCA/PyB7IHByb21wdDogMCwgY29tcGxldGlvbjogMCB9LCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCBmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTU5ld1Rva2VuOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVycm9yKGVyciwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBleHRyYVBhcmFtcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTUVycm9yPy4oZXJyLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCBleHRyYVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRW5kKG91dHB1dCwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBleHRyYVBhcmFtcykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTUVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgZXh0cmFQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTUVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1biBleHRlbmRzIEJhc2VSdW5NYW5hZ2VyIHtcbiAgICBnZXRDaGlsZCh0YWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcih0aGlzLnJ1bklkKTtcbiAgICAgICAgbWFuYWdlci5zZXRIYW5kbGVycyh0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMpO1xuICAgICAgICBtYW5hZ2VyLmFkZFRhZ3ModGhpcy5pbmhlcml0YWJsZVRhZ3MpO1xuICAgICAgICBtYW5hZ2VyLmFkZE1ldGFkYXRhKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVycm9yKGVyciwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYWluRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIGt3YXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5FcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpbkVuZChvdXRwdXQsIF9ydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywga3dhcmdzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDaGFpbkVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpbkVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUFnZW50QWN0aW9uPy4oYWN0aW9uLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEFjdGlvbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEVuZChhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUFnZW50RW5kPy4oYWN0aW9uLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JUb29sUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGdldENoaWxkKHRhZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMucnVuSWQpO1xuICAgICAgICBtYW5hZ2VyLnNldEhhbmRsZXJzKHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyk7XG4gICAgICAgIG1hbmFnZXIuYWRkVGFncyh0aGlzLmluaGVyaXRhYmxlVGFncyk7XG4gICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEodGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnIpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVG9vbEVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVuZChvdXRwdXQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRvb2xFbmQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHQgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXCJXaGF0IGlzIHRoZSBhbnN3ZXIgdG8ge3F1ZXN0aW9ufT9cIik7XG4gKlxuICogLy8gRXhhbXBsZSBvZiB1c2luZyBMTE1DaGFpbiB3aXRoIE9wZW5BSSBhbmQgYSBzaW1wbGUgcHJvbXB0XG4gKiBjb25zdCBjaGFpbiA9IG5ldyBMTE1DaGFpbih7XG4gKiAgIGxsbTogbmV3IENoYXRPcGVuQUkoeyB0ZW1wZXJhdHVyZTogMC45IH0pLFxuICogICBwcm9tcHQsXG4gKiB9KTtcbiAqXG4gKiAvLyBSdW5uaW5nIHRoZSBjaGFpbiB3aXRoIGEgc2luZ2xlIHF1ZXN0aW9uXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbi5jYWxsKHtcbiAqICAgcXVlc3Rpb246IFwiV2hhdCBpcyB0aGUgYWlyc3BlZWQgdmVsb2NpdHkgb2YgYW4gdW5sYWRlbiBzd2FsbG93P1wiLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhcIlRoZSBhbnN3ZXIgaXM6XCIsIHJlc3VsdCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlciBleHRlbmRzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFJ1bklkLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNhbGxiYWNrX21hbmFnZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBvcHRpb25zPy5oYW5kbGVycyA/PyB0aGlzLmhhbmRsZXJzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPVxuICAgICAgICAgICAgb3B0aW9ucz8uaW5oZXJpdGFibGVIYW5kbGVycyA/PyB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnM7XG4gICAgICAgIHRoaXMudGFncyA9IG9wdGlvbnM/LnRhZ3MgPz8gdGhpcy50YWdzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncyA9IG9wdGlvbnM/LmluaGVyaXRhYmxlVGFncyA/PyB0aGlzLmluaGVyaXRhYmxlVGFncztcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG9wdGlvbnM/Lm1ldGFkYXRhID8/IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSA9XG4gICAgICAgICAgICBvcHRpb25zPy5pbmhlcml0YWJsZU1ldGFkYXRhID8/IHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5fcGFyZW50UnVuSWQgPSBwYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHJ1biBJRCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcmVudCBydW4gSUQuXG4gICAgICovXG4gICAgZ2V0UGFyZW50UnVuSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNU3RhcnQobGxtLCBwcm9tcHRzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXB0cy5tYXAoYXN5bmMgKHByb21wdCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAvLyBDYW4ndCBoYXZlIGR1cGxpY2F0ZSBydW5zIHdpdGggdGhlIHNhbWUgcnVuIElEIChpZiBwcm92aWRlZClcbiAgICAgICAgICAgIGNvbnN0IHJ1bklkXyA9IGlkeCA9PT0gMCAmJiBydW5JZCA/IHJ1bklkIDogdXVpZHY0KCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUxMTSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0Jhc2VUcmFjZXIoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvckxMTVN0YXJ0KGxsbSwgW3Byb21wdF0sIHJ1bklkXywgdGhpcy5fcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNU3RhcnQ/LihsbG0sIFtwcm9tcHRdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkXywgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCA9IHVuZGVmaW5lZCwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBleHRyYVBhcmFtcyA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobWVzc2FnZXMubWFwKGFzeW5jIChtZXNzYWdlR3JvdXAsIGlkeCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2FuJ3QgaGF2ZSBkdXBsaWNhdGUgcnVucyB3aXRoIHRoZSBzYW1lIHJ1biBJRCAoaWYgcHJvdmlkZWQpXG4gICAgICAgICAgICBjb25zdCBydW5JZF8gPSBpZHggPT09IDAgJiYgcnVuSWQgPyBydW5JZCA6IHV1aWR2NCgpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNCYXNlVHJhY2VyKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHJ1biB0byB0aGUgcnVuIG1hcC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLl9jcmVhdGVSdW5Gb3JDaGF0TW9kZWxTdGFydChsbG0sIFttZXNzYWdlR3JvdXBdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5oYW5kbGVDaGF0TW9kZWxTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhdE1vZGVsU3RhcnQ/LihsbG0sIFttZXNzYWdlR3JvdXBdLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZXIuaGFuZGxlTExNU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlU3RyaW5nID0gZ2V0QnVmZmVyU3RyaW5nKG1lc3NhZ2VHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1TdGFydD8uKGxsbSwgW21lc3NhZ2VTdHJpbmddLCBydW5JZF8sIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVMTE1TdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yTExNUnVuKHJ1bklkXywgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkID0gdXVpZHY0KCksIHJ1blR5cGUgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQmFzZVRyYWNlcihoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHJ1biB0byB0aGUgcnVuIG1hcC5cbiAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgYXJlIGJhY2tncm91bmRlZC5cbiAgICAgICAgICAgICAgICBoYW5kbGVyLl9jcmVhdGVSdW5Gb3JDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5UeXBlLCBydW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhaW5TdGFydD8uKGNoYWluLCBpbnB1dHMsIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5UeXBlLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpblN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIucmFpc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbmV3IENhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkID0gdXVpZHY0KCksIF9wYXJlbnRSdW5JZCA9IHVuZGVmaW5lZCwgX3RhZ3MgPSB1bmRlZmluZWQsIF9tZXRhZGF0YSA9IHVuZGVmaW5lZCwgcnVuTmFtZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCYXNlVHJhY2VyKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgcnVuIHRvIHRoZSBydW4gbWFwLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgc3luY2hyb25vdXNseSB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNhbGxiYWNrcyBhcmUgYmFja2dyb3VuZGVkLlxuICAgICAgICAgICAgICAgIGhhbmRsZXIuX2NyZWF0ZVJ1bkZvclRvb2xTdGFydCh0b29sLCBpbnB1dCwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVUb29sU3RhcnQ/Lih0b29sLCBpbnB1dCwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ0Z1bmN0aW9uID0gaGFuZGxlci5yYWlzZUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uc29sZS53YXJuO1xuICAgICAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRvb2xTdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JUb29sUnVuKHJ1bklkLCB0aGlzLmhhbmRsZXJzLCB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMsIHRoaXMudGFncywgdGhpcy5pbmhlcml0YWJsZVRhZ3MsIHRoaXMubWV0YWRhdGEsIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5fcGFyZW50UnVuSWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSZXRyaWV2ZXJTdGFydChyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCA9IHV1aWR2NCgpLCBfcGFyZW50UnVuSWQgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Jhc2VUcmFjZXIoaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBydW4gdG8gdGhlIHJ1biBtYXAuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIGFyZSBiYWNrZ3JvdW5kZWQuXG4gICAgICAgICAgICAgICAgaGFuZGxlci5fY3JlYXRlUnVuRm9yUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVSZXRyaWV2ZXJTdGFydD8uKHJldHJpZXZlciwgcXVlcnksIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dGdW5jdGlvbiA9IGhhbmRsZXIucmFpc2VFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24oYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJTdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLnJhaXNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycyk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JSZXRyaWV2ZXJSdW4ocnVuSWQsIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBkYXRhLCBydW5JZCwgX3RhZ3MsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX21ldGFkYXRhKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDdXN0b21FdmVudD8uKGV2ZW50TmFtZSwgZGF0YSwgcnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nRnVuY3Rpb24gPSBoYW5kbGVyLnJhaXNlRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc29sZS5lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLndhcm47XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ3VzdG9tRXZlbnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5yYWlzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMuZmlsdGVyKChfaGFuZGxlcikgPT4gX2hhbmRsZXIgIT09IGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPSB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMuZmlsdGVyKChfaGFuZGxlcikgPT4gX2hhbmRsZXIgIT09IGhhbmRsZXIpO1xuICAgIH1cbiAgICBzZXRIYW5kbGVycyhoYW5kbGVycywgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFncyh0YWdzLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVRhZ3ModGFncyk7IC8vIFJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MucHVzaCguLi50YWdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVUYWdzKHRhZ3MpIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiAhdGFncy5pbmNsdWRlcyh0YWcpKTtcbiAgICAgICAgdGhpcy5pbmhlcml0YWJsZVRhZ3MgPSB0aGlzLmluaGVyaXRhYmxlVGFncy5maWx0ZXIoKHRhZykgPT4gIXRhZ3MuaW5jbHVkZXModGFnKSk7XG4gICAgfVxuICAgIGFkZE1ldGFkYXRhKG1ldGFkYXRhLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0geyAuLi50aGlzLm1ldGFkYXRhLCAuLi5tZXRhZGF0YSB9O1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhID0geyAuLi50aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIC4uLm1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tZXRhZGF0YVtrZXldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoYWRkaXRpb25hbEhhbmRsZXJzID0gW10sIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLmluY2x1ZGVzKGhhbmRsZXIpO1xuICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaGVyaXRhYmxlID0gdGhpcy5pbmhlcml0YWJsZVRhZ3MuaW5jbHVkZXModGFnKTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkVGFncyhbdGFnXSwgaW5oZXJpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmhlcml0YWJsZSA9IE9iamVjdC5rZXlzKHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSkuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEoeyBba2V5XTogdGhpcy5tZXRhZGF0YVtrZXldIH0sIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgYWRkaXRpb25hbEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGNvcGllcyBvZiBjb25zb2xlX2NhbGxiYWNrX2hhbmRsZXJcbiAgICAgICAgICAgIG1hbmFnZXIuaGFuZGxlcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChoKSA9PiBoLm5hbWUgPT09IFwiY29uc29sZV9jYWxsYmFja19oYW5kbGVyXCIpXG4gICAgICAgICAgICAgICAgLnNvbWUoKGgpID0+IGgubmFtZSA9PT0gaGFuZGxlci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIGNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkdjQoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgaGFuZGxlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgdGhpcygpO1xuICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIobmV3IEhhbmRsZXIoKSk7XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgY29uZmlndXJlKGluaGVyaXRhYmxlSGFuZGxlcnMsIGxvY2FsSGFuZGxlcnMsIGluaGVyaXRhYmxlVGFncywgbG9jYWxUYWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBsb2NhbE1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWd1cmVTeW5jKGluaGVyaXRhYmxlSGFuZGxlcnMsIGxvY2FsSGFuZGxlcnMsIGluaGVyaXRhYmxlVGFncywgbG9jYWxUYWdzLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBsb2NhbE1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVE9ETzogRGVwcmVjYXRlIGFzeW5jIG1ldGhvZCBpbiBmYXZvciBvZiB0aGlzIG9uZS5cbiAgICBzdGF0aWMgX2NvbmZpZ3VyZVN5bmMoaW5oZXJpdGFibGVIYW5kbGVycywgbG9jYWxIYW5kbGVycywgaW5oZXJpdGFibGVUYWdzLCBsb2NhbFRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIGxvY2FsTWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGNhbGxiYWNrTWFuYWdlcjtcbiAgICAgICAgaWYgKGluaGVyaXRhYmxlSGFuZGxlcnMgfHwgbG9jYWxIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5oZXJpdGFibGVIYW5kbGVycykgfHwgIWluaGVyaXRhYmxlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLnNldEhhbmRsZXJzKGluaGVyaXRhYmxlSGFuZGxlcnM/Lm1hcChlbnN1cmVIYW5kbGVyKSA/PyBbXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBpbmhlcml0YWJsZUhhbmRsZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyID0gY2FsbGJhY2tNYW5hZ2VyLmNvcHkoQXJyYXkuaXNBcnJheShsb2NhbEhhbmRsZXJzKVxuICAgICAgICAgICAgICAgID8gbG9jYWxIYW5kbGVycy5tYXAoZW5zdXJlSGFuZGxlcilcbiAgICAgICAgICAgICAgICA6IGxvY2FsSGFuZGxlcnM/LmhhbmRsZXJzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyYm9zZUVuYWJsZWQgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1ZFUkJPU0VcIikgPT09IFwidHJ1ZVwiIHx8XG4gICAgICAgICAgICBvcHRpb25zPy52ZXJib3NlO1xuICAgICAgICBjb25zdCB0cmFjaW5nVjJFbmFibGVkID0gTGFuZ0NoYWluVHJhY2VyLmdldFRyYWNlYWJsZVJ1blRyZWUoKT8udHJhY2luZ0VuYWJsZWQgfHxcbiAgICAgICAgICAgIGlzVHJhY2luZ0VuYWJsZWQoKTtcbiAgICAgICAgY29uc3QgdHJhY2luZ0VuYWJsZWQgPSB0cmFjaW5nVjJFbmFibGVkIHx8XG4gICAgICAgICAgICAoZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9UUkFDSU5HXCIpID8/IGZhbHNlKTtcbiAgICAgICAgaWYgKHZlcmJvc2VFbmFibGVkIHx8IHRyYWNpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJib3NlRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgICFjYWxsYmFja01hbmFnZXIuaGFuZGxlcnMuc29tZSgoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBDb25zb2xlQ2FsbGJhY2tIYW5kbGVyLnByb3RvdHlwZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnNvbGVIYW5kbGVyID0gbmV3IENvbnNvbGVDYWxsYmFja0hhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkSGFuZGxlcihjb25zb2xlSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2luZ0VuYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAhY2FsbGJhY2tNYW5hZ2VyLmhhbmRsZXJzLnNvbWUoKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNpbmdWMkVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2VyVjIgPSBuZXcgTGFuZ0NoYWluVHJhY2VyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRIYW5kbGVyKHRyYWNlclYyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZG9mZiBiZXR3ZWVuIGxhbmdjaGFpbiBhbmQgbGFuZ3NtaXRoL3RyYWNlYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZSB0aGUgcGFyZW50IHJ1biBJRFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuX3BhcmVudFJ1bklkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIExhbmdDaGFpblRyYWNlci5nZXRUcmFjZWFibGVSdW5UcmVlKCk/LmlkID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLl9wYXJlbnRSdW5JZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB7IGNvbnRleHRWYXIsIGluaGVyaXRhYmxlID0gdHJ1ZSwgaGFuZGxlckNsYXNzLCBlbnZWYXIsIH0gb2YgX2dldENvbmZpZ3VyZUhvb2tzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUlmTm90SW5Db250ZXh0ID0gZW52VmFyICYmIGdldEVudmlyb25tZW50VmFyaWFibGUoZW52VmFyKSA9PT0gXCJ0cnVlXCIgJiYgaGFuZGxlckNsYXNzO1xuICAgICAgICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0VmFyVmFsdWUgPSBjb250ZXh0VmFyICE9PSB1bmRlZmluZWQgPyBnZXRDb250ZXh0VmFyaWFibGUoY29udGV4dFZhcikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29udGV4dFZhclZhbHVlICYmIGlzQmFzZUNhbGxiYWNrSGFuZGxlcihjb250ZXh0VmFyVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGNvbnRleHRWYXJWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNyZWF0ZUlmTm90SW5Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gbmV3IGhhbmRsZXJDbGFzcyh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrTWFuYWdlci5oYW5kbGVycy5zb21lKChoKSA9PiBoLm5hbWUgPT09IGhhbmRsZXIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5oZXJpdGFibGVUYWdzIHx8IGxvY2FsVGFncykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRUYWdzKGluaGVyaXRhYmxlVGFncyA/PyBbXSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZFRhZ3MobG9jYWxUYWdzID8/IFtdLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaGVyaXRhYmxlTWV0YWRhdGEgfHwgbG9jYWxNZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRNZXRhZGF0YShpbmhlcml0YWJsZU1ldGFkYXRhID8/IHt9KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkTWV0YWRhdGEobG9jYWxNZXRhZGF0YSA/PyB7fSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFja01hbmFnZXI7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmIChcIm5hbWVcIiBpbiBoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gQmFzZUNhbGxiYWNrSGFuZGxlci5mcm9tTWV0aG9kcyhoYW5kbGVyKTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIFtgdHJhY2VhYmxlYF0oaHR0cHM6Ly9kb2NzLnNtaXRoLmxhbmdjaGFpbi5jb20vb2JzZXJ2YWJpbGl0eS9ob3dfdG9fZ3VpZGVzL3RyYWNpbmcvYW5ub3RhdGVfY29kZSlcbiAqIGZyb20gXCJsYW5nc21pdGhcIiBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgVHJhY2VHcm91cCB7XG4gICAgY29uc3RydWN0b3IoZ3JvdXBOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdyb3VwTmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ3JvdXBOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5NYW5hZ2VyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYWNlR3JvdXBDYWxsYmFja01hbmFnZXIoZ3JvdXBfbmFtZSwgaW5wdXRzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNiID0gbmV3IExhbmdDaGFpblRyYWNlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY20gPSBhd2FpdCBDYWxsYmFja01hbmFnZXIuY29uZmlndXJlKFtjYl0pO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY20/LmhhbmRsZUNoYWluU3RhcnQoe1xuICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICB0eXBlOiBcIm5vdF9pbXBsZW1lbnRlZFwiLFxuICAgICAgICAgICAgaWQ6IFtcImxhbmdjaGFpblwiLCBcImNhbGxiYWNrc1wiLCBcImdyb3Vwc1wiLCBncm91cF9uYW1lXSxcbiAgICAgICAgfSwgaW5wdXRzID8/IHt9KTtcbiAgICAgICAgaWYgKCFydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIHJ1biBncm91cCBjYWxsYmFjayBtYW5hZ2VyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuTWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoaW5wdXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5ydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bk1hbmFnZXIgPSBhd2FpdCB0aGlzLmdldFRyYWNlR3JvdXBDYWxsYmFja01hbmFnZXIodGhpcy5ncm91cE5hbWUsIGlucHV0cywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ydW5NYW5hZ2VyLmdldENoaWxkKCk7XG4gICAgfVxuICAgIGFzeW5jIGVycm9yKGVycikge1xuICAgICAgICBpZiAodGhpcy5ydW5NYW5hZ2VyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bk1hbmFnZXIuaGFuZGxlQ2hhaW5FcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy5ydW5NYW5hZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGVuZChvdXRwdXQpIHtcbiAgICAgICAgaWYgKHRoaXMucnVuTWFuYWdlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5NYW5hZ2VyLmhhbmRsZUNoYWluRW5kKG91dHB1dCA/PyB7fSk7XG4gICAgICAgICAgICB0aGlzLnJ1bk1hbmFnZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gX2NvZXJjZVRvRGljdCh2YWx1ZSwgZGVmYXVsdEtleSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiB7IFtkZWZhdWx0S2V5XTogdmFsdWUgfTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhY2VBc0dyb3VwKGdyb3VwT3B0aW9ucywgZW5jbG9zZWRDb2RlLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgdHJhY2VHcm91cCA9IG5ldyBUcmFjZUdyb3VwKGdyb3VwT3B0aW9ucy5uYW1lLCBncm91cE9wdGlvbnMpO1xuICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlciA9IGF3YWl0IHRyYWNlR3JvdXAuc3RhcnQoeyAuLi5hcmdzIH0pO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVuY2xvc2VkQ29kZShjYWxsYmFja01hbmFnZXIsIC4uLmFyZ3MpO1xuICAgICAgICBhd2FpdCB0cmFjZUdyb3VwLmVuZChfY29lcmNlVG9EaWN0KHJlc3VsdCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGF3YWl0IHRyYWNlR3JvdXAuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5pbXBvcnQgeyBSdW5UcmVlIH0gZnJvbSBcImxhbmdzbWl0aFwiO1xuaW1wb3J0IHsgZ2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSwgc2V0R2xvYmFsQXN5bmNMb2NhbFN0b3JhZ2VJbnN0YW5jZSwgX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSwgfSBmcm9tIFwiLi9nbG9iYWxzLmpzXCI7XG5pbXBvcnQgeyBDYWxsYmFja01hbmFnZXIgfSBmcm9tIFwiLi4vLi4vY2FsbGJhY2tzL21hbmFnZXIuanNcIjtcbmV4cG9ydCBjbGFzcyBNb2NrQXN5bmNMb2NhbFN0b3JhZ2Uge1xuICAgIGdldFN0b3JlKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBydW4oX3N0b3JlLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgZW50ZXJXaXRoKF9zdG9yZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNvbnN0IG1vY2tBc3luY0xvY2FsU3RvcmFnZSA9IG5ldyBNb2NrQXN5bmNMb2NhbFN0b3JhZ2UoKTtcbmNvbnN0IExDX0NISUxEX0tFWSA9IFN5bWJvbC5mb3IoXCJsYzpjaGlsZF9jb25maWdcIik7XG5jbGFzcyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyIHtcbiAgICBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UoKSA/PyBtb2NrQXN5bmNMb2NhbFN0b3JhZ2U7XG4gICAgfVxuICAgIGdldFJ1bm5hYmxlQ29uZmlnKCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAvLyB0aGlzIGhhcyB0aGUgcnVubmFibGUgY29uZmlnXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIGFsc28gaGF2ZSBhbiBpbnN0YW5jZSBvZiBhIExhbmdDaGFpblRyYWNlclxuICAgICAgICAvLyB3aXRoIHRoZSBydW4gbWFwIHByZXBvcHVsYXRlZFxuICAgICAgICByZXR1cm4gc3RvcmFnZS5nZXRTdG9yZSgpPy5leHRyYT8uW0xDX0NISUxEX0tFWV07XG4gICAgfVxuICAgIHJ1bldpdGhDb25maWcoY29uZmlnLCBjYWxsYmFjaywgYXZvaWRDcmVhdGluZ1Jvb3RSdW5UcmVlKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlciA9IENhbGxiYWNrTWFuYWdlci5fY29uZmlndXJlU3luYyhjb25maWc/LmNhbGxiYWNrcywgdW5kZWZpbmVkLCBjb25maWc/LnRhZ3MsIHVuZGVmaW5lZCwgY29uZmlnPy5tZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBzdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1bklkID0gY2FsbGJhY2tNYW5hZ2VyPy5nZXRQYXJlbnRSdW5JZCgpO1xuICAgICAgICBjb25zdCBsYW5nQ2hhaW5UcmFjZXIgPSBjYWxsYmFja01hbmFnZXI/LmhhbmRsZXJzPy5maW5kKChoYW5kbGVyKSA9PiBoYW5kbGVyPy5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIik7XG4gICAgICAgIGxldCBydW5UcmVlO1xuICAgICAgICBpZiAobGFuZ0NoYWluVHJhY2VyICYmIHBhcmVudFJ1bklkKSB7XG4gICAgICAgICAgICBydW5UcmVlID0gbGFuZ0NoYWluVHJhY2VyLmNvbnZlcnRUb1J1blRyZWUocGFyZW50UnVuSWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhdm9pZENyZWF0aW5nUm9vdFJ1blRyZWUpIHtcbiAgICAgICAgICAgIHJ1blRyZWUgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogXCI8cnVubmFibGVfbGFtYmRhPlwiLFxuICAgICAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5UcmVlKSB7XG4gICAgICAgICAgICBydW5UcmVlLmV4dHJhID0geyAuLi5ydW5UcmVlLmV4dHJhLCBbTENfQ0hJTERfS0VZXTogY29uZmlnIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZVtfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocnVuVHJlZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcnVuVHJlZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuVHJlZVtfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSA9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZVtfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmFnZS5ydW4ocnVuVHJlZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpbml0aWFsaXplR2xvYmFsSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGdldEdsb2JhbEFzeW5jTG9jYWxTdG9yYWdlSW5zdGFuY2UoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXRHbG9iYWxBc3luY0xvY2FsU3RvcmFnZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlcigpO1xuZXhwb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9O1xuIiwgImltcG9ydCB7IENhbGxiYWNrTWFuYWdlciwgZW5zdXJlSGFuZGxlciB9IGZyb20gXCIuLi9jYWxsYmFja3MvbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2luZGV4LmpzXCI7XG5leHBvcnQgY29uc3QgREVGQVVMVF9SRUNVUlNJT05fTElNSVQgPSAyNTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIENhbGxiYWNrTWFuYWdlci5fY29uZmlndXJlU3luYyhjb25maWc/LmNhbGxiYWNrcywgdW5kZWZpbmVkLCBjb25maWc/LnRhZ3MsIHVuZGVmaW5lZCwgY29uZmlnPy5tZXRhZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDb25maWdzKC4uLmNvbmZpZ3MpIHtcbiAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBjYWxsIGVuc3VyZUNvbmZpZyBvbiB0aGUgZW1wdHkgc3RhdGUgaGVyZSBhcyB0aGlzIG1heSBjYXVzZVxuICAgIC8vIGRvdWJsZSBsb2FkaW5nIG9mIGNhbGxiYWNrcyBpZiBhc3luYyBsb2NhbCBzdG9yYWdlIGlzIGJlaW5nIHVzZWQuXG4gICAgY29uc3QgY29weSA9IHt9O1xuICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBjb25maWdzLmZpbHRlcigoYykgPT4gISFjKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRpb25zKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJtZXRhZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29weVtrZXldID0geyAuLi5jb3B5W2tleV0sIC4uLm9wdGlvbnNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcInRhZ3NcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VLZXlzID0gY29weVtrZXldID8/IFtdO1xuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IFsuLi5uZXcgU2V0KGJhc2VLZXlzLmNvbmNhdChvcHRpb25zW2tleV0gPz8gW10pKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiY29uZmlndXJhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSB7IC4uLmNvcHlba2V5XSwgLi4ub3B0aW9uc1trZXldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwidGltZW91dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvcHkudGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy50aW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weS50aW1lb3V0ID0gTWF0aC5taW4oY29weS50aW1lb3V0LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJzaWduYWxcIikge1xuICAgICAgICAgICAgICAgIGlmIChjb3B5LnNpZ25hbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkuc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiYW55XCIgaW4gQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LnNpZ25hbCA9IEFib3J0U2lnbmFsLmFueShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weS5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiY2FsbGJhY2tzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlQ2FsbGJhY2tzID0gY29weS5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZWRDYWxsYmFja3MgPSBvcHRpb25zLmNhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAvLyBjYWxsYmFja3MgY2FuIGJlIGVpdGhlciB1bmRlZmluZWQsIEFycmF5PGhhbmRsZXI+IG9yIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAvLyBzbyBtZXJnaW5nIHR3byBjYWxsYmFja3MgdmFsdWVzIGhhcyA2IGNhc2VzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdmlkZWRDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBwcm92aWRlZENhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJhc2VDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IGJhc2VDYWxsYmFja3MuY29uY2F0KHByb3ZpZGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VDYWxsYmFja3MgaXMgYSBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYW5hZ2VyID0gYmFzZUNhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHByb3ZpZGVkQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGVuc3VyZUhhbmRsZXIoY2FsbGJhY2spLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbWFuYWdlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlZENhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlZENhbGxiYWNrcyBpcyBhIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiYXNlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IHByb3ZpZGVkQ2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYmFzZUNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hbmFnZXIgPSBwcm92aWRlZENhbGxiYWNrcy5jb3B5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGJhc2VDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmFkZEhhbmRsZXIoZW5zdXJlSGFuZGxlcihjYWxsYmFjayksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBtYW5hZ2VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFzZUNhbGxiYWNrcyBpcyBhbHNvIGEgbWFuYWdlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHByb3ZpZGVkQ2FsbGJhY2tzLl9wYXJlbnRSdW5JZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzOiBiYXNlQ2FsbGJhY2tzLmhhbmRsZXJzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy5oYW5kbGVycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGFibGVIYW5kbGVyczogYmFzZUNhbGxiYWNrcy5pbmhlcml0YWJsZUhhbmRsZXJzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy5pbmhlcml0YWJsZUhhbmRsZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiBBcnJheS5mcm9tKG5ldyBTZXQoYmFzZUNhbGxiYWNrcy50YWdzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy50YWdzKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRhYmxlVGFnczogQXJyYXkuZnJvbShuZXcgU2V0KGJhc2VDYWxsYmFja3MuaW5oZXJpdGFibGVUYWdzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcy5pbmhlcml0YWJsZVRhZ3MpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYmFzZUNhbGxiYWNrcy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucHJvdmlkZWRDYWxsYmFja3MubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgY29weVt0eXBlZEtleV0gPSBvcHRpb25zW3R5cGVkS2V5XSA/PyBjb3B5W3R5cGVkS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cbmNvbnN0IFBSSU1JVElWRVMgPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0pO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHBhc3NlZCBjb25maWcgaXMgYW4gb2JqZWN0IHdpdGggYWxsIHJlcXVpcmVkIGtleXMgcHJlc2VudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25zdCBpbXBsaWNpdENvbmZpZyA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0UnVubmFibGVDb25maWcoKTtcbiAgICBsZXQgZW1wdHkgPSB7XG4gICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAyNSxcbiAgICAgICAgcnVuSWQ6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIGlmIChpbXBsaWNpdENvbmZpZykge1xuICAgICAgICAvLyBEb24ndCBhbGxvdyBydW5JZCBhbmQgcnVuTmFtZSB0byBiZSBsb2FkZWQgaW1wbGljaXRseSwgYXMgdGhpcyBjYW4gY2F1c2VcbiAgICAgICAgLy8gY2hpbGQgcnVucyB0byBpbXByb3Blcmx5IGluaGVyaXQgdGhlaXIgcGFyZW50cycgcnVuIGlkcy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCB7IHJ1bklkLCBydW5OYW1lLCAuLi5yZXN0IH0gPSBpbXBsaWNpdENvbmZpZztcbiAgICAgICAgZW1wdHkgPSBPYmplY3QuZW50cmllcyhyZXN0KS5yZWR1Y2UoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChjdXJyZW50Q29uZmlnLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY3VycmVudENvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENvbmZpZztcbiAgICAgICAgfSwgZW1wdHkpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIGVtcHR5ID0gT2JqZWN0LmVudHJpZXMoY29uZmlnKS5yZWR1Y2UoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIChjdXJyZW50Q29uZmlnLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY3VycmVudENvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENvbmZpZztcbiAgICAgICAgfSwgZW1wdHkpO1xuICAgIH1cbiAgICBpZiAoZW1wdHk/LmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhlbXB0eS5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICBpZiAoUFJJTUlUSVZFUy5oYXModHlwZW9mIGVtcHR5LmNvbmZpZ3VyYWJsZVtrZXldKSAmJlxuICAgICAgICAgICAgICAgICFlbXB0eS5tZXRhZGF0YT8uW2tleV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5Lm1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5Lm1ldGFkYXRhID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtcHR5Lm1ldGFkYXRhW2tleV0gPSBlbXB0eS5jb25maWd1cmFibGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW1wdHkudGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChlbXB0eS50aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0U2lnbmFsID0gQWJvcnRTaWduYWwudGltZW91dChlbXB0eS50aW1lb3V0KTtcbiAgICAgICAgaWYgKGVtcHR5LnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoXCJhbnlcIiBpbiBBYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgZW1wdHkuc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFtlbXB0eS5zaWduYWwsIHRpbWVvdXRTaWduYWxdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVtcHR5LnNpZ25hbCA9IHRpbWVvdXRTaWduYWw7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGVtcHR5LnRpbWVvdXQ7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcGF0Y2hlcyBydW5uYWJsZSBjb25maWdzIHdpdGggdXBkYXRlZCBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDb25maWcoY29uZmlnID0ge30sIHsgY2FsbGJhY2tzLCBtYXhDb25jdXJyZW5jeSwgcmVjdXJzaW9uTGltaXQsIHJ1bk5hbWUsIGNvbmZpZ3VyYWJsZSwgcnVuSWQsIH0gPSB7fSkge1xuICAgIGNvbnN0IG5ld0NvbmZpZyA9IGVuc3VyZUNvbmZpZyhjb25maWcpO1xuICAgIGlmIChjYWxsYmFja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgcmVwbGFjaW5nIGNhbGxiYWNrcyB3ZSBuZWVkIHRvIHVuc2V0IHJ1bk5hbWVcbiAgICAgICAgICogc2luY2UgdGhhdCBzaG91bGQgYXBwbHkgb25seSB0byB0aGUgc2FtZSBydW4gYXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrc1xuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlIG5ld0NvbmZpZy5ydW5OYW1lO1xuICAgICAgICBuZXdDb25maWcuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH1cbiAgICBpZiAocmVjdXJzaW9uTGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcucmVjdXJzaW9uTGltaXQgPSByZWN1cnNpb25MaW1pdDtcbiAgICB9XG4gICAgaWYgKG1heENvbmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLm1heENvbmN1cnJlbmN5ID0gbWF4Q29uY3VycmVuY3k7XG4gICAgfVxuICAgIGlmIChydW5OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLnJ1bk5hbWUgPSBydW5OYW1lO1xuICAgIH1cbiAgICBpZiAoY29uZmlndXJhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Q29uZmlnLmNvbmZpZ3VyYWJsZSA9IHsgLi4ubmV3Q29uZmlnLmNvbmZpZ3VyYWJsZSwgLi4uY29uZmlndXJhYmxlIH07XG4gICAgfVxuICAgIGlmIChydW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBuZXdDb25maWcucnVuSWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdDb25maWc7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tSdW5uYWJsZUNvbmZpZ0tleXMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZ1xuICAgICAgICA/IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogY29uZmlnLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIHJlY3Vyc2lvbkxpbWl0OiBjb25maWcucmVjdXJzaW9uTGltaXQsXG4gICAgICAgICAgICBjYWxsYmFja3M6IGNvbmZpZy5jYWxsYmFja3MsXG4gICAgICAgICAgICB0YWdzOiBjb25maWcudGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjb25maWcubWV0YWRhdGEsXG4gICAgICAgICAgICBtYXhDb25jdXJyZW5jeTogY29uZmlnLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgdGltZW91dDogY29uZmlnLnRpbWVvdXQsXG4gICAgICAgICAgICBzaWduYWw6IGNvbmZpZy5zaWduYWwsXG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG4iLCAiZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHByb21pc2UsIHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgbGV0IGxpc3RlbmVyO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICBwcm9taXNlLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmICghc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydGVkXCIpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIE11c3QgYmUgaGVyZSBpbnNpZGUgdGhlIHByb21pc2UgdG8gYXZvaWQgYSByYWNlIGNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0ZWRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICBdKS5maW5hbGx5KCgpID0+IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpKTtcbn1cbiIsICJpbXBvcnQgeyBwaWNrUnVubmFibGVDb25maWdLZXlzIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9jb25maWcuanNcIjtcbmltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcmFjZVdpdGhTaWduYWwgfSBmcm9tIFwiLi9zaWduYWwuanNcIjtcbi8qXG4gKiBTdXBwb3J0IGFzeW5jIGl0ZXJhdG9yIHN5bnRheCBmb3IgUmVhZGFibGVTdHJlYW1zIGluIGFsbCBlbnZpcm9ubWVudHMuXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9NYXR0aWFzQnVlbGVucy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9wdWxsLzEyMiNpc3N1ZWNvbW1lbnQtMTYyNzM1NDQ5MFxuICovXG5leHBvcnQgY2xhc3MgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSBleHRlbmRzIFJlYWRhYmxlU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVhZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuc3VyZVJlYWRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIgPSB0aGlzLmdldFJlYWRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBjbG9zZWRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBlcnJvcmVkXG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkZXIoKTtcbiAgICAgICAgLy8gSWYgd3JhcHBlZCBpbiBhIE5vZGUgc3RyZWFtLCBjYW5jZWwgaXMgYWxyZWFkeSBjYWxsZWQuXG4gICAgICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHRoaXMucmVhZGVyLmNhbmNlbCgpOyAvLyBjYW5jZWwgZmlyc3QsIGJ1dCBkb24ndCBhd2FpdCB5ZXRcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayBmaXJzdFxuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTsgLy8gbm93IGF3YWl0IGl0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIHRocm93KGUpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gdGhpcy5yZWFkZXIuY2FuY2VsKCk7IC8vIGNhbmNlbCBmaXJzdCwgYnV0IGRvbid0IGF3YWl0IHlldFxuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIGZpcnN0XG4gICAgICAgICAgICBhd2FpdCBjYW5jZWxQcm9taXNlOyAvLyBub3cgYXdhaXQgaXRcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmUgTm90IHByZXNlbnQgaW4gTm9kZSAxOCB0eXBlcywgcmVxdWlyZWQgaW4gbGF0ZXN0IE5vZGUgMjJcbiAgICBhc3luYyBbU3ltYm9sLmFzeW5jRGlzcG9zZV0oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmV0dXJuKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N0cmVhbXNfQVBJL1VzaW5nX3JlYWRhYmxlX3N0cmVhbXMjcmVhZGluZ190aGVfc3RyZWFtXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBubyBtb3JlIGRhdGEgbmVlZHMgdG8gYmUgY29uc3VtZWQsIGNsb3NlIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVucXVldWUgdGhlIG5leHQgZGF0YSBjaHVuayBpbnRvIG91ciB0YXJnZXQgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1bXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFzeW5jR2VuZXJhdG9yKGdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgZ2VuZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG5vIG1vcmUgZGF0YSBuZWVkcyB0byBiZSBjb25zdW1lZCwgY2xvc2UgdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRml4OiBgZWxzZSBpZiAodmFsdWUpYCB3aWxsIGhhbmcgdGhlIHN0cmVhbWluZyB3aGVuIG51bGxpc2ggdmFsdWUgKGUuZy4gZW1wdHkgc3RyaW5nKSBpcyBwdWxsZWRcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBnZW5lcmF0b3IucmV0dXJuKHJlYXNvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYXRlZShpdGVyLCBsZW5ndGggPSAyKSB7XG4gICAgY29uc3QgYnVmZmVycyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSwgKCkgPT4gW10pO1xuICAgIHJldHVybiBidWZmZXJzLm1hcChhc3luYyBmdW5jdGlvbiogbWFrZUl0ZXIoYnVmZmVyKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGl0ZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChidWZmZXJbMF0uZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgeWllbGQgYnVmZmVyLnNoaWZ0KCkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoZmlyc3QsIHNlY29uZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpcnN0KSAmJiBBcnJheS5pc0FycmF5KHNlY29uZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0LmNvbmNhdChzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHNlY29uZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gKGZpcnN0ICsgc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBzZWNvbmQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIChmaXJzdCArIHNlY29uZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgXCJjb25jYXRcIiBpbiBmaXJzdCAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0eXBlb2YgZmlyc3QuY29uY2F0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGZpcnN0LmNvbmNhdChzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmlyc3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHNlY29uZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBjaHVuayA9IHsgLi4uZmlyc3QgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2Vjb25kKSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBjaHVuayAmJiAhQXJyYXkuaXNBcnJheShjaHVua1trZXldKSkge1xuICAgICAgICAgICAgICAgIGNodW5rW2tleV0gPSBjb25jYXQoY2h1bmtba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmtba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVuaztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbmNhdCAke3R5cGVvZiBmaXJzdH0gYW5kICR7dHlwZW9mIHNlY29uZH1gKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXN5bmNHZW5lcmF0b3JXaXRoU2V0dXAge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZW5lcmF0b3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0dXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpZ25hbFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaXJzdFJlc3VsdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaXJzdFJlc3VsdFVzZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdlbmVyYXRvciA9IHBhcmFtcy5nZW5lcmF0b3I7XG4gICAgICAgIHRoaXMuY29uZmlnID0gcGFyYW1zLmNvbmZpZztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdGhpcy5zaWduYWwgPSBwYXJhbXMuc2lnbmFsID8/IHRoaXMuY29uZmlnPy5zaWduYWw7XG4gICAgICAgIC8vIHNldHVwIGlzIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9ubHkgYWZ0ZXIgdGhlIGZpcnN0IGl0ZXJhdG9yIHZhbHVlXG4gICAgICAgIC8vIGlzIGF2YWlsYWJsZS4gdGhpcyBpcyB1c2VmdWwgd2hlbiBzZXR1cCBvZiBzZXZlcmFsIHBpcGVkIGdlbmVyYXRvcnNcbiAgICAgICAgLy8gbmVlZHMgdG8gaGFwcGVuIGluIGxvZ2ljYWwgb3JkZXIsIGllLiBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggaW5wdXQgdG9cbiAgICAgICAgLy8gdG8gZWFjaCBnZW5lcmF0b3IgaXMgYXZhaWxhYmxlLlxuICAgICAgICB0aGlzLnNldHVwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdm9pZCBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcocGlja1J1bm5hYmxlQ29uZmlnS2V5cyhwYXJhbXMuY29uZmlnKSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHQgPSBwYXJhbXMuZ2VuZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnN0YXJ0U2V0dXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdC50aGVuKHBhcmFtcy5zdGFydFNldHVwKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0UmVzdWx0LnRoZW4oKF9yZXN1bHQpID0+IHJlc29sdmUodW5kZWZpbmVkKSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIG5leHQoLi4uYXJncykge1xuICAgICAgICB0aGlzLnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UmVzdWx0VXNlZCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdFVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24ucnVuV2l0aENvbmZpZyhwaWNrUnVubmFibGVDb25maWdLZXlzKHRoaXMuY29uZmlnKSwgdGhpcy5zaWduYWxcbiAgICAgICAgICAgID8gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByYWNlV2l0aFNpZ25hbCh0aGlzLmdlbmVyYXRvci5uZXh0KC4uLmFyZ3MpLCB0aGlzLnNpZ25hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0b3IubmV4dCguLi5hcmdzKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLnJldHVybih2YWx1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHRocm93KGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLnRocm93KGUpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmUgTm90IHByZXNlbnQgaW4gTm9kZSAxOCB0eXBlcywgcmVxdWlyZWQgaW4gbGF0ZXN0IE5vZGUgMjJcbiAgICBhc3luYyBbU3ltYm9sLmFzeW5jRGlzcG9zZV0oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmV0dXJuKCk7XG4gICAgfVxufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBpcGVHZW5lcmF0b3JXaXRoU2V0dXAodG8sIGdlbmVyYXRvciwgc3RhcnRTZXR1cCwgc2lnbmFsLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZ2VuID0gbmV3IEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHtcbiAgICAgICAgZ2VuZXJhdG9yLFxuICAgICAgICBzdGFydFNldHVwLFxuICAgICAgICBzaWduYWwsXG4gICAgfSk7XG4gICAgY29uc3Qgc2V0dXAgPSBhd2FpdCBnZW4uc2V0dXA7XG4gICAgcmV0dXJuIHsgb3V0cHV0OiB0byhnZW4sIHNldHVwLCAuLi5hcmdzKSwgc2V0dXAgfTtcbn1cbiIsICJpbXBvcnQgeyBhcHBseVBhdGNoLCB9IGZyb20gXCIuLi91dGlscy9mYXN0LWpzb24tcGF0Y2gvaW5kZXguanNcIjtcbmltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgQUlNZXNzYWdlQ2h1bmsgfSBmcm9tIFwiLi4vbWVzc2FnZXMvYWkuanNcIjtcbi8qKlxuICogTGlzdCBvZiBqc29ucGF0Y2ggSlNPTlBhdGNoT3BlcmF0aW9ucywgd2hpY2ggZGVzY3JpYmUgaG93IHRvIGNyZWF0ZSB0aGUgcnVuIHN0YXRlXG4gKiBmcm9tIGFuIGVtcHR5IGRpY3QuIFRoaXMgaXMgdGhlIG1pbmltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxvZywgZGVzaWduZWQgdG9cbiAqIGJlIHNlcmlhbGl6ZWQgYXMgSlNPTiBhbmQgc2VudCBvdmVyIHRoZSB3aXJlIHRvIHJlY29uc3RydWN0IHRoZSBsb2cgb24gdGhlIG90aGVyXG4gKiBzaWRlLiBSZWNvbnN0cnVjdGlvbiBvZiB0aGUgc3RhdGUgY2FuIGJlIGRvbmUgd2l0aCBhbnkganNvbnBhdGNoLWNvbXBsaWFudCBsaWJyYXJ5LFxuICogc2VlIGh0dHBzOi8vanNvbnBhdGNoLmNvbSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bkxvZ1BhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3BzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3BzID0gZmllbGRzLm9wcyA/PyBbXTtcbiAgICB9XG4gICAgY29uY2F0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMub3BzLmNvbmNhdChvdGhlci5vcHMpO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBhcHBseVBhdGNoKHt9LCBvcHMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHtcbiAgICAgICAgICAgIG9wcyxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdLm5ld0RvY3VtZW50LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVuTG9nIGV4dGVuZHMgUnVuTG9nUGF0Y2gge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0gZmllbGRzLnN0YXRlO1xuICAgIH1cbiAgICBjb25jYXQob3RoZXIpIHtcbiAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5vcHMuY29uY2F0KG90aGVyLm9wcyk7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGFwcGx5UGF0Y2godGhpcy5zdGF0ZSwgb3RoZXIub3BzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5Mb2coeyBvcHMsIHN0YXRlOiBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdLm5ld0RvY3VtZW50IH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJ1bkxvZ1BhdGNoKHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGFwcGx5UGF0Y2goe30sIHBhdGNoLm9wcyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5Mb2coe1xuICAgICAgICAgICAgb3BzOiBwYXRjaC5vcHMsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGlzTG9nU3RyZWFtSGFuZGxlciA9IChoYW5kbGVyKSA9PiBoYW5kbGVyLm5hbWUgPT09IFwibG9nX3N0cmVhbV90cmFjZXJcIjtcbi8qKlxuICogRXh0cmFjdCBzdGFuZGFyZGl6ZWQgaW5wdXRzIGZyb20gYSBydW4uXG4gKlxuICogU3RhbmRhcmRpemVzIHRoZSBpbnB1dHMgYmFzZWQgb24gdGhlIHR5cGUgb2YgdGhlIHJ1bm5hYmxlIHVzZWQuXG4gKlxuICogQHBhcmFtIHJ1biAtIFJ1biBvYmplY3RcbiAqIEBwYXJhbSBzY2hlbWFGb3JtYXQgLSBUaGUgc2NoZW1hIGZvcm1hdCB0byB1c2UuXG4gKlxuICogQHJldHVybnMgVmFsaWQgaW5wdXRzIGFyZSBvbmx5IGRpY3QuIEJ5IGNvbnZlbnRpb25zLCBpbnB1dHMgYWx3YXlzIHJlcHJlc2VudGVkXG4gKiBpbnZvY2F0aW9uIHVzaW5nIG5hbWVkIGFyZ3VtZW50cy5cbiAqIEEgbnVsbCBtZWFucyB0aGF0IHRoZSBpbnB1dCBpcyBub3QgeWV0IGtub3duIVxuICovXG5hc3luYyBmdW5jdGlvbiBfZ2V0U3RhbmRhcmRpemVkSW5wdXRzKHJ1biwgc2NoZW1hRm9ybWF0KSB7XG4gICAgaWYgKHNjaGVtYUZvcm1hdCA9PT0gXCJvcmlnaW5hbFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvIG5vdCBhc3NpZ24gaW5wdXRzIHdpdGggb3JpZ2luYWwgc2NoZW1hIGRyb3AgdGhlIGtleSBmb3Igbm93LiBcIiArXG4gICAgICAgICAgICBcIldoZW4gaW5wdXRzIGFyZSBhZGRlZCB0byBzdHJlYW1Mb2cgdGhleSBzaG91bGQgYmUgYWRkZWQgd2l0aCBcIiArXG4gICAgICAgICAgICBcInN0YW5kYXJkaXplZCBzY2hlbWEgZm9yIHN0cmVhbWluZyBldmVudHMuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlucHV0cyB9ID0gcnVuO1xuICAgIGlmIChbXCJyZXRyaWV2ZXJcIiwgXCJsbG1cIiwgXCJwcm9tcHRcIl0uaW5jbHVkZXMocnVuLnJ1bl90eXBlKSkge1xuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMoaW5wdXRzKS5sZW5ndGggPT09IDEgJiYgaW5wdXRzPy5pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBuZXcgc3R5bGUgY2hhaW5zXG4gICAgLy8gVGhlc2UgbmVzdCBhbiBhZGRpdGlvbmFsICdpbnB1dCcga2V5IGluc2lkZSB0aGUgJ2lucHV0cycgdG8gbWFrZSBzdXJlXG4gICAgLy8gdGhlIGlucHV0IGlzIGFsd2F5cyBhIGRpY3QuIFdlIG5lZWQgdG8gdW5wYWNrIGFuZCB1c2VyIHRoZSBpbm5lciB2YWx1ZS5cbiAgICAvLyBXZSBzaG91bGQgdHJ5IHRvIGZpeCB0aGlzIGluIFJ1bm5hYmxlcyBhbmQgY2FsbGJhY2tzL3RyYWNlcnNcbiAgICAvLyBSdW5uYWJsZXMgc2hvdWxkIGJlIHVzaW5nIGEgbnVsbCB0eXBlIGhlcmUgbm90IGEgcGxhY2Vob2xkZXJcbiAgICAvLyBkaWN0LlxuICAgIHJldHVybiBpbnB1dHMuaW5wdXQ7XG59XG5hc3luYyBmdW5jdGlvbiBfZ2V0U3RhbmRhcmRpemVkT3V0cHV0cyhydW4sIHNjaGVtYUZvcm1hdCkge1xuICAgIGNvbnN0IHsgb3V0cHV0cyB9ID0gcnVuO1xuICAgIGlmIChzY2hlbWFGb3JtYXQgPT09IFwib3JpZ2luYWxcIikge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIG9sZCBzY2hlbWEsIHdpdGhvdXQgc3RhbmRhcmRpemluZyBhbnl0aGluZ1xuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgaWYgKFtcInJldHJpZXZlclwiLCBcImxsbVwiLCBcInByb21wdFwiXS5pbmNsdWRlcyhydW4ucnVuX3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBoYWNreSBjaGVja1xuICAgIGlmIChvdXRwdXRzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgT2JqZWN0LmtleXMob3V0cHV0cykubGVuZ3RoID09PSAxICYmXG4gICAgICAgIG91dHB1dHM/Lm91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzLm91dHB1dDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dHM7XG59XG5mdW5jdGlvbiBpc0NoYXRHZW5lcmF0aW9uQ2h1bmsoeCkge1xuICAgIHJldHVybiB4ICE9PSB1bmRlZmluZWQgJiYgeC5tZXNzYWdlICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyB0aGUgYEJhc2VUcmFjZXJgIGNsYXNzIGZyb20gdGhlXG4gKiBgbGFuZ2NoYWluLmNhbGxiYWNrcy50cmFjZXJzLmJhc2VgIG1vZHVsZS4gSXQgcmVwcmVzZW50cyBhIGNhbGxiYWNrXG4gKiBoYW5kbGVyIHRoYXQgbG9ncyB0aGUgZXhlY3V0aW9uIG9mIHJ1bnMgYW5kIGVtaXRzIGBSdW5Mb2dgIGluc3RhbmNlcyB0byBhXG4gKiBgUnVuTG9nU3RyZWFtYC5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIEJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcih7IF9hd2FpdEhhbmRsZXI6IHRydWUsIC4uLmZpZWxkcyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0Nsb3NlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NjaGVtYUZvcm1hdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJvcmlnaW5hbFwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb290SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5TWFwQnlSdW5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvdW50ZXJNYXBCeVJ1bk5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc2Zvcm1TdHJlYW1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid3JpdGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlY2VpdmVTdHJlYW1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJsb2dfc3RyZWFtX3RyYWNlclwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19wcmVmZXJfc3RyZWFtaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmF1dG9DbG9zZSA9IGZpZWxkcz8uYXV0b0Nsb3NlID8/IHRydWU7XG4gICAgICAgIHRoaXMuaW5jbHVkZU5hbWVzID0gZmllbGRzPy5pbmNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID0gZmllbGRzPy5pbmNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPSBmaWVsZHM/LmluY2x1ZGVUYWdzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVOYW1lcyA9IGZpZWxkcz8uZXhjbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUeXBlcyA9IGZpZWxkcz8uZXhjbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUYWdzID0gZmllbGRzPy5leGNsdWRlVGFncztcbiAgICAgICAgdGhpcy5fc2NoZW1hRm9ybWF0ID0gZmllbGRzPy5fc2NoZW1hRm9ybWF0ID8/IHRoaXMuX3NjaGVtYUZvcm1hdDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1TdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKCk7XG4gICAgICAgIHRoaXMud3JpdGVyID0gdGhpcy50cmFuc2Zvcm1TdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZVN0cmVhbSA9IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKHRoaXMudHJhbnNmb3JtU3RyZWFtLnJlYWRhYmxlKTtcbiAgICB9XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZVN0cmVhbTtcbiAgICB9XG4gICAgYXN5bmMgcGVyc2lzdFJ1bihfcnVuKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBsZWdhY3kgbWV0aG9kIG9ubHkgY2FsbGVkIG9uY2UgZm9yIGFuIGVudGlyZSBydW4gdHJlZVxuICAgICAgICAvLyBhbmQgaXMgdGhlcmVmb3JlIG5vdCB1c2VmdWwgaGVyZVxuICAgIH1cbiAgICBfaW5jbHVkZVJ1bihydW4pIHtcbiAgICAgICAgaWYgKHJ1bi5pZCA9PT0gdGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5UYWdzID0gcnVuLnRhZ3MgPz8gW107XG4gICAgICAgIGxldCBpbmNsdWRlID0gdGhpcy5pbmNsdWRlTmFtZXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5pbmNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVUeXBlcy5pbmNsdWRlcyhydW4ucnVuX3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgcnVuVGFncy5maW5kKCh0YWcpID0+IHRoaXMuaW5jbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVOYW1lcy5pbmNsdWRlcyhydW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVUeXBlcy5pbmNsdWRlcyhydW4ucnVuX3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgJiYgcnVuVGFncy5ldmVyeSgodGFnKSA9PiAhdGhpcy5leGNsdWRlVGFncz8uaW5jbHVkZXModGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfVxuICAgIGFzeW5jICp0YXBPdXRwdXRJdGVyYWJsZShydW5JZCwgb3V0cHV0KSB7XG4gICAgICAgIC8vIFRhcCBhbiBvdXRwdXQgYXN5bmMgaXRlcmF0b3IgdG8gc3RyZWFtIGl0cyB2YWx1ZXMgdG8gdGhlIGxvZy5cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBvdXRwdXQpIHtcbiAgICAgICAgICAgIC8vIHJvb3QgcnVuIGlzIGhhbmRsZWQgaW4gLnN0cmVhbUxvZygpXG4gICAgICAgICAgICBpZiAocnVuSWQgIT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmluZCB0aGUgcnVuIHNpbGVudGx5IGlnbm9yZVxuICAgICAgICAgICAgICAgIC8vIGVnLiBiZWNhdXNlIHRoaXMgcnVuIHdhc24ndCBpbmNsdWRlZCBpbiB0aGUgbG9nXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bklkXTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtrZXl9L3N0cmVhbWVkX291dHB1dC8tYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25SdW5DcmVhdGUocnVuKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RJZCA9IHJ1bi5pZDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBydW4uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcnVuLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbWVkX291dHB1dDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxfb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbmNsdWRlUnVuKHJ1bikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJNYXBCeVJ1bk5hbWVbcnVuLm5hbWVdID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvdW50ZXJNYXBCeVJ1bk5hbWVbcnVuLm5hbWVdICs9IDE7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXTtcbiAgICAgICAgdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF0gPVxuICAgICAgICAgICAgY291bnQgPT09IDEgPyBydW4ubmFtZSA6IGAke3J1bi5uYW1lfToke2NvdW50fWA7XG4gICAgICAgIGNvbnN0IGxvZ0VudHJ5ID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IG5ldyBEYXRlKHJ1bi5zdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgc3RyZWFtZWRfb3V0cHV0OiBbXSxcbiAgICAgICAgICAgIHN0cmVhbWVkX291dHB1dF9zdHI6IFtdLFxuICAgICAgICAgICAgZmluYWxfb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlbmRfdGltZTogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fc2NoZW1hRm9ybWF0ID09PSBcInN0cmVhbWluZ19ldmVudHNcIikge1xuICAgICAgICAgICAgbG9nRW50cnkuaW5wdXRzID0gYXdhaXQgX2dldFN0YW5kYXJkaXplZElucHV0cyhydW4sIHRoaXMuX3NjaGVtYUZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUobmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3RoaXMua2V5TWFwQnlSdW5JZFtydW4uaWRdfWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsb2dFbnRyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBvblJ1blVwZGF0ZShydW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bk5hbWUgPSB0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXTtcbiAgICAgICAgICAgIGlmIChydW5OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2hlbWFGb3JtYXQgPT09IFwic3RyZWFtaW5nX2V2ZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L2lucHV0c2AsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBfZ2V0U3RhbmRhcmRpemVkSW5wdXRzKHJ1biwgdGhpcy5fc2NoZW1hRm9ybWF0KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9maW5hbF9vdXRwdXRgLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBfZ2V0U3RhbmRhcmRpemVkT3V0cHV0cyhydW4sIHRoaXMuX3NjaGVtYUZvcm1hdCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChydW4uZW5kX3RpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGAvbG9ncy8ke3J1bk5hbWV9L2VuZF90aW1lYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHsgb3BzIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHJ1bi5pZCA9PT0gdGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIi9maW5hbF9vdXRwdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgX2dldFN0YW5kYXJkaXplZE91dHB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShwYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0Nsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uTExNTmV3VG9rZW4ocnVuLCB0b2tlbiwga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bk5hbWUgPSB0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXTtcbiAgICAgICAgaWYgKHJ1bk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBoYWNrXG4gICAgICAgIGNvbnN0IGlzQ2hhdE1vZGVsID0gcnVuLmlucHV0cy5tZXNzYWdlcyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgc3RyZWFtZWRPdXRwdXRWYWx1ZTtcbiAgICAgICAgaWYgKGlzQ2hhdE1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoaXNDaGF0R2VuZXJhdGlvbkNodW5rKGt3YXJncz8uY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtZWRPdXRwdXRWYWx1ZSA9IGt3YXJncz8uY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1lZE91dHB1dFZhbHVlID0gbmV3IEFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGBydW4tJHtydW4uaWR9YCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW1lZE91dHB1dFZhbHVlID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vc3RyZWFtZWRfb3V0cHV0X3N0ci8tYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRva2VuLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vc3RyZWFtZWRfb3V0cHV0Ly1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RyZWFtZWRPdXRwdXRWYWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IFJVTl9LRVkgPSBcIl9fcnVuXCI7XG4vKipcbiAqIENodW5rIG9mIGEgc2luZ2xlIGdlbmVyYXRpb24uIFVzZWQgZm9yIHN0cmVhbWluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEdlbmVyYXRpb25DaHVuayB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRleHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VuZXJhdGlvbkluZm9cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50ZXh0ID0gZmllbGRzLnRleHQ7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbkluZm8gPSBmaWVsZHMuZ2VuZXJhdGlvbkluZm87XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQgKyBjaHVuay50ZXh0LFxuICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgIC4uLmNodW5rLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENoYXRHZW5lcmF0aW9uQ2h1bmsgZXh0ZW5kcyBHZW5lcmF0aW9uQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGZpZWxkcy5tZXNzYWdlO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCArIGNodW5rLnRleHQsXG4gICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgLi4uY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLmNvbmNhdChjaHVuay5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgQUlNZXNzYWdlQ2h1bmsgfSBmcm9tIFwiLi4vbWVzc2FnZXMvYWkuanNcIjtcbmltcG9ydCB7IEdlbmVyYXRpb25DaHVuayB9IGZyb20gXCIuLi9vdXRwdXRzLmpzXCI7XG5mdW5jdGlvbiBhc3NpZ25OYW1lKHsgbmFtZSwgc2VyaWFsaXplZCwgfSkge1xuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemVkPy5uYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VyaWFsaXplZD8uaWQgIT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWQ/LmlkKSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZC5pZFtzZXJpYWxpemVkLmlkLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gXCJVbm5hbWVkXCI7XG59XG5leHBvcnQgY29uc3QgaXNTdHJlYW1FdmVudHNIYW5kbGVyID0gKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJldmVudF9zdHJlYW1fdHJhY2VyXCI7XG4vKipcbiAqIENsYXNzIHRoYXQgZXh0ZW5kcyB0aGUgYEJhc2VUcmFjZXJgIGNsYXNzIGZyb20gdGhlXG4gKiBgbGFuZ2NoYWluLmNhbGxiYWNrcy50cmFjZXJzLmJhc2VgIG1vZHVsZS4gSXQgcmVwcmVzZW50cyBhIGNhbGxiYWNrXG4gKiBoYW5kbGVyIHRoYXQgbG9ncyB0aGUgZXhlY3V0aW9uIG9mIHJ1bnMgYW5kIGVtaXRzIGBSdW5Mb2dgIGluc3RhbmNlcyB0byBhXG4gKiBgUnVuTG9nU3RyZWFtYC5cbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50U3RyZWFtQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKHsgX2F3YWl0SGFuZGxlcjogdHJ1ZSwgLi4uZmllbGRzIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQ2xvc2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5JbmZvTWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhcHBlZFByb21pc2VzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zZm9ybVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cml0ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVjZWl2ZVN0cmVhbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImV2ZW50X3N0cmVhbV90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfcHJlZmVyX3N0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPSBmaWVsZHM/LmF1dG9DbG9zZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lcyA9IGZpZWxkcz8uaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcz8uaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzPy5pbmNsdWRlVGFncztcbiAgICAgICAgdGhpcy5leGNsdWRlTmFtZXMgPSBmaWVsZHM/LmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHM/LmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcz8uZXhjbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICB0aGlzLndyaXRlciA9IHRoaXMudHJhbnNmb3JtU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVTdHJlYW0gPSBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbSh0aGlzLnRyYW5zZm9ybVN0cmVhbS5yZWFkYWJsZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVTdHJlYW07XG4gICAgfVxuICAgIGFzeW5jIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgICAgLy8gYW5kIGlzIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICB9XG4gICAgX2luY2x1ZGVSdW4ocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blRhZ3MgPSBydW4udGFncyA/PyBbXTtcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0aGlzLmluY2x1ZGVOYW1lcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhydW4ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZVR5cGVzLmluY2x1ZGVzKHJ1bi5ydW5UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ1blRhZ3MuZmluZCgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1blR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgJiYgcnVuVGFncy5ldmVyeSgodGFnKSA9PiAhdGhpcy5leGNsdWRlVGFncz8uaW5jbHVkZXModGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfVxuICAgIGFzeW5jICp0YXBPdXRwdXRJdGVyYWJsZShydW5JZCwgb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2h1bmsgPSBhd2FpdCBvdXRwdXRTdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoZmlyc3RDaHVuay5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuSWQpO1xuICAgICAgICAvLyBSdW4gaGFzIGZpbmlzaGVkLCBkb24ndCBpc3N1ZSBhbnkgc3RyZWFtIGV2ZW50cy5cbiAgICAgICAgLy8gQW4gZXhhbXBsZSBvZiB0aGlzIGlzIGZvciBydW5uYWJsZXMgdGhhdCB1c2UgdGhlIGRlZmF1bHRcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gb2YgLnN0cmVhbSgpLCB3aGljaCBkZWxlZ2F0ZXMgdG8gLmludm9rZSgpXG4gICAgICAgIC8vIGFuZCBjYWxscyAub25DaGFpbkVuZCgpIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSBpdGVyYXRvci5cbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeWllbGQgZmlyc3RDaHVuay52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXRjaCBmb3JtYXQgZnJvbSBoYW5kbGVycyBiZWxvd1xuICAgICAgICBmdW5jdGlvbiBfZm9ybWF0T3V0cHV0Q2h1bmsoZXZlbnRUeXBlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcImxsbVwiICYmIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0aW9uQ2h1bmsoeyB0ZXh0OiBkYXRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcHBlZFByb21pc2UgPSB0aGlzLnRhcHBlZFByb21pc2VzLmdldChydW5JZCk7XG4gICAgICAgIC8vIGlmIHdlIGFyZSB0aGUgZmlyc3QgdG8gdGFwLCBpc3N1ZSBzdHJlYW0gZXZlbnRzXG4gICAgICAgIGlmICh0YXBwZWRQcm9taXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCB0YXBwZWRQcm9taXNlUmVzb2x2ZXI7XG4gICAgICAgICAgICB0YXBwZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB0YXBwZWRQcm9taXNlUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRhcHBlZFByb21pc2VzLnNldChydW5JZCwgdGFwcGVkUHJvbWlzZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7cnVuSW5mby5ydW5UeXBlfV9zdHJlYW1gLFxuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBfZm9ybWF0T3V0cHV0Q2h1bmsocnVuSW5mby5ydW5UeXBlLCBmaXJzdENodW5rLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCBydW5JbmZvKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBmaXJzdENodW5rLnZhbHVlO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHlpZWxkIHRvb2wgYW5kIHJldHJpZXZlciBzdHJlYW0gZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChydW5JbmZvLnJ1blR5cGUgIT09IFwidG9vbFwiICYmIHJ1bkluZm8ucnVuVHlwZSAhPT0gXCJyZXRyaWV2ZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiBfZm9ybWF0T3V0cHV0Q2h1bmsocnVuSW5mby5ydW5UeXBlLCBjaHVuayksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJ1bkluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgdGFwcGVkUHJvbWlzZVJlc29sdmVyKCk7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgZGVsZXRlIGZyb20gdGhlIHByb21pc2VzIG1hcCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIHJ1bnMgaGF2ZSBiZWVuIHRhcHBlZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHBhc3MgdGhyb3VnaFxuICAgICAgICAgICAgeWllbGQgZmlyc3RDaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZChwYXlsb2FkLCBydW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2luY2x1ZGVSdW4ocnVuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZEVuZEV2ZW50KHBheWxvYWQsIHJ1bikge1xuICAgICAgICBjb25zdCB0YXBwZWRQcm9taXNlID0gdGhpcy50YXBwZWRQcm9taXNlcy5nZXQocGF5bG9hZC5ydW5faWQpO1xuICAgICAgICBpZiAodGFwcGVkUHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2b2lkIHRhcHBlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLnNlbmQocGF5bG9hZCwgcnVuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHBheWxvYWQsIHJ1bik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25MTE1TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IGFzc2lnbk5hbWUocnVuKTtcbiAgICAgICAgY29uc3QgcnVuVHlwZSA9IHJ1bi5pbnB1dHMubWVzc2FnZXMgIT09IHVuZGVmaW5lZCA/IFwiY2hhdF9tb2RlbFwiIDogXCJsbG1cIjtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHtcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBuYW1lOiBydW5OYW1lLFxuICAgICAgICAgICAgcnVuVHlwZSxcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBgb25fJHtydW5UeXBlfV9zdGFydGA7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlucHV0OiBydW4uaW5wdXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkxMTU5ld1Rva2VuKHJ1biwgdG9rZW4sIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAga3dhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgbGV0IGV2ZW50TmFtZTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvbkxMTU5ld1Rva2VuOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvcC1sZXZlbCBzdHJlYW1pbmcgZXZlbnRzIGFyZSBjb3ZlcmVkIGJ5IHRhcE91dHB1dEl0ZXJhYmxlXG4gICAgICAgIGlmICh0aGlzLnJ1bkluZm9NYXAuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5JbmZvLnJ1blR5cGUgPT09IFwiY2hhdF9tb2RlbFwiKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uX2NoYXRfbW9kZWxfc3RyZWFtXCI7XG4gICAgICAgICAgICBpZiAoa3dhcmdzPy5jaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgQUlNZXNzYWdlQ2h1bmsoeyBjb250ZW50OiB0b2tlbiwgaWQ6IGBydW4tJHtydW4uaWR9YCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rID0ga3dhcmdzLmNodW5rLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuSW5mby5ydW5UeXBlID09PSBcImxsbVwiKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBcIm9uX2xsbV9zdHJlYW1cIjtcbiAgICAgICAgICAgIGlmIChrd2FyZ3M/LmNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBHZW5lcmF0aW9uQ2h1bmsoeyB0ZXh0OiB0b2tlbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rID0ga3dhcmdzLmNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHJ1biB0eXBlICR7cnVuSW5mby5ydW5UeXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkxMTUVuZChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBsZXQgZXZlbnROYW1lO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uTExNRW5kOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gcnVuLm91dHB1dHM/LmdlbmVyYXRpb25zO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICBpZiAocnVuSW5mby5ydW5UeXBlID09PSBcImNoYXRfbW9kZWxcIikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0aW9uIG9mIGdlbmVyYXRpb25zID8/IFtdKSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBnZW5lcmF0aW9uWzBdPy5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbl9jaGF0X21vZGVsX2VuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bkluZm8ucnVuVHlwZSA9PT0gXCJsbG1cIikge1xuICAgICAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBnZW5lcmF0aW9ucz8ubWFwKChnZW5lcmF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0aW9uLm1hcCgoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzogY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBsbG1PdXRwdXQ6IHJ1bi5vdXRwdXRzPy5sbG1PdXRwdXQgPz8ge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnROYW1lID0gXCJvbl9sbG1fZW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uTExNRW5kOiBVbmV4cGVjdGVkIHJ1biB0eXBlOiAke3J1bkluZm8ucnVuVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFbmRFdmVudCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuSW5mby5pbnB1dHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uQ2hhaW5TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuTmFtZSA9IGFzc2lnbk5hbWUocnVuKTtcbiAgICAgICAgY29uc3QgcnVuVHlwZSA9IHJ1bi5ydW5fdHlwZSA/PyBcImNoYWluXCI7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB7XG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW4uZXh0cmE/Lm1ldGFkYXRhID8/IHt9LFxuICAgICAgICAgICAgbmFtZTogcnVuTmFtZSxcbiAgICAgICAgICAgIHJ1blR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGV2ZW50RGF0YSA9IHt9O1xuICAgICAgICAvLyBXb3JrYXJvdW5kIFJ1bm5hYmxlIGNvcmUgY29kZSBub3Qgc2VuZGluZyBpbnB1dCB3aGVuIHRyYW5zZm9ybSBzdHJlYW1pbmcuXG4gICAgICAgIGlmIChydW4uaW5wdXRzLmlucHV0ID09PSBcIlwiICYmIE9iamVjdC5rZXlzKHJ1bi5pbnB1dHMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZXZlbnREYXRhID0ge307XG4gICAgICAgICAgICBydW5JbmZvLmlucHV0cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bi5pbnB1dHMuaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXZlbnREYXRhLmlucHV0ID0gcnVuLmlucHV0cy5pbnB1dDtcbiAgICAgICAgICAgIHJ1bkluZm8uaW5wdXRzID0gcnVuLmlucHV0cy5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YS5pbnB1dCA9IHJ1bi5pbnB1dHM7XG4gICAgICAgICAgICBydW5JbmZvLmlucHV0cyA9IHJ1bi5pbnB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3J1blR5cGV9X3N0YXJ0YCxcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50RGF0YSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvbkNoYWluRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBydW5JbmZvID0gdGhpcy5ydW5JbmZvTWFwLmdldChydW4uaWQpO1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgIGlmIChydW5JbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25DaGFpbkVuZDogUnVuIElEICR7cnVuLmlkfSBub3QgZm91bmQgaW4gcnVuIG1hcC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBgb25fJHtydW4ucnVuX3R5cGV9X2VuZGA7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHJ1bi5pbnB1dHMgPz8gcnVuSW5mby5pbnB1dHMgPz8ge307XG4gICAgICAgIGNvbnN0IG91dHB1dHMgPSBydW4ub3V0cHV0cz8ub3V0cHV0ID8/IHJ1bi5vdXRwdXRzO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXRzLFxuICAgICAgICAgICAgaW5wdXQ6IGlucHV0cyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlucHV0cy5pbnB1dCAmJiBPYmplY3Qua2V5cyhpbnB1dHMpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZGF0YS5pbnB1dCA9IGlucHV0cy5pbnB1dDtcbiAgICAgICAgICAgIHJ1bkluZm8uaW5wdXRzID0gaW5wdXRzLmlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVuZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uVG9vbFN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gYXNzaWduTmFtZShydW4pO1xuICAgICAgICBjb25zdCBydW5JbmZvID0ge1xuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5UeXBlOiBcInRvb2xcIixcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyA/PyB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLnNldChydW4uaWQsIHJ1bkluZm8pO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgZXZlbnQ6IFwib25fdG9vbF9zdGFydFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGlucHV0OiBydW4uaW5wdXRzID8/IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5faWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvblRvb2xFbmQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bkluZm8gPSB0aGlzLnJ1bkluZm9NYXAuZ2V0KHJ1bi5pZCk7XG4gICAgICAgIHRoaXMucnVuSW5mb01hcC5kZWxldGUocnVuLmlkKTtcbiAgICAgICAgaWYgKHJ1bkluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvblRvb2xFbmQ6IFJ1biBJRCAke3J1bi5pZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bkluZm8uaW5wdXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25Ub29sRW5kOiBSdW4gSUQgJHtydW4uaWR9IGlzIGEgdG9vbCBjYWxsLCBhbmQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0cmFjZWQgaW5wdXRzLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHJ1bi5vdXRwdXRzPy5vdXRwdXQgPT09IHVuZGVmaW5lZCA/IHJ1bi5vdXRwdXRzIDogcnVuLm91dHB1dHMub3V0cHV0O1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRFbmRFdmVudCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl90b29sX2VuZFwiLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcnVuSW5mby5pbnB1dHMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVuX2lkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW5JbmZvLm5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW5JbmZvLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuSW5mby5tZXRhZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIG9uUmV0cmlldmVyU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1bk5hbWUgPSBhc3NpZ25OYW1lKHJ1bik7XG4gICAgICAgIGNvbnN0IHJ1blR5cGUgPSBcInJldHJpZXZlclwiO1xuICAgICAgICBjb25zdCBydW5JbmZvID0ge1xuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MgPz8gW10sXG4gICAgICAgICAgICBtZXRhZGF0YTogcnVuLmV4dHJhPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICBydW5UeXBlLFxuICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IHJ1bi5pbnB1dHMucXVlcnksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkluZm9NYXAuc2V0KHJ1bi5pZCwgcnVuSW5mbyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBldmVudDogXCJvbl9yZXRyaWV2ZXJfc3RhcnRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeTogcnVuLmlucHV0cy5xdWVyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IHJ1bk5hbWUsXG4gICAgICAgICAgICB0YWdzOiBydW4udGFncyA/PyBbXSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICBhc3luYyBvblJldHJpZXZlckVuZChydW4pIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuLmlkKTtcbiAgICAgICAgdGhpcy5ydW5JbmZvTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9uUmV0cmlldmVyRW5kOiBSdW4gSUQgJHtydW4uaWR9IG5vdCBmb3VuZCBpbiBydW4gbWFwLmApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZEVuZEV2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX3JldHJpZXZlcl9lbmRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJ1bi5vdXRwdXRzPy5kb2N1bWVudHMgPz8gcnVuLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHJ1bkluZm8uaW5wdXRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuSW5mby5uYW1lLFxuICAgICAgICAgICAgdGFnczogcnVuSW5mby50YWdzLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bkluZm8ubWV0YWRhdGEsXG4gICAgICAgIH0sIHJ1bkluZm8pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIGhhbmRsZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGF0YSwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuSW5mbyA9IHRoaXMucnVuSW5mb01hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAocnVuSW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhbmRsZUN1c3RvbUV2ZW50OiBSdW4gSUQgJHtydW5JZH0gbm90IGZvdW5kIGluIHJ1biBtYXAuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGV2ZW50OiBcIm9uX2N1c3RvbV9ldmVudFwiLFxuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bkluZm8udGFncyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBydW5JbmZvLm1ldGFkYXRhLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfSwgcnVuSW5mbyk7XG4gICAgfVxuICAgIGFzeW5jIGZpbmlzaCgpIHtcbiAgICAgICAgY29uc3QgcGVuZGluZ1Byb21pc2VzID0gWy4uLnRoaXMudGFwcGVkUHJvbWlzZXMudmFsdWVzKCldO1xuICAgICAgICB2b2lkIFByb21pc2UuYWxsKHBlbmRpbmdQcm9taXNlcykuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICB2b2lkIHRoaXMud3JpdGVyLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgUFF1ZXVlTW9kIGZyb20gXCJwLXF1ZXVlXCI7XG5jb25zdCBTVEFUVVNfTk9fUkVUUlkgPSBbXG4gICAgNDAwLFxuICAgIDQwMSxcbiAgICA0MDIsXG4gICAgNDAzLFxuICAgIDQwNCxcbiAgICA0MDUsXG4gICAgNDA2LFxuICAgIDQwNyxcbiAgICA0MDksIC8vIENvbmZsaWN0XG5dO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGRlZmF1bHRGYWlsZWRBdHRlbXB0SGFuZGxlciA9IChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQWJvcnRFcnJvclwiKSB8fFxuICAgICAgICBlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAoZXJyb3I/LmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXJyb3I/LnJlc3BvbnNlPy5zdGF0dXMgPz8gZXJyb3I/LnN0YXR1cztcbiAgICBpZiAoc3RhdHVzICYmIFNUQVRVU19OT19SRVRSWS5pbmNsdWRlcygrc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAoZXJyb3I/LmVycm9yPy5jb2RlID09PSBcImluc3VmZmljaWVudF9xdW90YVwiKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihlcnJvcj8ubWVzc2FnZSk7XG4gICAgICAgIGVyci5uYW1lID0gXCJJbnN1ZmZpY2llbnRRdW90YUVycm9yXCI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSBhc3luYyBjYWxscyB3aXRoIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWFraW5nIGNhbGxzIHRvIGFueSBraW5kIG9mIFwiZXhwZW5zaXZlXCIgZXh0ZXJuYWwgcmVzb3VyY2UsXG4gKiBiZSBpdCBiZWNhdXNlIGl0J3MgcmF0ZS1saW1pdGVkLCBzdWJqZWN0IHRvIG5ldHdvcmsgaXNzdWVzLCBldGMuXG4gKlxuICogQ29uY3VycmVudCBjYWxscyBhcmUgbGltaXRlZCBieSB0aGUgYG1heENvbmN1cnJlbmN5YCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzXG4gKiB0byBgSW5maW5pdHlgLiBUaGlzIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgYWxsIGNhbGxzIHdpbGwgYmUgbWFkZSBpbiBwYXJhbGxlbC5cbiAqXG4gKiBSZXRyaWVzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4UmV0cmllc2AgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0cyB0byA2LiBUaGlzXG4gKiBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGVhY2ggY2FsbCB3aWxsIGJlIHJldHJpZWQgdXAgdG8gNiB0aW1lcywgd2l0aCBhblxuICogZXhwb25lbnRpYWwgYmFja29mZiBiZXR3ZWVuIGVhY2ggYXR0ZW1wdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzeW5jQ2FsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4UmV0cmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkZhaWxlZEF0dGVtcHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNjtcbiAgICAgICAgdGhpcy5vbkZhaWxlZEF0dGVtcHQgPVxuICAgICAgICAgICAgcGFyYW1zLm9uRmFpbGVkQXR0ZW1wdCA/PyBkZWZhdWx0RmFpbGVkQXR0ZW1wdEhhbmRsZXI7XG4gICAgICAgIGNvbnN0IFBRdWV1ZSA9IFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCA/IFBRdWV1ZU1vZC5kZWZhdWx0IDogUFF1ZXVlTW9kO1xuICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZSh7IGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5IH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuYWRkKCgpID0+IHBSZXRyeSgoKSA9PiBjYWxsYWJsZSguLi5hcmdzKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgb25GYWlsZWRBdHRlbXB0OiB0aGlzLm9uRmFpbGVkQXR0ZW1wdCxcbiAgICAgICAgICAgIHJldHJpZXM6IHRoaXMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIElmIG5lZWRlZCB3ZSBjYW4gY2hhbmdlIHNvbWUgb2YgdGhlIGRlZmF1bHRzIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgdGhleSdyZSBxdWl0ZSBzZW5zaWJsZS5cbiAgICAgICAgfSksIHsgdGhyb3dPblRpbWVvdXQ6IHRydWUgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbFdpdGhPcHRpb25zKG9wdGlvbnMsIGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBkb2Vzbid0IGNhbmNlbCB0aGUgdW5kZXJseWluZyByZXF1ZXN0LFxuICAgICAgICAvLyB3aGVuIGF2YWlsYWJsZSBwcmVmZXIgdG8gdXNlIHRoZSBzaWduYWwgb3B0aW9uIG9mIHRoZSB1bmRlcmx5aW5nIGNhbGxcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyk7XG4gICAgfVxuICAgIGZldGNoKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCgoKSA9PiBmZXRjaCguLi5hcmdzKS50aGVuKChyZXMpID0+IChyZXMub2sgPyByZXMgOiBQcm9taXNlLnJlamVjdChyZXMpKSkpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuZXhwb3J0IGNsYXNzIFJvb3RMaXN0ZW5lcnNUcmFjZXIgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbmZpZywgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgc3VwZXIoeyBfYXdhaXRIYW5kbGVyOiB0cnVlIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcIlJvb3RMaXN0ZW5lcnNUcmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIFRoZSBSdW4ncyBJRC4gVHlwZSBVVUlEICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvb3RJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25maWdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25TdGFydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcmdPbkVuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcmdPbkVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmFyZ09uU3RhcnQgPSBvblN0YXJ0O1xuICAgICAgICB0aGlzLmFyZ09uRW5kID0gb25FbmQ7XG4gICAgICAgIHRoaXMuYXJnT25FcnJvciA9IG9uRXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBsZWdhY3kgbWV0aG9kIG9ubHkgY2FsbGVkIG9uY2UgZm9yIGFuIGVudGlyZSBydW4gdHJlZVxuICAgICAqIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICAgKiBAcGFyYW0ge1J1bn0gXyBOb3QgdXNlZFxuICAgICAqL1xuICAgIHBlcnNpc3RSdW4oXykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuQ3JlYXRlKHJ1bikge1xuICAgICAgICBpZiAodGhpcy5yb290SWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvb3RJZCA9IHJ1bi5pZDtcbiAgICAgICAgaWYgKHRoaXMuYXJnT25TdGFydCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdPblN0YXJ0KHJ1biwgdGhpcy5jb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuVXBkYXRlKHJ1bikge1xuICAgICAgICBpZiAocnVuLmlkICE9PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVuLmVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmdPbkVuZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJnT25FbmQocnVuLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcmdPbkVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uRXJyb3IocnVuLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiBpc1J1bm5hYmxlSW50ZXJmYWNlKHRoaW5nKSB7XG4gICAgcmV0dXJuIHRoaW5nID8gdGhpbmcubGNfcnVubmFibGUgOiBmYWxzZTtcbn1cbi8qKlxuICogVXRpbGl0eSB0byBmaWx0ZXIgdGhlIHJvb3QgZXZlbnQgaW4gdGhlIHN0cmVhbUV2ZW50cyBpbXBsZW1lbnRhdGlvbi5cbiAqIFRoaXMgaXMgc2ltcGx5IGJpbmRpbmcgdGhlIGFyZ3VtZW50cyB0byB0aGUgbmFtZXNwYWNlIHRvIG1ha2Ugc2F2ZSBvblxuICogYSBiaXQgb2YgdHlwaW5nIGluIHRoZSBzdHJlYW1FdmVudHMgaW1wbGVtZW50YXRpb24uXG4gKlxuICogVE9ETzogUmVmYWN0b3IgYW5kIHJlbW92ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIF9Sb290RXZlbnRGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbmNsdWRlTmFtZXMgPSBmaWVsZHMuaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcy5pbmNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPSBmaWVsZHMuaW5jbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuZXhjbHVkZU5hbWVzID0gZmllbGRzLmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHMuZXhjbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUYWdzID0gZmllbGRzLmV4Y2x1ZGVUYWdzO1xuICAgIH1cbiAgICBpbmNsdWRlRXZlbnQoZXZlbnQsIHJvb3RUeXBlKSB7XG4gICAgICAgIGxldCBpbmNsdWRlID0gdGhpcy5pbmNsdWRlTmFtZXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBldmVudFRhZ3MgPSBldmVudC50YWdzID8/IFtdO1xuICAgICAgICBpZiAodGhpcy5pbmNsdWRlTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlTmFtZXMuaW5jbHVkZXMoZXZlbnQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZVR5cGVzLmluY2x1ZGVzKHJvb3RUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8IGV2ZW50VGFncy5zb21lKCh0YWcpID0+IHRoaXMuaW5jbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMoZXZlbnQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVUeXBlcy5pbmNsdWRlcyhyb290VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZVRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9XG4gICAgICAgICAgICAgICAgaW5jbHVkZSAmJiBldmVudFRhZ3MuZXZlcnkoKHRhZykgPT4gIXRoaXMuZXhjbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH1cbn1cbiIsICJleHBvcnQgY29uc3QgaWdub3JlT3ZlcnJpZGUgPSBTeW1ib2woXCJMZXQgem9kVG9Kc29uU2NoZW1hIGRlY2lkZSBvbiB3aGljaCBwYXJzZXIgdG8gdXNlXCIpO1xuZXhwb3J0IGNvbnN0IGpzb25EZXNjcmlwdGlvbiA9IChqc29uU2NoZW1hLCBkZWYpID0+IHtcbiAgICBpZiAoZGVmLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmpzb25TY2hlbWEsXG4gICAgICAgICAgICAgICAgLi4uSlNPTi5wYXJzZShkZWYuZGVzY3JpcHRpb24pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7IH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb25TY2hlbWE7XG59O1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAkcmVmU3RyYXRlZ3k6IFwicm9vdFwiLFxuICAgIGJhc2VQYXRoOiBbXCIjXCJdLFxuICAgIGVmZmVjdFN0cmF0ZWd5OiBcImlucHV0XCIsXG4gICAgcGlwZVN0cmF0ZWd5OiBcImFsbFwiLFxuICAgIGRhdGVTdHJhdGVneTogXCJmb3JtYXQ6ZGF0ZS10aW1lXCIsXG4gICAgbWFwU3RyYXRlZ3k6IFwiZW50cmllc1wiLFxuICAgIHJlbW92ZUFkZGl0aW9uYWxTdHJhdGVneTogXCJwYXNzdGhyb3VnaFwiLFxuICAgIGFsbG93ZWRBZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgICByZWplY3RlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICBkZWZpbml0aW9uUGF0aDogXCJkZWZpbml0aW9uc1wiLFxuICAgIHRhcmdldDogXCJqc29uU2NoZW1hN1wiLFxuICAgIHN0cmljdFVuaW9uczogZmFsc2UsXG4gICAgZGVmaW5pdGlvbnM6IHt9LFxuICAgIGVycm9yTWVzc2FnZXM6IGZhbHNlLFxuICAgIG1hcmtkb3duRGVzY3JpcHRpb246IGZhbHNlLFxuICAgIHBhdHRlcm5TdHJhdGVneTogXCJlc2NhcGVcIixcbiAgICBhcHBseVJlZ2V4RmxhZ3M6IGZhbHNlLFxuICAgIGVtYWlsU3RyYXRlZ3k6IFwiZm9ybWF0OmVtYWlsXCIsXG4gICAgYmFzZTY0U3RyYXRlZ3k6IFwiY29udGVudEVuY29kaW5nOmJhc2U2NFwiLFxuICAgIG5hbWVTdHJhdGVneTogXCJyZWZcIixcbn07XG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdE9wdGlvbnMgPSAob3B0aW9ucykgPT4gKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiXG4gICAgPyB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICBuYW1lOiBvcHRpb25zLFxuICAgIH1cbiAgICA6IHtcbiAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4iLCAiaW1wb3J0IHsgZ2V0RGVmYXVsdE9wdGlvbnMgfSBmcm9tIFwiLi9PcHRpb25zLmpzXCI7XG5leHBvcnQgY29uc3QgZ2V0UmVmcyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgX29wdGlvbnMgPSBnZXREZWZhdWx0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IF9vcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IFsuLi5fb3B0aW9ucy5iYXNlUGF0aCwgX29wdGlvbnMuZGVmaW5pdGlvblBhdGgsIF9vcHRpb25zLm5hbWVdXG4gICAgICAgIDogX29wdGlvbnMuYmFzZVBhdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uX29wdGlvbnMsXG4gICAgICAgIGN1cnJlbnRQYXRoOiBjdXJyZW50UGF0aCxcbiAgICAgICAgcHJvcGVydHlQYXRoOiB1bmRlZmluZWQsXG4gICAgICAgIHNlZW46IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoX29wdGlvbnMuZGVmaW5pdGlvbnMpLm1hcCgoW25hbWUsIGRlZl0pID0+IFtcbiAgICAgICAgICAgIGRlZi5fZGVmLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRlZjogZGVmLl9kZWYsXG4gICAgICAgICAgICAgICAgcGF0aDogWy4uLl9vcHRpb25zLmJhc2VQYXRoLCBfb3B0aW9ucy5kZWZpbml0aW9uUGF0aCwgbmFtZV0sXG4gICAgICAgICAgICAgICAgLy8gUmVzb2x1dGlvbiBvZiByZWZlcmVuY2VzIHdpbGwgYmUgZm9yY2VkIGV2ZW4gdGhvdWdoIHNlZW4sIHNvIGl0J3Mgb2sgdGhhdCB0aGUgc2NoZW1hIGlzIHVuZGVmaW5lZCBoZXJlIGZvciBub3cuXG4gICAgICAgICAgICAgICAganNvblNjaGVtYTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSkpLFxuICAgIH07XG59O1xuIiwgImV4cG9ydCBmdW5jdGlvbiBhZGRFcnJvck1lc3NhZ2UocmVzLCBrZXksIGVycm9yTWVzc2FnZSwgcmVmcykge1xuICAgIGlmICghcmVmcz8uZXJyb3JNZXNzYWdlcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgcmVzLmVycm9yTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIC4uLnJlcy5lcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICBba2V5XTogZXJyb3JNZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywga2V5LCB2YWx1ZSwgZXJyb3JNZXNzYWdlLCByZWZzKSB7XG4gICAgcmVzW2tleV0gPSB2YWx1ZTtcbiAgICBhZGRFcnJvck1lc3NhZ2UocmVzLCBrZXksIGVycm9yTWVzc2FnZSwgcmVmcyk7XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQW55RGVmKCkge1xuICAgIHJldHVybiB7fTtcbn1cbiIsICJpbXBvcnQgeyBab2RGaXJzdFBhcnR5VHlwZUtpbmQgfSBmcm9tIFwiem9kXCI7XG5pbXBvcnQgeyBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzIH0gZnJvbSBcIi4uL2Vycm9yTWVzc2FnZXMuanNcIjtcbmltcG9ydCB7IHBhcnNlRGVmIH0gZnJvbSBcIi4uL3BhcnNlRGVmLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBcnJheURlZihkZWYsIHJlZnMpIHtcbiAgICBjb25zdCByZXMgPSB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB9O1xuICAgIGlmIChkZWYudHlwZT8uX2RlZiAmJlxuICAgICAgICBkZWYudHlwZT8uX2RlZj8udHlwZU5hbWUgIT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnkpIHtcbiAgICAgICAgcmVzLml0ZW1zID0gcGFyc2VEZWYoZGVmLnR5cGUuX2RlZiwge1xuICAgICAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJpdGVtc1wiXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkZWYubWluTGVuZ3RoKSB7XG4gICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbkl0ZW1zXCIsIGRlZi5taW5MZW5ndGgudmFsdWUsIGRlZi5taW5MZW5ndGgubWVzc2FnZSwgcmVmcyk7XG4gICAgfVxuICAgIGlmIChkZWYubWF4TGVuZ3RoKSB7XG4gICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1heEl0ZW1zXCIsIGRlZi5tYXhMZW5ndGgudmFsdWUsIGRlZi5tYXhMZW5ndGgubWVzc2FnZSwgcmVmcyk7XG4gICAgfVxuICAgIGlmIChkZWYuZXhhY3RMZW5ndGgpIHtcbiAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWluSXRlbXNcIiwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlLCBkZWYuZXhhY3RMZW5ndGgubWVzc2FnZSwgcmVmcyk7XG4gICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1heEl0ZW1zXCIsIGRlZi5leGFjdExlbmd0aC52YWx1ZSwgZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsIHJlZnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuIiwgImltcG9ydCB7IHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMgfSBmcm9tIFwiLi4vZXJyb3JNZXNzYWdlcy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQmlnaW50RGVmKGRlZiwgcmVmcykge1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgICAgIGZvcm1hdDogXCJpbnQ2NFwiLFxuICAgIH07XG4gICAgaWYgKCFkZWYuY2hlY2tzKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIGZvciAoY29uc3QgY2hlY2sgb2YgZGVmLmNoZWNrcykge1xuICAgICAgICBzd2l0Y2ggKGNoZWNrLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtaW5cIjpcbiAgICAgICAgICAgICAgICBpZiAocmVmcy50YXJnZXQgPT09IFwianNvblNjaGVtYTdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2suaW5jbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtaW5pbXVtXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcImV4Y2x1c2l2ZU1pbmltdW1cIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrLmluY2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmV4Y2x1c2l2ZU1pbmltdW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbmltdW1cIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVmcy50YXJnZXQgPT09IFwianNvblNjaGVtYTdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2suaW5jbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtYXhpbXVtXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcImV4Y2x1c2l2ZU1heGltdW1cIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrLmluY2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmV4Y2x1c2l2ZU1heGltdW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1heGltdW1cIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZU9mXCI6XG4gICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibXVsdGlwbGVPZlwiLCBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gcGFyc2VCb29sZWFuRGVmKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIH07XG59XG4iLCAiaW1wb3J0IHsgcGFyc2VEZWYgfSBmcm9tIFwiLi4vcGFyc2VEZWYuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJyYW5kZWREZWYoX2RlZiwgcmVmcykge1xuICAgIHJldHVybiBwYXJzZURlZihfZGVmLnR5cGUuX2RlZiwgcmVmcyk7XG59XG4iLCAiaW1wb3J0IHsgcGFyc2VEZWYgfSBmcm9tIFwiLi4vcGFyc2VEZWYuanNcIjtcbmV4cG9ydCBjb25zdCBwYXJzZUNhdGNoRGVmID0gKGRlZiwgcmVmcykgPT4ge1xuICAgIHJldHVybiBwYXJzZURlZihkZWYuaW5uZXJUeXBlLl9kZWYsIHJlZnMpO1xufTtcbiIsICJpbXBvcnQgeyBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzIH0gZnJvbSBcIi4uL2Vycm9yTWVzc2FnZXMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURhdGVEZWYoZGVmLCByZWZzLCBvdmVycmlkZURhdGVTdHJhdGVneSkge1xuICAgIGNvbnN0IHN0cmF0ZWd5ID0gb3ZlcnJpZGVEYXRlU3RyYXRlZ3kgPz8gcmVmcy5kYXRlU3RyYXRlZ3k7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RyYXRlZ3kpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbnlPZjogc3RyYXRlZ3kubWFwKChpdGVtLCBpKSA9PiBwYXJzZURhdGVEZWYoZGVmLCByZWZzLCBpdGVtKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiZm9ybWF0OmRhdGUtdGltZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkYXRlLXRpbWVcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJmb3JtYXQ6ZGF0ZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkYXRlXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgcmV0dXJuIGludGVnZXJEYXRlUGFyc2VyKGRlZiwgcmVmcyk7XG4gICAgfVxufVxuY29uc3QgaW50ZWdlckRhdGVQYXJzZXIgPSAoZGVmLCByZWZzKSA9PiB7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICAgICAgZm9ybWF0OiBcInVuaXgtdGltZVwiLFxuICAgIH07XG4gICAgaWYgKHJlZnMudGFyZ2V0ID09PSBcIm9wZW5BcGkzXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiBkZWYuY2hlY2tzKSB7XG4gICAgICAgIHN3aXRjaCAoY2hlY2sua2luZCkge1xuICAgICAgICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbmltdW1cIiwgY2hlY2sudmFsdWUsIC8vIFRoaXMgaXMgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICAgICAgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF4XCI6XG4gICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWF4aW11bVwiLCBjaGVjay52YWx1ZSwgLy8gVGhpcyBpcyBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgICBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbiIsICJpbXBvcnQgeyBwYXJzZURlZiB9IGZyb20gXCIuLi9wYXJzZURlZi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGVmYXVsdERlZihfZGVmLCByZWZzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucGFyc2VEZWYoX2RlZi5pbm5lclR5cGUuX2RlZiwgcmVmcyksXG4gICAgICAgIGRlZmF1bHQ6IF9kZWYuZGVmYXVsdFZhbHVlKCksXG4gICAgfTtcbn1cbiIsICJpbXBvcnQgeyBwYXJzZURlZiB9IGZyb20gXCIuLi9wYXJzZURlZi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRWZmZWN0c0RlZihfZGVmLCByZWZzKSB7XG4gICAgcmV0dXJuIHJlZnMuZWZmZWN0U3RyYXRlZ3kgPT09IFwiaW5wdXRcIlxuICAgICAgICA/IHBhcnNlRGVmKF9kZWYuc2NoZW1hLl9kZWYsIHJlZnMpXG4gICAgICAgIDoge307XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRW51bURlZihkZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBlbnVtOiBBcnJheS5mcm9tKGRlZi52YWx1ZXMpLFxuICAgIH07XG59XG4iLCAiaW1wb3J0IHsgcGFyc2VEZWYgfSBmcm9tIFwiLi4vcGFyc2VEZWYuanNcIjtcbmNvbnN0IGlzSnNvblNjaGVtYTdBbGxPZlR5cGUgPSAodHlwZSkgPT4ge1xuICAgIGlmIChcInR5cGVcIiBpbiB0eXBlICYmIHR5cGUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBcImFsbE9mXCIgaW4gdHlwZTtcbn07XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlcnNlY3Rpb25EZWYoZGVmLCByZWZzKSB7XG4gICAgY29uc3QgYWxsT2YgPSBbXG4gICAgICAgIHBhcnNlRGVmKGRlZi5sZWZ0Ll9kZWYsIHtcbiAgICAgICAgICAgIC4uLnJlZnMsXG4gICAgICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWxsT2ZcIiwgXCIwXCJdLFxuICAgICAgICB9KSxcbiAgICAgICAgcGFyc2VEZWYoZGVmLnJpZ2h0Ll9kZWYsIHtcbiAgICAgICAgICAgIC4uLnJlZnMsXG4gICAgICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWxsT2ZcIiwgXCIxXCJdLFxuICAgICAgICB9KSxcbiAgICBdLmZpbHRlcigoeCkgPT4gISF4KTtcbiAgICBsZXQgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzID0gcmVmcy50YXJnZXQgPT09IFwianNvblNjaGVtYTIwMTktMDlcIlxuICAgICAgICA/IHsgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiBmYWxzZSB9XG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1lcmdlZEFsbE9mID0gW107XG4gICAgLy8gSWYgZWl0aGVyIG9mIHRoZSBzY2hlbWFzIGlzIGFuIGFsbE9mLCBtZXJnZSB0aGVtIGludG8gYSBzaW5nbGUgYWxsT2ZcbiAgICBhbGxPZi5mb3JFYWNoKChzY2hlbWEpID0+IHtcbiAgICAgICAgaWYgKGlzSnNvblNjaGVtYTdBbGxPZlR5cGUoc2NoZW1hKSkge1xuICAgICAgICAgICAgbWVyZ2VkQWxsT2YucHVzaCguLi5zY2hlbWEuYWxsT2YpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG9uZSBvZiB0aGUgc2NoZW1hcyBoYXMgbm8gdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzIHNldCxcbiAgICAgICAgICAgICAgICAvLyB0aGUgbWVyZ2VkIHNjaGVtYSBzaG91bGQgYWxzbyBoYXZlIG5vIHVuZXZhbHVhdGVkUHJvcGVydGllcyBzZXRcbiAgICAgICAgICAgICAgICB1bmV2YWx1YXRlZFByb3BlcnRpZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmVzdGVkU2NoZW1hID0gc2NoZW1hO1xuICAgICAgICAgICAgaWYgKFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIiBpbiBzY2hlbWEgJiZcbiAgICAgICAgICAgICAgICBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhZGRpdGlvbmFsUHJvcGVydGllcywgLi4ucmVzdCB9ID0gc2NoZW1hO1xuICAgICAgICAgICAgICAgIG5lc3RlZFNjaGVtYSA9IHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBcyBzb29uIGFzIG9uZSBvZiB0aGUgc2NoZW1hcyBoYXMgYWRkaXRpb25hbFByb3BlcnRpZXMgc2V0IG5vdCB0byBmYWxzZSwgd2UgYWxsb3cgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2VkQWxsT2YucHVzaChuZXN0ZWRTY2hlbWEpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZEFsbE9mLmxlbmd0aFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGFsbE9mOiBtZXJnZWRBbGxPZixcbiAgICAgICAgICAgIC4uLnVuZXZhbHVhdGVkUHJvcGVydGllcyxcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gcGFyc2VMaXRlcmFsRGVmKGRlZiwgcmVmcykge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0eXBlb2YgZGVmLnZhbHVlO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBcImJpZ2ludFwiICYmXG4gICAgICAgIHBhcnNlZFR5cGUgIT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgcGFyc2VkVHlwZSAhPT0gXCJib29sZWFuXCIgJiZcbiAgICAgICAgcGFyc2VkVHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogQXJyYXkuaXNBcnJheShkZWYudmFsdWUpID8gXCJhcnJheVwiIDogXCJvYmplY3RcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHJlZnMudGFyZ2V0ID09PSBcIm9wZW5BcGkzXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHBhcnNlZFR5cGUgPT09IFwiYmlnaW50XCIgPyBcImludGVnZXJcIiA6IHBhcnNlZFR5cGUsXG4gICAgICAgICAgICBlbnVtOiBbZGVmLnZhbHVlXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogcGFyc2VkVHlwZSA9PT0gXCJiaWdpbnRcIiA/IFwiaW50ZWdlclwiIDogcGFyc2VkVHlwZSxcbiAgICAgICAgY29uc3Q6IGRlZi52YWx1ZSxcbiAgICB9O1xufVxuIiwgImltcG9ydCB7IHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMgfSBmcm9tIFwiLi4vZXJyb3JNZXNzYWdlcy5qc1wiO1xubGV0IGVtb2ppUmVnZXggPSB1bmRlZmluZWQ7XG4vKipcbiAqIEdlbmVyYXRlZCBmcm9tIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zIGZvdW5kIGhlcmUgYXMgb2YgMjAyNC0wNS0yMjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2xpbmhhY2tzL3pvZC9ibG9iL21hc3Rlci9zcmMvdHlwZXMudHMuXG4gKlxuICogRXhwcmVzc2lvbnMgd2l0aCAvaSBmbGFnIGhhdmUgYmVlbiBjaGFuZ2VkIGFjY29yZGluZ2x5LlxuICovXG5leHBvcnQgY29uc3Qgem9kUGF0dGVybnMgPSB7XG4gICAgLyoqXG4gICAgICogYGNgIHdhcyBjaGFuZ2VkIHRvIGBbY0NdYCB0byByZXBsaWNhdGUgL2kgZmxhZ1xuICAgICAqL1xuICAgIGN1aWQ6IC9eW2NDXVteXFxzLV17OCx9JC8sXG4gICAgY3VpZDI6IC9eWzAtOWEtel0rJC8sXG4gICAgdWxpZDogL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC8sXG4gICAgLyoqXG4gICAgICogYGEtemAgd2FzIGFkZGVkIHRvIHJlcGxpY2F0ZSAvaSBmbGFnXG4gICAgICovXG4gICAgZW1haWw6IC9eKD8hXFwuKSg/IS4qXFwuXFwuKShbYS16QS1aMC05XycrXFwtXFwuXSopW2EtekEtWjAtOV8rLV1AKFthLXpBLVowLTldW2EtekEtWjAtOVxcLV0qXFwuKStbYS16QS1aXXsyLH0kLyxcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RlZCBhIHZhbGlkIFVuaWNvZGUgUmVnRXhwXG4gICAgICpcbiAgICAgKiBMYXppbHkgaW5zdGFudGlhdGUgc2luY2UgdGhpcyB0eXBlIG9mIHJlZ2V4IGlzbid0IHN1cHBvcnRlZFxuICAgICAqIGluIGFsbCBlbnZzIChlLmcuIFJlYWN0IE5hdGl2ZSkuXG4gICAgICpcbiAgICAgKiBTZWU6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kL2lzc3Vlcy8yNDMzXG4gICAgICogRml4IGluIFpvZDpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vY29saW5oYWNrcy96b2QvY29tbWl0LzkzNDBmZDUxZTQ4NTc2YTc1YWRjOTE5YmZmNjVkYmM0YTVkNGM5OWJcbiAgICAgKi9cbiAgICBlbW9qaTogKCkgPT4ge1xuICAgICAgICBpZiAoZW1vamlSZWdleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbW9qaVJlZ2V4ID0gUmVnRXhwKFwiXihcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRcIiwgXCJ1XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbW9qaVJlZ2V4O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVW51c2VkXG4gICAgICovXG4gICAgdXVpZDogL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kLyxcbiAgICAvKipcbiAgICAgKiBVbnVzZWRcbiAgICAgKi9cbiAgICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvLFxuICAgIGlwdjRDaWRyOiAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLyxcbiAgICAvKipcbiAgICAgKiBVbnVzZWRcbiAgICAgKi9cbiAgICBpcHY2OiAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLyxcbiAgICBpcHY2Q2lkcjogL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLyxcbiAgICBiYXNlNjQ6IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLyxcbiAgICBiYXNlNjR1cmw6IC9eKFswLTlhLXpBLVotX117NH0pKigoWzAtOWEtekEtWi1fXXsyfSg9PSk/KXwoWzAtOWEtekEtWi1fXXszfSg9KT8pKT8kLyxcbiAgICBuYW5vaWQ6IC9eW2EtekEtWjAtOV8tXXsyMX0kLyxcbiAgICBqd3Q6IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC8sXG59O1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3RyaW5nRGVmKGRlZiwgcmVmcykge1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICB9O1xuICAgIGlmIChkZWYuY2hlY2tzKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgc3dpdGNoIChjaGVjay5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtaW5MZW5ndGhcIiwgdHlwZW9mIHJlcy5taW5MZW5ndGggPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTWF0aC5tYXgocmVzLm1pbkxlbmd0aCwgY2hlY2sudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1heFwiOlxuICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtYXhMZW5ndGhcIiwgdHlwZW9mIHJlcy5tYXhMZW5ndGggPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTWF0aC5taW4ocmVzLm1heExlbmd0aCwgY2hlY2sudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVtYWlsXCI6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVmcy5lbWFpbFN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybWF0OmVtYWlsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJlbWFpbFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtYXQ6aWRuLWVtYWlsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJpZG4tZW1haWxcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGF0dGVybjp6b2RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuZW1haWwsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1cmxcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJ1cmlcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1dWlkXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwidXVpZFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlZ2V4XCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBjaGVjay5yZWdleCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjdWlkXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5jdWlkLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImN1aWQyXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5jdWlkMiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdGFydHNXaXRoXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBSZWdFeHAoYF4ke2VzY2FwZUxpdGVyYWxDaGVja1ZhbHVlKGNoZWNrLnZhbHVlLCByZWZzKX1gKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRzV2l0aFwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgUmVnRXhwKGAke2VzY2FwZUxpdGVyYWxDaGVja1ZhbHVlKGNoZWNrLnZhbHVlLCByZWZzKX0kYCksIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJkYXRlLXRpbWVcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiZGF0ZVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJ0aW1lXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZHVyYXRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJkdXJhdGlvblwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxlbmd0aFwiOlxuICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtaW5MZW5ndGhcIiwgdHlwZW9mIHJlcy5taW5MZW5ndGggPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTWF0aC5tYXgocmVzLm1pbkxlbmd0aCwgY2hlY2sudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWF4TGVuZ3RoXCIsIHR5cGVvZiByZXMubWF4TGVuZ3RoID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWluKHJlcy5tYXhMZW5ndGgsIGNoZWNrLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpbmNsdWRlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBSZWdFeHAoZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUoY2hlY2sudmFsdWUsIHJlZnMpKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiaXBcIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImlwdjRcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJpcHY2XCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiYmFzZTY0dXJsXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5iYXNlNjR1cmwsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiand0XCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5qd3QsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2lkclwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVjay52ZXJzaW9uICE9PSBcInY2XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5pcHY0Q2lkciwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmlwdjZDaWRyLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImVtb2ppXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5lbW9qaSgpLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVsaWRcIjoge1xuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMudWxpZCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZWZzLmJhc2U2NFN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybWF0OmJpbmFyeVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJiaW5hcnlcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29udGVudEVuY29kaW5nOmJhc2U2NFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwiY29udGVudEVuY29kaW5nXCIsIFwiYmFzZTY0XCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBhdHRlcm46em9kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuYmFzZTY0LCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5hbm9pZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5uYW5vaWQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidG9Mb3dlckNhc2VcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9VcHBlckNhc2VcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidHJpbVwiOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAoKF8pID0+IHsgfSkoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBlc2NhcGVMaXRlcmFsQ2hlY2tWYWx1ZShsaXRlcmFsLCByZWZzKSB7XG4gICAgcmV0dXJuIHJlZnMucGF0dGVyblN0cmF0ZWd5ID09PSBcImVzY2FwZVwiXG4gICAgICAgID8gZXNjYXBlTm9uQWxwaGFOdW1lcmljKGxpdGVyYWwpXG4gICAgICAgIDogbGl0ZXJhbDtcbn1cbmNvbnN0IEFMUEhBX05VTUVSSUMgPSBuZXcgU2V0KFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVlhZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ4eXowMTIzNDU2Nzg5XCIpO1xuZnVuY3Rpb24gZXNjYXBlTm9uQWxwaGFOdW1lcmljKHNvdXJjZSkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghQUxQSEFfTlVNRVJJQy5oYXMoc291cmNlW2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxcXFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBzb3VyY2VbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBBZGRzIGEgXCJmb3JtYXRcIiBrZXl3b3JkIHRvIHRoZSBzY2hlbWEuIElmIGEgZm9ybWF0IGV4aXN0cywgYm90aCBmb3JtYXRzIHdpbGwgYmUgam9pbmVkIGluIGFuIGFsbE9mLW5vZGUsIGFsb25nIHdpdGggc3Vic2VxdWVudCBvbmVzLlxuZnVuY3Rpb24gYWRkRm9ybWF0KHNjaGVtYSwgdmFsdWUsIG1lc3NhZ2UsIHJlZnMpIHtcbiAgICBpZiAoc2NoZW1hLmZvcm1hdCB8fCBzY2hlbWEuYW55T2Y/LnNvbWUoKHgpID0+IHguZm9ybWF0KSkge1xuICAgICAgICBpZiAoIXNjaGVtYS5hbnlPZikge1xuICAgICAgICAgICAgc2NoZW1hLmFueU9mID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgICAgIHNjaGVtYS5hbnlPZi5wdXNoKHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHNjaGVtYS5mb3JtYXQsXG4gICAgICAgICAgICAgICAgLi4uKHNjaGVtYS5lcnJvck1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVmcy5lcnJvck1lc3NhZ2VzICYmIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiB7IGZvcm1hdDogc2NoZW1hLmVycm9yTWVzc2FnZS5mb3JtYXQgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5mb3JtYXQ7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlLmZvcm1hdDtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hLmVycm9yTWVzc2FnZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2hlbWEuYW55T2YucHVzaCh7XG4gICAgICAgICAgICBmb3JtYXQ6IHZhbHVlLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICByZWZzLmVycm9yTWVzc2FnZXMgJiYgeyBlcnJvck1lc3NhZ2U6IHsgZm9ybWF0OiBtZXNzYWdlIH0gfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhzY2hlbWEsIFwiZm9ybWF0XCIsIHZhbHVlLCBtZXNzYWdlLCByZWZzKTtcbiAgICB9XG59XG4vLyBBZGRzIGEgXCJwYXR0ZXJuXCIga2V5d29yZCB0byB0aGUgc2NoZW1hLiBJZiBhIHBhdHRlcm4gZXhpc3RzLCBib3RoIHBhdHRlcm5zIHdpbGwgYmUgam9pbmVkIGluIGFuIGFsbE9mLW5vZGUsIGFsb25nIHdpdGggc3Vic2VxdWVudCBvbmVzLlxuZnVuY3Rpb24gYWRkUGF0dGVybihzY2hlbWEsIHJlZ2V4LCBtZXNzYWdlLCByZWZzKSB7XG4gICAgaWYgKHNjaGVtYS5wYXR0ZXJuIHx8IHNjaGVtYS5hbGxPZj8uc29tZSgoeCkgPT4geC5wYXR0ZXJuKSkge1xuICAgICAgICBpZiAoIXNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgc2NoZW1hLmFsbE9mID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5wYXR0ZXJuKSB7XG4gICAgICAgICAgICBzY2hlbWEuYWxsT2YucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogc2NoZW1hLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgLi4uKHNjaGVtYS5lcnJvck1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVmcy5lcnJvck1lc3NhZ2VzICYmIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiB7IHBhdHRlcm46IHNjaGVtYS5lcnJvck1lc3NhZ2UucGF0dGVybiB9LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgc2NoZW1hLnBhdHRlcm47XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlLnBhdHRlcm47XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYS5lcnJvck1lc3NhZ2UpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLmVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NoZW1hLmFsbE9mLnB1c2goe1xuICAgICAgICAgICAgcGF0dGVybjogc3RyaW5naWZ5UmVnRXhwV2l0aEZsYWdzKHJlZ2V4LCByZWZzKSxcbiAgICAgICAgICAgIC4uLihtZXNzYWdlICYmXG4gICAgICAgICAgICAgICAgcmVmcy5lcnJvck1lc3NhZ2VzICYmIHsgZXJyb3JNZXNzYWdlOiB7IHBhdHRlcm46IG1lc3NhZ2UgfSB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHNjaGVtYSwgXCJwYXR0ZXJuXCIsIHN0cmluZ2lmeVJlZ0V4cFdpdGhGbGFncyhyZWdleCwgcmVmcyksIG1lc3NhZ2UsIHJlZnMpO1xuICAgIH1cbn1cbi8vIE11dGF0ZSB6LnN0cmluZy5yZWdleCgpIGluIGEgYmVzdCBhdHRlbXB0IHRvIGFjY29tbW9kYXRlIGZvciByZWdleCBmbGFncyB3aGVuIGFwcGx5UmVnZXhGbGFncyBpcyB0cnVlXG5mdW5jdGlvbiBzdHJpbmdpZnlSZWdFeHBXaXRoRmxhZ3MocmVnZXgsIHJlZnMpIHtcbiAgICBpZiAoIXJlZnMuYXBwbHlSZWdleEZsYWdzIHx8ICFyZWdleC5mbGFncykge1xuICAgICAgICByZXR1cm4gcmVnZXguc291cmNlO1xuICAgIH1cbiAgICAvLyBDdXJyZW50bHkgaGFuZGxlZCBmbGFnc1xuICAgIGNvbnN0IGZsYWdzID0ge1xuICAgICAgICBpOiByZWdleC5mbGFncy5pbmNsdWRlcyhcImlcIiksXG4gICAgICAgIG06IHJlZ2V4LmZsYWdzLmluY2x1ZGVzKFwibVwiKSxcbiAgICAgICAgczogcmVnZXguZmxhZ3MuaW5jbHVkZXMoXCJzXCIpLCAvLyBgLmAgbWF0Y2hlcyBuZXdsaW5lc1xuICAgIH07XG4gICAgLy8gVGhlIGdlbmVyYWwgcHJpbmNpcGxlIGhlcmUgaXMgdG8gc3RlcCB0aHJvdWdoIGVhY2ggY2hhcmFjdGVyLCBvbmUgYXQgYSB0aW1lLCBhcHBseWluZyBtdXRhdGlvbnMgYXMgZmxhZ3MgcmVxdWlyZS4gV2Uga2VlcCB0cmFjayB3aGVuIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBlc2NhcGVkLCBhbmQgd2hlbiBpdCdzIGluc2lkZSBhIGdyb3VwIC9saWtlIFt0aGlzXS8gb3IgKGFsc28pIGEgcmFuZ2UgbGlrZSAvW2Etel0vLiBUaGUgZm9sbG93aW5nIGlzIGZhaXJseSBicml0dGxlIGltcGVyYXRpdmUgY29kZTsgZWRpdCBhdCB5b3VyIHBlcmlsIVxuICAgIGNvbnN0IHNvdXJjZSA9IGZsYWdzLmkgPyByZWdleC5zb3VyY2UudG9Mb3dlckNhc2UoKSA6IHJlZ2V4LnNvdXJjZTtcbiAgICBsZXQgcGF0dGVybiA9IFwiXCI7XG4gICAgbGV0IGlzRXNjYXBlZCA9IGZhbHNlO1xuICAgIGxldCBpbkNoYXJHcm91cCA9IGZhbHNlO1xuICAgIGxldCBpbkNoYXJSYW5nZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0VzY2FwZWQpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgICAgICAgaXNFc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MuaSkge1xuICAgICAgICAgICAgaWYgKGluQ2hhckdyb3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpXS5tYXRjaCgvW2Etel0vKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5DaGFyUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSBgJHtzb3VyY2VbaSAtIDJdfS0ke3NvdXJjZVtpXX1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkNoYXJSYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVtpICsgMV0gPT09IFwiLVwiICYmIHNvdXJjZVtpICsgMl0/Lm1hdGNoKC9bYS16XS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQ2hhclJhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gYCR7c291cmNlW2ldfSR7c291cmNlW2ldLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VbaV0ubWF0Y2goL1thLXpdLykpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGBbJHtzb3VyY2VbaV19JHtzb3VyY2VbaV0udG9VcHBlckNhc2UoKX1dYDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MubSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZVtpXSA9PT0gXCJeXCIpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGAoXnwoPzw9W1xcclxcbl0pKWA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VbaV0gPT09IFwiJFwiKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSBgKCR8KD89W1xcclxcbl0pKWA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzLnMgJiYgc291cmNlW2ldID09PSBcIi5cIikge1xuICAgICAgICAgICAgcGF0dGVybiArPSBpbkNoYXJHcm91cCA/IGAke3NvdXJjZVtpXX1cXHJcXG5gIDogYFske3NvdXJjZVtpXX1cXHJcXG5dYDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgICBpZiAoc291cmNlW2ldID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgaXNFc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbkNoYXJHcm91cCAmJiBzb3VyY2VbaV0gPT09IFwiXVwiKSB7XG4gICAgICAgICAgICBpbkNoYXJHcm91cCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbkNoYXJHcm91cCAmJiBzb3VyY2VbaV0gPT09IFwiW1wiKSB7XG4gICAgICAgICAgICBpbkNoYXJHcm91cCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBjb252ZXJ0IHJlZ2V4IHBhdHRlcm4gYXQgJHtyZWZzLmN1cnJlbnRQYXRoLmpvaW4oXCIvXCIpfSB0byBhIGZsYWctaW5kZXBlbmRlbnQgZm9ybSEgRmFsbGluZyBiYWNrIHRvIHRoZSBmbGFnLWlnbm9yYW50IHNvdXJjZWApO1xuICAgICAgICByZXR1cm4gcmVnZXguc291cmNlO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbn1cbiIsICJpbXBvcnQgeyBab2RGaXJzdFBhcnR5VHlwZUtpbmQsIH0gZnJvbSBcInpvZFwiO1xuaW1wb3J0IHsgcGFyc2VEZWYgfSBmcm9tIFwiLi4vcGFyc2VEZWYuanNcIjtcbmltcG9ydCB7IHBhcnNlU3RyaW5nRGVmIH0gZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUJyYW5kZWREZWYgfSBmcm9tIFwiLi9icmFuZGVkLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWNvcmREZWYoZGVmLCByZWZzKSB7XG4gICAgaWYgKHJlZnMudGFyZ2V0ID09PSBcIm9wZW5BaVwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IE9wZW5BSSBtYXkgbm90IHN1cHBvcnQgcmVjb3JkcyBpbiBzY2hlbWFzISBUcnkgYW4gYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBpZiAocmVmcy50YXJnZXQgPT09IFwib3BlbkFwaTNcIiAmJlxuICAgICAgICBkZWYua2V5VHlwZT8uX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICByZXF1aXJlZDogZGVmLmtleVR5cGUuX2RlZi52YWx1ZXMsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBkZWYua2V5VHlwZS5fZGVmLnZhbHVlcy5yZWR1Y2UoKGFjYywga2V5KSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgICAgICBba2V5XTogcGFyc2VEZWYoZGVmLnZhbHVlVHlwZS5fZGVmLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnJlZnMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJwcm9wZXJ0aWVzXCIsIGtleV0sXG4gICAgICAgICAgICAgICAgfSkgPz8ge30sXG4gICAgICAgICAgICB9KSwge30pLFxuICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHJlZnMucmVqZWN0ZWRBZGRpdGlvbmFsUHJvcGVydGllcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogcGFyc2VEZWYoZGVmLnZhbHVlVHlwZS5fZGVmLCB7XG4gICAgICAgICAgICAuLi5yZWZzLFxuICAgICAgICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCJdLFxuICAgICAgICB9KSA/PyByZWZzLmFsbG93ZWRBZGRpdGlvbmFsUHJvcGVydGllcyxcbiAgICB9O1xuICAgIGlmIChyZWZzLnRhcmdldCA9PT0gXCJvcGVuQXBpM1wiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGlmIChkZWYua2V5VHlwZT8uX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyAmJlxuICAgICAgICBkZWYua2V5VHlwZS5fZGVmLmNoZWNrcz8ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgLi4ua2V5VHlwZSB9ID0gcGFyc2VTdHJpbmdEZWYoZGVmLmtleVR5cGUuX2RlZiwgcmVmcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zY2hlbWEsXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWVzOiBrZXlUeXBlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkZWYua2V5VHlwZT8uX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNjaGVtYSxcbiAgICAgICAgICAgIHByb3BlcnR5TmFtZXM6IHtcbiAgICAgICAgICAgICAgICBlbnVtOiBkZWYua2V5VHlwZS5fZGVmLnZhbHVlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi5rZXlUeXBlPy5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCAmJlxuICAgICAgICBkZWYua2V5VHlwZS5fZGVmLnR5cGUuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyAmJlxuICAgICAgICBkZWYua2V5VHlwZS5fZGVmLnR5cGUuX2RlZi5jaGVja3M/Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCB7IHR5cGUsIC4uLmtleVR5cGUgfSA9IHBhcnNlQnJhbmRlZERlZihkZWYua2V5VHlwZS5fZGVmLCByZWZzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNjaGVtYSxcbiAgICAgICAgICAgIHByb3BlcnR5TmFtZXM6IGtleVR5cGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG59XG4iLCAiaW1wb3J0IHsgcGFyc2VEZWYgfSBmcm9tIFwiLi4vcGFyc2VEZWYuanNcIjtcbmltcG9ydCB7IHBhcnNlUmVjb3JkRGVmIH0gZnJvbSBcIi4vcmVjb3JkLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNYXBEZWYoZGVmLCByZWZzKSB7XG4gICAgaWYgKHJlZnMubWFwU3RyYXRlZ3kgPT09IFwicmVjb3JkXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVjb3JkRGVmKGRlZiwgcmVmcyk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBwYXJzZURlZihkZWYua2V5VHlwZS5fZGVmLCB7XG4gICAgICAgIC4uLnJlZnMsXG4gICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJpdGVtc1wiLCBcIml0ZW1zXCIsIFwiMFwiXSxcbiAgICB9KSB8fCB7fTtcbiAgICBjb25zdCB2YWx1ZXMgPSBwYXJzZURlZihkZWYudmFsdWVUeXBlLl9kZWYsIHtcbiAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcIml0ZW1zXCIsIFwiaXRlbXNcIiwgXCIxXCJdLFxuICAgIH0pIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgbWF4SXRlbXM6IDEyNSxcbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIGl0ZW1zOiBba2V5cywgdmFsdWVzXSxcbiAgICAgICAgICAgIG1pbkl0ZW1zOiAyLFxuICAgICAgICAgICAgbWF4SXRlbXM6IDIsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gcGFyc2VOYXRpdmVFbnVtRGVmKGRlZikge1xuICAgIGNvbnN0IG9iamVjdCA9IGRlZi52YWx1ZXM7XG4gICAgY29uc3QgYWN0dWFsS2V5cyA9IE9iamVjdC5rZXlzKGRlZi52YWx1ZXMpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0W29iamVjdFtrZXldXSAhPT0gXCJudW1iZXJcIjtcbiAgICB9KTtcbiAgICBjb25zdCBhY3R1YWxWYWx1ZXMgPSBhY3R1YWxLZXlzLm1hcCgoa2V5KSA9PiBvYmplY3Rba2V5XSk7XG4gICAgY29uc3QgcGFyc2VkVHlwZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoYWN0dWFsVmFsdWVzLm1hcCgodmFsdWVzKSA9PiB0eXBlb2YgdmFsdWVzKSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHBhcnNlZFR5cGVzLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgPyBwYXJzZWRUeXBlc1swXSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgIDogXCJudW1iZXJcIlxuICAgICAgICAgICAgOiBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIl0sXG4gICAgICAgIGVudW06IGFjdHVhbFZhbHVlcyxcbiAgICB9O1xufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBwYXJzZU5ldmVyRGVmKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vdDoge30sXG4gICAgfTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gcGFyc2VOdWxsRGVmKHJlZnMpIHtcbiAgICByZXR1cm4gcmVmcy50YXJnZXQgPT09IFwib3BlbkFwaTNcIlxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGVudW06IFtcIm51bGxcIl0sXG4gICAgICAgICAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibnVsbFwiLFxuICAgICAgICB9O1xufVxuIiwgImltcG9ydCB7IHBhcnNlRGVmIH0gZnJvbSBcIi4uL3BhcnNlRGVmLmpzXCI7XG5leHBvcnQgY29uc3QgcHJpbWl0aXZlTWFwcGluZ3MgPSB7XG4gICAgWm9kU3RyaW5nOiBcInN0cmluZ1wiLFxuICAgIFpvZE51bWJlcjogXCJudW1iZXJcIixcbiAgICBab2RCaWdJbnQ6IFwiaW50ZWdlclwiLFxuICAgIFpvZEJvb2xlYW46IFwiYm9vbGVhblwiLFxuICAgIFpvZE51bGw6IFwibnVsbFwiLFxufTtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVuaW9uRGVmKGRlZiwgcmVmcykge1xuICAgIGlmIChyZWZzLnRhcmdldCA9PT0gXCJvcGVuQXBpM1wiKVxuICAgICAgICByZXR1cm4gYXNBbnlPZihkZWYsIHJlZnMpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBkZWYub3B0aW9ucyBpbnN0YW5jZW9mIE1hcCA/IEFycmF5LmZyb20oZGVmLm9wdGlvbnMudmFsdWVzKCkpIDogZGVmLm9wdGlvbnM7XG4gICAgLy8gVGhpcyBibG9ja3MgdHJpZXMgdG8gbG9vayBhaGVhZCBhIGJpdCB0byBwcm9kdWNlIG5pY2VyIGxvb2tpbmcgc2NoZW1hcyB3aXRoIHR5cGUgYXJyYXkgaW5zdGVhZCBvZiBhbnlPZi5cbiAgICBpZiAob3B0aW9ucy5ldmVyeSgoeCkgPT4geC5fZGVmLnR5cGVOYW1lIGluIHByaW1pdGl2ZU1hcHBpbmdzICYmXG4gICAgICAgICgheC5fZGVmLmNoZWNrcyB8fCAheC5fZGVmLmNoZWNrcy5sZW5ndGgpKSkge1xuICAgICAgICAvLyBhbGwgdHlwZXMgaW4gdW5pb24gYXJlIHByaW1pdGl2ZSBhbmQgbGFjayBjaGVja3MsIHNvIG1pZ2h0IGFzIHdlbGwgc3F1YXNoIGludG8ge3R5cGU6IFsuLi5dfVxuICAgICAgICBjb25zdCB0eXBlcyA9IG9wdGlvbnMucmVkdWNlKCh0eXBlcywgeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHByaW1pdGl2ZU1hcHBpbmdzW3guX2RlZi50eXBlTmFtZV07IC8vQ2FuIGJlIHNhZmVseSBjYXN0ZWQgZHVlIHRvIHJvdyA0M1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUgJiYgIXR5cGVzLmluY2x1ZGVzKHR5cGUpID8gWy4uLnR5cGVzLCB0eXBlXSA6IHR5cGVzO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlcy5sZW5ndGggPiAxID8gdHlwZXMgOiB0eXBlc1swXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5ldmVyeSgoeCkgPT4geC5fZGVmLnR5cGVOYW1lID09PSBcIlpvZExpdGVyYWxcIiAmJiAheC5kZXNjcmlwdGlvbikpIHtcbiAgICAgICAgLy8gYWxsIG9wdGlvbnMgbGl0ZXJhbHNcbiAgICAgICAgY29uc3QgdHlwZXMgPSBvcHRpb25zLnJlZHVjZSgoYWNjLCB4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHguX2RlZi52YWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIHR5cGVdO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIFwiaW50ZWdlclwiXTtcbiAgICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh4Ll9kZWYudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLmFjYywgXCJudWxsXCJdO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSBvcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gYWxsIHRoZSBsaXRlcmFscyBhcmUgcHJpbWl0aXZlLCBhcyBmYXIgYXMgbnVsbCBjYW4gYmUgY29uc2lkZXJlZCBwcmltaXRpdmVcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVR5cGVzID0gdHlwZXMuZmlsdGVyKCh4LCBpLCBhKSA9PiBhLmluZGV4T2YoeCkgPT09IGkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB1bmlxdWVUeXBlcy5sZW5ndGggPiAxID8gdW5pcXVlVHlwZXMgOiB1bmlxdWVUeXBlc1swXSxcbiAgICAgICAgICAgICAgICBlbnVtOiBvcHRpb25zLnJlZHVjZSgoYWNjLCB4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2MuaW5jbHVkZXMoeC5fZGVmLnZhbHVlKSA/IGFjYyA6IFsuLi5hY2MsIHguX2RlZi52YWx1ZV07XG4gICAgICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLmV2ZXJ5KCh4KSA9PiB4Ll9kZWYudHlwZU5hbWUgPT09IFwiWm9kRW51bVwiKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGVudW06IG9wdGlvbnMucmVkdWNlKChhY2MsIHgpID0+IFtcbiAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgLi4ueC5fZGVmLnZhbHVlcy5maWx0ZXIoKHgpID0+ICFhY2MuaW5jbHVkZXMoeCkpLFxuICAgICAgICAgICAgXSwgW10pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYXNBbnlPZihkZWYsIHJlZnMpO1xufVxuY29uc3QgYXNBbnlPZiA9IChkZWYsIHJlZnMpID0+IHtcbiAgICBjb25zdCBhbnlPZiA9IChkZWYub3B0aW9ucyBpbnN0YW5jZW9mIE1hcFxuICAgICAgICA/IEFycmF5LmZyb20oZGVmLm9wdGlvbnMudmFsdWVzKCkpXG4gICAgICAgIDogZGVmLm9wdGlvbnMpXG4gICAgICAgIC5tYXAoKHgsIGkpID0+IHBhcnNlRGVmKHguX2RlZiwge1xuICAgICAgICAuLi5yZWZzLFxuICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYW55T2ZcIiwgYCR7aX1gXSxcbiAgICB9KSlcbiAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4ICYmXG4gICAgICAgICghcmVmcy5zdHJpY3RVbmlvbnMgfHxcbiAgICAgICAgICAgICh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyh4KS5sZW5ndGggPiAwKSkpO1xuICAgIHJldHVybiBhbnlPZi5sZW5ndGggPyB7IGFueU9mIH0gOiB1bmRlZmluZWQ7XG59O1xuIiwgImltcG9ydCB7IHBhcnNlRGVmIH0gZnJvbSBcIi4uL3BhcnNlRGVmLmpzXCI7XG5pbXBvcnQgeyBwcmltaXRpdmVNYXBwaW5ncyB9IGZyb20gXCIuL3VuaW9uLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VOdWxsYWJsZURlZihkZWYsIHJlZnMpIHtcbiAgICBpZiAoW1wiWm9kU3RyaW5nXCIsIFwiWm9kTnVtYmVyXCIsIFwiWm9kQmlnSW50XCIsIFwiWm9kQm9vbGVhblwiLCBcIlpvZE51bGxcIl0uaW5jbHVkZXMoZGVmLmlubmVyVHlwZS5fZGVmLnR5cGVOYW1lKSAmJlxuICAgICAgICAoIWRlZi5pbm5lclR5cGUuX2RlZi5jaGVja3MgfHwgIWRlZi5pbm5lclR5cGUuX2RlZi5jaGVja3MubGVuZ3RoKSkge1xuICAgICAgICBpZiAocmVmcy50YXJnZXQgPT09IFwib3BlbkFwaTNcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwcmltaXRpdmVNYXBwaW5nc1tkZWYuaW5uZXJUeXBlLl9kZWYudHlwZU5hbWVdLFxuICAgICAgICAgICAgICAgIG51bGxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogW1xuICAgICAgICAgICAgICAgIHByaW1pdGl2ZU1hcHBpbmdzW2RlZi5pbm5lclR5cGUuX2RlZi50eXBlTmFtZV0sXG4gICAgICAgICAgICAgICAgXCJudWxsXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAocmVmcy50YXJnZXQgPT09IFwib3BlbkFwaTNcIikge1xuICAgICAgICBjb25zdCBiYXNlID0gcGFyc2VEZWYoZGVmLmlubmVyVHlwZS5fZGVmLCB7XG4gICAgICAgICAgICAuLi5yZWZzLFxuICAgICAgICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChiYXNlICYmIFwiJHJlZlwiIGluIGJhc2UpXG4gICAgICAgICAgICByZXR1cm4geyBhbGxPZjogW2Jhc2VdLCBudWxsYWJsZTogdHJ1ZSB9O1xuICAgICAgICByZXR1cm4gYmFzZSAmJiB7IC4uLmJhc2UsIG51bGxhYmxlOiB0cnVlIH07XG4gICAgfVxuICAgIGNvbnN0IGJhc2UgPSBwYXJzZURlZihkZWYuaW5uZXJUeXBlLl9kZWYsIHtcbiAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFueU9mXCIsIFwiMFwiXSxcbiAgICB9KTtcbiAgICByZXR1cm4gYmFzZSAmJiB7IGFueU9mOiBbYmFzZSwgeyB0eXBlOiBcIm51bGxcIiB9XSB9O1xufVxuIiwgImltcG9ydCB7IGFkZEVycm9yTWVzc2FnZSwgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycywgfSBmcm9tIFwiLi4vZXJyb3JNZXNzYWdlcy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTnVtYmVyRGVmKGRlZiwgcmVmcykge1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICB9O1xuICAgIGlmICghZGVmLmNoZWNrcylcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIGRlZi5jaGVja3MpIHtcbiAgICAgICAgc3dpdGNoIChjaGVjay5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW50XCI6XG4gICAgICAgICAgICAgICAgcmVzLnR5cGUgPSBcImludGVnZXJcIjtcbiAgICAgICAgICAgICAgICBhZGRFcnJvck1lc3NhZ2UocmVzLCBcInR5cGVcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlZnMudGFyZ2V0ID09PSBcImpzb25TY2hlbWE3XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLmluY2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWluaW11bVwiLCBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJleGNsdXNpdmVNaW5pbXVtXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVjay5pbmNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5leGNsdXNpdmVNaW5pbXVtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtaW5pbXVtXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF4XCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlZnMudGFyZ2V0ID09PSBcImpzb25TY2hlbWE3XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLmluY2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWF4aW11bVwiLCBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJleGNsdXNpdmVNYXhpbXVtXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVjay5pbmNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5leGNsdXNpdmVNYXhpbXVtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtYXhpbXVtXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVPZlwiOlxuICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm11bHRpcGxlT2ZcIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4iLCAiaW1wb3J0IHsgWm9kT3B0aW9uYWwgfSBmcm9tIFwiem9kXCI7XG5pbXBvcnQgeyBwYXJzZURlZiB9IGZyb20gXCIuLi9wYXJzZURlZi5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlT2JqZWN0RGVmKGRlZiwgcmVmcykge1xuICAgIGNvbnN0IGZvcmNlT3B0aW9uYWxJbnRvTnVsbGFibGUgPSByZWZzLnRhcmdldCA9PT0gXCJvcGVuQWlcIjtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIH07XG4gICAgY29uc3QgcmVxdWlyZWQgPSBbXTtcbiAgICBjb25zdCBzaGFwZSA9IGRlZi5zaGFwZSgpO1xuICAgIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gc2hhcGUpIHtcbiAgICAgICAgbGV0IHByb3BEZWYgPSBzaGFwZVtwcm9wTmFtZV07XG4gICAgICAgIGlmIChwcm9wRGVmID09PSB1bmRlZmluZWQgfHwgcHJvcERlZi5fZGVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcm9wT3B0aW9uYWwgPSBzYWZlSXNPcHRpb25hbChwcm9wRGVmKTtcbiAgICAgICAgaWYgKHByb3BPcHRpb25hbCAmJiBmb3JjZU9wdGlvbmFsSW50b051bGxhYmxlKSB7XG4gICAgICAgICAgICBpZiAocHJvcERlZiBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcHJvcERlZiA9IHByb3BEZWYuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByb3BEZWYuaXNOdWxsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcHJvcERlZiA9IHByb3BEZWYubnVsbGFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BPcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZERlZiA9IHBhcnNlRGVmKHByb3BEZWYuX2RlZiwge1xuICAgICAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJwcm9wZXJ0aWVzXCIsIHByb3BOYW1lXSxcbiAgICAgICAgICAgIHByb3BlcnR5UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwicHJvcGVydGllc1wiLCBwcm9wTmFtZV0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGFyc2VkRGVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHBhcnNlZERlZjtcbiAgICAgICAgaWYgKCFwcm9wT3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHJlcXVpcmVkLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZXF1aXJlZC5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnJlcXVpcmVkID0gcmVxdWlyZWQ7XG4gICAgfVxuICAgIGNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gZGVjaWRlQWRkaXRpb25hbFByb3BlcnRpZXMoZGVmLCByZWZzKTtcbiAgICBpZiAoYWRkaXRpb25hbFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQuYWRkaXRpb25hbFByb3BlcnRpZXMgPSBhZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRlY2lkZUFkZGl0aW9uYWxQcm9wZXJ0aWVzKGRlZiwgcmVmcykge1xuICAgIGlmIChkZWYuY2F0Y2hhbGwuX2RlZi50eXBlTmFtZSAhPT0gXCJab2ROZXZlclwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZURlZihkZWYuY2F0Y2hhbGwuX2RlZiwge1xuICAgICAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN3aXRjaCAoZGVmLnVua25vd25LZXlzKSB7XG4gICAgICAgIGNhc2UgXCJwYXNzdGhyb3VnaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHJlZnMuYWxsb3dlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgICAgICBjYXNlIFwic3RyaWN0XCI6XG4gICAgICAgICAgICByZXR1cm4gcmVmcy5yZWplY3RlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgICAgICBjYXNlIFwic3RyaXBcIjpcbiAgICAgICAgICAgIHJldHVybiByZWZzLnJlbW92ZUFkZGl0aW9uYWxTdHJhdGVneSA9PT0gXCJzdHJpY3RcIlxuICAgICAgICAgICAgICAgID8gcmVmcy5hbGxvd2VkQWRkaXRpb25hbFByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICA6IHJlZnMucmVqZWN0ZWRBZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICB9XG59XG5mdW5jdGlvbiBzYWZlSXNPcHRpb25hbChzY2hlbWEpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmlzT3B0aW9uYWwoKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgcGFyc2VEZWYgfSBmcm9tIFwiLi4vcGFyc2VEZWYuanNcIjtcbmV4cG9ydCBjb25zdCBwYXJzZU9wdGlvbmFsRGVmID0gKGRlZiwgcmVmcykgPT4ge1xuICAgIGlmIChyZWZzLmN1cnJlbnRQYXRoLnRvU3RyaW5nKCkgPT09IHJlZnMucHJvcGVydHlQYXRoPy50b1N0cmluZygpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZURlZihkZWYuaW5uZXJUeXBlLl9kZWYsIHJlZnMpO1xuICAgIH1cbiAgICBjb25zdCBpbm5lclNjaGVtYSA9IHBhcnNlRGVmKGRlZi5pbm5lclR5cGUuX2RlZiwge1xuICAgICAgICAuLi5yZWZzLFxuICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYW55T2ZcIiwgXCIxXCJdLFxuICAgIH0pO1xuICAgIHJldHVybiBpbm5lclNjaGVtYVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGFueU9mOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBub3Q6IHt9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5uZXJTY2hlbWEsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9XG4gICAgICAgIDoge307XG59O1xuIiwgImltcG9ydCB7IHBhcnNlRGVmIH0gZnJvbSBcIi4uL3BhcnNlRGVmLmpzXCI7XG5leHBvcnQgY29uc3QgcGFyc2VQaXBlbGluZURlZiA9IChkZWYsIHJlZnMpID0+IHtcbiAgICBpZiAocmVmcy5waXBlU3RyYXRlZ3kgPT09IFwiaW5wdXRcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VEZWYoZGVmLmluLl9kZWYsIHJlZnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWZzLnBpcGVTdHJhdGVneSA9PT0gXCJvdXRwdXRcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VEZWYoZGVmLm91dC5fZGVmLCByZWZzKTtcbiAgICB9XG4gICAgY29uc3QgYSA9IHBhcnNlRGVmKGRlZi5pbi5fZGVmLCB7XG4gICAgICAgIC4uLnJlZnMsXG4gICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJhbGxPZlwiLCBcIjBcIl0sXG4gICAgfSk7XG4gICAgY29uc3QgYiA9IHBhcnNlRGVmKGRlZi5vdXQuX2RlZiwge1xuICAgICAgICAuLi5yZWZzLFxuICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWxsT2ZcIiwgYSA/IFwiMVwiIDogXCIwXCJdLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFsbE9mOiBbYSwgYl0uZmlsdGVyKCh4KSA9PiB4ICE9PSB1bmRlZmluZWQpLFxuICAgIH07XG59O1xuIiwgImltcG9ydCB7IHBhcnNlRGVmIH0gZnJvbSBcIi4uL3BhcnNlRGVmLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQcm9taXNlRGVmKGRlZiwgcmVmcykge1xuICAgIHJldHVybiBwYXJzZURlZihkZWYudHlwZS5fZGVmLCByZWZzKTtcbn1cbiIsICJpbXBvcnQgeyBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzIH0gZnJvbSBcIi4uL2Vycm9yTWVzc2FnZXMuanNcIjtcbmltcG9ydCB7IHBhcnNlRGVmIH0gZnJvbSBcIi4uL3BhcnNlRGVmLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTZXREZWYoZGVmLCByZWZzKSB7XG4gICAgY29uc3QgaXRlbXMgPSBwYXJzZURlZihkZWYudmFsdWVUeXBlLl9kZWYsIHtcbiAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcIml0ZW1zXCJdLFxuICAgIH0pO1xuICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgICAgICAgaXRlbXMsXG4gICAgfTtcbiAgICBpZiAoZGVmLm1pblNpemUpIHtcbiAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhzY2hlbWEsIFwibWluSXRlbXNcIiwgZGVmLm1pblNpemUudmFsdWUsIGRlZi5taW5TaXplLm1lc3NhZ2UsIHJlZnMpO1xuICAgIH1cbiAgICBpZiAoZGVmLm1heFNpemUpIHtcbiAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhzY2hlbWEsIFwibWF4SXRlbXNcIiwgZGVmLm1heFNpemUudmFsdWUsIGRlZi5tYXhTaXplLm1lc3NhZ2UsIHJlZnMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hO1xufVxuIiwgImltcG9ydCB7IHBhcnNlRGVmIH0gZnJvbSBcIi4uL3BhcnNlRGVmLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUdXBsZURlZihkZWYsIHJlZnMpIHtcbiAgICBpZiAoZGVmLnJlc3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIG1pbkl0ZW1zOiBkZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgaXRlbXM6IGRlZi5pdGVtc1xuICAgICAgICAgICAgICAgIC5tYXAoKHgsIGkpID0+IHBhcnNlRGVmKHguX2RlZiwge1xuICAgICAgICAgICAgICAgIC4uLnJlZnMsXG4gICAgICAgICAgICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcIml0ZW1zXCIsIGAke2l9YF0sXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIHgpID0+ICh4ID09PSB1bmRlZmluZWQgPyBhY2MgOiBbLi4uYWNjLCB4XSksIFtdKSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxJdGVtczogcGFyc2VEZWYoZGVmLnJlc3QuX2RlZiwge1xuICAgICAgICAgICAgICAgIC4uLnJlZnMsXG4gICAgICAgICAgICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFkZGl0aW9uYWxJdGVtc1wiXSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIG1pbkl0ZW1zOiBkZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgbWF4SXRlbXM6IGRlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICBpdGVtczogZGVmLml0ZW1zXG4gICAgICAgICAgICAgICAgLm1hcCgoeCwgaSkgPT4gcGFyc2VEZWYoeC5fZGVmLCB7XG4gICAgICAgICAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiaXRlbXNcIiwgYCR7aX1gXSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgeCkgPT4gKHggPT09IHVuZGVmaW5lZCA/IGFjYyA6IFsuLi5hY2MsIHhdKSwgW10pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gcGFyc2VVbmRlZmluZWREZWYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm90OiB7fSxcbiAgICB9O1xufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBwYXJzZVVua25vd25EZWYoKSB7XG4gICAgcmV0dXJuIHt9O1xufVxuIiwgImltcG9ydCB7IHBhcnNlRGVmIH0gZnJvbSBcIi4uL3BhcnNlRGVmLmpzXCI7XG5leHBvcnQgY29uc3QgcGFyc2VSZWFkb25seURlZiA9IChkZWYsIHJlZnMpID0+IHtcbiAgICByZXR1cm4gcGFyc2VEZWYoZGVmLmlubmVyVHlwZS5fZGVmLCByZWZzKTtcbn07XG4iLCAiaW1wb3J0IHsgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIH0gZnJvbSBcInpvZFwiO1xuaW1wb3J0IHsgcGFyc2VBbnlEZWYgfSBmcm9tIFwiLi9wYXJzZXJzL2FueS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VBcnJheURlZiB9IGZyb20gXCIuL3BhcnNlcnMvYXJyYXkuanNcIjtcbmltcG9ydCB7IHBhcnNlQmlnaW50RGVmIH0gZnJvbSBcIi4vcGFyc2Vycy9iaWdpbnQuanNcIjtcbmltcG9ydCB7IHBhcnNlQm9vbGVhbkRlZiB9IGZyb20gXCIuL3BhcnNlcnMvYm9vbGVhbi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VCcmFuZGVkRGVmIH0gZnJvbSBcIi4vcGFyc2Vycy9icmFuZGVkLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUNhdGNoRGVmIH0gZnJvbSBcIi4vcGFyc2Vycy9jYXRjaC5qc1wiO1xuaW1wb3J0IHsgcGFyc2VEYXRlRGVmIH0gZnJvbSBcIi4vcGFyc2Vycy9kYXRlLmpzXCI7XG5pbXBvcnQgeyBwYXJzZURlZmF1bHREZWYgfSBmcm9tIFwiLi9wYXJzZXJzL2RlZmF1bHQuanNcIjtcbmltcG9ydCB7IHBhcnNlRWZmZWN0c0RlZiB9IGZyb20gXCIuL3BhcnNlcnMvZWZmZWN0cy5qc1wiO1xuaW1wb3J0IHsgcGFyc2VFbnVtRGVmIH0gZnJvbSBcIi4vcGFyc2Vycy9lbnVtLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUludGVyc2VjdGlvbkRlZiB9IGZyb20gXCIuL3BhcnNlcnMvaW50ZXJzZWN0aW9uLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUxpdGVyYWxEZWYgfSBmcm9tIFwiLi9wYXJzZXJzL2xpdGVyYWwuanNcIjtcbmltcG9ydCB7IHBhcnNlTWFwRGVmIH0gZnJvbSBcIi4vcGFyc2Vycy9tYXAuanNcIjtcbmltcG9ydCB7IHBhcnNlTmF0aXZlRW51bURlZiB9IGZyb20gXCIuL3BhcnNlcnMvbmF0aXZlRW51bS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VOZXZlckRlZiB9IGZyb20gXCIuL3BhcnNlcnMvbmV2ZXIuanNcIjtcbmltcG9ydCB7IHBhcnNlTnVsbERlZiB9IGZyb20gXCIuL3BhcnNlcnMvbnVsbC5qc1wiO1xuaW1wb3J0IHsgcGFyc2VOdWxsYWJsZURlZiB9IGZyb20gXCIuL3BhcnNlcnMvbnVsbGFibGUuanNcIjtcbmltcG9ydCB7IHBhcnNlTnVtYmVyRGVmIH0gZnJvbSBcIi4vcGFyc2Vycy9udW1iZXIuanNcIjtcbmltcG9ydCB7IHBhcnNlT2JqZWN0RGVmIH0gZnJvbSBcIi4vcGFyc2Vycy9vYmplY3QuanNcIjtcbmltcG9ydCB7IHBhcnNlT3B0aW9uYWxEZWYgfSBmcm9tIFwiLi9wYXJzZXJzL29wdGlvbmFsLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVBpcGVsaW5lRGVmIH0gZnJvbSBcIi4vcGFyc2Vycy9waXBlbGluZS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VQcm9taXNlRGVmIH0gZnJvbSBcIi4vcGFyc2Vycy9wcm9taXNlLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVJlY29yZERlZiB9IGZyb20gXCIuL3BhcnNlcnMvcmVjb3JkLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVNldERlZiB9IGZyb20gXCIuL3BhcnNlcnMvc2V0LmpzXCI7XG5pbXBvcnQgeyBwYXJzZVN0cmluZ0RlZiB9IGZyb20gXCIuL3BhcnNlcnMvc3RyaW5nLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVR1cGxlRGVmIH0gZnJvbSBcIi4vcGFyc2Vycy90dXBsZS5qc1wiO1xuaW1wb3J0IHsgcGFyc2VVbmRlZmluZWREZWYgfSBmcm9tIFwiLi9wYXJzZXJzL3VuZGVmaW5lZC5qc1wiO1xuaW1wb3J0IHsgcGFyc2VVbmlvbkRlZiB9IGZyb20gXCIuL3BhcnNlcnMvdW5pb24uanNcIjtcbmltcG9ydCB7IHBhcnNlVW5rbm93bkRlZiB9IGZyb20gXCIuL3BhcnNlcnMvdW5rbm93bi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VSZWFkb25seURlZiB9IGZyb20gXCIuL3BhcnNlcnMvcmVhZG9ubHkuanNcIjtcbmV4cG9ydCBjb25zdCBzZWxlY3RQYXJzZXIgPSAoZGVmLCB0eXBlTmFtZSwgcmVmcykgPT4ge1xuICAgIHN3aXRjaCAodHlwZU5hbWUpIHtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nRGVmKGRlZiwgcmVmcyk7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWJlckRlZihkZWYsIHJlZnMpO1xuICAgICAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3Q6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VPYmplY3REZWYoZGVmLCByZWZzKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50OlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQmlnaW50RGVmKGRlZiwgcmVmcyk7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW46XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VCb29sZWFuRGVmKCk7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGU6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VEYXRlRGVmKGRlZiwgcmVmcyk7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVVuZGVmaW5lZERlZigpO1xuICAgICAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVsbERlZihyZWZzKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXk6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheURlZihkZWYsIHJlZnMpO1xuICAgICAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbjpcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVW5pb25EZWYoZGVmLCByZWZzKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50ZXJzZWN0aW9uRGVmKGRlZiwgcmVmcyk7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHVwbGVEZWYoZGVmLCByZWZzKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmVjb3JkRGVmKGRlZiwgcmVmcyk7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWw6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VMaXRlcmFsRGVmKGRlZiwgcmVmcyk7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW06XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VFbnVtRGVmKGRlZik7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW06XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOYXRpdmVFbnVtRGVmKGRlZik7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVsbGFibGVEZWYoZGVmLCByZWZzKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT3B0aW9uYWw6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VPcHRpb25hbERlZihkZWYsIHJlZnMpO1xuICAgICAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXA6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VNYXBEZWYoZGVmLCByZWZzKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0OlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2V0RGVmKGRlZiwgcmVmcyk7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenk6XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gZGVmLmdldHRlcigpLl9kZWY7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2U6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VQcm9taXNlRGVmKGRlZiwgcmVmcyk7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTjpcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOZXZlckRlZigpO1xuICAgICAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRWZmZWN0c0RlZihkZWYsIHJlZnMpO1xuICAgICAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnk6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VBbnlEZWYoKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5rbm93bjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVVua25vd25EZWYoKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZURlZmF1bHREZWYoZGVmLCByZWZzKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZDpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUJyYW5kZWREZWYoZGVmLCByZWZzKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVhZG9ubHk6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSZWFkb25seURlZihkZWYsIHJlZnMpO1xuICAgICAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaDpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUNhdGNoRGVmKGRlZiwgcmVmcyk7XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFBpcGVsaW5lOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUGlwZWxpbmVEZWYoZGVmLCByZWZzKTtcbiAgICAgICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRnVuY3Rpb246XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQ6XG4gICAgICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN5bWJvbDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuICgoXykgPT4gdW5kZWZpbmVkKSh0eXBlTmFtZSk7XG4gICAgfVxufTtcbiIsICJpbXBvcnQgeyBpZ25vcmVPdmVycmlkZSB9IGZyb20gXCIuL09wdGlvbnMuanNcIjtcbmltcG9ydCB7IHNlbGVjdFBhcnNlciB9IGZyb20gXCIuL3NlbGVjdFBhcnNlci5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRGVmKGRlZiwgcmVmcywgZm9yY2VSZXNvbHV0aW9uID0gZmFsc2UpIHtcbiAgICBjb25zdCBzZWVuSXRlbSA9IHJlZnMuc2Vlbi5nZXQoZGVmKTtcbiAgICBpZiAocmVmcy5vdmVycmlkZSkge1xuICAgICAgICBjb25zdCBvdmVycmlkZVJlc3VsdCA9IHJlZnMub3ZlcnJpZGU/LihkZWYsIHJlZnMsIHNlZW5JdGVtLCBmb3JjZVJlc29sdXRpb24pO1xuICAgICAgICBpZiAob3ZlcnJpZGVSZXN1bHQgIT09IGlnbm9yZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlZW5JdGVtICYmICFmb3JjZVJlc29sdXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2VlblNjaGVtYSA9IGdldCRyZWYoc2Vlbkl0ZW0sIHJlZnMpO1xuICAgICAgICBpZiAoc2VlblNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VlblNjaGVtYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdJdGVtID0geyBkZWYsIHBhdGg6IHJlZnMuY3VycmVudFBhdGgsIGpzb25TY2hlbWE6IHVuZGVmaW5lZCB9O1xuICAgIHJlZnMuc2Vlbi5zZXQoZGVmLCBuZXdJdGVtKTtcbiAgICBjb25zdCBqc29uU2NoZW1hT3JHZXR0ZXIgPSBzZWxlY3RQYXJzZXIoZGVmLCBkZWYudHlwZU5hbWUsIHJlZnMpO1xuICAgIC8vIElmIHRoZSByZXR1cm4gd2FzIGEgZnVuY3Rpb24sIHRoZW4gdGhlIGlubmVyIGRlZmluaXRpb24gbmVlZHMgdG8gYmUgZXh0cmFjdGVkIGJlZm9yZSBhIGNhbGwgdG8gcGFyc2VEZWYgKHJlY3Vyc2l2ZSlcbiAgICBjb25zdCBqc29uU2NoZW1hID0gdHlwZW9mIGpzb25TY2hlbWFPckdldHRlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gcGFyc2VEZWYoanNvblNjaGVtYU9yR2V0dGVyKCksIHJlZnMpXG4gICAgICAgIDoganNvblNjaGVtYU9yR2V0dGVyO1xuICAgIGlmIChqc29uU2NoZW1hKSB7XG4gICAgICAgIGFkZE1ldGEoZGVmLCByZWZzLCBqc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKHJlZnMucG9zdFByb2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcG9zdFByb2Nlc3NSZXN1bHQgPSByZWZzLnBvc3RQcm9jZXNzKGpzb25TY2hlbWEsIGRlZiwgcmVmcyk7XG4gICAgICAgIG5ld0l0ZW0uanNvblNjaGVtYSA9IGpzb25TY2hlbWE7XG4gICAgICAgIHJldHVybiBwb3N0UHJvY2Vzc1Jlc3VsdDtcbiAgICB9XG4gICAgbmV3SXRlbS5qc29uU2NoZW1hID0ganNvblNjaGVtYTtcbiAgICByZXR1cm4ganNvblNjaGVtYTtcbn1cbmNvbnN0IGdldCRyZWYgPSAoaXRlbSwgcmVmcykgPT4ge1xuICAgIHN3aXRjaCAocmVmcy4kcmVmU3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSBcInJvb3RcIjpcbiAgICAgICAgICAgIHJldHVybiB7ICRyZWY6IGl0ZW0ucGF0aC5qb2luKFwiL1wiKSB9O1xuICAgICAgICBjYXNlIFwicmVsYXRpdmVcIjpcbiAgICAgICAgICAgIHJldHVybiB7ICRyZWY6IGdldFJlbGF0aXZlUGF0aChyZWZzLmN1cnJlbnRQYXRoLCBpdGVtLnBhdGgpIH07XG4gICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgIGNhc2UgXCJzZWVuXCI6IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnBhdGgubGVuZ3RoIDwgcmVmcy5jdXJyZW50UGF0aC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBpdGVtLnBhdGguZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gcmVmcy5jdXJyZW50UGF0aFtpbmRleF0gPT09IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgUmVjdXJzaXZlIHJlZmVyZW5jZSBkZXRlY3RlZCBhdCAke3JlZnMuY3VycmVudFBhdGguam9pbihcIi9cIil9ISBEZWZhdWx0aW5nIHRvIGFueWApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWZzLiRyZWZTdHJhdGVneSA9PT0gXCJzZWVuXCIgPyB7fSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBnZXRSZWxhdGl2ZVBhdGggPSAocGF0aEEsIHBhdGhCKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgcGF0aEEubGVuZ3RoICYmIGkgPCBwYXRoQi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aEFbaV0gIT09IHBhdGhCW2ldKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBbKHBhdGhBLmxlbmd0aCAtIGkpLnRvU3RyaW5nKCksIC4uLnBhdGhCLnNsaWNlKGkpXS5qb2luKFwiL1wiKTtcbn07XG5jb25zdCBhZGRNZXRhID0gKGRlZiwgcmVmcywganNvblNjaGVtYSkgPT4ge1xuICAgIGlmIChkZWYuZGVzY3JpcHRpb24pIHtcbiAgICAgICAganNvblNjaGVtYS5kZXNjcmlwdGlvbiA9IGRlZi5kZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKHJlZnMubWFya2Rvd25EZXNjcmlwdGlvbikge1xuICAgICAgICAgICAganNvblNjaGVtYS5tYXJrZG93bkRlc2NyaXB0aW9uID0gZGVmLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqc29uU2NoZW1hO1xufTtcbiIsICJpbXBvcnQgeyBwYXJzZURlZiB9IGZyb20gXCIuL3BhcnNlRGVmLmpzXCI7XG5pbXBvcnQgeyBnZXRSZWZzIH0gZnJvbSBcIi4vUmVmcy5qc1wiO1xuY29uc3Qgem9kVG9Kc29uU2NoZW1hID0gKHNjaGVtYSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHJlZnMgPSBnZXRSZWZzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlZmluaXRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5kZWZpbml0aW9uc1xuICAgICAgICA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuZGVmaW5pdGlvbnMpLnJlZHVjZSgoYWNjLCBbbmFtZSwgc2NoZW1hXSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIFtuYW1lXTogcGFyc2VEZWYoc2NoZW1hLl9kZWYsIHtcbiAgICAgICAgICAgICAgICAuLi5yZWZzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5iYXNlUGF0aCwgcmVmcy5kZWZpbml0aW9uUGF0aCwgbmFtZV0sXG4gICAgICAgICAgICB9LCB0cnVlKSA/PyB7fSxcbiAgICAgICAgfSksIHt9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBvcHRpb25zXG4gICAgICAgIDogb3B0aW9ucz8ubmFtZVN0cmF0ZWd5ID09PSBcInRpdGxlXCJcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IG9wdGlvbnM/Lm5hbWU7XG4gICAgY29uc3QgbWFpbiA9IHBhcnNlRGVmKHNjaGVtYS5fZGVmLCBuYW1lID09PSB1bmRlZmluZWRcbiAgICAgICAgPyByZWZzXG4gICAgICAgIDoge1xuICAgICAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5iYXNlUGF0aCwgcmVmcy5kZWZpbml0aW9uUGF0aCwgbmFtZV0sXG4gICAgICAgIH0sIGZhbHNlKSA/PyB7fTtcbiAgICBjb25zdCB0aXRsZSA9IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG9wdGlvbnMubmFtZVN0cmF0ZWd5ID09PSBcInRpdGxlXCJcbiAgICAgICAgPyBvcHRpb25zLm5hbWVcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWFpbi50aXRsZSA9IHRpdGxlO1xuICAgIH1cbiAgICBjb25zdCBjb21iaW5lZCA9IG5hbWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGRlZmluaXRpb25zXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAuLi5tYWluLFxuICAgICAgICAgICAgICAgIFtyZWZzLmRlZmluaXRpb25QYXRoXTogZGVmaW5pdGlvbnMsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IG1haW5cbiAgICAgICAgOiB7XG4gICAgICAgICAgICAkcmVmOiBbXG4gICAgICAgICAgICAgICAgLi4uKHJlZnMuJHJlZlN0cmF0ZWd5ID09PSBcInJlbGF0aXZlXCIgPyBbXSA6IHJlZnMuYmFzZVBhdGgpLFxuICAgICAgICAgICAgICAgIHJlZnMuZGVmaW5pdGlvblBhdGgsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIF0uam9pbihcIi9cIiksXG4gICAgICAgICAgICBbcmVmcy5kZWZpbml0aW9uUGF0aF06IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZpbml0aW9ucyxcbiAgICAgICAgICAgICAgICBbbmFtZV06IG1haW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIGlmIChyZWZzLnRhcmdldCA9PT0gXCJqc29uU2NoZW1hN1wiKSB7XG4gICAgICAgIGNvbWJpbmVkLiRzY2hlbWEgPSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWZzLnRhcmdldCA9PT0gXCJqc29uU2NoZW1hMjAxOS0wOVwiIHx8IHJlZnMudGFyZ2V0ID09PSBcIm9wZW5BaVwiKSB7XG4gICAgICAgIGNvbWJpbmVkLiRzY2hlbWEgPSBcImh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMTktMDkvc2NoZW1hI1wiO1xuICAgIH1cbiAgICBpZiAocmVmcy50YXJnZXQgPT09IFwib3BlbkFpXCIgJiZcbiAgICAgICAgKFwiYW55T2ZcIiBpbiBjb21iaW5lZCB8fFxuICAgICAgICAgICAgXCJvbmVPZlwiIGluIGNvbWJpbmVkIHx8XG4gICAgICAgICAgICBcImFsbE9mXCIgaW4gY29tYmluZWQgfHxcbiAgICAgICAgICAgIChcInR5cGVcIiBpbiBjb21iaW5lZCAmJiBBcnJheS5pc0FycmF5KGNvbWJpbmVkLnR5cGUpKSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogT3BlbkFJIG1heSBub3Qgc3VwcG9ydCBzY2hlbWFzIHdpdGggdW5pb25zIGFzIHJvb3RzISBUcnkgd3JhcHBpbmcgaXQgaW4gYW4gb2JqZWN0IHByb3BlcnR5LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmVkO1xufTtcbmV4cG9ydCB7IHpvZFRvSnNvblNjaGVtYSB9O1xuIiwgImZ1bmN0aW9uIF9lc2NhcGVOb2RlTGFiZWwobm9kZUxhYmVsKSB7XG4gICAgLy8gRXNjYXBlcyB0aGUgbm9kZSBsYWJlbCBmb3IgTWVybWFpZCBzeW50YXguXG4gICAgcmV0dXJuIG5vZGVMYWJlbC5yZXBsYWNlKC9bXmEtekEtWi1fMC05XS9nLCBcIl9cIik7XG59XG5jb25zdCBNQVJLRE9XTl9TUEVDSUFMX0NIQVJTID0gW1wiKlwiLCBcIl9cIiwgXCJgXCJdO1xuZnVuY3Rpb24gX2dlbmVyYXRlTWVybWFpZEdyYXBoU3R5bGVzKG5vZGVDb2xvcnMpIHtcbiAgICBsZXQgc3R5bGVzID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IFtjbGFzc05hbWUsIGNvbG9yXSBvZiBPYmplY3QuZW50cmllcyhub2RlQ29sb3JzKSkge1xuICAgICAgICBzdHlsZXMgKz0gYFxcdGNsYXNzRGVmICR7Y2xhc3NOYW1lfSAke2NvbG9yfTtcXG5gO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xufVxuLyoqXG4gKiBEcmF3cyBhIE1lcm1haWQgZ3JhcGggdXNpbmcgdGhlIHByb3ZpZGVkIGdyYXBoIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdNZXJtYWlkKG5vZGVzLCBlZGdlcywgY29uZmlnKSB7XG4gICAgY29uc3QgeyBmaXJzdE5vZGUsIGxhc3ROb2RlLCBub2RlQ29sb3JzLCB3aXRoU3R5bGVzID0gdHJ1ZSwgY3VydmVTdHlsZSA9IFwibGluZWFyXCIsIHdyYXBMYWJlbE5Xb3JkcyA9IDksIH0gPSBjb25maWcgPz8ge307XG4gICAgLy8gSW5pdGlhbGl6ZSBNZXJtYWlkIGdyYXBoIGNvbmZpZ3VyYXRpb25cbiAgICBsZXQgbWVybWFpZEdyYXBoID0gd2l0aFN0eWxlc1xuICAgICAgICA/IGAlJXtpbml0OiB7J2Zsb3djaGFydCc6IHsnY3VydmUnOiAnJHtjdXJ2ZVN0eWxlfSd9fX0lJVxcbmdyYXBoIFREO1xcbmBcbiAgICAgICAgOiBcImdyYXBoIFREO1xcblwiO1xuICAgIGlmICh3aXRoU3R5bGVzKSB7XG4gICAgICAgIC8vIE5vZGUgZm9ybWF0dGluZyB0ZW1wbGF0ZXNcbiAgICAgICAgY29uc3QgZGVmYXVsdENsYXNzTGFiZWwgPSBcImRlZmF1bHRcIjtcbiAgICAgICAgY29uc3QgZm9ybWF0RGljdCA9IHtcbiAgICAgICAgICAgIFtkZWZhdWx0Q2xhc3NMYWJlbF06IFwiezB9KHsxfSlcIixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpcnN0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3JtYXREaWN0W2ZpcnN0Tm9kZV0gPSBcInswfShbezF9XSk6OjpmaXJzdFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3JtYXREaWN0W2xhc3ROb2RlXSA9IFwiezB9KFt7MX1dKTo6Omxhc3RcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgbm9kZXMgdG8gdGhlIGdyYXBoXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IG5vZGUubmFtZS5zcGxpdChcIjpcIikucG9wKCkgPz8gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gTUFSS0RPV05fU1BFQ0lBTF9DSEFSUy5zb21lKChjaGFyKSA9PiBub2RlTmFtZS5zdGFydHNXaXRoKGNoYXIpICYmIG5vZGVOYW1lLmVuZHNXaXRoKGNoYXIpKVxuICAgICAgICAgICAgICAgID8gYDxwPiR7bm9kZU5hbWV9PC9wPmBcbiAgICAgICAgICAgICAgICA6IG5vZGVOYW1lO1xuICAgICAgICAgICAgbGV0IGZpbmFsTGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlLm1ldGFkYXRhID8/IHt9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmaW5hbExhYmVsICs9IGA8aHIvPjxzbWFsbD48ZW0+JHtPYmplY3QuZW50cmllcyhub2RlLm1ldGFkYXRhID8/IHt9KVxuICAgICAgICAgICAgICAgICAgICAubWFwKChbaywgdl0pID0+IGAke2t9ID0gJHt2fWApXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpfTwvZW0+PC9zbWFsbD5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZUxhYmVsID0gKGZvcm1hdERpY3Rba2V5XSA/PyBmb3JtYXREaWN0W2RlZmF1bHRDbGFzc0xhYmVsXSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcInswfVwiLCBfZXNjYXBlTm9kZUxhYmVsKGtleSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJ7MX1cIiwgZmluYWxMYWJlbCk7XG4gICAgICAgICAgICBtZXJtYWlkR3JhcGggKz0gYFxcdCR7bm9kZUxhYmVsfVxcbmA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR3JvdXAgZWRnZXMgYnkgdGhlaXIgY29tbW9uIHByZWZpeGVzXG4gICAgY29uc3QgZWRnZUdyb3VwcyA9IHt9O1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICBjb25zdCBzcmNQYXJ0cyA9IGVkZ2Uuc291cmNlLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgY29uc3QgdGd0UGFydHMgPSBlZGdlLnRhcmdldC5zcGxpdChcIjpcIik7XG4gICAgICAgIGNvbnN0IGNvbW1vblByZWZpeCA9IHNyY1BhcnRzXG4gICAgICAgICAgICAuZmlsdGVyKChzcmMsIGkpID0+IHNyYyA9PT0gdGd0UGFydHNbaV0pXG4gICAgICAgICAgICAuam9pbihcIjpcIik7XG4gICAgICAgIGlmICghZWRnZUdyb3Vwc1tjb21tb25QcmVmaXhdKSB7XG4gICAgICAgICAgICBlZGdlR3JvdXBzW2NvbW1vblByZWZpeF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlZGdlR3JvdXBzW2NvbW1vblByZWZpeF0ucHVzaChlZGdlKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlblN1YmdyYXBocyA9IG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiBhZGRTdWJncmFwaChlZGdlcywgcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IHNlbGZMb29wID0gZWRnZXMubGVuZ3RoID09PSAxICYmIGVkZ2VzWzBdLnNvdXJjZSA9PT0gZWRnZXNbMF0udGFyZ2V0O1xuICAgICAgICBpZiAocHJlZml4ICYmICFzZWxmTG9vcCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViZ3JhcGggPSBwcmVmaXguc3BsaXQoXCI6XCIpLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHNlZW5TdWJncmFwaHMuaGFzKHN1YmdyYXBoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm91bmQgZHVwbGljYXRlIHN1YmdyYXBoICcke3N1YmdyYXBofScgLS0gdGhpcyBsaWtlbHkgbWVhbnMgdGhhdCBgICtcbiAgICAgICAgICAgICAgICAgICAgXCJ5b3UncmUgcmV1c2luZyBhIHN1YmdyYXBoIG5vZGUgd2l0aCB0aGUgc2FtZSBuYW1lLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIGFkanVzdCB5b3VyIGdyYXBoIHRvIGhhdmUgc3ViZ3JhcGggbm9kZXMgd2l0aCB1bmlxdWUgbmFtZXMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VlblN1YmdyYXBocy5hZGQoc3ViZ3JhcGgpO1xuICAgICAgICAgICAgbWVybWFpZEdyYXBoICs9IGBcXHRzdWJncmFwaCAke3N1YmdyYXBofVxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBlZGdlIG9mIGVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNvdXJjZSwgdGFyZ2V0LCBkYXRhLCBjb25kaXRpb25hbCB9ID0gZWRnZTtcbiAgICAgICAgICAgIGxldCBlZGdlTGFiZWwgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBlZGdlRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBlZGdlRGF0YS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmRzLmxlbmd0aCA+IHdyYXBMYWJlbE5Xb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBlZGdlRGF0YSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IE1hdGguY2VpbCh3b3Jkcy5sZW5ndGggLyB3cmFwTGFiZWxOV29yZHMpIH0sIChfLCBpKSA9PiB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGkgKiB3cmFwTGFiZWxOV29yZHMsIChpICsgMSkgKiB3cmFwTGFiZWxOV29yZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIiBcIikpLmpvaW4oXCImbmJzcDs8YnI+Jm5ic3A7XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlZGdlTGFiZWwgPSBjb25kaXRpb25hbFxuICAgICAgICAgICAgICAgICAgICA/IGAgLS4gJm5ic3A7JHtlZGdlRGF0YX0mbmJzcDsgLi0+IGBcbiAgICAgICAgICAgICAgICAgICAgOiBgIC0tICZuYnNwOyR7ZWRnZURhdGF9Jm5ic3A7IC0tPiBgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRnZUxhYmVsID0gY29uZGl0aW9uYWwgPyBcIiAtLi0+IFwiIDogXCIgLS0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVybWFpZEdyYXBoICs9IGBcXHQke19lc2NhcGVOb2RlTGFiZWwoc291cmNlKX0ke2VkZ2VMYWJlbH0ke19lc2NhcGVOb2RlTGFiZWwodGFyZ2V0KX07XFxuYDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBhZGQgbmVzdGVkIHN1YmdyYXBoc1xuICAgICAgICBmb3IgKGNvbnN0IG5lc3RlZFByZWZpeCBpbiBlZGdlR3JvdXBzKSB7XG4gICAgICAgICAgICBpZiAobmVzdGVkUHJlZml4LnN0YXJ0c1dpdGgoYCR7cHJlZml4fTpgKSAmJiBuZXN0ZWRQcmVmaXggIT09IHByZWZpeCkge1xuICAgICAgICAgICAgICAgIGFkZFN1YmdyYXBoKGVkZ2VHcm91cHNbbmVzdGVkUHJlZml4XSwgbmVzdGVkUHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZml4ICYmICFzZWxmTG9vcCkge1xuICAgICAgICAgICAgbWVybWFpZEdyYXBoICs9IFwiXFx0ZW5kXFxuXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RhcnQgd2l0aCB0aGUgdG9wLWxldmVsIGVkZ2VzIChubyBjb21tb24gcHJlZml4KVxuICAgIGFkZFN1YmdyYXBoKGVkZ2VHcm91cHNbXCJcIl0gPz8gW10sIFwiXCIpO1xuICAgIC8vIEFkZCByZW1haW5pbmcgc3ViZ3JhcGhzXG4gICAgZm9yIChjb25zdCBwcmVmaXggaW4gZWRnZUdyb3Vwcykge1xuICAgICAgICBpZiAoIXByZWZpeC5pbmNsdWRlcyhcIjpcIikgJiYgcHJlZml4ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBhZGRTdWJncmFwaChlZGdlR3JvdXBzW3ByZWZpeF0sIHByZWZpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIGN1c3RvbSBzdHlsZXMgZm9yIG5vZGVzXG4gICAgaWYgKHdpdGhTdHlsZXMpIHtcbiAgICAgICAgbWVybWFpZEdyYXBoICs9IF9nZW5lcmF0ZU1lcm1haWRHcmFwaFN0eWxlcyhub2RlQ29sb3JzID8/IHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcm1haWRHcmFwaDtcbn1cbi8qKlxuICogUmVuZGVycyBNZXJtYWlkIGdyYXBoIHVzaW5nIHRoZSBNZXJtYWlkLklOSyBBUEkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkcmF3TWVybWFpZFBuZyhtZXJtYWlkU3ludGF4LCBjb25maWcpIHtcbiAgICBsZXQgeyBiYWNrZ3JvdW5kQ29sb3IgPSBcIndoaXRlXCIgfSA9IGNvbmZpZyA/PyB7fTtcbiAgICAvLyBVc2UgYnRvYSBmb3IgY29tcGF0aWJpbGl0eSwgYXNzdW1lIEFTQ0lJXG4gICAgY29uc3QgbWVybWFpZFN5bnRheEVuY29kZWQgPSBidG9hKG1lcm1haWRTeW50YXgpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGlzIGEgaGV4YWRlY2ltYWwgY29sb3IgY29kZSB1c2luZyByZWdleFxuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBoZXhDb2xvclBhdHRlcm4gPSAvXiMoPzpbMC05YS1mQS1GXXszfSl7MSwyfSQvO1xuICAgICAgICBpZiAoIWhleENvbG9yUGF0dGVybi50ZXN0KGJhY2tncm91bmRDb2xvcikpIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGAhJHtiYWNrZ3JvdW5kQ29sb3J9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbWFnZVVybCA9IGBodHRwczovL21lcm1haWQuaW5rL2ltZy8ke21lcm1haWRTeW50YXhFbmNvZGVkfT9iZ0NvbG9yPSR7YmFja2dyb3VuZENvbG9yfWA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goaW1hZ2VVcmwpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHJlbmRlciB0aGUgZ3JhcGggdXNpbmcgdGhlIE1lcm1haWQuSU5LIEFQSS5gLFxuICAgICAgICAgICAgYFN0YXR1cyBjb2RlOiAke3Jlcy5zdGF0dXN9YCxcbiAgICAgICAgICAgIGBTdGF0dXMgdGV4dDogJHtyZXMuc3RhdHVzVGV4dH1gLFxuICAgICAgICBdLmpvaW4oXCJcXG5cIikpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVzLmJsb2IoKTtcbiAgICByZXR1cm4gY29udGVudDtcbn1cbiIsICJpbXBvcnQgeyB6b2RUb0pzb25TY2hlbWEgfSBmcm9tIFwiem9kLXRvLWpzb24tc2NoZW1hXCI7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQsIHZhbGlkYXRlIGFzIGlzVXVpZCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBpc1J1bm5hYmxlSW50ZXJmYWNlIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IGRyYXdNZXJtYWlkLCBkcmF3TWVybWFpZFBuZyB9IGZyb20gXCIuL2dyYXBoX21lcm1haWQuanNcIjtcbmZ1bmN0aW9uIG5vZGVEYXRhU3RyKGlkLCBkYXRhKSB7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgIWlzVXVpZChpZCkpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1J1bm5hYmxlSW50ZXJmYWNlKGRhdGEpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZGF0YVN0ciA9IGRhdGEuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgZGF0YVN0ciA9IGRhdGFTdHIuc3RhcnRzV2l0aChcIlJ1bm5hYmxlXCIpXG4gICAgICAgICAgICAgICAgPyBkYXRhU3RyLnNsaWNlKFwiUnVubmFibGVcIi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgOiBkYXRhU3RyO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFTdHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5nZXROYW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRhLm5hbWUgPz8gXCJVbmtub3duU2NoZW1hXCI7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZURhdGFKc29uKG5vZGUpIHtcbiAgICAvLyBpZiBub2RlLmRhdGEgaW1wbGVtZW50cyBSdW5uYWJsZVxuICAgIGlmIChpc1J1bm5hYmxlSW50ZXJmYWNlKG5vZGUuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicnVubmFibGVcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBpZDogbm9kZS5kYXRhLmxjX2lkLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUuZGF0YS5nZXROYW1lKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwic2NoZW1hXCIsXG4gICAgICAgICAgICBkYXRhOiB7IC4uLnpvZFRvSnNvblNjaGVtYShub2RlLmRhdGEuc2NoZW1hKSwgdGl0bGU6IG5vZGUuZGF0YS5uYW1lIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEdyYXBoIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibm9kZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlZGdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBwYXJhbXM/Lm5vZGVzID8/IHRoaXMubm9kZXM7XG4gICAgICAgIHRoaXMuZWRnZXMgPSBwYXJhbXM/LmVkZ2VzID8/IHRoaXMuZWRnZXM7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgdGhlIGdyYXBoIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgZm9ybWF0LlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBzdGFibGVOb2RlSWRzID0ge307XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgc3RhYmxlTm9kZUlkc1tub2RlLmlkXSA9IGlzVXVpZChub2RlLmlkKSA/IGkgOiBub2RlLmlkO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVzOiBPYmplY3QudmFsdWVzKHRoaXMubm9kZXMpLm1hcCgobm9kZSkgPT4gKHtcbiAgICAgICAgICAgICAgICBpZDogc3RhYmxlTm9kZUlkc1tub2RlLmlkXSxcbiAgICAgICAgICAgICAgICAuLi5ub2RlRGF0YUpzb24obm9kZSksXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBlZGdlczogdGhpcy5lZGdlcy5tYXAoKGVkZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHN0YWJsZU5vZGVJZHNbZWRnZS5zb3VyY2VdLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHN0YWJsZU5vZGVJZHNbZWRnZS50YXJnZXRdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlZGdlLmRhdGEgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kYXRhID0gZWRnZS5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVkZ2UuY29uZGl0aW9uYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jb25kaXRpb25hbCA9IGVkZ2UuY29uZGl0aW9uYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZE5vZGUoZGF0YSwgaWQsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ub2Rlc1tpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb2RlIHdpdGggaWQgJHtpZH0gYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlSWQgPSBpZCA/PyB1dWlkdjQoKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgICAgIGlkOiBub2RlSWQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgbmFtZTogbm9kZURhdGFTdHIoaWQsIGRhdGEpLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUlkXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIG5vZGVzIG1hcFxuICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1tub2RlLmlkXTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIG5vZGVcbiAgICAgICAgdGhpcy5lZGdlcyA9IHRoaXMuZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLnNvdXJjZSAhPT0gbm9kZS5pZCAmJiBlZGdlLnRhcmdldCAhPT0gbm9kZS5pZCk7XG4gICAgfVxuICAgIGFkZEVkZ2Uoc291cmNlLCB0YXJnZXQsIGRhdGEsIGNvbmRpdGlvbmFsKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzW3NvdXJjZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTb3VyY2Ugbm9kZSAke3NvdXJjZS5pZH0gbm90IGluIGdyYXBoYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm9kZXNbdGFyZ2V0LmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBub2RlICR7dGFyZ2V0LmlkfSBub3QgaW4gZ3JhcGhgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGdlID0ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UuaWQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldC5pZCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBjb25kaXRpb25hbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZmlyc3ROb2RlKCkge1xuICAgICAgICByZXR1cm4gX2ZpcnN0Tm9kZSh0aGlzKTtcbiAgICB9XG4gICAgbGFzdE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBfbGFzdE5vZGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbGwgbm9kZXMgYW5kIGVkZ2VzIGZyb20gYW5vdGhlciBncmFwaC5cbiAgICAgKiBOb3RlIHRoaXMgZG9lc24ndCBjaGVjayBmb3IgZHVwbGljYXRlcywgbm9yIGRvZXMgaXQgY29ubmVjdCB0aGUgZ3JhcGhzLlxuICAgICAqL1xuICAgIGV4dGVuZChncmFwaCwgcHJlZml4ID0gXCJcIikge1xuICAgICAgICBsZXQgZmluYWxQcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIGNvbnN0IG5vZGVJZHMgPSBPYmplY3QudmFsdWVzKGdyYXBoLm5vZGVzKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpO1xuICAgICAgICBpZiAobm9kZUlkcy5ldmVyeShpc1V1aWQpKSB7XG4gICAgICAgICAgICBmaW5hbFByZWZpeCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlZml4ZWQgPSAoaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbFByZWZpeCA/IGAke2ZpbmFsUHJlZml4fToke2lkfWAgOiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZ3JhcGgubm9kZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1twcmVmaXhlZChrZXkpXSA9IHsgLi4udmFsdWUsIGlkOiBwcmVmaXhlZChrZXkpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBuZXdFZGdlcyA9IGdyYXBoLmVkZ2VzLm1hcCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5lZGdlLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogcHJlZml4ZWQoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgICAgICAgIHRhcmdldDogcHJlZml4ZWQoZWRnZS50YXJnZXQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBhbGwgZWRnZXMgZnJvbSB0aGUgb3RoZXIgZ3JhcGhcbiAgICAgICAgdGhpcy5lZGdlcyA9IFsuLi50aGlzLmVkZ2VzLCAuLi5uZXdFZGdlc107XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gZ3JhcGguZmlyc3ROb2RlKCk7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBncmFwaC5sYXN0Tm9kZSgpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmlyc3QgPyB7IGlkOiBwcmVmaXhlZChmaXJzdC5pZCksIGRhdGE6IGZpcnN0LmRhdGEgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxhc3QgPyB7IGlkOiBwcmVmaXhlZChsYXN0LmlkKSwgZGF0YTogbGFzdC5kYXRhIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIF07XG4gICAgfVxuICAgIHRyaW1GaXJzdE5vZGUoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Tm9kZSA9IHRoaXMuZmlyc3ROb2RlKCk7XG4gICAgICAgIGlmIChmaXJzdE5vZGUgJiYgX2ZpcnN0Tm9kZSh0aGlzLCBbZmlyc3ROb2RlLmlkXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShmaXJzdE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyaW1MYXN0Tm9kZSgpIHtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSB0aGlzLmxhc3ROb2RlKCk7XG4gICAgICAgIGlmIChsYXN0Tm9kZSAmJiBfbGFzdE5vZGUodGhpcywgW2xhc3ROb2RlLmlkXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShsYXN0Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IGdyYXBoIHdpdGggYWxsIG5vZGVzIHJlLWlkZW50aWZpZWQsXG4gICAgICogdXNpbmcgdGhlaXIgdW5pcXVlLCByZWFkYWJsZSBuYW1lcyB3aGVyZSBwb3NzaWJsZS5cbiAgICAgKi9cbiAgICByZWlkKCkge1xuICAgICAgICBjb25zdCBub2RlTGFiZWxzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC52YWx1ZXModGhpcy5ub2RlcykubWFwKChub2RlKSA9PiBbbm9kZS5pZCwgbm9kZS5uYW1lXSkpO1xuICAgICAgICBjb25zdCBub2RlTGFiZWxDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIE9iamVjdC52YWx1ZXMobm9kZUxhYmVscykuZm9yRWFjaCgobGFiZWwpID0+IHtcbiAgICAgICAgICAgIG5vZGVMYWJlbENvdW50cy5zZXQobGFiZWwsIChub2RlTGFiZWxDb3VudHMuZ2V0KGxhYmVsKSB8fCAwKSArIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZ2V0Tm9kZUlkID0gKG5vZGVJZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBub2RlTGFiZWxzW25vZGVJZF07XG4gICAgICAgICAgICBpZiAoaXNVdWlkKG5vZGVJZCkgJiYgbm9kZUxhYmVsQ291bnRzLmdldChsYWJlbCkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEdyYXBoKHtcbiAgICAgICAgICAgIG5vZGVzOiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModGhpcy5ub2RlcykubWFwKChbaWQsIG5vZGVdKSA9PiBbXG4gICAgICAgICAgICAgICAgZ2V0Tm9kZUlkKGlkKSxcbiAgICAgICAgICAgICAgICB7IC4uLm5vZGUsIGlkOiBnZXROb2RlSWQoaWQpIH0sXG4gICAgICAgICAgICBdKSksXG4gICAgICAgICAgICBlZGdlczogdGhpcy5lZGdlcy5tYXAoKGVkZ2UpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uZWRnZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGdldE5vZGVJZChlZGdlLnNvdXJjZSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBnZXROb2RlSWQoZWRnZS50YXJnZXQpLFxuICAgICAgICAgICAgfSkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHJhd01lcm1haWQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgd2l0aFN0eWxlcywgY3VydmVTdHlsZSwgbm9kZUNvbG9ycyA9IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IFwiZmlsbDojZjJmMGZmLGxpbmUtaGVpZ2h0OjEuMlwiLFxuICAgICAgICAgICAgZmlyc3Q6IFwiZmlsbC1vcGFjaXR5OjBcIixcbiAgICAgICAgICAgIGxhc3Q6IFwiZmlsbDojYmZiNmZjXCIsXG4gICAgICAgIH0sIHdyYXBMYWJlbE5Xb3JkcywgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICAgICAgY29uc3QgZ3JhcGggPSB0aGlzLnJlaWQoKTtcbiAgICAgICAgY29uc3QgZmlyc3ROb2RlID0gZ3JhcGguZmlyc3ROb2RlKCk7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gZ3JhcGgubGFzdE5vZGUoKTtcbiAgICAgICAgcmV0dXJuIGRyYXdNZXJtYWlkKGdyYXBoLm5vZGVzLCBncmFwaC5lZGdlcywge1xuICAgICAgICAgICAgZmlyc3ROb2RlOiBmaXJzdE5vZGU/LmlkLFxuICAgICAgICAgICAgbGFzdE5vZGU6IGxhc3ROb2RlPy5pZCxcbiAgICAgICAgICAgIHdpdGhTdHlsZXMsXG4gICAgICAgICAgICBjdXJ2ZVN0eWxlLFxuICAgICAgICAgICAgbm9kZUNvbG9ycyxcbiAgICAgICAgICAgIHdyYXBMYWJlbE5Xb3JkcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRyYXdNZXJtYWlkUG5nKHBhcmFtcykge1xuICAgICAgICBjb25zdCBtZXJtYWlkU3ludGF4ID0gdGhpcy5kcmF3TWVybWFpZChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gZHJhd01lcm1haWRQbmcobWVybWFpZFN5bnRheCwge1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBwYXJhbXM/LmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBGaW5kIHRoZSBzaW5nbGUgbm9kZSB0aGF0IGlzIG5vdCBhIHRhcmdldCBvZiBhbnkgZWRnZS5cbiAqIEV4Y2x1ZGUgbm9kZXMvc291cmNlcyB3aXRoIGlkcyBpbiB0aGUgZXhjbHVkZSBsaXN0LlxuICogSWYgdGhlcmUgaXMgbm8gc3VjaCBub2RlLCBvciB0aGVyZSBhcmUgbXVsdGlwbGUsIHJldHVybiB1bmRlZmluZWQuXG4gKiBXaGVuIGRyYXdpbmcgdGhlIGdyYXBoLCB0aGlzIG5vZGUgd291bGQgYmUgdGhlIG9yaWdpbi5cbiAqL1xuZnVuY3Rpb24gX2ZpcnN0Tm9kZShncmFwaCwgZXhjbHVkZSA9IFtdKSB7XG4gICAgY29uc3QgdGFyZ2V0cyA9IG5ldyBTZXQoZ3JhcGguZWRnZXNcbiAgICAgICAgLmZpbHRlcigoZWRnZSkgPT4gIWV4Y2x1ZGUuaW5jbHVkZXMoZWRnZS5zb3VyY2UpKVxuICAgICAgICAubWFwKChlZGdlKSA9PiBlZGdlLnRhcmdldCkpO1xuICAgIGNvbnN0IGZvdW5kID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIE9iamVjdC52YWx1ZXMoZ3JhcGgubm9kZXMpKSB7XG4gICAgICAgIGlmICghZXhjbHVkZS5pbmNsdWRlcyhub2RlLmlkKSAmJiAhdGFyZ2V0cy5oYXMobm9kZS5pZCkpIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kLmxlbmd0aCA9PT0gMSA/IGZvdW5kWzBdIDogdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBGaW5kIHRoZSBzaW5nbGUgbm9kZSB0aGF0IGlzIG5vdCBhIHNvdXJjZSBvZiBhbnkgZWRnZS5cbiAqIEV4Y2x1ZGUgbm9kZXMvdGFyZ2V0cyB3aXRoIGlkcyBpbiB0aGUgZXhjbHVkZSBsaXN0LlxuICogSWYgdGhlcmUgaXMgbm8gc3VjaCBub2RlLCBvciB0aGVyZSBhcmUgbXVsdGlwbGUsIHJldHVybiB1bmRlZmluZWQuXG4gKiBXaGVuIGRyYXdpbmcgdGhlIGdyYXBoLCB0aGlzIG5vZGUgd291bGQgYmUgdGhlIGRlc3RpbmF0aW9uLlxuICovXG5mdW5jdGlvbiBfbGFzdE5vZGUoZ3JhcGgsIGV4Y2x1ZGUgPSBbXSkge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBuZXcgU2V0KGdyYXBoLmVkZ2VzXG4gICAgICAgIC5maWx0ZXIoKGVkZ2UpID0+ICFleGNsdWRlLmluY2x1ZGVzKGVkZ2UudGFyZ2V0KSlcbiAgICAgICAgLm1hcCgoZWRnZSkgPT4gZWRnZS5zb3VyY2UpKTtcbiAgICBjb25zdCBmb3VuZCA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBPYmplY3QudmFsdWVzKGdyYXBoLm5vZGVzKSkge1xuICAgICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXMobm9kZS5pZCkgJiYgIXNvdXJjZXMuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgICAgICBmb3VuZC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZC5sZW5ndGggPT09IDEgPyBmb3VuZFswXSA6IHVuZGVmaW5lZDtcbn1cbiIsICJpbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0h0dHBFdmVudFN0cmVhbShzdHJlYW0pIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZmluYWxTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShgZXZlbnQ6IGRhdGFcXG5kYXRhOiAke0pTT04uc3RyaW5naWZ5KGNodW5rKX1cXG5cXG5gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoXCJldmVudDogZW5kXFxuXFxuXCIpKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0oZmluYWxTdHJlYW0pO1xufVxuIiwgImltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgcGlja1J1bm5hYmxlQ29uZmlnS2V5cyB9IGZyb20gXCIuL2NvbmZpZy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzSXRlcmFibGVJdGVyYXRvcih0aGluZykge1xuICAgIHJldHVybiAodHlwZW9mIHRoaW5nID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHRoaW5nICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB0aGluZ1tTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgLy8gYXZvaWQgZGV0ZWN0aW5nIGFycmF5L3NldCBhcyBpdGVyYXRvclxuICAgICAgICB0eXBlb2YgdGhpbmcubmV4dCA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydCBjb25zdCBpc0l0ZXJhdG9yID0gKHgpID0+IHggIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmXG4gICAgXCJuZXh0XCIgaW4geCAmJlxuICAgIHR5cGVvZiB4Lm5leHQgPT09IFwiZnVuY3Rpb25cIjtcbmV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUodGhpbmcpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB0aGluZyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0aGluZyAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdGhpbmdbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PVxuICAgICAgICAgICAgXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiogY29uc3VtZUl0ZXJhdG9ySW5Db250ZXh0KGNvbnRleHQsIGl0ZXIpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcocGlja1J1bm5hYmxlQ29uZmlnS2V5cyhjb250ZXh0KSwgaXRlci5uZXh0LmJpbmQoaXRlciksIHRydWUpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogY29uc3VtZUFzeW5jSXRlcmFibGVJbkNvbnRleHQoY29udGV4dCwgaXRlcikge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gaXRlcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uLnJ1bldpdGhDb25maWcocGlja1J1bm5hYmxlQ29uZmlnS2V5cyhjb250ZXh0KSwgaXRlcmF0b3IubmV4dC5iaW5kKGl0ZXIpLCB0cnVlKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiLy8gQHRzLW5vY2hlY2tcbi8vIElubGluZWQgdG8gZGVhbCB3aXRoIHBvcnRhYmlsaXR5IGlzc3VlcyB3aXRoIGltcG9ydGluZyBjcnlwdG8gbW9kdWxlXG4vKlxuICogW2pzLXNoYTFde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhMX1cbiAqXG4gKiBAdmVyc2lvbiAwLjYuMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNC0yMDE3XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgPyB3aW5kb3cgOiB7fTtcbnZhciBIRVhfQ0hBUlMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIi5zcGxpdChcIlwiKTtcbnZhciBFWFRSQSA9IFstMjE0NzQ4MzY0OCwgODM4ODYwOCwgMzI3NjgsIDEyOF07XG52YXIgU0hJRlQgPSBbMjQsIDE2LCA4LCAwXTtcbnZhciBPVVRQVVRfVFlQRVMgPSBbXCJoZXhcIiwgXCJhcnJheVwiLCBcImRpZ2VzdFwiLCBcImFycmF5QnVmZmVyXCJdO1xudmFyIGJsb2NrcyA9IFtdO1xuZnVuY3Rpb24gU2hhMShzaGFyZWRNZW1vcnkpIHtcbiAgICBpZiAoc2hhcmVkTWVtb3J5KSB7XG4gICAgICAgIGJsb2Nrc1swXSA9XG4gICAgICAgICAgICBibG9ja3NbMTZdID1cbiAgICAgICAgICAgICAgICBibG9ja3NbMV0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzZdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbN10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzExXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIH1cbiAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMTtcbiAgICB0aGlzLmgxID0gMHhlZmNkYWI4OTtcbiAgICB0aGlzLmgyID0gMHg5OGJhZGNmZTtcbiAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NjtcbiAgICB0aGlzLmg0ID0gMHhjM2QyZTFmMDtcbiAgICB0aGlzLmJsb2NrID0gdGhpcy5zdGFydCA9IHRoaXMuYnl0ZXMgPSB0aGlzLmhCeXRlcyA9IDA7XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZmlyc3QgPSB0cnVlO1xufVxuU2hhMS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm90U3RyaW5nID0gdHlwZW9mIG1lc3NhZ2UgIT09IFwic3RyaW5nXCI7XG4gICAgaWYgKG5vdFN0cmluZyAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSByb290LkFycmF5QnVmZmVyKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICB9XG4gICAgdmFyIGNvZGUsIGluZGV4ID0gMCwgaSwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGggfHwgMCwgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG4gICAgICAgICAgICBibG9ja3NbMTZdID1cbiAgICAgICAgICAgICAgICBibG9ja3NbMV0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzZdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbN10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzldID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzExXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IGNvZGUgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAweDEwMDAwICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChtZXNzYWdlLmNoYXJDb2RlQXQoKytpbmRleCkgJiAweDNmZikpO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgICAgIHRoaXMuYnl0ZXMgKz0gaSAtIHRoaXMuc3RhcnQ7XG4gICAgICAgIGlmIChpID49IDY0KSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gNjQ7XG4gICAgICAgICAgICB0aGlzLmhhc2goKTtcbiAgICAgICAgICAgIHRoaXMuaGFzaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmJ5dGVzID4gNDI5NDk2NzI5NSkge1xuICAgICAgICB0aGlzLmhCeXRlcyArPSAodGhpcy5ieXRlcyAvIDQyOTQ5NjcyOTYpIDw8IDA7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSB0aGlzLmJ5dGVzICUgNDI5NDk2NzI5NjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuU2hhMS5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgaSA9IHRoaXMubGFzdEJ5dGVJbmRleDtcbiAgICBibG9ja3NbMTZdID0gdGhpcy5ibG9jaztcbiAgICBibG9ja3NbaSA+PiAyXSB8PSBFWFRSQVtpICYgM107XG4gICAgdGhpcy5ibG9jayA9IGJsb2Nrc1sxNl07XG4gICAgaWYgKGkgPj0gNTYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgYmxvY2tzWzE2XSA9XG4gICAgICAgICAgICBibG9ja3NbMV0gPVxuICAgICAgICAgICAgICAgIGJsb2Nrc1syXSA9XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1szXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s2XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbN10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTBdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTFdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEyXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTNdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbMTRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgIH1cbiAgICBibG9ja3NbMTRdID0gKHRoaXMuaEJ5dGVzIDw8IDMpIHwgKHRoaXMuYnl0ZXMgPj4+IDI5KTtcbiAgICBibG9ja3NbMTVdID0gdGhpcy5ieXRlcyA8PCAzO1xuICAgIHRoaXMuaGFzaCgpO1xufTtcblNoYTEucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmgwLCBiID0gdGhpcy5oMSwgYyA9IHRoaXMuaDIsIGQgPSB0aGlzLmgzLCBlID0gdGhpcy5oNDtcbiAgICB2YXIgZiwgaiwgdCwgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG4gICAgZm9yIChqID0gMTY7IGogPCA4MDsgKytqKSB7XG4gICAgICAgIHQgPSBibG9ja3NbaiAtIDNdIF4gYmxvY2tzW2ogLSA4XSBeIGJsb2Nrc1tqIC0gMTRdIF4gYmxvY2tzW2ogLSAxNl07XG4gICAgICAgIGJsb2Nrc1tqXSA9ICh0IDw8IDEpIHwgKHQgPj4+IDMxKTtcbiAgICB9XG4gICAgZm9yIChqID0gMDsgaiA8IDIwOyBqICs9IDUpIHtcbiAgICAgICAgZiA9IChiICYgYykgfCAofmIgJiBkKTtcbiAgICAgICAgdCA9IChhIDw8IDUpIHwgKGEgPj4+IDI3KTtcbiAgICAgICAgZSA9ICh0ICsgZiArIGUgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2pdKSA8PCAwO1xuICAgICAgICBiID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuICAgICAgICBmID0gKGEgJiBiKSB8ICh+YSAmIGMpO1xuICAgICAgICB0ID0gKGUgPDwgNSkgfCAoZSA+Pj4gMjcpO1xuICAgICAgICBkID0gKHQgKyBmICsgZCArIDE1MTg1MDAyNDkgKyBibG9ja3NbaiArIDFdKSA8PCAwO1xuICAgICAgICBhID0gKGEgPDwgMzApIHwgKGEgPj4+IDIpO1xuICAgICAgICBmID0gKGUgJiBhKSB8ICh+ZSAmIGIpO1xuICAgICAgICB0ID0gKGQgPDwgNSkgfCAoZCA+Pj4gMjcpO1xuICAgICAgICBjID0gKHQgKyBmICsgYyArIDE1MTg1MDAyNDkgKyBibG9ja3NbaiArIDJdKSA8PCAwO1xuICAgICAgICBlID0gKGUgPDwgMzApIHwgKGUgPj4+IDIpO1xuICAgICAgICBmID0gKGQgJiBlKSB8ICh+ZCAmIGEpO1xuICAgICAgICB0ID0gKGMgPDwgNSkgfCAoYyA+Pj4gMjcpO1xuICAgICAgICBiID0gKHQgKyBmICsgYiArIDE1MTg1MDAyNDkgKyBibG9ja3NbaiArIDNdKSA8PCAwO1xuICAgICAgICBkID0gKGQgPDwgMzApIHwgKGQgPj4+IDIpO1xuICAgICAgICBmID0gKGMgJiBkKSB8ICh+YyAmIGUpO1xuICAgICAgICB0ID0gKGIgPDwgNSkgfCAoYiA+Pj4gMjcpO1xuICAgICAgICBhID0gKHQgKyBmICsgYSArIDE1MTg1MDAyNDkgKyBibG9ja3NbaiArIDRdKSA8PCAwO1xuICAgICAgICBjID0gKGMgPDwgMzApIHwgKGMgPj4+IDIpO1xuICAgIH1cbiAgICBmb3IgKDsgaiA8IDQwOyBqICs9IDUpIHtcbiAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgdCA9IChhIDw8IDUpIHwgKGEgPj4+IDI3KTtcbiAgICAgICAgZSA9ICh0ICsgZiArIGUgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2pdKSA8PCAwO1xuICAgICAgICBiID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuICAgICAgICBmID0gYSBeIGIgXiBjO1xuICAgICAgICB0ID0gKGUgPDwgNSkgfCAoZSA+Pj4gMjcpO1xuICAgICAgICBkID0gKHQgKyBmICsgZCArIDE4NTk3NzUzOTMgKyBibG9ja3NbaiArIDFdKSA8PCAwO1xuICAgICAgICBhID0gKGEgPDwgMzApIHwgKGEgPj4+IDIpO1xuICAgICAgICBmID0gZSBeIGEgXiBiO1xuICAgICAgICB0ID0gKGQgPDwgNSkgfCAoZCA+Pj4gMjcpO1xuICAgICAgICBjID0gKHQgKyBmICsgYyArIDE4NTk3NzUzOTMgKyBibG9ja3NbaiArIDJdKSA8PCAwO1xuICAgICAgICBlID0gKGUgPDwgMzApIHwgKGUgPj4+IDIpO1xuICAgICAgICBmID0gZCBeIGUgXiBhO1xuICAgICAgICB0ID0gKGMgPDwgNSkgfCAoYyA+Pj4gMjcpO1xuICAgICAgICBiID0gKHQgKyBmICsgYiArIDE4NTk3NzUzOTMgKyBibG9ja3NbaiArIDNdKSA8PCAwO1xuICAgICAgICBkID0gKGQgPDwgMzApIHwgKGQgPj4+IDIpO1xuICAgICAgICBmID0gYyBeIGQgXiBlO1xuICAgICAgICB0ID0gKGIgPDwgNSkgfCAoYiA+Pj4gMjcpO1xuICAgICAgICBhID0gKHQgKyBmICsgYSArIDE4NTk3NzUzOTMgKyBibG9ja3NbaiArIDRdKSA8PCAwO1xuICAgICAgICBjID0gKGMgPDwgMzApIHwgKGMgPj4+IDIpO1xuICAgIH1cbiAgICBmb3IgKDsgaiA8IDYwOyBqICs9IDUpIHtcbiAgICAgICAgZiA9IChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcbiAgICAgICAgdCA9IChhIDw8IDUpIHwgKGEgPj4+IDI3KTtcbiAgICAgICAgZSA9ICh0ICsgZiArIGUgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2pdKSA8PCAwO1xuICAgICAgICBiID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuICAgICAgICBmID0gKGEgJiBiKSB8IChhICYgYykgfCAoYiAmIGMpO1xuICAgICAgICB0ID0gKGUgPDwgNSkgfCAoZSA+Pj4gMjcpO1xuICAgICAgICBkID0gKHQgKyBmICsgZCAtIDE4OTQwMDc1ODggKyBibG9ja3NbaiArIDFdKSA8PCAwO1xuICAgICAgICBhID0gKGEgPDwgMzApIHwgKGEgPj4+IDIpO1xuICAgICAgICBmID0gKGUgJiBhKSB8IChlICYgYikgfCAoYSAmIGIpO1xuICAgICAgICB0ID0gKGQgPDwgNSkgfCAoZCA+Pj4gMjcpO1xuICAgICAgICBjID0gKHQgKyBmICsgYyAtIDE4OTQwMDc1ODggKyBibG9ja3NbaiArIDJdKSA8PCAwO1xuICAgICAgICBlID0gKGUgPDwgMzApIHwgKGUgPj4+IDIpO1xuICAgICAgICBmID0gKGQgJiBlKSB8IChkICYgYSkgfCAoZSAmIGEpO1xuICAgICAgICB0ID0gKGMgPDwgNSkgfCAoYyA+Pj4gMjcpO1xuICAgICAgICBiID0gKHQgKyBmICsgYiAtIDE4OTQwMDc1ODggKyBibG9ja3NbaiArIDNdKSA8PCAwO1xuICAgICAgICBkID0gKGQgPDwgMzApIHwgKGQgPj4+IDIpO1xuICAgICAgICBmID0gKGMgJiBkKSB8IChjICYgZSkgfCAoZCAmIGUpO1xuICAgICAgICB0ID0gKGIgPDwgNSkgfCAoYiA+Pj4gMjcpO1xuICAgICAgICBhID0gKHQgKyBmICsgYSAtIDE4OTQwMDc1ODggKyBibG9ja3NbaiArIDRdKSA8PCAwO1xuICAgICAgICBjID0gKGMgPDwgMzApIHwgKGMgPj4+IDIpO1xuICAgIH1cbiAgICBmb3IgKDsgaiA8IDgwOyBqICs9IDUpIHtcbiAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgdCA9IChhIDw8IDUpIHwgKGEgPj4+IDI3KTtcbiAgICAgICAgZSA9ICh0ICsgZiArIGUgLSA4OTk0OTc1MTQgKyBibG9ja3Nbal0pIDw8IDA7XG4gICAgICAgIGIgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG4gICAgICAgIGYgPSBhIF4gYiBeIGM7XG4gICAgICAgIHQgPSAoZSA8PCA1KSB8IChlID4+PiAyNyk7XG4gICAgICAgIGQgPSAodCArIGYgKyBkIC0gODk5NDk3NTE0ICsgYmxvY2tzW2ogKyAxXSkgPDwgMDtcbiAgICAgICAgYSA9IChhIDw8IDMwKSB8IChhID4+PiAyKTtcbiAgICAgICAgZiA9IGUgXiBhIF4gYjtcbiAgICAgICAgdCA9IChkIDw8IDUpIHwgKGQgPj4+IDI3KTtcbiAgICAgICAgYyA9ICh0ICsgZiArIGMgLSA4OTk0OTc1MTQgKyBibG9ja3NbaiArIDJdKSA8PCAwO1xuICAgICAgICBlID0gKGUgPDwgMzApIHwgKGUgPj4+IDIpO1xuICAgICAgICBmID0gZCBeIGUgXiBhO1xuICAgICAgICB0ID0gKGMgPDwgNSkgfCAoYyA+Pj4gMjcpO1xuICAgICAgICBiID0gKHQgKyBmICsgYiAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgM10pIDw8IDA7XG4gICAgICAgIGQgPSAoZCA8PCAzMCkgfCAoZCA+Pj4gMik7XG4gICAgICAgIGYgPSBjIF4gZCBeIGU7XG4gICAgICAgIHQgPSAoYiA8PCA1KSB8IChiID4+PiAyNyk7XG4gICAgICAgIGEgPSAodCArIGYgKyBhIC0gODk5NDk3NTE0ICsgYmxvY2tzW2ogKyA0XSkgPDwgMDtcbiAgICAgICAgYyA9IChjIDw8IDMwKSB8IChjID4+PiAyKTtcbiAgICB9XG4gICAgdGhpcy5oMCA9ICh0aGlzLmgwICsgYSkgPDwgMDtcbiAgICB0aGlzLmgxID0gKHRoaXMuaDEgKyBiKSA8PCAwO1xuICAgIHRoaXMuaDIgPSAodGhpcy5oMiArIGMpIDw8IDA7XG4gICAgdGhpcy5oMyA9ICh0aGlzLmgzICsgZCkgPDwgMDtcbiAgICB0aGlzLmg0ID0gKHRoaXMuaDQgKyBlKSA8PCAwO1xufTtcblNoYTEucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0O1xuICAgIHJldHVybiAoSEVYX0NIQVJTWyhoMCA+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDAgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gxICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMiAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDMgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2g0ICYgMHgwZl0pO1xufTtcblNoYTEucHJvdG90eXBlLnRvU3RyaW5nID0gU2hhMS5wcm90b3R5cGUuaGV4O1xuU2hhMS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICB2YXIgaDAgPSB0aGlzLmgwLCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMiwgaDMgPSB0aGlzLmgzLCBoNCA9IHRoaXMuaDQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgKGgwID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMCA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDAgPj4gOCkgJiAweGZmLFxuICAgICAgICBoMCAmIDB4ZmYsXG4gICAgICAgIChoMSA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDEgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgxID4+IDgpICYgMHhmZixcbiAgICAgICAgaDEgJiAweGZmLFxuICAgICAgICAoaDIgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgyID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMiA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgyICYgMHhmZixcbiAgICAgICAgKGgzID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMyA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDMgPj4gOCkgJiAweGZmLFxuICAgICAgICBoMyAmIDB4ZmYsXG4gICAgICAgIChoNCA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDQgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGg0ID4+IDgpICYgMHhmZixcbiAgICAgICAgaDQgJiAweGZmLFxuICAgIF07XG59O1xuU2hhMS5wcm90b3R5cGUuYXJyYXkgPSBTaGExLnByb3RvdHlwZS5kaWdlc3Q7XG5TaGExLnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigyMCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDAsIHRoaXMuaDApO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig0LCB0aGlzLmgxKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoOCwgdGhpcy5oMik7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDEyLCB0aGlzLmgzKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTYsIHRoaXMuaDQpO1xuICAgIHJldHVybiBidWZmZXI7XG59O1xuZXhwb3J0IGNvbnN0IGluc2VjdXJlSGFzaCA9IChtZXNzYWdlKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBTaGExKHRydWUpLnVwZGF0ZShtZXNzYWdlKVtcImhleFwiXSgpO1xufTtcbiIsICJpbXBvcnQgeyBpbnNlY3VyZUhhc2ggfSBmcm9tIFwiLi4vdXRpbHMvaGFzaC5qc1wiO1xuaW1wb3J0IHsgbWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UgfSBmcm9tIFwiLi4vbWVzc2FnZXMvdXRpbHMuanNcIjtcbi8qKlxuICogVGhpcyBjYWNoZSBrZXkgc2hvdWxkIGJlIGNvbnNpc3RlbnQgYWNyb3NzIGFsbCB2ZXJzaW9ucyBvZiBMYW5nQ2hhaW4uXG4gKiBJdCBpcyBjdXJyZW50bHkgTk9UIGNvbnNpc3RlbnQgYWNyb3NzIHZlcnNpb25zIG9mIExhbmdDaGFpbi5cbiAqXG4gKiBBIGh1Z2UgYmVuZWZpdCBvZiBoYXZpbmcgYSByZW1vdGUgY2FjaGUgKGxpa2UgcmVkaXMpIGlzIHRoYXQgeW91IGNhblxuICogYWNjZXNzIHRoZSBjYWNoZSBmcm9tIGRpZmZlcmVudCBwcm9jZXNzZXMvbWFjaGluZXMuIFRoZSBhbGxvd3MgeW91IHRvXG4gKiBzZXBhcmF0ZSBjb25jZXJucyBhbmQgc2NhbGUgaG9yaXpvbnRhbGx5LlxuICpcbiAqIFRPRE86IE1ha2UgY2FjaGUga2V5IGNvbnNpc3RlbnQgYWNyb3NzIHZlcnNpb25zIG9mIExhbmdDaGFpbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldENhY2hlS2V5ID0gKC4uLnN0cmluZ3MpID0+IGluc2VjdXJlSGFzaChzdHJpbmdzLmpvaW4oXCJfXCIpKTtcbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZVN0b3JlZEdlbmVyYXRpb24oc3RvcmVkR2VuZXJhdGlvbikge1xuICAgIGlmIChzdG9yZWRHZW5lcmF0aW9uLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogc3RvcmVkR2VuZXJhdGlvbi50ZXh0LFxuICAgICAgICAgICAgbWVzc2FnZTogbWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2Uoc3RvcmVkR2VuZXJhdGlvbi5tZXNzYWdlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IHN0b3JlZEdlbmVyYXRpb24udGV4dCB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVHZW5lcmF0aW9uKGdlbmVyYXRpb24pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVmFsdWUgPSB7XG4gICAgICAgIHRleHQ6IGdlbmVyYXRpb24udGV4dCxcbiAgICB9O1xuICAgIGlmIChnZW5lcmF0aW9uLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJpYWxpemVkVmFsdWUubWVzc2FnZSA9IGdlbmVyYXRpb24ubWVzc2FnZS50b0RpY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRWYWx1ZTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGNhY2hlcy4gQWxsIGNhY2hlcyBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlQ2FjaGUge1xufVxuY29uc3QgR0xPQkFMX01BUCA9IG5ldyBNYXAoKTtcbi8qKlxuICogQSBjYWNoZSBmb3Igc3RvcmluZyBMTE0gZ2VuZXJhdGlvbnMgdGhhdCBzdG9yZXMgZGF0YSBpbiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbk1lbW9yeUNhY2hlIGV4dGVuZHMgQmFzZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FjaGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG1hcCA/PyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkYXRhIGZyb20gdGhlIGNhY2hlIHVzaW5nIGEgcHJvbXB0IGFuZCBhbiBMTE0ga2V5LiBJZiB0aGVcbiAgICAgKiBkYXRhIGlzIG5vdCBmb3VuZCwgaXQgcmV0dXJucyBudWxsLlxuICAgICAqIEBwYXJhbSBwcm9tcHQgVGhlIHByb21wdCB1c2VkIHRvIGZpbmQgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIGxsbUtleSBUaGUgTExNIGtleSB1c2VkIHRvIGZpbmQgdGhlIGRhdGEuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvbXB0IGFuZCBMTE0ga2V5LCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsb29rdXAocHJvbXB0LCBsbG1LZXkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNhY2hlLmdldChnZXRDYWNoZUtleShwcm9tcHQsIGxsbUtleSkpID8/IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjYWNoZSB3aXRoIG5ldyBkYXRhIHVzaW5nIGEgcHJvbXB0IGFuZCBhbiBMTE0ga2V5LlxuICAgICAqIEBwYXJhbSBwcm9tcHQgVGhlIHByb21wdCB1c2VkIHRvIHN0b3JlIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSBsbG1LZXkgVGhlIExMTSBrZXkgdXNlZCB0byBzdG9yZSB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGRhdGEgdG8gYmUgc3RvcmVkLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShwcm9tcHQsIGxsbUtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoZ2V0Q2FjaGVLZXkocHJvbXB0LCBsbG1LZXkpLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBnbG9iYWwgaW5zdGFuY2Ugb2YgSW5NZW1vcnlDYWNoZSB1c2luZyBhIHByZWRlZmluZWQgZ2xvYmFsXG4gICAgICogbWFwIGFzIHRoZSBpbml0aWFsIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIEEgZ2xvYmFsIGluc3RhbmNlIG9mIEluTWVtb3J5Q2FjaGUuXG4gICAgICovXG4gICAgc3RhdGljIGdsb2JhbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbk1lbW9yeUNhY2hlKEdMT0JBTF9NQVApO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBTZXJpYWxpemFibGUgfSBmcm9tIFwiLi9sb2FkL3NlcmlhbGl6YWJsZS5qc1wiO1xuaW1wb3J0IHsgSHVtYW5NZXNzYWdlIH0gZnJvbSBcIi4vbWVzc2FnZXMvaHVtYW4uanNcIjtcbmltcG9ydCB7IGdldEJ1ZmZlclN0cmluZyB9IGZyb20gXCIuL21lc3NhZ2VzL3V0aWxzLmpzXCI7XG4vKipcbiAqIEJhc2UgUHJvbXB0VmFsdWUgY2xhc3MuIEFsbCBwcm9tcHQgdmFsdWVzIHNob3VsZCBleHRlbmQgdGhpcyBjbGFzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VQcm9tcHRWYWx1ZSBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwcm9tcHQgdmFsdWUgYXMgYSBzdHJpbmcuIEl0IGV4dGVuZHMgdGhlIEJhc2VQcm9tcHRWYWx1ZVxuICogY2xhc3MgYW5kIG92ZXJyaWRlcyB0aGUgdG9TdHJpbmcgYW5kIHRvQ2hhdE1lc3NhZ2VzIG1ldGhvZHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpbmdQcm9tcHRWYWx1ZSBleHRlbmRzIEJhc2VQcm9tcHRWYWx1ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN0cmluZ1Byb21wdFZhbHVlXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKHsgdmFsdWUgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJwcm9tcHRfdmFsdWVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0NoYXRNZXNzYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgSHVtYW5NZXNzYWdlKHRoaXMudmFsdWUpXTtcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhIGNoYXQgcHJvbXB0IHZhbHVlLiBJdCBleHRlbmRzIHRoZVxuICogQmFzZVByb21wdFZhbHVlIGFuZCBpbmNsdWRlcyBhbiBhcnJheSBvZiBCYXNlTWVzc2FnZSBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGF0UHJvbXB0VmFsdWUgZXh0ZW5kcyBCYXNlUHJvbXB0VmFsdWUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJDaGF0UHJvbXB0VmFsdWVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBtZXNzYWdlczogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdF92YWx1ZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IGZpZWxkcy5tZXNzYWdlcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBnZXRCdWZmZXJTdHJpbmcodGhpcy5tZXNzYWdlcyk7XG4gICAgfVxuICAgIHRvQ2hhdE1lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcztcbiAgICB9XG59XG4vKipcbiAqIENsYXNzIHRoYXQgcmVwcmVzZW50cyBhbiBpbWFnZSBwcm9tcHQgdmFsdWUuIEl0IGV4dGVuZHMgdGhlXG4gKiBCYXNlUHJvbXB0VmFsdWUgYW5kIGluY2x1ZGVzIGFuIEltYWdlVVJMIGluc3RhbmNlLlxuICovXG5leHBvcnQgY2xhc3MgSW1hZ2VQcm9tcHRWYWx1ZSBleHRlbmRzIEJhc2VQcm9tcHRWYWx1ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkltYWdlUHJvbXB0VmFsdWVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmICghKFwiaW1hZ2VVcmxcIiBpbiBmaWVsZHMpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgaW1hZ2VVcmw6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJwcm9tcHRfdmFsdWVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImltYWdlVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW1hZ2VVcmwgPSBmaWVsZHMuaW1hZ2VVcmw7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZVVybC51cmw7XG4gICAgfVxuICAgIHRvQ2hhdE1lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IEh1bWFuTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VfdXJsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB0aGlzLmltYWdlVXJsLmRldGFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMuaW1hZ2VVcmwudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfVxufVxuIiwgImltcG9ydCBiYXNlNjQgZnJvbSAnYmFzZTY0LWpzJztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIG5ldmVyKF8pIHtcbn1cbmZ1bmN0aW9uIGJ5dGVQYWlyTWVyZ2UocGllY2UsIHJhbmtzKSB7XG4gIGxldCBwYXJ0cyA9IEFycmF5LmZyb20oXG4gICAgeyBsZW5ndGg6IHBpZWNlLmxlbmd0aCB9LFxuICAgIChfLCBpKSA9PiAoeyBzdGFydDogaSwgZW5kOiBpICsgMSB9KVxuICApO1xuICB3aGlsZSAocGFydHMubGVuZ3RoID4gMSkge1xuICAgIGxldCBtaW5SYW5rID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgY29uc3Qgc2xpY2UgPSBwaWVjZS5zbGljZShwYXJ0c1tpXS5zdGFydCwgcGFydHNbaSArIDFdLmVuZCk7XG4gICAgICBjb25zdCByYW5rID0gcmFua3MuZ2V0KHNsaWNlLmpvaW4oXCIsXCIpKTtcbiAgICAgIGlmIChyYW5rID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKG1pblJhbmsgPT0gbnVsbCB8fCByYW5rIDwgbWluUmFua1swXSkge1xuICAgICAgICBtaW5SYW5rID0gW3JhbmssIGldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluUmFuayAhPSBudWxsKSB7XG4gICAgICBjb25zdCBpID0gbWluUmFua1sxXTtcbiAgICAgIHBhcnRzW2ldID0geyBzdGFydDogcGFydHNbaV0uc3RhcnQsIGVuZDogcGFydHNbaSArIDFdLmVuZCB9O1xuICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIGJ5dGVQYWlyRW5jb2RlKHBpZWNlLCByYW5rcykge1xuICBpZiAocGllY2UubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiBbcmFua3MuZ2V0KHBpZWNlLmpvaW4oXCIsXCIpKV07XG4gIHJldHVybiBieXRlUGFpck1lcmdlKHBpZWNlLCByYW5rcykubWFwKChwKSA9PiByYW5rcy5nZXQocGllY2Uuc2xpY2UocC5zdGFydCwgcC5lbmQpLmpvaW4oXCIsXCIpKSkuZmlsdGVyKCh4KSA9PiB4ICE9IG51bGwpO1xufVxuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csIFwiXFxcXCQmXCIpO1xufVxudmFyIF9UaWt0b2tlbiA9IGNsYXNzIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzcGVjaWFsVG9rZW5zO1xuICAvKiogQGludGVybmFsICovXG4gIGludmVyc2VTcGVjaWFsVG9rZW5zO1xuICAvKiogQGludGVybmFsICovXG4gIHBhdFN0cjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAvKiogQGludGVybmFsICovXG4gIHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmFua01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdGV4dE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKHJhbmtzLCBleHRlbmRlZFNwZWNpYWxUb2tlbnMpIHtcbiAgICB0aGlzLnBhdFN0ciA9IHJhbmtzLnBhdF9zdHI7XG4gICAgY29uc3QgdW5jb21wcmVzc2VkID0gcmFua3MuYnBlX3JhbmtzLnNwbGl0KFwiXFxuXCIpLmZpbHRlcihCb29sZWFuKS5yZWR1Y2UoKG1lbW8sIHgpID0+IHtcbiAgICAgIGNvbnN0IFtfLCBvZmZzZXRTdHIsIC4uLnRva2Vuc10gPSB4LnNwbGl0KFwiIFwiKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IE51bWJlci5wYXJzZUludChvZmZzZXRTdHIsIDEwKTtcbiAgICAgIHRva2Vucy5mb3JFYWNoKCh0b2tlbiwgaSkgPT4gbWVtb1t0b2tlbl0gPSBvZmZzZXQgKyBpKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KTtcbiAgICBmb3IgKGNvbnN0IFt0b2tlbiwgcmFua10gb2YgT2JqZWN0LmVudHJpZXModW5jb21wcmVzc2VkKSkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBiYXNlNjQudG9CeXRlQXJyYXkodG9rZW4pO1xuICAgICAgdGhpcy5yYW5rTWFwLnNldChieXRlcy5qb2luKFwiLFwiKSwgcmFuayk7XG4gICAgICB0aGlzLnRleHRNYXAuc2V0KHJhbmssIGJ5dGVzKTtcbiAgICB9XG4gICAgdGhpcy5zcGVjaWFsVG9rZW5zID0geyAuLi5yYW5rcy5zcGVjaWFsX3Rva2VucywgLi4uZXh0ZW5kZWRTcGVjaWFsVG9rZW5zIH07XG4gICAgdGhpcy5pbnZlcnNlU3BlY2lhbFRva2VucyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuc3BlY2lhbFRva2VucykucmVkdWNlKChtZW1vLCBbdGV4dCwgcmFua10pID0+IHtcbiAgICAgIG1lbW9bcmFua10gPSB0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh0ZXh0KTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KTtcbiAgfVxuICBlbmNvZGUodGV4dCwgYWxsb3dlZFNwZWNpYWwgPSBbXSwgZGlzYWxsb3dlZFNwZWNpYWwgPSBcImFsbFwiKSB7XG4gICAgY29uc3QgcmVnZXhlcyA9IG5ldyBSZWdFeHAodGhpcy5wYXRTdHIsIFwidWdcIik7XG4gICAgY29uc3Qgc3BlY2lhbFJlZ2V4ID0gX1Rpa3Rva2VuLnNwZWNpYWxUb2tlblJlZ2V4KFxuICAgICAgT2JqZWN0LmtleXModGhpcy5zcGVjaWFsVG9rZW5zKVxuICAgICk7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgY29uc3QgYWxsb3dlZFNwZWNpYWxTZXQgPSBuZXcgU2V0KFxuICAgICAgYWxsb3dlZFNwZWNpYWwgPT09IFwiYWxsXCIgPyBPYmplY3Qua2V5cyh0aGlzLnNwZWNpYWxUb2tlbnMpIDogYWxsb3dlZFNwZWNpYWxcbiAgICApO1xuICAgIGNvbnN0IGRpc2FsbG93ZWRTcGVjaWFsU2V0ID0gbmV3IFNldChcbiAgICAgIGRpc2FsbG93ZWRTcGVjaWFsID09PSBcImFsbFwiID8gT2JqZWN0LmtleXModGhpcy5zcGVjaWFsVG9rZW5zKS5maWx0ZXIoXG4gICAgICAgICh4KSA9PiAhYWxsb3dlZFNwZWNpYWxTZXQuaGFzKHgpXG4gICAgICApIDogZGlzYWxsb3dlZFNwZWNpYWxcbiAgICApO1xuICAgIGlmIChkaXNhbGxvd2VkU3BlY2lhbFNldC5zaXplID4gMCkge1xuICAgICAgY29uc3QgZGlzYWxsb3dlZFNwZWNpYWxSZWdleCA9IF9UaWt0b2tlbi5zcGVjaWFsVG9rZW5SZWdleChbXG4gICAgICAgIC4uLmRpc2FsbG93ZWRTcGVjaWFsU2V0XG4gICAgICBdKTtcbiAgICAgIGNvbnN0IHNwZWNpYWxNYXRjaCA9IHRleHQubWF0Y2goZGlzYWxsb3dlZFNwZWNpYWxSZWdleCk7XG4gICAgICBpZiAoc3BlY2lhbE1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUaGUgdGV4dCBjb250YWlucyBhIHNwZWNpYWwgdG9rZW4gdGhhdCBpcyBub3QgYWxsb3dlZDogJHtzcGVjaWFsTWF0Y2hbMF19YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgbmV4dFNwZWNpYWwgPSBudWxsO1xuICAgICAgbGV0IHN0YXJ0RmluZCA9IHN0YXJ0O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3BlY2lhbFJlZ2V4Lmxhc3RJbmRleCA9IHN0YXJ0RmluZDtcbiAgICAgICAgbmV4dFNwZWNpYWwgPSBzcGVjaWFsUmVnZXguZXhlYyh0ZXh0KTtcbiAgICAgICAgaWYgKG5leHRTcGVjaWFsID09IG51bGwgfHwgYWxsb3dlZFNwZWNpYWxTZXQuaGFzKG5leHRTcGVjaWFsWzBdKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgc3RhcnRGaW5kID0gbmV4dFNwZWNpYWwuaW5kZXggKyAxO1xuICAgICAgfVxuICAgICAgY29uc3QgZW5kID0gbmV4dFNwZWNpYWw/LmluZGV4ID8/IHRleHQubGVuZ3RoO1xuICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiB0ZXh0LnN1YnN0cmluZyhzdGFydCwgZW5kKS5tYXRjaEFsbChyZWdleGVzKSkge1xuICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKG1hdGNoWzBdKTtcbiAgICAgICAgY29uc3QgdG9rZW4yID0gdGhpcy5yYW5rTWFwLmdldChwaWVjZS5qb2luKFwiLFwiKSk7XG4gICAgICAgIGlmICh0b2tlbjIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldC5wdXNoKHRva2VuMik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0LnB1c2goLi4uYnl0ZVBhaXJFbmNvZGUocGllY2UsIHRoaXMucmFua01hcCkpO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRTcGVjaWFsID09IG51bGwpXG4gICAgICAgIGJyZWFrO1xuICAgICAgbGV0IHRva2VuID0gdGhpcy5zcGVjaWFsVG9rZW5zW25leHRTcGVjaWFsWzBdXTtcbiAgICAgIHJldC5wdXNoKHRva2VuKTtcbiAgICAgIHN0YXJ0ID0gbmV4dFNwZWNpYWwuaW5kZXggKyBuZXh0U3BlY2lhbFswXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZGVjb2RlKHRva2Vucykge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0b2tlbnMubGVuZ3RoOyArK2kyKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICBjb25zdCBieXRlcyA9IHRoaXMudGV4dE1hcC5nZXQodG9rZW4pID8/IHRoaXMuaW52ZXJzZVNwZWNpYWxUb2tlbnNbdG9rZW5dO1xuICAgICAgaWYgKGJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgcmVzLnB1c2goYnl0ZXMpO1xuICAgICAgICBsZW5ndGggKz0gYnl0ZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXJnZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgYnl0ZXMgb2YgcmVzKSB7XG4gICAgICBtZXJnZWRBcnJheS5zZXQoYnl0ZXMsIGkpO1xuICAgICAgaSArPSBieXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRleHREZWNvZGVyLmRlY29kZShtZXJnZWRBcnJheSk7XG4gIH1cbn07XG52YXIgVGlrdG9rZW4gPSBfVGlrdG9rZW47XG5fX3B1YmxpY0ZpZWxkKFRpa3Rva2VuLCBcInNwZWNpYWxUb2tlblJlZ2V4XCIsICh0b2tlbnMpID0+IHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAodG9rZW5zLm1hcCgoaSkgPT4gZXNjYXBlUmVnZXgoaSkpLmpvaW4oXCJ8XCIpLCBcImdcIik7XG59KTtcbmZ1bmN0aW9uIGdldEVuY29kaW5nTmFtZUZvck1vZGVsKG1vZGVsKSB7XG4gIHN3aXRjaCAobW9kZWwpIHtcbiAgICBjYXNlIFwiZ3B0MlwiOiB7XG4gICAgICByZXR1cm4gXCJncHQyXCI7XG4gICAgfVxuICAgIGNhc2UgXCJjb2RlLWN1c2htYW4tMDAxXCI6XG4gICAgY2FzZSBcImNvZGUtY3VzaG1hbi0wMDJcIjpcbiAgICBjYXNlIFwiY29kZS1kYXZpbmNpLTAwMVwiOlxuICAgIGNhc2UgXCJjb2RlLWRhdmluY2ktMDAyXCI6XG4gICAgY2FzZSBcImN1c2htYW4tY29kZXhcIjpcbiAgICBjYXNlIFwiZGF2aW5jaS1jb2RleFwiOlxuICAgIGNhc2UgXCJkYXZpbmNpLTAwMlwiOlxuICAgIGNhc2UgXCJ0ZXh0LWRhdmluY2ktMDAyXCI6XG4gICAgY2FzZSBcInRleHQtZGF2aW5jaS0wMDNcIjoge1xuICAgICAgcmV0dXJuIFwicDUwa19iYXNlXCI7XG4gICAgfVxuICAgIGNhc2UgXCJjb2RlLWRhdmluY2ktZWRpdC0wMDFcIjpcbiAgICBjYXNlIFwidGV4dC1kYXZpbmNpLWVkaXQtMDAxXCI6IHtcbiAgICAgIHJldHVybiBcInA1MGtfZWRpdFwiO1xuICAgIH1cbiAgICBjYXNlIFwiYWRhXCI6XG4gICAgY2FzZSBcImJhYmJhZ2VcIjpcbiAgICBjYXNlIFwiYmFiYmFnZS0wMDJcIjpcbiAgICBjYXNlIFwiY29kZS1zZWFyY2gtYWRhLWNvZGUtMDAxXCI6XG4gICAgY2FzZSBcImNvZGUtc2VhcmNoLWJhYmJhZ2UtY29kZS0wMDFcIjpcbiAgICBjYXNlIFwiY3VyaWVcIjpcbiAgICBjYXNlIFwiZGF2aW5jaVwiOlxuICAgIGNhc2UgXCJ0ZXh0LWFkYS0wMDFcIjpcbiAgICBjYXNlIFwidGV4dC1iYWJiYWdlLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LWN1cmllLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LWRhdmluY2ktMDAxXCI6XG4gICAgY2FzZSBcInRleHQtc2VhcmNoLWFkYS1kb2MtMDAxXCI6XG4gICAgY2FzZSBcInRleHQtc2VhcmNoLWJhYmJhZ2UtZG9jLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LXNlYXJjaC1jdXJpZS1kb2MtMDAxXCI6XG4gICAgY2FzZSBcInRleHQtc2VhcmNoLWRhdmluY2ktZG9jLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LXNpbWlsYXJpdHktYWRhLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LXNpbWlsYXJpdHktYmFiYmFnZS0wMDFcIjpcbiAgICBjYXNlIFwidGV4dC1zaW1pbGFyaXR5LWN1cmllLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LXNpbWlsYXJpdHktZGF2aW5jaS0wMDFcIjoge1xuICAgICAgcmV0dXJuIFwicjUwa19iYXNlXCI7XG4gICAgfVxuICAgIGNhc2UgXCJncHQtMy41LXR1cmJvLWluc3RydWN0LTA5MTRcIjpcbiAgICBjYXNlIFwiZ3B0LTMuNS10dXJiby1pbnN0cnVjdFwiOlxuICAgIGNhc2UgXCJncHQtMy41LXR1cmJvLTE2ay0wNjEzXCI6XG4gICAgY2FzZSBcImdwdC0zLjUtdHVyYm8tMTZrXCI6XG4gICAgY2FzZSBcImdwdC0zLjUtdHVyYm8tMDYxM1wiOlxuICAgIGNhc2UgXCJncHQtMy41LXR1cmJvLTAzMDFcIjpcbiAgICBjYXNlIFwiZ3B0LTMuNS10dXJib1wiOlxuICAgIGNhc2UgXCJncHQtNC0zMmstMDYxM1wiOlxuICAgIGNhc2UgXCJncHQtNC0zMmstMDMxNFwiOlxuICAgIGNhc2UgXCJncHQtNC0zMmtcIjpcbiAgICBjYXNlIFwiZ3B0LTQtMDYxM1wiOlxuICAgIGNhc2UgXCJncHQtNC0wMzE0XCI6XG4gICAgY2FzZSBcImdwdC00XCI6XG4gICAgY2FzZSBcImdwdC0zLjUtdHVyYm8tMTEwNlwiOlxuICAgIGNhc2UgXCJncHQtMzUtdHVyYm9cIjpcbiAgICBjYXNlIFwiZ3B0LTQtMTEwNi1wcmV2aWV3XCI6XG4gICAgY2FzZSBcImdwdC00LXZpc2lvbi1wcmV2aWV3XCI6XG4gICAgY2FzZSBcImdwdC0zLjUtdHVyYm8tMDEyNVwiOlxuICAgIGNhc2UgXCJncHQtNC10dXJib1wiOlxuICAgIGNhc2UgXCJncHQtNC10dXJiby0yMDI0LTA0LTA5XCI6XG4gICAgY2FzZSBcImdwdC00LXR1cmJvLXByZXZpZXdcIjpcbiAgICBjYXNlIFwiZ3B0LTQtMDEyNS1wcmV2aWV3XCI6XG4gICAgY2FzZSBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIjpcbiAgICBjYXNlIFwidGV4dC1lbWJlZGRpbmctMy1zbWFsbFwiOlxuICAgIGNhc2UgXCJ0ZXh0LWVtYmVkZGluZy0zLWxhcmdlXCI6IHtcbiAgICAgIHJldHVybiBcImNsMTAwa19iYXNlXCI7XG4gICAgfVxuICAgIGNhc2UgXCJncHQtNG9cIjpcbiAgICBjYXNlIFwiZ3B0LTRvLTIwMjQtMDUtMTNcIjpcbiAgICBjYXNlIFwiZ3B0LTRvLTIwMjQtMDgtMDZcIjpcbiAgICBjYXNlIFwiZ3B0LTRvLTIwMjQtMTEtMjBcIjpcbiAgICBjYXNlIFwiZ3B0LTRvLW1pbmktMjAyNC0wNy0xOFwiOlxuICAgIGNhc2UgXCJncHQtNG8tbWluaVwiOlxuICAgIGNhc2UgXCJncHQtNG8tc2VhcmNoLXByZXZpZXdcIjpcbiAgICBjYXNlIFwiZ3B0LTRvLXNlYXJjaC1wcmV2aWV3LTIwMjUtMDMtMTFcIjpcbiAgICBjYXNlIFwiZ3B0LTRvLW1pbmktc2VhcmNoLXByZXZpZXdcIjpcbiAgICBjYXNlIFwiZ3B0LTRvLW1pbmktc2VhcmNoLXByZXZpZXctMjAyNS0wMy0xMVwiOlxuICAgIGNhc2UgXCJncHQtNG8tYXVkaW8tcHJldmlld1wiOlxuICAgIGNhc2UgXCJncHQtNG8tYXVkaW8tcHJldmlldy0yMDI0LTEyLTE3XCI6XG4gICAgY2FzZSBcImdwdC00by1hdWRpby1wcmV2aWV3LTIwMjQtMTAtMDFcIjpcbiAgICBjYXNlIFwiZ3B0LTRvLW1pbmktYXVkaW8tcHJldmlld1wiOlxuICAgIGNhc2UgXCJncHQtNG8tbWluaS1hdWRpby1wcmV2aWV3LTIwMjQtMTItMTdcIjpcbiAgICBjYXNlIFwibzFcIjpcbiAgICBjYXNlIFwibzEtMjAyNC0xMi0xN1wiOlxuICAgIGNhc2UgXCJvMS1taW5pXCI6XG4gICAgY2FzZSBcIm8xLW1pbmktMjAyNC0wOS0xMlwiOlxuICAgIGNhc2UgXCJvMS1wcmV2aWV3XCI6XG4gICAgY2FzZSBcIm8xLXByZXZpZXctMjAyNC0wOS0xMlwiOlxuICAgIGNhc2UgXCJvMS1wcm9cIjpcbiAgICBjYXNlIFwibzEtcHJvLTIwMjUtMDMtMTlcIjpcbiAgICBjYXNlIFwibzNcIjpcbiAgICBjYXNlIFwibzMtMjAyNS0wNC0xNlwiOlxuICAgIGNhc2UgXCJvMy1taW5pXCI6XG4gICAgY2FzZSBcIm8zLW1pbmktMjAyNS0wMS0zMVwiOlxuICAgIGNhc2UgXCJvNC1taW5pXCI6XG4gICAgY2FzZSBcIm80LW1pbmktMjAyNS0wNC0xNlwiOlxuICAgIGNhc2UgXCJjaGF0Z3B0LTRvLWxhdGVzdFwiOlxuICAgIGNhc2UgXCJncHQtNG8tcmVhbHRpbWVcIjpcbiAgICBjYXNlIFwiZ3B0LTRvLXJlYWx0aW1lLXByZXZpZXctMjAyNC0xMC0wMVwiOlxuICAgIGNhc2UgXCJncHQtNG8tcmVhbHRpbWUtcHJldmlldy0yMDI0LTEyLTE3XCI6XG4gICAgY2FzZSBcImdwdC00by1taW5pLXJlYWx0aW1lLXByZXZpZXdcIjpcbiAgICBjYXNlIFwiZ3B0LTRvLW1pbmktcmVhbHRpbWUtcHJldmlldy0yMDI0LTEyLTE3XCI6XG4gICAgY2FzZSBcImdwdC00LjFcIjpcbiAgICBjYXNlIFwiZ3B0LTQuMS0yMDI1LTA0LTE0XCI6XG4gICAgY2FzZSBcImdwdC00LjEtbWluaVwiOlxuICAgIGNhc2UgXCJncHQtNC4xLW1pbmktMjAyNS0wNC0xNFwiOlxuICAgIGNhc2UgXCJncHQtNC4xLW5hbm9cIjpcbiAgICBjYXNlIFwiZ3B0LTQuMS1uYW5vLTIwMjUtMDQtMTRcIjpcbiAgICBjYXNlIFwiZ3B0LTQuNS1wcmV2aWV3XCI6XG4gICAgY2FzZSBcImdwdC00LjUtcHJldmlldy0yMDI1LTAyLTI3XCI6IHtcbiAgICAgIHJldHVybiBcIm8yMDBrX2Jhc2VcIjtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kZWxcIik7XG4gIH1cbn1cblxuZXhwb3J0IHsgVGlrdG9rZW4sIGdldEVuY29kaW5nTmFtZUZvck1vZGVsLCBuZXZlciB9O1xuIiwgImltcG9ydCB7IFRpa3Rva2VuLCBnZXRFbmNvZGluZ05hbWVGb3JNb2RlbCwgfSBmcm9tIFwianMtdGlrdG9rZW4vbGl0ZVwiO1xuaW1wb3J0IHsgQXN5bmNDYWxsZXIgfSBmcm9tIFwiLi9hc3luY19jYWxsZXIuanNcIjtcbmNvbnN0IGNhY2hlID0ge307XG5jb25zdCBjYWxsZXIgPSAvKiAjX19QVVJFX18gKi8gbmV3IEFzeW5jQ2FsbGVyKHt9KTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbmNvZGluZyhlbmNvZGluZykge1xuICAgIGlmICghKGVuY29kaW5nIGluIGNhY2hlKSkge1xuICAgICAgICBjYWNoZVtlbmNvZGluZ10gPSBjYWxsZXJcbiAgICAgICAgICAgIC5mZXRjaChgaHR0cHM6Ly90aWt0b2tlbi5wYWdlcy5kZXYvanMvJHtlbmNvZGluZ30uanNvbmApXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IG5ldyBUaWt0b2tlbihkYXRhKSlcbiAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2VuY29kaW5nXTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgY2FjaGVbZW5jb2RpbmddO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY29kaW5nRm9yTW9kZWwobW9kZWwpIHtcbiAgICByZXR1cm4gZ2V0RW5jb2RpbmcoZ2V0RW5jb2RpbmdOYW1lRm9yTW9kZWwobW9kZWwpKTtcbn1cbiIsICJpbXBvcnQgeyBJbk1lbW9yeUNhY2hlIH0gZnJvbSBcIi4uL2NhY2hlcy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBTdHJpbmdQcm9tcHRWYWx1ZSwgQ2hhdFByb21wdFZhbHVlLCB9IGZyb20gXCIuLi9wcm9tcHRfdmFsdWVzLmpzXCI7XG5pbXBvcnQgeyBjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSB9IGZyb20gXCIuLi9tZXNzYWdlcy91dGlscy5qc1wiO1xuaW1wb3J0IHsgQXN5bmNDYWxsZXIgfSBmcm9tIFwiLi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGluZ0Zvck1vZGVsIH0gZnJvbSBcIi4uL3V0aWxzL3Rpa3Rva2VuLmpzXCI7XG5pbXBvcnQgeyBSdW5uYWJsZSB9IGZyb20gXCIuLi9ydW5uYWJsZXMvYmFzZS5qc1wiO1xuLy8gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvanMtdGlrdG9rZW5cbmV4cG9ydCBjb25zdCBnZXRNb2RlbE5hbWVGb3JUaWt0b2tlbiA9IChtb2RlbE5hbWUpID0+IHtcbiAgICBpZiAobW9kZWxOYW1lLnN0YXJ0c1dpdGgoXCJncHQtMy41LXR1cmJvLTE2a1wiKSkge1xuICAgICAgICByZXR1cm4gXCJncHQtMy41LXR1cmJvLTE2a1wiO1xuICAgIH1cbiAgICBpZiAobW9kZWxOYW1lLnN0YXJ0c1dpdGgoXCJncHQtMy41LXR1cmJvLVwiKSkge1xuICAgICAgICByZXR1cm4gXCJncHQtMy41LXR1cmJvXCI7XG4gICAgfVxuICAgIGlmIChtb2RlbE5hbWUuc3RhcnRzV2l0aChcImdwdC00LTMya1wiKSkge1xuICAgICAgICByZXR1cm4gXCJncHQtNC0zMmtcIjtcbiAgICB9XG4gICAgaWYgKG1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ3B0LTQtXCIpKSB7XG4gICAgICAgIHJldHVybiBcImdwdC00XCI7XG4gICAgfVxuICAgIGlmIChtb2RlbE5hbWUuc3RhcnRzV2l0aChcImdwdC00b1wiKSkge1xuICAgICAgICByZXR1cm4gXCJncHQtNG9cIjtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsTmFtZTtcbn07XG5leHBvcnQgY29uc3QgZ2V0RW1iZWRkaW5nQ29udGV4dFNpemUgPSAobW9kZWxOYW1lKSA9PiB7XG4gICAgc3dpdGNoIChtb2RlbE5hbWUpIHtcbiAgICAgICAgY2FzZSBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIjpcbiAgICAgICAgICAgIHJldHVybiA4MTkxO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDIwNDY7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBnZXRNb2RlbENvbnRleHRTaXplID0gKG1vZGVsTmFtZSkgPT4ge1xuICAgIHN3aXRjaCAoZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW4obW9kZWxOYW1lKSkge1xuICAgICAgICBjYXNlIFwiZ3B0LTMuNS10dXJiby0xNmtcIjpcbiAgICAgICAgICAgIHJldHVybiAxNjM4NDtcbiAgICAgICAgY2FzZSBcImdwdC0zLjUtdHVyYm9cIjpcbiAgICAgICAgICAgIHJldHVybiA0MDk2O1xuICAgICAgICBjYXNlIFwiZ3B0LTQtMzJrXCI6XG4gICAgICAgICAgICByZXR1cm4gMzI3Njg7XG4gICAgICAgIGNhc2UgXCJncHQtNFwiOlxuICAgICAgICAgICAgcmV0dXJuIDgxOTI7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWRhdmluY2ktMDAzXCI6XG4gICAgICAgICAgICByZXR1cm4gNDA5NztcbiAgICAgICAgY2FzZSBcInRleHQtY3VyaWUtMDAxXCI6XG4gICAgICAgICAgICByZXR1cm4gMjA0ODtcbiAgICAgICAgY2FzZSBcInRleHQtYmFiYmFnZS0wMDFcIjpcbiAgICAgICAgICAgIHJldHVybiAyMDQ4O1xuICAgICAgICBjYXNlIFwidGV4dC1hZGEtMDAxXCI6XG4gICAgICAgICAgICByZXR1cm4gMjA0ODtcbiAgICAgICAgY2FzZSBcImNvZGUtZGF2aW5jaS0wMDJcIjpcbiAgICAgICAgICAgIHJldHVybiA4MDAwO1xuICAgICAgICBjYXNlIFwiY29kZS1jdXNobWFuLTAwMVwiOlxuICAgICAgICAgICAgcmV0dXJuIDIwNDg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gNDA5NztcbiAgICB9XG59O1xuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgbWF0Y2hlcyB0aGUgT3BlbkFJIHRvb2wgZGVmaW5pdGlvbi5cbiAqIEBwYXJhbSB7dW5rbm93bn0gdG9vbCBUaGUgaW5wdXQgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaW5wdXQgaXMgYW4gT3BlbkFJIHRvb2wgZGVmaW5pdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT3BlbkFJVG9vbCh0b29sKSB7XG4gICAgaWYgKHR5cGVvZiB0b29sICE9PSBcIm9iamVjdFwiIHx8ICF0b29sKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKFwidHlwZVwiIGluIHRvb2wgJiZcbiAgICAgICAgdG9vbC50eXBlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiIGluIHRvb2wgJiZcbiAgICAgICAgdHlwZW9mIHRvb2wuZnVuY3Rpb24gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdG9vbC5mdW5jdGlvbiAmJlxuICAgICAgICBcIm5hbWVcIiBpbiB0b29sLmZ1bmN0aW9uICYmXG4gICAgICAgIFwicGFyYW1ldGVyc1wiIGluIHRvb2wuZnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVNYXhUb2tlbnMgPSBhc3luYyAoeyBwcm9tcHQsIG1vZGVsTmFtZSwgfSkgPT4ge1xuICAgIGxldCBudW1Ub2tlbnM7XG4gICAgdHJ5IHtcbiAgICAgICAgbnVtVG9rZW5zID0gKGF3YWl0IGVuY29kaW5nRm9yTW9kZWwoZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW4obW9kZWxOYW1lKSkpLmVuY29kZShwcm9tcHQpLmxlbmd0aDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjYWxjdWxhdGUgbnVtYmVyIG9mIHRva2VucywgZmFsbGluZyBiYWNrIHRvIGFwcHJveGltYXRlIGNvdW50XCIpO1xuICAgICAgICAvLyBmYWxsYmFjayB0byBhcHByb3hpbWF0ZSBjYWxjdWxhdGlvbiBpZiB0aWt0b2tlbiBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgIC8vIGVhY2ggdG9rZW4gaXMgfjQgY2hhcmFjdGVyczogaHR0cHM6Ly9oZWxwLm9wZW5haS5jb20vZW4vYXJ0aWNsZXMvNDkzNjg1Ni13aGF0LWFyZS10b2tlbnMtYW5kLWhvdy10by1jb3VudC10aGVtI1xuICAgICAgICBudW1Ub2tlbnMgPSBNYXRoLmNlaWwocHJvbXB0Lmxlbmd0aCAvIDQpO1xuICAgIH1cbiAgICBjb25zdCBtYXhUb2tlbnMgPSBnZXRNb2RlbENvbnRleHRTaXplKG1vZGVsTmFtZSk7XG4gICAgcmV0dXJuIG1heFRva2VucyAtIG51bVRva2Vucztcbn07XG5jb25zdCBnZXRWZXJib3NpdHkgPSAoKSA9PiBmYWxzZTtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGFuZ3VhZ2UgbW9kZWxzLCBjaGFpbnMsIHRvb2xzLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUxhbmdDaGFpbiBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBnZXQgbGNfYXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhbGxiYWNrczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmVyYm9zZTogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdG8gcHJpbnQgb3V0IHJlc3BvbnNlIHRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJib3NlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxiYWNrc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IHBhcmFtcy52ZXJib3NlID8/IGdldFZlcmJvc2l0eSgpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIHRoaXMudGFncyA9IHBhcmFtcy50YWdzID8/IFtdO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gcGFyYW1zLm1ldGFkYXRhID8/IHt9O1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGFuZ3VhZ2UgbW9kZWxzLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUxhbmd1YWdlTW9kZWwgZXh0ZW5kcyBCYXNlTGFuZ0NoYWluIHtcbiAgICAvKipcbiAgICAgKiBLZXlzIHRoYXQgdGhlIGxhbmd1YWdlIG1vZGVsIGFjY2VwdHMgYXMgY2FsbCBvcHRpb25zLlxuICAgICAqL1xuICAgIGdldCBjYWxsS2V5cygpIHtcbiAgICAgICAgcmV0dXJuIFtcInN0b3BcIiwgXCJ0aW1lb3V0XCIsIFwic2lnbmFsXCIsIFwidGFnc1wiLCBcIm1ldGFkYXRhXCIsIFwiY2FsbGJhY2tzXCJdO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGNhbGxiYWNrcywgY2FsbGJhY2tNYW5hZ2VyLCAuLi5wYXJhbXMgfSkge1xuICAgICAgICBjb25zdCB7IGNhY2hlLCAuLi5yZXN0IH0gPSBwYXJhbXM7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNhbGxiYWNrczogY2FsbGJhY2tzID8/IGNhbGxiYWNrTWFuYWdlcixcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFzeW5jIGNhbGxlciBzaG91bGQgYmUgdXNlZCBieSBzdWJjbGFzc2VzIHRvIG1ha2UgYW55IGFzeW5jIGNhbGxzLFxuICAgICAgICAgKiB3aGljaCB3aWxsIHRodXMgYmVuZWZpdCBmcm9tIHRoZSBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FjaGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2VuY29kaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FjaGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IEluTWVtb3J5Q2FjaGUuZ2xvYmFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbGVyID0gbmV3IEFzeW5jQ2FsbGVyKHBhcmFtcyA/PyB7fSk7XG4gICAgfVxuICAgIGFzeW5jIGdldE51bVRva2Vucyhjb250ZW50KSB7XG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgY29ycmVjdCB2YWx1ZS5cbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsYmFjayB0byBhcHByb3hpbWF0ZSBjYWxjdWxhdGlvbiBpZiB0aWt0b2tlbiBpcyBub3QgYXZhaWxhYmxlXG4gICAgICAgIGxldCBudW1Ub2tlbnMgPSBNYXRoLmNlaWwoY29udGVudC5sZW5ndGggLyA0KTtcbiAgICAgICAgaWYgKCF0aGlzLl9lbmNvZGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGF3YWl0IGVuY29kaW5nRm9yTW9kZWwoXCJtb2RlbE5hbWVcIiBpbiB0aGlzXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW4odGhpcy5tb2RlbE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIDogXCJncHQyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNhbGN1bGF0ZSBudW1iZXIgb2YgdG9rZW5zLCBmYWxsaW5nIGJhY2sgdG8gYXBwcm94aW1hdGUgY291bnRcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbmNvZGluZykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBudW1Ub2tlbnMgPSB0aGlzLl9lbmNvZGluZy5lbmNvZGUoY29udGVudCkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGNhbGN1bGF0ZSBudW1iZXIgb2YgdG9rZW5zLCBmYWxsaW5nIGJhY2sgdG8gYXBwcm94aW1hdGUgY291bnRcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1Ub2tlbnM7XG4gICAgfVxuICAgIHN0YXRpYyBfY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGF0UHJvbXB0VmFsdWUoaW5wdXQubWFwKGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZGVudGlmeWluZyBwYXJhbWV0ZXJzIG9mIHRoZSBMTE0uXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfaWRlbnRpZnlpbmdQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdW5pcXVlIGNhY2hlIGtleSBmb3IgYSBzcGVjaWZpYyBjYWxsIHRvIGEgc3BlY2lmaWMgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHBhcmFtIGNhbGxPcHRpb25zIENhbGwgb3B0aW9ucyBmb3IgdGhlIG1vZGVsXG4gICAgICogQHJldHVybnMgQSB1bmlxdWUgY2FjaGUga2V5LlxuICAgICAqL1xuICAgIF9nZXRTZXJpYWxpemVkQ2FjaGVLZXlQYXJhbWV0ZXJzRm9yQ2FsbChcbiAgICAvLyBUT0RPOiBGaXggd2hlbiB3ZSByZW1vdmUgdGhlIFJ1bm5hYmxlTGFtYmRhIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHNoaW0uXG4gICAgeyBjb25maWcsIC4uLmNhbGxPcHRpb25zIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5faWRlbnRpZnlpbmdQYXJhbXMoKSxcbiAgICAgICAgICAgIC4uLmNhbGxPcHRpb25zLFxuICAgICAgICAgICAgX3R5cGU6IHRoaXMuX2xsbVR5cGUoKSxcbiAgICAgICAgICAgIF9tb2RlbDogdGhpcy5fbW9kZWxUeXBlKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEVudHJpZXMgPSBmaWx0ZXJlZEVudHJpZXNcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgLmpvaW4oXCIsXCIpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZEVudHJpZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogUmV0dXJuIGEganNvbi1saWtlIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBMTE0uXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5faWRlbnRpZnlpbmdQYXJhbXMoKSxcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9sbG1UeXBlKCksXG4gICAgICAgICAgICBfbW9kZWw6IHRoaXMuX21vZGVsVHlwZSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIExvYWQgYW4gTExNIGZyb20gYSBqc29uLWxpa2Ugb2JqZWN0IGRlc2NyaWJpbmcgaXQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKF9kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSAudG9KU09OKCkgaW5zdGVhZFwiKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgY29uY2F0IH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgUnVubmFibGUsIFJ1bm5hYmxlQXNzaWduLCBSdW5uYWJsZU1hcCwgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBlbnN1cmVDb25maWcgfSBmcm9tIFwiLi9jb25maWcuanNcIjtcbi8qKlxuICogQSBydW5uYWJsZSB0byBwYXNzdGhyb3VnaCBpbnB1dHMgdW5jaGFuZ2VkIG9yIHdpdGggYWRkaXRpb25hbCBrZXlzLlxuICpcbiAqIFRoaXMgcnVubmFibGUgYmVoYXZlcyBhbG1vc3QgbGlrZSB0aGUgaWRlbnRpdHkgZnVuY3Rpb24sIGV4Y2VwdCB0aGF0IGl0XG4gKiBjYW4gYmUgY29uZmlndXJlZCB0byBhZGQgYWRkaXRpb25hbCBrZXlzIHRvIHRoZSBvdXRwdXQsIGlmIHRoZSBpbnB1dCBpc1xuICogYW4gb2JqZWN0LlxuICpcbiAqIFRoZSBleGFtcGxlIGJlbG93IGRlbW9uc3RyYXRlcyBob3cgdG8gdXNlIGBSdW5uYWJsZVBhc3N0aHJvdWdoIHRvXG4gKiBwYXNzdGhyb3VnaCB0aGUgaW5wdXQgZnJvbSB0aGUgYC5pbnZva2UoKWBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgY2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW1xuICogICB7XG4gKiAgICAgcXVlc3Rpb246IG5ldyBSdW5uYWJsZVBhc3N0aHJvdWdoKCksXG4gKiAgICAgY29udGV4dDogYXN5bmMgKCkgPT4gbG9hZENvbnRleHRGcm9tU3RvcmUoKSxcbiAqICAgfSxcbiAqICAgcHJvbXB0LFxuICogICBsbG0sXG4gKiAgIG91dHB1dFBhcnNlcixcbiAqIF0pO1xuICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGFpbi5pbnZva2UoXG4gKiAgIFwiSSBjYW4gcGFzcyBhIHNpbmdsZSBzdHJpbmcgaW5zdGVhZCBvZiBhbiBvYmplY3Qgc2luY2UgSSdtIHVzaW5nIGBSdW5uYWJsZVBhc3N0aHJvdWdoYC5cIlxuICogKTtcbiAqIGBgYFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlUGFzc3Rocm91Z2ggZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlUGFzc3Rocm91Z2hcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bmMgPSBmaWVsZHMuZnVuYztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5mdW5jKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZ1bmMoaW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKChpbnB1dCkgPT4gUHJvbWlzZS5yZXNvbHZlKGlucHV0KSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jICp0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICBsZXQgZmluYWxPdXRwdXRTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCAoaW5wdXQpID0+IGlucHV0LCBjb25maWcpKSB7XG4gICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY29uY2F0KGZpbmFsT3V0cHV0LCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZ1bmMgJiYgZmluYWxPdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mdW5jKGZpbmFsT3V0cHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcnVubmFibGUgdGhhdCBhc3NpZ25zIGtleS12YWx1ZSBwYWlycyB0byB0aGUgaW5wdXQuXG4gICAgICpcbiAgICAgKiBUaGUgZXhhbXBsZSBiZWxvdyBzaG93cyBob3cgeW91IGNvdWxkIHVzZSBpdCB3aXRoIGFuIGlubGluZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHByb21wdCA9XG4gICAgICogICBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoYFdyaXRlIGEgU1FMIHF1ZXJ5IHRvIGFuc3dlciB0aGUgcXVlc3Rpb24gdXNpbmcgdGhlIGZvbGxvd2luZyBzY2hlbWE6IHtzY2hlbWF9XG4gICAgICogUXVlc3Rpb246IHtxdWVzdGlvbn1cbiAgICAgKiBTUUwgUXVlcnk6YCk7XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYFJ1bm5hYmxlUGFzc3Rocm91Z2guYXNzaWduKClgIGlzIHVzZWQgaGVyZSB0byBwYXNzdGhyb3VnaCB0aGUgaW5wdXQgZnJvbSB0aGUgYC5pbnZva2UoKWBcbiAgICAgKiAvLyBjYWxsIChpbiB0aGlzIGV4YW1wbGUgaXQncyB0aGUgcXVlc3Rpb24pLCBhbG9uZyB3aXRoIGFueSBpbnB1dHMgcGFzc2VkIHRvIHRoZSBgLmFzc2lnbigpYCBtZXRob2QuXG4gICAgICogLy8gSW4gdGhpcyBjYXNlLCB3ZSdyZSBwYXNzaW5nIHRoZSBzY2hlbWEuXG4gICAgICogY29uc3Qgc3FsUXVlcnlHZW5lcmF0b3JDaGFpbiA9IFJ1bm5hYmxlU2VxdWVuY2UuZnJvbShbXG4gICAgICogICBSdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbih7XG4gICAgICogICAgIHNjaGVtYTogYXN5bmMgKCkgPT4gZGIuZ2V0VGFibGVJbmZvKCksXG4gICAgICogICB9KSxcbiAgICAgKiAgIHByb21wdCxcbiAgICAgKiAgIG5ldyBDaGF0T3BlbkFJKHt9KS5iaW5kKHsgc3RvcDogW1wiXFxuU1FMUmVzdWx0OlwiXSB9KSxcbiAgICAgKiAgIG5ldyBTdHJpbmdPdXRwdXRQYXJzZXIoKSxcbiAgICAgKiBdKTtcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzcWxRdWVyeUdlbmVyYXRvckNoYWluLmludm9rZSh7XG4gICAgICogICBxdWVzdGlvbjogXCJIb3cgbWFueSBlbXBsb3llZXMgYXJlIHRoZXJlP1wiLFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3NpZ24obWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQXNzaWduKG5ldyBSdW5uYWJsZU1hcCh7IHN0ZXBzOiBtYXBwaW5nIH0pKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcbi8qKlxuICogR2l2ZW4gZWl0aGVyIGEgWm9kIHNjaGVtYSwgb3IgcGxhaW4gb2JqZWN0LCBkZXRlcm1pbmUgaWYgdGhlIGlucHV0IGlzIGEgWm9kIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0ge3ouWm9kVHlwZTxSdW5PdXRwdXQ+IHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj59IGlucHV0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHByb3ZpZGVkIGlucHV0IGlzIGEgWm9kIHNjaGVtYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzWm9kU2NoZW1hKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhc1pvZFNjaGVtYSA9IGlucHV0O1xuICAgIC8vIHJlbGllcyBvbiBhbiBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBab2Qgc2NoZW1hcywgc28gdGhpcyBtYXkgYnJlYWsgaW4gdGhlIGZ1dHVyZSwgaGVuY2UgdGhlXG4gICAgLy8gYWRkaXRpb25hbCBmYWxsYmFjayBjaGVja3MgYmVsb3dcbiAgICBpZiAoYXNab2RTY2hlbWEuX2RlZikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgem9kRmlyc3RQYXJ0eVR5cGVLaW5kcyA9IE9iamVjdC52YWx1ZXMoei5ab2RGaXJzdFBhcnR5VHlwZUtpbmQpO1xuICAgIGlmICh6b2RGaXJzdFBhcnR5VHlwZUtpbmRzLmluY2x1ZGVzKGFzWm9kU2NoZW1hLmNvbnN0cnVjdG9yPy5uYW1lID8/IFwiTk9UX0lOQ0xVREVEXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBpZiBhbGwgZWxzZSBmYWlscywgYXNzdW1lIGJhc2VkIG9uIHRoZSBwcmVzZW5jZSBvZiBwYXJzZSwgcGFyc2VBc3luYywgc2FmZVBhcnNlLCBhbmRcbiAgICAvLyBzYWZlUGFyc2VBc3luYywgYXMgdGhlc2UgYXJlIGNoYXJhY3RlcmlzdGljIG9mIFpvZCBzY2hlbWFzXG4gICAgcmV0dXJuICh0eXBlb2YgYXNab2RTY2hlbWEucGFyc2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgYXNab2RTY2hlbWEucGFyc2VBc3luYyA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiBhc1pvZFNjaGVtYS5zYWZlUGFyc2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgYXNab2RTY2hlbWEuc2FmZVBhcnNlQXN5bmMgPT09IFwiZnVuY3Rpb25cIik7XG59XG4iLCAiaW1wb3J0IHsgem9kVG9Kc29uU2NoZW1hIH0gZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuaW1wb3J0IHsgQUlNZXNzYWdlLCBIdW1hbk1lc3NhZ2UsIGNvZXJjZU1lc3NhZ2VMaWtlVG9NZXNzYWdlLCBpc0FJTWVzc2FnZUNodW5rLCBpc0Jhc2VNZXNzYWdlLCBpc0FJTWVzc2FnZSwgY29udmVydFRvT3BlbkFJSW1hZ2VCbG9jaywgaXNVUkxDb250ZW50QmxvY2ssIGlzQmFzZTY0Q29udGVudEJsb2NrLCB9IGZyb20gXCIuLi9tZXNzYWdlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgUlVOX0tFWSwgfSBmcm9tIFwiLi4vb3V0cHV0cy5qc1wiO1xuaW1wb3J0IHsgQmFzZUxhbmd1YWdlTW9kZWwsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgQ2FsbGJhY2tNYW5hZ2VyLCB9IGZyb20gXCIuLi9jYWxsYmFja3MvbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgUnVubmFibGVMYW1iZGEsIFJ1bm5hYmxlU2VxdWVuY2UsIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBjb25jYXQgfSBmcm9tIFwiLi4vdXRpbHMvc3RyZWFtLmpzXCI7XG5pbXBvcnQgeyBSdW5uYWJsZVBhc3N0aHJvdWdoIH0gZnJvbSBcIi4uL3J1bm5hYmxlcy9wYXNzdGhyb3VnaC5qc1wiO1xuaW1wb3J0IHsgaXNab2RTY2hlbWEgfSBmcm9tIFwiLi4vdXRpbHMvdHlwZXMvaXNfem9kX3NjaGVtYS5qc1wiO1xuaW1wb3J0IHsgY2FsbGJhY2tIYW5kbGVyUHJlZmVyc1N0cmVhbWluZyB9IGZyb20gXCIuLi9jYWxsYmFja3MvYmFzZS5qc1wiO1xuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSBmb3IgZW5jb2RpbmcgY2hhdCBtZXNzYWdlIGNodW5rcy5cbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgQnl0ZXNPdXRwdXRQYXJzZXJ9IGluc3RlYWRcbiAqIEByZXR1cm5zIEEgVHJhbnNmb3JtU3RyZWFtIGluc3RhbmNlIHRoYXQgZW5jb2RlcyBjaGF0IG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hhdE1lc3NhZ2VDaHVua0VuY29kZXJTdHJlYW0oKSB7XG4gICAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZSh0eXBlb2YgY2h1bmsuY29udGVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gY2h1bmsuY29udGVudFxuICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoY2h1bmsuY29udGVudCkpKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9mb3JtYXRGb3JUcmFjaW5nKG1lc3NhZ2VzKSB7XG4gICAgY29uc3QgbWVzc2FnZXNUb1RyYWNlID0gW107XG4gICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgIGxldCBtZXNzYWdlVG9UcmFjZSA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UuY29udGVudCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IG1lc3NhZ2UuY29udGVudC5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBtZXNzYWdlLmNvbnRlbnRbaWR4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNVUkxDb250ZW50QmxvY2soYmxvY2spIHx8IGlzQmFzZTY0Q29udGVudEJsb2NrKGJsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZVRvVHJhY2UgPT09IG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28gc2hhbGxvdy1jb3B5IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlVG9UcmFjZSA9IG5ldyBtZXNzYWdlLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tZXNzYWdlVG9UcmFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2UuY29udGVudC5zbGljZSgwLCBpZHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0VG9PcGVuQUlJbWFnZUJsb2NrKGJsb2NrKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZS5jb250ZW50LnNsaWNlKGlkeCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlc1RvVHJhY2UucHVzaChtZXNzYWdlVG9UcmFjZSk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlc1RvVHJhY2U7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNoYXQgbW9kZWxzLiBJdCBleHRlbmRzIHRoZSBCYXNlTGFuZ3VhZ2VNb2RlbCBjbGFzcyBhbmRcbiAqIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGdlbmVyYXRpbmcgY2hhdCBiYXNlZCBvbiBpbnB1dCBtZXNzYWdlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VDaGF0TW9kZWwgZXh0ZW5kcyBCYXNlTGFuZ3VhZ2VNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIC8vIE9ubHkgZXZlciBpbnN0YW50aWF0ZWQgaW4gbWFpbiBMYW5nQ2hhaW5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJjaGF0X21vZGVsc1wiLCB0aGlzLl9sbG1UeXBlKCldXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaXNhYmxlU3RyZWFtaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnNDb21wYXQob3B0aW9ucykge1xuICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdCwga2VlcCBgc2lnbmFsYCBpbiBib3RoIHJ1bm5hYmxlQ29uZmlnIGFuZCBjYWxsT3B0aW9uc1xuICAgICAgICBjb25zdCBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXSA9IHN1cGVyLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjYWxsT3B0aW9ucy5zaWduYWwgPSBydW5uYWJsZUNvbmZpZy5zaWduYWw7XG4gICAgICAgIHJldHVybiBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgY2hhdCBtb2RlbCB3aXRoIGEgc2luZ2xlIGlucHV0LlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgZm9yIHRoZSBsYW5ndWFnZSBtb2RlbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgQmFzZU1lc3NhZ2VDaHVuay5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0VmFsdWUgPSBCYXNlQ2hhdE1vZGVsLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVByb21wdChbcHJvbXB0VmFsdWVdLCBvcHRpb25zLCBvcHRpb25zPy5jYWxsYmFja3MpO1xuICAgICAgICBjb25zdCBjaGF0R2VuZXJhdGlvbiA9IHJlc3VsdC5nZW5lcmF0aW9uc1swXVswXTtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGNhc3QgYWZ0ZXIgZmlndXJpbmcgb3V0IGluaGVyaXRhbmNlXG4gICAgICAgIHJldHVybiBjaGF0R2VuZXJhdGlvbi5tZXNzYWdlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS15aWVsZFxuICAgIGFzeW5jICpfc3RyZWFtUmVzcG9uc2VDaHVua3MoX21lc3NhZ2VzLCBfb3B0aW9ucywgX3J1bk1hbmFnZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBTdWJjbGFzcyBjaGVjayByZXF1aXJlZCB0byBhdm9pZCBkb3VibGUgY2FsbGJhY2tzIHdpdGggZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAodGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MgPT09XG4gICAgICAgICAgICBCYXNlQ2hhdE1vZGVsLnByb3RvdHlwZS5fc3RyZWFtUmVzcG9uc2VDaHVua3MgfHxcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZVN0cmVhbWluZykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gQmFzZUNoYXRNb2RlbC5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHByb21wdC50b0NoYXRNZXNzYWdlcygpO1xuICAgICAgICAgICAgY29uc3QgW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc10gPSB0aGlzLl9zZXBhcmF0ZVJ1bm5hYmxlQ29uZmlnRnJvbUNhbGxPcHRpb25zQ29tcGF0KG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGVNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAuLi5ydW5uYWJsZUNvbmZpZy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmdldExzUGFyYW1zKGNhbGxPcHRpb25zKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBydW5uYWJsZUNvbmZpZy50YWdzLCB0aGlzLnRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMoY2FsbE9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGJhdGNoX3NpemU6IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGF0TW9kZWxTdGFydCh0aGlzLnRvSlNPTigpLCBbX2Zvcm1hdEZvclRyYWNpbmcobWVzc2FnZXMpXSwgcnVubmFibGVDb25maWcucnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBydW5uYWJsZUNvbmZpZy5ydW5OYW1lKTtcbiAgICAgICAgICAgIGxldCBnZW5lcmF0aW9uQ2h1bms7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgbGV0IGxsbU91dHB1dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhtZXNzYWdlcywgY2FsbE9wdGlvbnMsIHJ1bk1hbmFnZXJzPy5bMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bklkID0gcnVuTWFuYWdlcnM/LmF0KDApPy5ydW5JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5JZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLm1lc3NhZ2UuX3VwZGF0ZUlkKGBydW4tJHtydW5JZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaHVuay5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jaHVuay5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBjaHVuay5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdlbmVyYXRpb25DaHVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbkNodW5rID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uQ2h1bmsgPSBnZW5lcmF0aW9uQ2h1bmsuY29uY2F0KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBSU1lc3NhZ2VDaHVuayhjaHVuay5tZXNzYWdlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Vc2FnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEuaW5wdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLm91dHB1dF90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLnRvdGFsX3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IoZXJyKSkpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBjYXN0IGFmdGVyIGZpZ3VyaW5nIG91dCBpbmhlcml0YW5jZVxuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbW2dlbmVyYXRpb25DaHVua11dLFxuICAgICAgICAgICAgICAgIGxsbU91dHB1dCxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0THNQYXJhbXMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm92aWRlck5hbWUgPSB0aGlzLmdldE5hbWUoKS5zdGFydHNXaXRoKFwiQ2hhdFwiKVxuICAgICAgICAgICAgPyB0aGlzLmdldE5hbWUoKS5yZXBsYWNlKFwiQ2hhdFwiLCBcIlwiKVxuICAgICAgICAgICAgOiB0aGlzLmdldE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxzX21vZGVsX3R5cGU6IFwiY2hhdFwiLFxuICAgICAgICAgICAgbHNfc3RvcDogb3B0aW9ucy5zdG9wLFxuICAgICAgICAgICAgbHNfcHJvdmlkZXI6IHByb3ZpZGVyTmFtZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhc3luYyBfZ2VuZXJhdGVVbmNhY2hlZChtZXNzYWdlcywgcGFyc2VkT3B0aW9ucywgaGFuZGxlZE9wdGlvbnMsIHN0YXJ0ZWRSdW5NYW5hZ2Vycykge1xuICAgICAgICBjb25zdCBiYXNlTWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2VMaXN0KSA9PiBtZXNzYWdlTGlzdC5tYXAoY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpKTtcbiAgICAgICAgbGV0IHJ1bk1hbmFnZXJzO1xuICAgICAgICBpZiAoc3RhcnRlZFJ1bk1hbmFnZXJzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHN0YXJ0ZWRSdW5NYW5hZ2Vycy5sZW5ndGggPT09IGJhc2VNZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJ1bk1hbmFnZXJzID0gc3RhcnRlZFJ1bk1hbmFnZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGVNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAuLi5oYW5kbGVkT3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmdldExzUGFyYW1zKHBhcnNlZE9wdGlvbnMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBjYWxsYmFjayBtYW5hZ2VyIGFuZCBzdGFydCBydW5cbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBDYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGhhbmRsZWRPcHRpb25zLmNhbGxiYWNrcywgdGhpcy5jYWxsYmFja3MsIGhhbmRsZWRPcHRpb25zLnRhZ3MsIHRoaXMudGFncywgaW5oZXJpdGFibGVNZXRhZGF0YSwgdGhpcy5tZXRhZGF0YSwgeyB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgfSk7XG4gICAgICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBwYXJzZWRPcHRpb25zLFxuICAgICAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKHBhcnNlZE9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGJhdGNoX3NpemU6IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGF0TW9kZWxTdGFydCh0aGlzLnRvSlNPTigpLCBiYXNlTWVzc2FnZXMubWFwKF9mb3JtYXRGb3JUcmFjaW5nKSwgaGFuZGxlZE9wdGlvbnMucnVuSWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoYW5kbGVkT3B0aW9ucy5ydW5OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBsbG1PdXRwdXRzID0gW107XG4gICAgICAgIC8vIEV2ZW4gaWYgc3RyZWFtIGlzIG5vdCBleHBsaWNpdGx5IGNhbGxlZCwgY2hlY2sgaWYgbW9kZWwgaXMgaW1wbGljaXRseVxuICAgICAgICAvLyBjYWxsZWQgZnJvbSBzdHJlYW1FdmVudHMoKSBvciBzdHJlYW1Mb2coKSB0byBnZXQgYWxsIHN0cmVhbWVkIGV2ZW50cy5cbiAgICAgICAgLy8gQmFpbCBvdXQgaWYgX3N0cmVhbVJlc3BvbnNlQ2h1bmtzIG5vdCBvdmVycmlkZGVuXG4gICAgICAgIGNvbnN0IGhhc1N0cmVhbWluZ0hhbmRsZXIgPSAhIXJ1bk1hbmFnZXJzPy5bMF0uaGFuZGxlcnMuZmluZChjYWxsYmFja0hhbmRsZXJQcmVmZXJzU3RyZWFtaW5nKTtcbiAgICAgICAgaWYgKGhhc1N0cmVhbWluZ0hhbmRsZXIgJiZcbiAgICAgICAgICAgICF0aGlzLmRpc2FibGVTdHJlYW1pbmcgJiZcbiAgICAgICAgICAgIGJhc2VNZXNzYWdlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzICE9PVxuICAgICAgICAgICAgICAgIEJhc2VDaGF0TW9kZWwucHJvdG90eXBlLl9zdHJlYW1SZXNwb25zZUNodW5rcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhiYXNlTWVzc2FnZXNbMF0sIHBhcnNlZE9wdGlvbnMsIHJ1bk1hbmFnZXJzPy5bMF0pO1xuICAgICAgICAgICAgICAgIGxldCBhZ2dyZWdhdGVkO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgbGV0IGxsbU91dHB1dDtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsubWVzc2FnZS5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydW5JZCA9IHJ1bk1hbmFnZXJzPy5hdCgwKT8ucnVuSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVuSWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5tZXNzYWdlLl91cGRhdGVJZChgcnVuLSR7cnVuSWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFnZ3JlZ2F0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlZCA9IGNvbmNhdChhZ2dyZWdhdGVkLCBjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQUlNZXNzYWdlQ2h1bmsoY2h1bmsubWVzc2FnZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGxtT3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXNhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay5tZXNzYWdlLnVzYWdlX21ldGFkYXRhLmlucHV0X3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS5vdXRwdXRfdG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFRva2VuczogY2h1bmsubWVzc2FnZS51c2FnZV9tZXRhZGF0YS50b3RhbF90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFnZ3JlZ2F0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWNlaXZlZCBlbXB0eSByZXNwb25zZSBmcm9tIGNoYXQgbW9kZWwgY2FsbC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zLnB1c2goW2FnZ3JlZ2F0ZWRdKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2Vycz8uWzBdLmhhbmRsZUxMTUVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXJzPy5bMF0uaGFuZGxlTExNRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIHJlc3VsdHNcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYmFzZU1lc3NhZ2VzLm1hcCgobWVzc2FnZUxpc3QsIGkpID0+IHRoaXMuX2dlbmVyYXRlKG1lc3NhZ2VMaXN0LCB7IC4uLnBhcnNlZE9wdGlvbnMsIHByb21wdEluZGV4OiBpIH0sIHJ1bk1hbmFnZXJzPy5baV0pKSk7XG4gICAgICAgICAgICAvLyBoYW5kbGUgcmVzdWx0c1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5tYXAoYXN5bmMgKHBSZXN1bHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocFJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcFJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0aW9uIG9mIHJlc3VsdC5nZW5lcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb24ubWVzc2FnZS5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVuSWQgPSBydW5NYW5hZ2Vycz8uYXQoMCk/LnJ1bklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydW5JZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uLm1lc3NhZ2UuX3VwZGF0ZUlkKGBydW4tJHtydW5JZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb24ubWVzc2FnZS5yZXNwb25zZV9tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5nZW5lcmF0aW9uLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmdlbmVyYXRpb24ubWVzc2FnZS5yZXNwb25zZV9tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5nZW5lcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5nZW5lcmF0aW9uc1swXS5tZXNzYWdlLnJlc3BvbnNlX21ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdC5sbG1PdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0LmdlbmVyYXRpb25zWzBdLm1lc3NhZ2UucmVzcG9uc2VfbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zW2ldID0gcmVzdWx0LmdlbmVyYXRpb25zO1xuICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXRzW2ldID0gcmVzdWx0LmxsbU91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bk1hbmFnZXJzPy5baV0/LmhhbmRsZUxMTUVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW3Jlc3VsdC5nZW5lcmF0aW9uc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQ6IHJlc3VsdC5sbG1PdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhdHVzID09PSBcInJlamVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcnM/LltpXT8uaGFuZGxlTExNRXJyb3IocFJlc3VsdC5yZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocFJlc3VsdC5yZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgY29tYmluZWQgb3V0cHV0XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zLFxuICAgICAgICAgICAgbGxtT3V0cHV0OiBsbG1PdXRwdXRzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gdGhpcy5fY29tYmluZUxMTU91dHB1dD8uKC4uLmxsbU91dHB1dHMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvdXRwdXQsIFJVTl9LRVksIHtcbiAgICAgICAgICAgIHZhbHVlOiBydW5NYW5hZ2Vyc1xuICAgICAgICAgICAgICAgID8geyBydW5JZHM6IHJ1bk1hbmFnZXJzPy5tYXAoKG1hbmFnZXIpID0+IG1hbmFnZXIucnVuSWQpIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZW5lcmF0ZUNhY2hlZCh7IG1lc3NhZ2VzLCBjYWNoZSwgbGxtU3RyaW5nS2V5LCBwYXJzZWRPcHRpb25zLCBoYW5kbGVkT3B0aW9ucywgfSkge1xuICAgICAgICBjb25zdCBiYXNlTWVzc2FnZXMgPSBtZXNzYWdlcy5tYXAoKG1lc3NhZ2VMaXN0KSA9PiBtZXNzYWdlTGlzdC5tYXAoY29lcmNlTWVzc2FnZUxpa2VUb01lc3NhZ2UpKTtcbiAgICAgICAgY29uc3QgaW5oZXJpdGFibGVNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmhhbmRsZWRPcHRpb25zLm1ldGFkYXRhLFxuICAgICAgICAgICAgLi4udGhpcy5nZXRMc1BhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY3JlYXRlIGNhbGxiYWNrIG1hbmFnZXIgYW5kIHN0YXJ0IHJ1blxuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShoYW5kbGVkT3B0aW9ucy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBoYW5kbGVkT3B0aW9ucy50YWdzLCB0aGlzLnRhZ3MsIGluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMubWV0YWRhdGEsIHsgdmVyYm9zZTogdGhpcy52ZXJib3NlIH0pO1xuICAgICAgICBjb25zdCBleHRyYSA9IHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHBhcnNlZE9wdGlvbnMsXG4gICAgICAgICAgICBpbnZvY2F0aW9uX3BhcmFtczogdGhpcz8uaW52b2NhdGlvblBhcmFtcyhwYXJzZWRPcHRpb25zKSxcbiAgICAgICAgICAgIGJhdGNoX3NpemU6IDEsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhdE1vZGVsU3RhcnQodGhpcy50b0pTT04oKSwgYmFzZU1lc3NhZ2VzLm1hcChfZm9ybWF0Rm9yVHJhY2luZyksIGhhbmRsZWRPcHRpb25zLnJ1bklkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGFuZGxlZE9wdGlvbnMucnVuTmFtZSk7XG4gICAgICAgIC8vIGdlbmVyYXRlIHJlc3VsdHNcbiAgICAgICAgY29uc3QgbWlzc2luZ1Byb21wdEluZGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChiYXNlTWVzc2FnZXMubWFwKGFzeW5jIChiYXNlTWVzc2FnZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vIEpvaW4gYWxsIGNvbnRlbnQgaW50byBvbmUgc3RyaW5nIGZvciB0aGUgcHJvbXB0IGluZGV4XG4gICAgICAgICAgICBjb25zdCBwcm9tcHQgPSBCYXNlQ2hhdE1vZGVsLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGJhc2VNZXNzYWdlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUubG9va3VwKHByb21wdCwgbGxtU3RyaW5nS2V5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdQcm9tcHRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBNYXAgcnVuIG1hbmFnZXJzIHRvIHRoZSByZXN1bHRzIGJlZm9yZSBmaWx0ZXJpbmcgb3V0IG51bGwgcmVzdWx0c1xuICAgICAgICAvLyBOdWxsIHJlc3VsdHMgYXJlIGp1c3QgYWJzZW50IGZyb20gdGhlIGNhY2hlLlxuICAgICAgICBjb25zdCBjYWNoZWRSZXN1bHRzID0gcmVzdWx0c1xuICAgICAgICAgICAgLm1hcCgocmVzdWx0LCBpbmRleCkgPT4gKHsgcmVzdWx0LCBydW5NYW5hZ2VyOiBydW5NYW5hZ2Vycz8uW2luZGV4XSB9KSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHsgcmVzdWx0IH0pID0+IChyZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiICYmIHJlc3VsdC52YWx1ZSAhPSBudWxsKSB8fFxuICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKTtcbiAgICAgICAgLy8gSGFuZGxlIHJlc3VsdHMgYW5kIGNhbGwgcnVuIG1hbmFnZXJzXG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gW107XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNhY2hlZFJlc3VsdHMubWFwKGFzeW5jICh7IHJlc3VsdDogcHJvbWlzZVJlc3VsdCwgcnVuTWFuYWdlciB9LCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZVJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9taXNlUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zW2ldID0gcmVzdWx0Lm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm1lc3NhZ2VcIiBpbiByZXN1bHQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQmFzZU1lc3NhZ2UocmVzdWx0Lm1lc3NhZ2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FJTWVzc2FnZShyZXN1bHQubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm1lc3NhZ2UudXNhZ2VfbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfdG9rZW5zOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxfdG9rZW5zOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmdlbmVyYXRpb25JbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0LmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Vc2FnZToge30sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNTmV3VG9rZW4ocmVzdWx0WzBdLnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRW5kKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnM6IFtyZXN1bHRdLFxuICAgICAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhdHVzID09PSBcInJlamVjdGVkXCJcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FcnJvcihwcm9taXNlUmVzdWx0LnJlYXNvbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHByb21pc2VSZXN1bHQucmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICBnZW5lcmF0aW9ucyxcbiAgICAgICAgICAgIG1pc3NpbmdQcm9tcHRJbmRpY2VzLFxuICAgICAgICAgICAgc3RhcnRlZFJ1bk1hbmFnZXJzOiBydW5NYW5hZ2VycyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBkZWZpbmVzIFJVTl9LRVkgYXMgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb3V0cHV0IG9iamVjdFxuICAgICAgICAvLyBzbyB0aGF0IGl0IGlzIG5vdCBzZXJpYWxpemVkIHdoZW4gdGhlIG91dHB1dCBpcyBzdHJpbmdpZmllZCwgYW5kIHNvIHRoYXRcbiAgICAgICAgLy8gaXQgaXNudCBpbmNsdWRlZCB3aGVuIGxpc3RpbmcgdGhlIGtleXMgb2YgdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvdXRwdXQsIFJVTl9LRVksIHtcbiAgICAgICAgICAgIHZhbHVlOiBydW5NYW5hZ2Vyc1xuICAgICAgICAgICAgICAgID8geyBydW5JZHM6IHJ1bk1hbmFnZXJzPy5tYXAoKG1hbmFnZXIpID0+IG1hbmFnZXIucnVuSWQpIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBjaGF0IGJhc2VkIG9uIHRoZSBpbnB1dCBtZXNzYWdlcy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgQW4gYXJyYXkgb2YgYXJyYXlzIG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIExMTVJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZShtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIHBhcnNlIGNhbGwgb3B0aW9uc1xuICAgICAgICBsZXQgcGFyc2VkT3B0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMgPSB7IHN0b3A6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VNZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgobWVzc2FnZUxpc3QpID0+IG1lc3NhZ2VMaXN0Lm1hcChjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSkpO1xuICAgICAgICBjb25zdCBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXSA9IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnNDb21wYXQocGFyc2VkT3B0aW9ucyk7XG4gICAgICAgIHJ1bm5hYmxlQ29uZmlnLmNhbGxiYWNrcyA9IHJ1bm5hYmxlQ29uZmlnLmNhbGxiYWNrcyA/PyBjYWxsYmFja3M7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dlbmVyYXRlVW5jYWNoZWQoYmFzZU1lc3NhZ2VzLCBjYWxsT3B0aW9ucywgcnVubmFibGVDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxsbVN0cmluZ0tleSA9IHRoaXMuX2dldFNlcmlhbGl6ZWRDYWNoZUtleVBhcmFtZXRlcnNGb3JDYWxsKGNhbGxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBnZW5lcmF0aW9ucywgbWlzc2luZ1Byb21wdEluZGljZXMsIHN0YXJ0ZWRSdW5NYW5hZ2VycyB9ID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVDYWNoZWQoe1xuICAgICAgICAgICAgbWVzc2FnZXM6IGJhc2VNZXNzYWdlcyxcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgbGxtU3RyaW5nS2V5LFxuICAgICAgICAgICAgcGFyc2VkT3B0aW9uczogY2FsbE9wdGlvbnMsXG4gICAgICAgICAgICBoYW5kbGVkT3B0aW9uczogcnVubmFibGVDb25maWcsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGxtT3V0cHV0ID0ge307XG4gICAgICAgIGlmIChtaXNzaW5nUHJvbXB0SW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5fZ2VuZXJhdGVVbmNhY2hlZChtaXNzaW5nUHJvbXB0SW5kaWNlcy5tYXAoKGkpID0+IGJhc2VNZXNzYWdlc1tpXSksIGNhbGxPcHRpb25zLCBydW5uYWJsZUNvbmZpZywgc3RhcnRlZFJ1bk1hbmFnZXJzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1pc3NpbmdQcm9tcHRJbmRpY2VzLm1hcCgoaSkgPT4gc3RhcnRlZFJ1bk1hbmFnZXJzPy5baV0pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5nZW5lcmF0aW9ucy5tYXAoYXN5bmMgKGdlbmVyYXRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbXB0SW5kZXggPSBtaXNzaW5nUHJvbXB0SW5kaWNlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbnNbcHJvbXB0SW5kZXhdID0gZ2VuZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBjb250ZW50IGludG8gb25lIHN0cmluZyBmb3IgdGhlIHByb21wdCBpbmRleFxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21wdCA9IEJhc2VDaGF0TW9kZWwuX2NvbnZlcnRJbnB1dFRvUHJvbXB0VmFsdWUoYmFzZU1lc3NhZ2VzW3Byb21wdEluZGV4XSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUudXBkYXRlKHByb21wdCwgbGxtU3RyaW5nS2V5LCBnZW5lcmF0aW9uKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGxsbU91dHB1dCA9IHJlc3VsdHMubGxtT3V0cHV0ID8/IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGdlbmVyYXRpb25zLCBsbG1PdXRwdXQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXJhbWV0ZXJzIHVzZWQgdG8gaW52b2tlIHRoZSBtb2RlbFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaW52b2NhdGlvblBhcmFtcyhfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIF9tb2RlbFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImJhc2VfY2hhdF9tb2RlbFwiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIFJldHVybiBhIGpzb24tbGlrZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgTExNLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuaW52b2NhdGlvblBhcmFtcygpLFxuICAgICAgICAgICAgX3R5cGU6IHRoaXMuX2xsbVR5cGUoKSxcbiAgICAgICAgICAgIF9tb2RlbDogdGhpcy5fbW9kZWxUeXBlKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHByb21wdCBiYXNlZCBvbiB0aGUgaW5wdXQgcHJvbXB0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gcHJvbXB0VmFsdWVzIEFuIGFycmF5IG9mIEJhc2VQcm9tcHRWYWx1ZSBpbnN0YW5jZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNhbGwgb3B0aW9ucyBvciBhbiBhcnJheSBvZiBzdG9wIHNlcXVlbmNlcy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIFRoZSBjYWxsYmFja3MgZm9yIHRoZSBsYW5ndWFnZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBMTE1SZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVQcm9tcHQocHJvbXB0VmFsdWVzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBwcm9tcHRWYWx1ZXMubWFwKChwcm9tcHRWYWx1ZSkgPT4gcHJvbXB0VmFsdWUudG9DaGF0TWVzc2FnZXMoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlKHByb21wdE1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKlxuICAgICAqIE1ha2VzIGEgc2luZ2xlIGNhbGwgdG8gdGhlIGNoYXQgbW9kZWwuXG4gICAgICogQHBhcmFtIG1lc3NhZ2VzIEFuIGFycmF5IG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgQmFzZU1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgY2FsbChtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGUoW21lc3NhZ2VzLm1hcChjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSldLCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IHJlc3VsdC5nZW5lcmF0aW9ucztcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRpb25zWzBdWzBdLm1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSAuaW52b2tlKCkgaW5zdGVhZC4gV2lsbCBiZSByZW1vdmVkIGluIDAuMi4wLlxuICAgICAqXG4gICAgICogTWFrZXMgYSBzaW5nbGUgY2FsbCB0byB0aGUgY2hhdCBtb2RlbCB3aXRoIGEgcHJvbXB0IHZhbHVlLlxuICAgICAqIEBwYXJhbSBwcm9tcHRWYWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHByb21wdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2FsbCBvcHRpb25zIG9yIGFuIGFycmF5IG9mIHN0b3Agc2VxdWVuY2VzLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgVGhlIGNhbGxiYWNrcyBmb3IgdGhlIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgQmFzZU1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgY2FsbFByb21wdChwcm9tcHRWYWx1ZSwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gcHJvbXB0VmFsdWUudG9DaGF0TWVzc2FnZXMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbChwcm9tcHRNZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICpcbiAgICAgKiBQcmVkaWN0cyB0aGUgbmV4dCBtZXNzYWdlIGJhc2VkIG9uIHRoZSBpbnB1dCBtZXNzYWdlcy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgQW4gYXJyYXkgb2YgQmFzZU1lc3NhZ2UgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMgb3IgYW4gYXJyYXkgb2Ygc3RvcCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBUaGUgY2FsbGJhY2tzIGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBCYXNlTWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVkaWN0TWVzc2FnZXMobWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKlxuICAgICAqIFByZWRpY3RzIHRoZSBuZXh0IG1lc3NhZ2UgYmFzZWQgb24gYSB0ZXh0IGlucHV0LlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IGlucHV0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjYWxsIG9wdGlvbnMgb3IgYW4gYXJyYXkgb2Ygc3RvcCBzZXF1ZW5jZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBUaGUgY2FsbGJhY2tzIGZvciB0aGUgbGFuZ3VhZ2UgbW9kZWwuXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdCh0ZXh0LCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBIdW1hbk1lc3NhZ2UodGV4dCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbChbbWVzc2FnZV0sIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgcHJlZGljdCB3aGVuIG91dHB1dCBpcyBub3QgYSBzdHJpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuY29udGVudDtcbiAgICB9XG4gICAgd2l0aFN0cnVjdHVyZWRPdXRwdXQob3V0cHV0U2NoZW1hLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRUb29scyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoYXQgbW9kZWwgbXVzdCBpbXBsZW1lbnQgXCIuYmluZFRvb2xzKClcIiB0byB1c2Ugd2l0aFN0cnVjdHVyZWRPdXRwdXQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZz8uc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwic3RyaWN0XCIgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG1vZGVsIGJ5IGRlZmF1bHQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gb3V0cHV0U2NoZW1hO1xuICAgICAgICBjb25zdCBuYW1lID0gY29uZmlnPy5uYW1lO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHNjaGVtYS5kZXNjcmlwdGlvbiA/PyBcIkEgZnVuY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwuXCI7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGNvbmZpZz8ubWV0aG9kO1xuICAgICAgICBjb25zdCBpbmNsdWRlUmF3ID0gY29uZmlnPy5pbmNsdWRlUmF3O1xuICAgICAgICBpZiAobWV0aG9kID09PSBcImpzb25Nb2RlXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFzZSB3aXRoU3RydWN0dXJlZE91dHB1dCBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIFwiZnVuY3Rpb25DYWxsaW5nXCIgYXMgYSBtZXRob2QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bmN0aW9uTmFtZSA9IG5hbWUgPz8gXCJleHRyYWN0XCI7XG4gICAgICAgIGxldCB0b29scztcbiAgICAgICAgaWYgKGlzWm9kU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHRvb2xzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB6b2RUb0pzb25TY2hlbWEoc2NoZW1hKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChcIm5hbWVcIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBzY2hlbWEubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvb2xzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGxtID0gdGhpcy5iaW5kVG9vbHModG9vbHMpO1xuICAgICAgICBjb25zdCBvdXRwdXRQYXJzZXIgPSBSdW5uYWJsZUxhbWJkYS5mcm9tKChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dC50b29sX2NhbGxzIHx8IGlucHV0LnRvb2xfY2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBjYWxscyBmb3VuZCBpbiB0aGUgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBpbnB1dC50b29sX2NhbGxzLmZpbmQoKHRjKSA9PiB0Yy5uYW1lID09PSBmdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgaWYgKCF0b29sQ2FsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gdG9vbCBjYWxsIGZvdW5kIHdpdGggbmFtZSAke2Z1bmN0aW9uTmFtZX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbENhbGwuYXJncztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaW5jbHVkZVJhdykge1xuICAgICAgICAgICAgcmV0dXJuIGxsbS5waXBlKG91dHB1dFBhcnNlcikud2l0aENvbmZpZyh7XG4gICAgICAgICAgICAgICAgcnVuTmFtZTogXCJTdHJ1Y3R1cmVkT3V0cHV0XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZXJBc3NpZ24gPSBSdW5uYWJsZVBhc3N0aHJvdWdoLmFzc2lnbih7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcGFyc2VkOiAoaW5wdXQsIGNvbmZpZykgPT4gb3V0cHV0UGFyc2VyLmludm9rZShpbnB1dC5yYXcsIGNvbmZpZyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZXJOb25lID0gUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAgICAgICAgcGFyc2VkOiAoKSA9PiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VkV2l0aEZhbGxiYWNrID0gcGFyc2VyQXNzaWduLndpdGhGYWxsYmFja3Moe1xuICAgICAgICAgICAgZmFsbGJhY2tzOiBbcGFyc2VyTm9uZV0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByYXc6IGxsbSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZWRXaXRoRmFsbGJhY2ssXG4gICAgICAgIF0pLndpdGhDb25maWcoe1xuICAgICAgICAgICAgcnVuTmFtZTogXCJTdHJ1Y3R1cmVkT3V0cHV0UnVubmFibGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGV4dGVuZHMgQmFzZUNoYXRNb2RlbCBhbmQgcHJvdmlkZXMgYSBzaW1wbGVcbiAqIGltcGxlbWVudGF0aW9uIG9mIF9nZW5lcmF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXBsZUNoYXRNb2RlbCBleHRlbmRzIEJhc2VDaGF0TW9kZWwge1xuICAgIGFzeW5jIF9nZW5lcmF0ZShtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5fY2FsbChtZXNzYWdlcywgb3B0aW9ucywgcnVuTWFuYWdlcik7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgQUlNZXNzYWdlKHRleHQpO1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdlbmVyYXRlIHdpdGggYSBzaW1wbGUgY2hhdCBtb2RlbCB3aGVuIG91dHB1dCBpcyBub3QgYSBzdHJpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZW5lcmF0aW9uczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICIvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cbnZhciBnID1cbiAgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzKSB8fFxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsKSB8fFxuICB7fVxuXG52YXIgc3VwcG9ydCA9IHtcbiAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBnLFxuICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gZyAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgYmxvYjpcbiAgICAnRmlsZVJlYWRlcicgaW4gZyAmJlxuICAgICdCbG9iJyBpbiBnICYmXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBnLFxuICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBnXG59XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxufVxuXG5pZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgXVxuXG4gIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICB9XG4gIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+IV0vaS50ZXN0KG5hbWUpIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWU6IFwiJyArIG5hbWUgKyAnXCInKVxuICB9XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbmZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdGhpcy5tYXAgPSB7fVxuXG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgaWYgKGhlYWRlci5sZW5ndGggIT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIZWFkZXJzIGNvbnN0cnVjdG9yOiBleHBlY3RlZCBuYW1lL3ZhbHVlIHBhaXIgdG8gYmUgbGVuZ3RoIDIsIGZvdW5kJyArIGhlYWRlci5sZW5ndGgpXG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgfSwgdGhpcylcbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICB9XG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKG5hbWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIGl0ZW1zLnB1c2godmFsdWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXNcbn1cblxuZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICBpZiAoYm9keS5fbm9Cb2R5KSByZXR1cm5cbiAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gIH1cbiAgYm9keS5ib2R5VXNlZCA9IHRydWVcbn1cblxuZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgIH1cbiAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB2YXIgbWF0Y2ggPSAvY2hhcnNldD0oW0EtWmEtejAtOV8tXSspLy5leGVjKGJsb2IudHlwZSlcbiAgdmFyIGVuY29kaW5nID0gbWF0Y2ggPyBtYXRjaFsxXSA6ICd1dGYtOCdcbiAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYiwgZW5jb2RpbmcpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgfVxuICByZXR1cm4gY2hhcnMuam9pbignJylcbn1cblxuZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gIGlmIChidWYuc2xpY2UpIHtcbiAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gIH0gZWxzZSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aClcbiAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICB9XG59XG5cbmZ1bmN0aW9uIEJvZHkoKSB7XG4gIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG4gIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgIC8qXG4gICAgICBmZXRjaC1tb2NrIHdyYXBzIHRoZSBSZXNwb25zZSBvYmplY3QgaW4gYW4gRVM2IFByb3h5IHRvXG4gICAgICBwcm92aWRlIHVzZWZ1bCB0ZXN0IGhhcm5lc3MgZmVhdHVyZXMgc3VjaCBhcyBmbHVzaC4gSG93ZXZlciwgb25cbiAgICAgIEVTNSBicm93c2VycyB3aXRob3V0IGZldGNoIG9yIFByb3h5IHN1cHBvcnQgcG9sbHlmaWxscyBtdXN0IGJlIHVzZWQ7XG4gICAgICB0aGUgcHJveHktcG9sbHlmaWxsIGlzIHVuYWJsZSB0byBwcm94eSBhbiBhdHRyaWJ1dGUgdW5sZXNzIGl0IGV4aXN0c1xuICAgICAgb24gdGhlIG9iamVjdCBiZWZvcmUgdGhlIFByb3h5IGlzIGNyZWF0ZWQuIFRoaXMgY2hhbmdlIGVuc3VyZXNcbiAgICAgIFJlc3BvbnNlLmJvZHlVc2VkIGV4aXN0cyBvbiB0aGUgaW5zdGFuY2UsIHdoaWxlIG1haW50YWluaW5nIHRoZVxuICAgICAgc2VtYW50aWMgb2Ygc2V0dGluZyBSZXF1ZXN0LmJvZHlVc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgIF9pbml0Qm9keSBpcyBjYWxsZWQuXG4gICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICB0aGlzLmJvZHlVc2VkID0gdGhpcy5ib2R5VXNlZFxuICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgIGlmICghYm9keSkge1xuICAgICAgdGhpcy5fbm9Cb2R5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcilcbiAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgaXNDb25zdW1lZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAoaXNDb25zdW1lZCkge1xuICAgICAgICByZXR1cm4gaXNDb25zdW1lZFxuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5fYm9keUFycmF5QnVmZmVyKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0ICsgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgYXMgQXJyYXlCdWZmZXInKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbnZhciBtZXRob2RzID0gWydDT05ORUNUJywgJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BBVENIJywgJ1BPU1QnLCAnUFVUJywgJ1RSQUNFJ11cblxuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcblxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgIH1cbiAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICB0aGlzLnNpZ25hbCA9IGlucHV0LnNpZ25hbFxuICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICB9XG5cbiAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nXG4gIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgfVxuICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWwgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ0Fib3J0Q29udHJvbGxlcicgaW4gZykge1xuICAgICAgdmFyIGN0cmwgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICByZXR1cm4gY3RybC5zaWduYWw7XG4gICAgfVxuICB9KCkpO1xuICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gIH1cbiAgdGhpcy5faW5pdEJvZHkoYm9keSlcblxuICBpZiAodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICBpZiAob3B0aW9ucy5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBvcHRpb25zLmNhY2hlID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAvLyBTZWFyY2ggZm9yIGEgJ18nIHBhcmFtZXRlciBpbiB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICB2YXIgcmVQYXJhbVNlYXJjaCA9IC8oWz8mXSlfPVteJl0qL1xuICAgICAgaWYgKHJlUGFyYW1TZWFyY2gudGVzdCh0aGlzLnVybCkpIHtcbiAgICAgICAgLy8gSWYgaXQgYWxyZWFkeSBleGlzdHMgdGhlbiBzZXQgdGhlIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnJlcGxhY2UocmVQYXJhbVNlYXJjaCwgJyQxXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGEgbmV3ICdfJyBwYXJhbWV0ZXIgdG8gdGhlIGVuZCB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgdmFyIHJlUXVlcnlTdHJpbmcgPSAvXFw/L1xuICAgICAgICB0aGlzLnVybCArPSAocmVRdWVyeVN0cmluZy50ZXN0KHRoaXMudXJsKSA/ICcmJyA6ICc/JykgKyAnXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG59XG5cbmZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgYm9keVxuICAgIC50cmltKClcbiAgICAuc3BsaXQoJyYnKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gZm9ybVxufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcbiAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKVxuICAvLyBBdm9pZGluZyBzcGxpdCB2aWEgcmVnZXggdG8gd29yayBhcm91bmQgYSBjb21tb24gSUUxMSBidWcgd2l0aCB0aGUgY29yZS1qcyAzLjYuMCByZWdleCBwb2x5ZmlsbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoL2lzc3Vlcy83NDhcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzc1MVxuICBwcmVQcm9jZXNzZWRIZWFkZXJzXG4gICAgLnNwbGl0KCdcXHInKVxuICAgIC5tYXAoZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICByZXR1cm4gaGVhZGVyLmluZGV4T2YoJ1xcbicpID09PSAwID8gaGVhZGVyLnN1YnN0cigxLCBoZWFkZXIubGVuZ3RoKSA6IGhlYWRlclxuICAgIH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdSZXNwb25zZSAnICsgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbkJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuZXhwb3J0IGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXNcbiAgaWYgKHRoaXMuc3RhdHVzIDwgMjAwIHx8IHRoaXMuc3RhdHVzID4gNTk5KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNwb25zZSc6IFRoZSBzdGF0dXMgcHJvdmlkZWQgKDApIGlzIG91dHNpZGUgdGhlIHJhbmdlIFsyMDAsIDU5OV0uXCIpXG4gIH1cbiAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHQgPT09IHVuZGVmaW5lZCA/ICcnIDogJycgKyBvcHRpb25zLnN0YXR1c1RleHRcbiAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxufVxuXG5Cb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG5SZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgdXJsOiB0aGlzLnVybFxuICB9KVxufVxuXG5SZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMjAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gIHJlc3BvbnNlLm9rID0gZmFsc2VcbiAgcmVzcG9uc2Uuc3RhdHVzID0gMFxuICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxudmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cblJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxufVxuXG5leHBvcnQgdmFyIERPTUV4Y2VwdGlvbiA9IGcuRE9NRXhjZXB0aW9uXG50cnkge1xuICBuZXcgRE9NRXhjZXB0aW9uKClcbn0gY2F0Y2ggKGVycikge1xuICBET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKVxuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFja1xuICB9XG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERPTUV4Y2VwdGlvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgeGhyLmFib3J0KClcbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICB9XG4gICAgICAvLyBUaGlzIGNoZWNrIGlmIHNwZWNpZmljYWxseSBmb3Igd2hlbiBhIHVzZXIgZmV0Y2hlcyBhIGZpbGUgbG9jYWxseSBmcm9tIHRoZSBmaWxlIHN5c3RlbVxuICAgICAgLy8gT25seSBpZiB0aGUgc3RhdHVzIGlzIG91dCBvZiBhIG5vcm1hbCByYW5nZVxuICAgICAgaWYgKHJlcXVlc3QudXJsLmluZGV4T2YoJ2ZpbGU6Ly8nKSA9PT0gMCAmJiAoeGhyLnN0YXR1cyA8IDIwMCB8fCB4aHIuc3RhdHVzID4gNTk5KSkge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IDIwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgdGltZWQgb3V0JykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFVybCh1cmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cmwgPT09ICcnICYmIGcubG9jYXRpb24uaHJlZiA/IGcubG9jYXRpb24uaHJlZiA6IHVybFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIGZpeFVybChyZXF1ZXN0LnVybCksIHRydWUpXG5cbiAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XG4gICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHN1cHBvcnQuYXJyYXlCdWZmZXJcbiAgICAgICkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbml0ICYmIHR5cGVvZiBpbml0LmhlYWRlcnMgPT09ICdvYmplY3QnICYmICEoaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyB8fCAoZy5IZWFkZXJzICYmIGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIGcuSGVhZGVycykpKSB7XG4gICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWVzLnB1c2gobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgbm9ybWFsaXplVmFsdWUoaW5pdC5oZWFkZXJzW25hbWVdKSlcbiAgICAgIH0pXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcblxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICB9KVxufVxuXG5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcblxuaWYgKCFnLmZldGNoKSB7XG4gIGcuZmV0Y2ggPSBmZXRjaFxuICBnLkhlYWRlcnMgPSBIZWFkZXJzXG4gIGcuUmVxdWVzdCA9IFJlcXVlc3RcbiAgZy5SZXNwb25zZSA9IFJlc3BvbnNlXG59XG4iLCAiaW1wb3J0ICd3aGF0d2ctZmV0Y2gnO1xuXG5jb25zdCBkZWZhdWx0UG9ydCA9IFwiMTE0MzRcIjtcbmNvbnN0IGRlZmF1bHRIb3N0ID0gYGh0dHA6Ly8xMjcuMC4wLjE6JHtkZWZhdWx0UG9ydH1gO1xuXG5jb25zdCB2ZXJzaW9uID0gXCIwLjUuMTVcIjtcblxudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGVycm9yLCBzdGF0dXNfY29kZSkge1xuICAgIHN1cGVyKGVycm9yKTtcbiAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgdGhpcy5zdGF0dXNfY29kZSA9IHN0YXR1c19jb2RlO1xuICAgIHRoaXMubmFtZSA9IFwiUmVzcG9uc2VFcnJvclwiO1xuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVzcG9uc2VFcnJvcik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBYm9ydGFibGVBc3luY0l0ZXJhdG9yIHtcbiAgY29uc3RydWN0b3IoYWJvcnRDb250cm9sbGVyLCBpdHIsIGRvbmVDYWxsYmFjaykge1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImFib3J0Q29udHJvbGxlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpdHJcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiZG9uZUNhbGxiYWNrXCIpO1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgIHRoaXMuaXRyID0gaXRyO1xuICAgIHRoaXMuZG9uZUNhbGxiYWNrID0gZG9uZUNhbGxiYWNrO1xuICB9XG4gIGFib3J0KCkge1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBtZXNzYWdlIG9mIHRoaXMuaXRyKSB7XG4gICAgICBpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgfVxuICAgICAgeWllbGQgbWVzc2FnZTtcbiAgICAgIGlmIChtZXNzYWdlLmRvbmUgfHwgbWVzc2FnZS5zdGF0dXMgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgIHRoaXMuZG9uZUNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCByZWNlaXZlIGRvbmUgb3Igc3VjY2VzcyByZXNwb25zZSBpbiBzdHJlYW0uXCIpO1xuICB9XG59XG5jb25zdCBjaGVja09rID0gYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gIGlmIChyZXNwb25zZS5vaykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbWVzc2FnZSA9IGBFcnJvciAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gO1xuICBsZXQgZXJyb3JEYXRhID0gbnVsbDtcbiAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpPy5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICB0cnkge1xuICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgbWVzc2FnZSA9IGVycm9yRGF0YS5lcnJvciB8fCBtZXNzYWdlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBwYXJzZSBlcnJvciByZXNwb25zZSBhcyBKU09OXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJHZXR0aW5nIHRleHQgZnJvbSByZXNwb25zZVwiKTtcbiAgICAgIGNvbnN0IHRleHRSZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIG1lc3NhZ2UgPSB0ZXh0UmVzcG9uc2UgfHwgbWVzc2FnZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gZ2V0IHRleHQgZnJvbSBlcnJvciByZXNwb25zZVwiKTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IFJlc3BvbnNlRXJyb3IobWVzc2FnZSwgcmVzcG9uc2Uuc3RhdHVzKTtcbn07XG5mdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hdmlnYXRvcikge1xuICAgIGNvbnN0IG5hdiA9IG5hdmlnYXRvcjtcbiAgICBpZiAoXCJ1c2VyQWdlbnREYXRhXCIgaW4gbmF2ICYmIG5hdi51c2VyQWdlbnREYXRhPy5wbGF0Zm9ybSkge1xuICAgICAgcmV0dXJuIGAke25hdi51c2VyQWdlbnREYXRhLnBsYXRmb3JtLnRvTG93ZXJDYXNlKCl9IEJyb3dzZXIvJHtuYXZpZ2F0b3IudXNlckFnZW50fTtgO1xuICAgIH1cbiAgICBpZiAobmF2aWdhdG9yLnBsYXRmb3JtKSB7XG4gICAgICByZXR1cm4gYCR7bmF2aWdhdG9yLnBsYXRmb3JtLnRvTG93ZXJDYXNlKCl9IEJyb3dzZXIvJHtuYXZpZ2F0b3IudXNlckFnZW50fTtgO1xuICAgIH1cbiAgICByZXR1cm4gYHVua25vd24gQnJvd3Nlci8ke25hdmlnYXRvci51c2VyQWdlbnR9O2A7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gYCR7cHJvY2Vzcy5hcmNofSAke3Byb2Nlc3MucGxhdGZvcm19IE5vZGUuanMvJHtwcm9jZXNzLnZlcnNpb259YDtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcnMoaGVhZGVycykge1xuICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGVhZGVycyB8fCB7fTtcbiAgfVxufVxuY29uc3QgZmV0Y2hXaXRoSGVhZGVycyA9IGFzeW5jIChmZXRjaCwgdXJsLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBcIlVzZXItQWdlbnRcIjogYG9sbGFtYS1qcy8ke3ZlcnNpb259ICgke2dldFBsYXRmb3JtKCl9KWBcbiAgfTtcbiAgb3B0aW9ucy5oZWFkZXJzID0gbm9ybWFsaXplSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICBjb25zdCBjdXN0b21IZWFkZXJzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuaGVhZGVycykuZmlsdGVyKChba2V5XSkgPT4gIU9iamVjdC5rZXlzKGRlZmF1bHRIZWFkZXJzKS5zb21lKChkZWZhdWx0S2V5KSA9PiBkZWZhdWx0S2V5LnRvTG93ZXJDYXNlKCkgPT09IGtleS50b0xvd2VyQ2FzZSgpKSlcbiAgKTtcbiAgb3B0aW9ucy5oZWFkZXJzID0ge1xuICAgIC4uLmRlZmF1bHRIZWFkZXJzLFxuICAgIC4uLmN1c3RvbUhlYWRlcnNcbiAgfTtcbiAgcmV0dXJuIGZldGNoKHVybCwgb3B0aW9ucyk7XG59O1xuY29uc3QgZ2V0ID0gYXN5bmMgKGZldGNoLCBob3N0LCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoSGVhZGVycyhmZXRjaCwgaG9zdCwge1xuICAgIGhlYWRlcnM6IG9wdGlvbnM/LmhlYWRlcnNcbiAgfSk7XG4gIGF3YWl0IGNoZWNrT2socmVzcG9uc2UpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59O1xuY29uc3QgcG9zdCA9IGFzeW5jIChmZXRjaCwgaG9zdCwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBpc1JlY29yZCA9IChpbnB1dCkgPT4ge1xuICAgIHJldHVybiBpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXQpO1xuICB9O1xuICBjb25zdCBmb3JtYXR0ZWREYXRhID0gaXNSZWNvcmQoZGF0YSkgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IGRhdGE7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoSGVhZGVycyhmZXRjaCwgaG9zdCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogZm9ybWF0dGVkRGF0YSxcbiAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCxcbiAgICBoZWFkZXJzOiBvcHRpb25zPy5oZWFkZXJzXG4gIH0pO1xuICBhd2FpdCBjaGVja09rKHJlc3BvbnNlKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbmNvbnN0IGRlbCA9IGFzeW5jIChmZXRjaCwgaG9zdCwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aEhlYWRlcnMoZmV0Y2gsIGhvc3QsIHtcbiAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgaGVhZGVyczogb3B0aW9ucz8uaGVhZGVyc1xuICB9KTtcbiAgYXdhaXQgY2hlY2tPayhyZXNwb25zZSk7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG5jb25zdCBwYXJzZUpTT04gPSBhc3luYyBmdW5jdGlvbiogKGl0cikge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gIGxldCBidWZmZXIgPSBcIlwiO1xuICBjb25zdCByZWFkZXIgPSBpdHIuZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZTogY2h1bmsgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgIGNvbnN0IHBhcnRzID0gYnVmZmVyLnNwbGl0KFwiXFxuXCIpO1xuICAgIGJ1ZmZlciA9IHBhcnRzLnBvcCgpID8/IFwiXCI7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCBKU09OLnBhcnNlKHBhcnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiaW52YWxpZCBqc29uOiBcIiwgcGFydCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcGFydCBvZiBidWZmZXIuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChwKSA9PiBwICE9PSBcIlwiKSkge1xuICAgIHRyeSB7XG4gICAgICB5aWVsZCBKU09OLnBhcnNlKHBhcnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJpbnZhbGlkIGpzb246IFwiLCBwYXJ0KTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBmb3JtYXRIb3N0ID0gKGhvc3QpID0+IHtcbiAgaWYgKCFob3N0KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRIb3N0O1xuICB9XG4gIGxldCBpc0V4cGxpY2l0UHJvdG9jb2wgPSBob3N0LmluY2x1ZGVzKFwiOi8vXCIpO1xuICBpZiAoaG9zdC5zdGFydHNXaXRoKFwiOlwiKSkge1xuICAgIGhvc3QgPSBgaHR0cDovLzEyNy4wLjAuMSR7aG9zdH1gO1xuICAgIGlzRXhwbGljaXRQcm90b2NvbCA9IHRydWU7XG4gIH1cbiAgaWYgKCFpc0V4cGxpY2l0UHJvdG9jb2wpIHtcbiAgICBob3N0ID0gYGh0dHA6Ly8ke2hvc3R9YDtcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKGhvc3QpO1xuICBsZXQgcG9ydCA9IHVybC5wb3J0O1xuICBpZiAoIXBvcnQpIHtcbiAgICBpZiAoIWlzRXhwbGljaXRQcm90b2NvbCkge1xuICAgICAgcG9ydCA9IGRlZmF1bHRQb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3J0ID0gdXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCI0NDNcIiA6IFwiODBcIjtcbiAgICB9XG4gIH1cbiAgbGV0IGF1dGggPSBcIlwiO1xuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgYXV0aCA9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSB7XG4gICAgICBhdXRoICs9IGA6JHt1cmwucGFzc3dvcmR9YDtcbiAgICB9XG4gICAgYXV0aCArPSBcIkBcIjtcbiAgfVxuICBsZXQgZm9ybWF0dGVkSG9zdCA9IGAke3VybC5wcm90b2NvbH0vLyR7YXV0aH0ke3VybC5ob3N0bmFtZX06JHtwb3J0fSR7dXJsLnBhdGhuYW1lfWA7XG4gIGlmIChmb3JtYXR0ZWRIb3N0LmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIGZvcm1hdHRlZEhvc3QgPSBmb3JtYXR0ZWRIb3N0LnNsaWNlKDAsIC0xKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVkSG9zdDtcbn07XG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmxldCBPbGxhbWEkMSA9IGNsYXNzIE9sbGFtYSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25maWdcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZldGNoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvbmdvaW5nU3RyZWFtZWRSZXF1ZXN0c1wiLCBbXSk7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBob3N0OiBcIlwiLFxuICAgICAgaGVhZGVyczogY29uZmlnPy5oZWFkZXJzXG4gICAgfTtcbiAgICBpZiAoIWNvbmZpZz8ucHJveHkpIHtcbiAgICAgIHRoaXMuY29uZmlnLmhvc3QgPSBmb3JtYXRIb3N0KGNvbmZpZz8uaG9zdCA/PyBkZWZhdWx0SG9zdCk7XG4gICAgfVxuICAgIHRoaXMuZmV0Y2ggPSBjb25maWc/LmZldGNoID8/IGZldGNoO1xuICB9XG4gIC8vIEFib3J0IGFueSBvbmdvaW5nIHN0cmVhbWVkIHJlcXVlc3RzIHRvIE9sbGFtYVxuICBhYm9ydCgpIHtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgdGhpcy5vbmdvaW5nU3RyZWFtZWRSZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgIH1cbiAgICB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLmxlbmd0aCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIHJlcXVlc3QgdG8gdGhlIE9sbGFtYSBzZXJ2ZXIuIElmIHRoZSByZXF1ZXN0IGlzIHN0cmVhbWFibGUsIGl0IHdpbGwgcmV0dXJuIGFcbiAgICogQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyB0aGUgcmVzcG9uc2UgbWVzc2FnZXMuIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIHJlc3BvbnNlXG4gICAqIG9iamVjdC5cbiAgICogQHBhcmFtIGVuZHBvaW50IHtzdHJpbmd9IC0gVGhlIGVuZHBvaW50IHRvIHNlbmQgdGhlIHJlcXVlc3QgdG8uXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtvYmplY3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0IHRvIHNlbmQgdG8gdGhlIGVuZHBvaW50LlxuICAgKiBAcHJvdGVjdGVkIHtUIHwgQWJvcnRhYmxlQXN5bmNJdGVyYXRvcjxUPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGEgQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkc1xuICAgKiByZXNwb25zZSBtZXNzYWdlcy5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgbWlzc2luZyBvciBpZiB0aGUgcmVzcG9uc2UgaXMgYW4gZXJyb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFQgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFQ+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGEgQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyB0aGUgc3RyZWFtZWQgcmVzcG9uc2UuXG4gICAqL1xuICBhc3luYyBwcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoZW5kcG9pbnQsIHJlcXVlc3QpIHtcbiAgICByZXF1ZXN0LnN0cmVhbSA9IHJlcXVlc3Quc3RyZWFtID8/IGZhbHNlO1xuICAgIGNvbnN0IGhvc3QgPSBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvJHtlbmRwb2ludH1gO1xuICAgIGlmIChyZXF1ZXN0LnN0cmVhbSkge1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgcG9zdCh0aGlzLmZldGNoLCBob3N0LCByZXF1ZXN0LCB7XG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlMi5ib2R5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYm9keVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ciA9IHBhcnNlSlNPTihyZXNwb25zZTIuYm9keSk7XG4gICAgICBjb25zdCBhYm9ydGFibGVBc3luY0l0ZXJhdG9yID0gbmV3IEFib3J0YWJsZUFzeW5jSXRlcmF0b3IoXG4gICAgICAgIGFib3J0Q29udHJvbGxlcixcbiAgICAgICAgaXRyLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IHRoaXMub25nb2luZ1N0cmVhbWVkUmVxdWVzdHMuaW5kZXhPZihhYm9ydGFibGVBc3luY0l0ZXJhdG9yKTtcbiAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0aGlzLm9uZ29pbmdTdHJlYW1lZFJlcXVlc3RzLnB1c2goYWJvcnRhYmxlQXN5bmNJdGVyYXRvcik7XG4gICAgICByZXR1cm4gYWJvcnRhYmxlQXN5bmNJdGVyYXRvcjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGhvc3QsIHJlcXVlc3QsIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBFbmNvZGVzIGFuIGltYWdlIHRvIGJhc2U2NCBpZiBpdCBpcyBhIFVpbnQ4QXJyYXkuXG4gICAqIEBwYXJhbSBpbWFnZSB7VWludDhBcnJheSB8IHN0cmluZ30gLSBUaGUgaW1hZ2UgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIFRoZSBiYXNlNjQgZW5jb2RlZCBpbWFnZS5cbiAgICovXG4gIGFzeW5jIGVuY29kZUltYWdlKGltYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBpbWFnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGltYWdlKTtcbiAgICAgIGxldCBieXRlU3RyaW5nID0gXCJcIjtcbiAgICAgIGNvbnN0IGxlbiA9IHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYnl0ZVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4QXJyYXlbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ0b2EoYnl0ZVN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcmVzcG9uc2UgZnJvbSBhIHRleHQgcHJvbXB0LlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7R2VuZXJhdGVSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8R2VuZXJhdGVSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8R2VuZXJhdGVSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3JcbiAgICogYW4gQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlKHJlcXVlc3QpIHtcbiAgICBpZiAocmVxdWVzdC5pbWFnZXMpIHtcbiAgICAgIHJlcXVlc3QuaW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdC5pbWFnZXMubWFwKHRoaXMuZW5jb2RlSW1hZ2UuYmluZCh0aGlzKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJnZW5lcmF0ZVwiLCByZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogQ2hhdHMgd2l0aCB0aGUgbW9kZWwuIFRoZSByZXF1ZXN0IG9iamVjdCBjYW4gY29udGFpbiBtZXNzYWdlcyB3aXRoIGltYWdlcyB0aGF0IGFyZSBlaXRoZXJcbiAgICogVWludDhBcnJheXMgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5ncy4gVGhlIGltYWdlcyB3aWxsIGJlIGJhc2U2NCBlbmNvZGVkIGJlZm9yZSBzZW5kaW5nIHRoZVxuICAgKiByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7Q2hhdFJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDaGF0UmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPENoYXRSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3IgYW5cbiAgICogQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIGNoYXQocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0Lm1lc3NhZ2VzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcmVxdWVzdC5tZXNzYWdlcykge1xuICAgICAgICBpZiAobWVzc2FnZS5pbWFnZXMpIHtcbiAgICAgICAgICBtZXNzYWdlLmltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgbWVzc2FnZS5pbWFnZXMubWFwKHRoaXMuZW5jb2RlSW1hZ2UuYmluZCh0aGlzKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcImNoYXRcIiwgcmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbW9kZWwgZnJvbSBhIHN0cmVhbSBvZiBkYXRhLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7Q3JlYXRlUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFByb2dyZXNzUmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFByb2dyZXNzUmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGEgc3RyZWFtIG9mIHByb2dyZXNzIHJlc3BvbnNlcy5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZShyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmVhbWFibGVSZXF1ZXN0KFwiY3JlYXRlXCIsIHtcbiAgICAgIC4uLnJlcXVlc3RcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHVsbHMgYSBtb2RlbCBmcm9tIHRoZSBPbGxhbWEgcmVnaXN0cnkuIFRoZSByZXF1ZXN0IG9iamVjdCBjYW4gY29udGFpbiBhIHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIGlmIHRoZVxuICAgKiByZXNwb25zZSBzaG91bGQgYmUgc3RyZWFtZWQuXG4gICAqIEBwYXJhbSByZXF1ZXN0IHtQdWxsUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFByb2dyZXNzUmVzcG9uc2UgfCBBYm9ydGFibGVBc3luY0l0ZXJhdG9yPFByb2dyZXNzUmVzcG9uc2U+Pn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IG9yXG4gICAqIGFuIEFib3J0YWJsZUFzeW5jSXRlcmF0b3IgdGhhdCB5aWVsZHMgcmVzcG9uc2UgbWVzc2FnZXMuXG4gICAqL1xuICBhc3luYyBwdWxsKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtYWJsZVJlcXVlc3QoXCJwdWxsXCIsIHtcbiAgICAgIG5hbWU6IHJlcXVlc3QubW9kZWwsXG4gICAgICBzdHJlYW06IHJlcXVlc3Quc3RyZWFtLFxuICAgICAgaW5zZWN1cmU6IHJlcXVlc3QuaW5zZWN1cmVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHVzaGVzIGEgbW9kZWwgdG8gdGhlIE9sbGFtYSByZWdpc3RyeS4gVGhlIHJlcXVlc3Qgb2JqZWN0IGNhbiBjb250YWluIGEgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlXG4gICAqIHJlc3BvbnNlIHNob3VsZCBiZSBzdHJlYW1lZC5cbiAgICogQHBhcmFtIHJlcXVlc3Qge1B1c2hSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8UHJvZ3Jlc3NSZXNwb25zZSB8IEFib3J0YWJsZUFzeW5jSXRlcmF0b3I8UHJvZ3Jlc3NSZXNwb25zZT4+fSAtIFRoZSByZXNwb25zZSBvYmplY3Qgb3JcbiAgICogYW4gQWJvcnRhYmxlQXN5bmNJdGVyYXRvciB0aGF0IHlpZWxkcyByZXNwb25zZSBtZXNzYWdlcy5cbiAgICovXG4gIGFzeW5jIHB1c2gocmVxdWVzdCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJlYW1hYmxlUmVxdWVzdChcInB1c2hcIiwge1xuICAgICAgbmFtZTogcmVxdWVzdC5tb2RlbCxcbiAgICAgIHN0cmVhbTogcmVxdWVzdC5zdHJlYW0sXG4gICAgICBpbnNlY3VyZTogcmVxdWVzdC5pbnNlY3VyZVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbW9kZWwgZnJvbSB0aGUgc2VydmVyLiBUaGUgcmVxdWVzdCBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvXG4gICAqIGRlbGV0ZS5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0RlbGV0ZVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdGF0dXNSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZShyZXF1ZXN0KSB7XG4gICAgYXdhaXQgZGVsKFxuICAgICAgdGhpcy5mZXRjaCxcbiAgICAgIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9kZWxldGVgLFxuICAgICAgeyBuYW1lOiByZXF1ZXN0Lm1vZGVsIH0sXG4gICAgICB7IGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnMgfVxuICAgICk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9O1xuICB9XG4gIC8qKlxuICAgKiBDb3BpZXMgYSBtb2RlbCBmcm9tIG9uZSBuYW1lIHRvIGFub3RoZXIuIFRoZSByZXF1ZXN0IG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgbmFtZSBvZiB0aGVcbiAgICogbW9kZWwgdG8gY29weSBhbmQgdGhlIG5ldyBuYW1lLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7Q29weVJlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTdGF0dXNSZXNwb25zZT59IC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGNvcHkocmVxdWVzdCkge1xuICAgIGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL2NvcHlgLCB7IC4uLnJlcXVlc3QgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiB7IHN0YXR1czogXCJzdWNjZXNzXCIgfTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgdGhlIG1vZGVscyBvbiB0aGUgc2VydmVyLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0UmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIG1pc3NpbmcuXG4gICAqL1xuICBhc3luYyBsaXN0KCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS90YWdzYCwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBtZXRhZGF0YSBvZiBhIG1vZGVsLiBUaGUgcmVxdWVzdCBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG5hbWUgb2YgdGhlIG1vZGVsLlxuICAgKiBAcGFyYW0gcmVxdWVzdCB7U2hvd1JlcXVlc3R9IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaG93UmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBzaG93KHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy5jb25maWcuaG9zdH0vYXBpL3Nob3dgLCB7XG4gICAgICAuLi5yZXF1ZXN0XG4gICAgfSwge1xuICAgICAgaGVhZGVyczogdGhpcy5jb25maWcuaGVhZGVyc1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEVtYmVkcyB0ZXh0IGlucHV0IGludG8gdmVjdG9ycy5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0VtYmVkUmVxdWVzdH0gLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEVtYmVkUmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqL1xuICBhc3luYyBlbWJlZChyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9lbWJlZGAsIHtcbiAgICAgIC4uLnJlcXVlc3RcbiAgICB9LCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRW1iZWRzIGEgdGV4dCBwcm9tcHQgaW50byBhIHZlY3Rvci5cbiAgICogQHBhcmFtIHJlcXVlc3Qge0VtYmVkZGluZ3NSZXF1ZXN0fSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8RW1iZWRkaW5nc1Jlc3BvbnNlPn0gLSBUaGUgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgZW1iZWRkaW5ncyhyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMuY29uZmlnLmhvc3R9L2FwaS9lbWJlZGRpbmdzYCwge1xuICAgICAgLi4ucmVxdWVzdFxuICAgIH0sIHtcbiAgICAgIGhlYWRlcnM6IHRoaXMuY29uZmlnLmhlYWRlcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgcnVubmluZyBtb2RlbHMgb24gdGhlIHNlcnZlclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0UmVzcG9uc2U+fSAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIG1pc3NpbmcuXG4gICAqL1xuICBhc3luYyBwcygpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLmNvbmZpZy5ob3N0fS9hcGkvcHNgLCB7XG4gICAgICBoZWFkZXJzOiB0aGlzLmNvbmZpZy5oZWFkZXJzXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfVxufTtcbmNvbnN0IGJyb3dzZXIgPSBuZXcgT2xsYW1hJDEoKTtcblxuZXhwb3J0IHsgT2xsYW1hJDEgYXMgT2xsYW1hLCBicm93c2VyIGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBSdW5uYWJsZSwgfSBmcm9tIFwiLi4vcnVubmFibGVzL2Jhc2UuanNcIjtcbmltcG9ydCB7IGlzWm9kU2NoZW1hIH0gZnJvbSBcIi4uL3V0aWxzL3R5cGVzL2lzX3pvZF9zY2hlbWEuanNcIjtcbi8qKlxuICogQ29uZmlybSB3aGV0aGVyIHRoZSBpbnB1dHRlZCB0b29sIGlzIGFuIGluc3RhbmNlIG9mIGBTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZSB8IEpTT05TY2hlbWEgfCB1bmRlZmluZWR9IHRvb2wgVGhlIHRvb2wgdG8gY2hlY2sgaWYgaXQgaXMgYW4gaW5zdGFuY2Ugb2YgYFN0cnVjdHVyZWRUb29sSW50ZXJmYWNlYC5cbiAqIEByZXR1cm5zIHt0b29sIGlzIFN0cnVjdHVyZWRUb29sSW50ZXJmYWNlfSBXaGV0aGVyIHRoZSBpbnB1dHRlZCB0b29sIGlzIGFuIGluc3RhbmNlIG9mIGBTdHJ1Y3R1cmVkVG9vbEludGVyZmFjZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cnVjdHVyZWRUb29sKHRvb2wpIHtcbiAgICByZXR1cm4gKHRvb2wgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHRvb2wubGNfbmFtZXNwYWNlKSk7XG59XG4vKipcbiAqIENvbmZpcm0gd2hldGhlciB0aGUgaW5wdXR0ZWQgdG9vbCBpcyBhbiBpbnN0YW5jZSBvZiBgUnVubmFibGVUb29sTGlrZWAuXG4gKlxuICogQHBhcmFtIHt1bmtub3duIHwgdW5kZWZpbmVkfSB0b29sIFRoZSB0b29sIHRvIGNoZWNrIGlmIGl0IGlzIGFuIGluc3RhbmNlIG9mIGBSdW5uYWJsZVRvb2xMaWtlYC5cbiAqIEByZXR1cm5zIHt0b29sIGlzIFJ1bm5hYmxlVG9vbExpa2V9IFdoZXRoZXIgdGhlIGlucHV0dGVkIHRvb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYFJ1bm5hYmxlVG9vbExpa2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSdW5uYWJsZVRvb2xMaWtlKHRvb2wpIHtcbiAgICByZXR1cm4gKHRvb2wgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBSdW5uYWJsZS5pc1J1bm5hYmxlKHRvb2wpICYmXG4gICAgICAgIFwibGNfbmFtZVwiIGluIHRvb2wuY29uc3RydWN0b3IgJiZcbiAgICAgICAgdHlwZW9mIHRvb2wuY29uc3RydWN0b3IubGNfbmFtZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHRvb2wuY29uc3RydWN0b3IubGNfbmFtZSgpID09PSBcIlJ1bm5hYmxlVG9vbExpa2VcIik7XG59XG4vKipcbiAqIENvbmZpcm0gd2hldGhlciBvciBub3QgdGhlIHRvb2wgY29udGFpbnMgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzIHRvIGJlIGNvbnNpZGVyZWQgYSBgU3RydWN0dXJlZFRvb2xQYXJhbXNgLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93biB8IHVuZGVmaW5lZH0gdG9vbCBUaGUgb2JqZWN0IHRvIGNoZWNrIGlmIGl0IGlzIGEgYFN0cnVjdHVyZWRUb29sUGFyYW1zYC5cbiAqIEByZXR1cm5zIHt0b29sIGlzIFN0cnVjdHVyZWRUb29sUGFyYW1zfSBXaGV0aGVyIHRoZSBpbnB1dHRlZCBvYmplY3QgaXMgYSBgU3RydWN0dXJlZFRvb2xQYXJhbXNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtcyh0b29sKSB7XG4gICAgcmV0dXJuICghIXRvb2wgJiZcbiAgICAgICAgdHlwZW9mIHRvb2wgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgXCJuYW1lXCIgaW4gdG9vbCAmJlxuICAgICAgICBcInNjaGVtYVwiIGluIHRvb2wgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKGlzWm9kU2NoZW1hKHRvb2wuc2NoZW1hKSB8fFxuICAgICAgICAgICAgKHRvb2wuc2NoZW1hICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdG9vbC5zY2hlbWEgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICBcInR5cGVcIiBpbiB0b29sLnNjaGVtYSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0b29sLnNjaGVtYS50eXBlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgW1wibnVsbFwiLCBcImJvb2xlYW5cIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcIm51bWJlclwiLCBcInN0cmluZ1wiXS5pbmNsdWRlcyh0b29sLnNjaGVtYS50eXBlKSkpKTtcbn1cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHRvb2wgaXMgb25lIG9mIFN0cnVjdHVyZWRUb29sLCBSdW5uYWJsZVRvb2wgb3IgU3RydWN0dXJlZFRvb2xQYXJhbXMuXG4gKiBJdCByZXR1cm5zIGBpcyBTdHJ1Y3R1cmVkVG9vbFBhcmFtc2Agc2luY2UgdGhhdCBpcyB0aGUgbW9zdCBtaW5pbWFsIGludGVyZmFjZSBvZiB0aGUgdGhyZWUsXG4gKiB3aGlsZSBzdGlsbCBjb250YWluaW5nIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllcyB0byBiZSBwYXNzZWQgdG8gYSBMTE0gZm9yIHRvb2wgY2FsbGluZy5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd24gfCB1bmRlZmluZWR9IHRvb2wgVGhlIHRvb2wgdG8gY2hlY2sgaWYgaXQgaXMgYSBMYW5nQ2hhaW4gdG9vbC5cbiAqIEByZXR1cm5zIHt0b29sIGlzIFN0cnVjdHVyZWRUb29sUGFyYW1zfSBXaGV0aGVyIHRoZSBpbnB1dHRlZCB0b29sIGlzIGEgTGFuZ0NoYWluIHRvb2wuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xhbmdDaGFpblRvb2wodG9vbCkge1xuICAgIHJldHVybiAoaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtcyh0b29sKSB8fFxuICAgICAgICBpc1J1bm5hYmxlVG9vbExpa2UodG9vbCkgfHxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgaXNTdHJ1Y3R1cmVkVG9vbCh0b29sKSk7XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb21wYXJlU3RyaWN0KGEsIGIpIHtcbiAgICBjb25zdCB0eXBlb2ZhID0gdHlwZW9mIGE7XG4gICAgaWYgKHR5cGVvZmEgIT09IHR5cGVvZiBiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFkZWVwQ29tcGFyZVN0cmljdChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZmEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYUtleXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgYUtleXMpIHtcbiAgICAgICAgICAgIGlmICghZGVlcENvbXBhcmVTdHJpY3QoYVtrXSwgYltrXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufVxuIiwgImltcG9ydCB7IGVuY29kZVBvaW50ZXIgfSBmcm9tICcuL3BvaW50ZXIuanMnO1xuZXhwb3J0IGNvbnN0IHNjaGVtYUtleXdvcmQgPSB7XG4gICAgYWRkaXRpb25hbEl0ZW1zOiB0cnVlLFxuICAgIHVuZXZhbHVhdGVkSXRlbXM6IHRydWUsXG4gICAgaXRlbXM6IHRydWUsXG4gICAgY29udGFpbnM6IHRydWUsXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gICAgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiB0cnVlLFxuICAgIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gICAgbm90OiB0cnVlLFxuICAgIGlmOiB0cnVlLFxuICAgIHRoZW46IHRydWUsXG4gICAgZWxzZTogdHJ1ZVxufTtcbmV4cG9ydCBjb25zdCBzY2hlbWFBcnJheUtleXdvcmQgPSB7XG4gICAgcHJlZml4SXRlbXM6IHRydWUsXG4gICAgaXRlbXM6IHRydWUsXG4gICAgYWxsT2Y6IHRydWUsXG4gICAgYW55T2Y6IHRydWUsXG4gICAgb25lT2Y6IHRydWVcbn07XG5leHBvcnQgY29uc3Qgc2NoZW1hTWFwS2V5d29yZCA9IHtcbiAgICAkZGVmczogdHJ1ZSxcbiAgICBkZWZpbml0aW9uczogdHJ1ZSxcbiAgICBwcm9wZXJ0aWVzOiB0cnVlLFxuICAgIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICAgIGRlcGVuZGVudFNjaGVtYXM6IHRydWVcbn07XG5leHBvcnQgY29uc3QgaWdub3JlZEtleXdvcmQgPSB7XG4gICAgaWQ6IHRydWUsXG4gICAgJGlkOiB0cnVlLFxuICAgICRyZWY6IHRydWUsXG4gICAgJHNjaGVtYTogdHJ1ZSxcbiAgICAkYW5jaG9yOiB0cnVlLFxuICAgICR2b2NhYnVsYXJ5OiB0cnVlLFxuICAgICRjb21tZW50OiB0cnVlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgZW51bTogdHJ1ZSxcbiAgICBjb25zdDogdHJ1ZSxcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLFxuICAgIG1heGltdW06IHRydWUsXG4gICAgbWluaW11bTogdHJ1ZSxcbiAgICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICAgIGV4Y2x1c2l2ZU1pbmltdW06IHRydWUsXG4gICAgbXVsdGlwbGVPZjogdHJ1ZSxcbiAgICBtYXhMZW5ndGg6IHRydWUsXG4gICAgbWluTGVuZ3RoOiB0cnVlLFxuICAgIHBhdHRlcm46IHRydWUsXG4gICAgZm9ybWF0OiB0cnVlLFxuICAgIG1heEl0ZW1zOiB0cnVlLFxuICAgIG1pbkl0ZW1zOiB0cnVlLFxuICAgIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICAgIG1heFByb3BlcnRpZXM6IHRydWUsXG4gICAgbWluUHJvcGVydGllczogdHJ1ZVxufTtcbmV4cG9ydCBsZXQgaW5pdGlhbEJhc2VVUkkgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBzZWxmLmxvY2F0aW9uICYmXG4gICAgc2VsZi5sb2NhdGlvbi5vcmlnaW4gIT09ICdudWxsJ1xuICAgID9cbiAgICAgICAgbmV3IFVSTChzZWxmLmxvY2F0aW9uLm9yaWdpbiArIHNlbGYubG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2gpXG4gICAgOiBuZXcgVVJMKCdodHRwczovL2dpdGh1Yi5jb20vY2Z3b3JrZXInKTtcbmV4cG9ydCBmdW5jdGlvbiBkZXJlZmVyZW5jZShzY2hlbWEsIGxvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCksIGJhc2VVUkkgPSBpbml0aWFsQmFzZVVSSSwgYmFzZVBvaW50ZXIgPSAnJykge1xuICAgIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICBjb25zdCBpZCA9IHNjaGVtYS4kaWQgfHwgc2NoZW1hLmlkO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaWQsIGJhc2VVUkkuaHJlZik7XG4gICAgICAgICAgICBpZiAodXJsLmhhc2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGxvb2t1cFt1cmwuaHJlZl0gPSBzY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwuaGFzaCA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlUG9pbnRlciA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVSSSA9IHVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcmVmZXJlbmNlKHNjaGVtYSwgbG9va3VwLCBiYXNlVVJJKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hICE9PSB0cnVlICYmIHNjaGVtYSAhPT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hVVJJID0gYmFzZVVSSS5ocmVmICsgKGJhc2VQb2ludGVyID8gJyMnICsgYmFzZVBvaW50ZXIgOiAnJyk7XG4gICAgaWYgKGxvb2t1cFtzY2hlbWFVUkldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgc2NoZW1hIFVSSSBcIiR7c2NoZW1hVVJJfVwiLmApO1xuICAgIH1cbiAgICBsb29rdXBbc2NoZW1hVVJJXSA9IHNjaGVtYTtcbiAgICBpZiAoc2NoZW1hID09PSB0cnVlIHx8IHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5fX2Fic29sdXRlX3VyaV9fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjaGVtYSwgJ19fYWJzb2x1dGVfdXJpX18nLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBzY2hlbWFVUklcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWEuJHJlZiAmJiBzY2hlbWEuX19hYnNvbHV0ZV9yZWZfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoc2NoZW1hLiRyZWYsIGJhc2VVUkkuaHJlZik7XG4gICAgICAgIHVybC5oYXNoID0gdXJsLmhhc2g7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY2hlbWEsICdfX2Fic29sdXRlX3JlZl9fJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdXJsLmhyZWZcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWEuJHJlY3Vyc2l2ZVJlZiAmJiBzY2hlbWEuX19hYnNvbHV0ZV9yZWN1cnNpdmVfcmVmX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHNjaGVtYS4kcmVjdXJzaXZlUmVmLCBiYXNlVVJJLmhyZWYpO1xuICAgICAgICB1cmwuaGFzaCA9IHVybC5oYXNoO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NoZW1hLCAnX19hYnNvbHV0ZV9yZWN1cnNpdmVfcmVmX18nLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiB1cmwuaHJlZlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS4kYW5jaG9yKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoJyMnICsgc2NoZW1hLiRhbmNob3IsIGJhc2VVUkkuaHJlZik7XG4gICAgICAgIGxvb2t1cFt1cmwuaHJlZl0gPSBzY2hlbWE7XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGlnbm9yZWRLZXl3b3JkW2tleV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleUJhc2UgPSBgJHtiYXNlUG9pbnRlcn0vJHtlbmNvZGVQb2ludGVyKGtleSl9YDtcbiAgICAgICAgY29uc3Qgc3ViU2NoZW1hID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YlNjaGVtYSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFBcnJheUtleXdvcmRba2V5XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHN1YlNjaGVtYS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkZXJlZmVyZW5jZShzdWJTY2hlbWFbaV0sIGxvb2t1cCwgYmFzZVVSSSwgYCR7a2V5QmFzZX0vJHtpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWFNYXBLZXl3b3JkW2tleV0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHN1YktleSBpbiBzdWJTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBkZXJlZmVyZW5jZShzdWJTY2hlbWFbc3ViS2V5XSwgbG9va3VwLCBiYXNlVVJJLCBgJHtrZXlCYXNlfS8ke2VuY29kZVBvaW50ZXIoc3ViS2V5KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcmVmZXJlbmNlKHN1YlNjaGVtYSwgbG9va3VwLCBiYXNlVVJJLCBrZXlCYXNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9va3VwO1xufVxuIiwgImNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC87XG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuY29uc3QgVElNRSA9IC9eKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkoXFwuXFxkKyk/KHp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaTtcbmNvbnN0IEhPU1ROQU1FID0gL14oPz0uezEsMjUzfVxcLj8kKVthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86Wy0wLTlhLXpdezAsNjF9WzAtOWEtel0pPykqXFwuPyQvaTtcbmNvbnN0IFVSSVJFRiA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopPyg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopPyg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG5jb25zdCBVUklURU1QTEFURSA9IC9eKD86KD86W15cXHgwMC1cXHgyMFwiJzw+JVxcXFxeYHt8fV18JVswLTlhLWZdezJ9KXxcXHtbKyMuLzs/Jj0sIUB8XT8oPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KD86LCg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8pKlxcfSkqJC9pO1xuY29uc3QgVVJMXyA9IC9eKD86KD86aHR0cHM/fGZ0cCk6XFwvXFwvKSg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hMTAoPzpcXC5cXGR7MSwzfSl7M30pKD8hMTI3KD86XFwuXFxkezEsM30pezN9KSg/ITE2OVxcLjI1NCg/OlxcLlxcZHsxLDN9KXsyfSkoPyExOTJcXC4xNjgoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn0wLTldKy0/KSpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfTAtOV0rKSg/OlxcLig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9MC05XSstPykqW2EtelxcdXswMGExfS1cXHV7ZmZmZn0wLTldKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdTtcbmNvbnN0IFVVSUQgPSAvXig/OnVybjp1dWlkOik/WzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQvaTtcbmNvbnN0IEpTT05fUE9JTlRFUiA9IC9eKD86XFwvKD86W15+L118fjB8fjEpKikqJC87XG5jb25zdCBKU09OX1BPSU5URVJfVVJJX0ZSQUdNRU5UID0gL14jKD86XFwvKD86W2EtejAtOV9cXC0uISQmJygpKissOzo9QF18JVswLTlhLWZdezJ9fH4wfH4xKSopKiQvaTtcbmNvbnN0IFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKD86MHxbMS05XVswLTldKikoPzojfCg/OlxcLyg/Oltefi9dfH4wfH4xKSopKikkLztcbmNvbnN0IEVNQUlMID0gKGlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0WzBdID09PSAnXCInKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgW25hbWUsIGhvc3QsIC4uLnJlc3RdID0gaW5wdXQuc3BsaXQoJ0AnKTtcbiAgICBpZiAoIW5hbWUgfHxcbiAgICAgICAgIWhvc3QgfHxcbiAgICAgICAgcmVzdC5sZW5ndGggIT09IDAgfHxcbiAgICAgICAgbmFtZS5sZW5ndGggPiA2NCB8fFxuICAgICAgICBob3N0Lmxlbmd0aCA+IDI1MylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuYW1lWzBdID09PSAnLicgfHwgbmFtZS5lbmRzV2l0aCgnLicpIHx8IG5hbWUuaW5jbHVkZXMoJy4uJykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIS9eW2EtejAtOS4tXSskL2kudGVzdChob3N0KSB8fFxuICAgICAgICAhL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dKyQvaS50ZXN0KG5hbWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGhvc3RcbiAgICAgICAgLnNwbGl0KCcuJylcbiAgICAgICAgLmV2ZXJ5KHBhcnQgPT4gL15bYS16MC05XShbYS16MC05LV17MCw2MX1bYS16MC05XSk/JC9pLnRlc3QocGFydCkpO1xufTtcbmNvbnN0IElQVjQgPSAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvO1xuY29uc3QgSVBWNiA9IC9eKCgoWzAtOWEtZl17MSw0fTopezd9KFswLTlhLWZdezEsNH18OikpfCgoWzAtOWEtZl17MSw0fTopezZ9KDpbMC05YS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NX0oKCg6WzAtOWEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NH0oKCg6WzAtOWEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOWEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezN9KCgoOlswLTlhLWZdezEsNH0pezEsNH0pfCgoOlswLTlhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Mn0oKCg6WzAtOWEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsxfSgoKDpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05YS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg6KCgoOlswLTlhLWZdezEsNH0pezEsN30pfCgoOlswLTlhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpJC9pO1xuY29uc3QgRFVSQVRJT04gPSAoaW5wdXQpID0+IGlucHV0Lmxlbmd0aCA+IDEgJiZcbiAgICBpbnB1dC5sZW5ndGggPCA4MCAmJlxuICAgICgvXlBcXGQrKFsuLF1cXGQrKT9XJC8udGVzdChpbnB1dCkgfHxcbiAgICAgICAgKC9eUFtcXGRZTURUSFNdKihcXGRbLixdXFxkKyk/W1lNREhTXSQvLnRlc3QoaW5wdXQpICYmXG4gICAgICAgICAgICAvXlAoWy4sXFxkXStZKT8oWy4sXFxkXStNKT8oWy4sXFxkXStEKT8oVChbLixcXGRdK0gpPyhbLixcXGRdK00pPyhbLixcXGRdK1MpPyk/JC8udGVzdChpbnB1dCkpKTtcbmZ1bmN0aW9uIGJpbmQocikge1xuICAgIHJldHVybiByLnRlc3QuYmluZChyKTtcbn1cbmV4cG9ydCBjb25zdCBmb3JtYXQgPSB7XG4gICAgZGF0ZSxcbiAgICB0aW1lOiB0aW1lLmJpbmQodW5kZWZpbmVkLCBmYWxzZSksXG4gICAgJ2RhdGUtdGltZSc6IGRhdGVfdGltZSxcbiAgICBkdXJhdGlvbjogRFVSQVRJT04sXG4gICAgdXJpLFxuICAgICd1cmktcmVmZXJlbmNlJzogYmluZChVUklSRUYpLFxuICAgICd1cmktdGVtcGxhdGUnOiBiaW5kKFVSSVRFTVBMQVRFKSxcbiAgICB1cmw6IGJpbmQoVVJMXyksXG4gICAgZW1haWw6IEVNQUlMLFxuICAgIGhvc3RuYW1lOiBiaW5kKEhPU1ROQU1FKSxcbiAgICBpcHY0OiBiaW5kKElQVjQpLFxuICAgIGlwdjY6IGJpbmQoSVBWNiksXG4gICAgcmVnZXg6IHJlZ2V4LFxuICAgIHV1aWQ6IGJpbmQoVVVJRCksXG4gICAgJ2pzb24tcG9pbnRlcic6IGJpbmQoSlNPTl9QT0lOVEVSKSxcbiAgICAnanNvbi1wb2ludGVyLXVyaS1mcmFnbWVudCc6IGJpbmQoSlNPTl9QT0lOVEVSX1VSSV9GUkFHTUVOVCksXG4gICAgJ3JlbGF0aXZlLWpzb24tcG9pbnRlcic6IGJpbmQoUkVMQVRJVkVfSlNPTl9QT0lOVEVSKVxufTtcbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmZ1bmN0aW9uIGRhdGUoc3RyKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHN0ci5tYXRjaChEQVRFKTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB5ZWFyID0gK21hdGNoZXNbMV07XG4gICAgY29uc3QgbW9udGggPSArbWF0Y2hlc1syXTtcbiAgICBjb25zdCBkYXkgPSArbWF0Y2hlc1szXTtcbiAgICByZXR1cm4gKG1vbnRoID49IDEgJiZcbiAgICAgICAgbW9udGggPD0gMTIgJiZcbiAgICAgICAgZGF5ID49IDEgJiZcbiAgICAgICAgZGF5IDw9IChtb250aCA9PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKSk7XG59XG5mdW5jdGlvbiB0aW1lKGZ1bGwsIHN0cikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2goVElNRSk7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaG91ciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1pbnV0ZSA9ICttYXRjaGVzWzJdO1xuICAgIGNvbnN0IHNlY29uZCA9ICttYXRjaGVzWzNdO1xuICAgIGNvbnN0IHRpbWVab25lID0gISFtYXRjaGVzWzVdO1xuICAgIHJldHVybiAoKChob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTkpIHx8XG4gICAgICAgIChob3VyID09IDIzICYmIG1pbnV0ZSA9PSA1OSAmJiBzZWNvbmQgPT0gNjApKSAmJlxuICAgICAgICAoIWZ1bGwgfHwgdGltZVpvbmUpKTtcbn1cbmNvbnN0IERBVEVfVElNRV9TRVBBUkFUT1IgPSAvdHxcXHMvaTtcbmZ1bmN0aW9uIGRhdGVfdGltZShzdHIpIHtcbiAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICByZXR1cm4gZGF0ZVRpbWUubGVuZ3RoID09IDIgJiYgZGF0ZShkYXRlVGltZVswXSkgJiYgdGltZSh0cnVlLCBkYXRlVGltZVsxXSk7XG59XG5jb25zdCBOT1RfVVJJX0ZSQUdNRU5UID0gL1xcL3w6LztcbmNvbnN0IFVSSV9QQVRURVJOID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKSg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgICByZXR1cm4gTk9UX1VSSV9GUkFHTUVOVC50ZXN0KHN0cikgJiYgVVJJX1BBVFRFUk4udGVzdChzdHIpO1xufVxuY29uc3QgWl9BTkNIT1IgPSAvW15cXFxcXVxcXFxaLztcbmZ1bmN0aW9uIHJlZ2V4KHN0cikge1xuICAgIGlmIChaX0FOQ0hPUi50ZXN0KHN0cikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHN0ciwgJ3UnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCAiZXhwb3J0IHZhciBPdXRwdXRGb3JtYXQ7XG4oZnVuY3Rpb24gKE91dHB1dEZvcm1hdCkge1xuICAgIE91dHB1dEZvcm1hdFtPdXRwdXRGb3JtYXRbXCJGbGFnXCJdID0gMV0gPSBcIkZsYWdcIjtcbiAgICBPdXRwdXRGb3JtYXRbT3V0cHV0Rm9ybWF0W1wiQmFzaWNcIl0gPSAyXSA9IFwiQmFzaWNcIjtcbiAgICBPdXRwdXRGb3JtYXRbT3V0cHV0Rm9ybWF0W1wiRGV0YWlsZWRcIl0gPSA0XSA9IFwiRGV0YWlsZWRcIjtcbn0pKE91dHB1dEZvcm1hdCB8fCAoT3V0cHV0Rm9ybWF0ID0ge30pKTtcbiIsICJpbXBvcnQgeyB6b2RUb0pzb25TY2hlbWEgfSBmcm9tIFwiem9kLXRvLWpzb24tc2NoZW1hXCI7XG5pbXBvcnQgeyBkZXJlZmVyZW5jZSB9IGZyb20gXCJAY2Z3b3JrZXIvanNvbi1zY2hlbWFcIjtcbmltcG9ydCB7IGlzWm9kU2NoZW1hIH0gZnJvbSBcIi4vdHlwZXMvaXNfem9kX3NjaGVtYS5qc1wiO1xuZXhwb3J0IHsgZGVlcENvbXBhcmVTdHJpY3QsIFZhbGlkYXRvciB9IGZyb20gXCJAY2Z3b3JrZXIvanNvbi1zY2hlbWFcIjtcbi8qKlxuICogQ29udmVydHMgYSBab2Qgc2NoZW1hIG9yIEpTT04gc2NoZW1hIHRvIGEgSlNPTiBzY2hlbWEuXG4gKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBzY2hlbWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0pzb25TY2hlbWEoc2NoZW1hKSB7XG4gICAgaWYgKGlzWm9kU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHpvZFRvSnNvblNjaGVtYShzY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgaWYgYSBKU09OIHNjaGVtYSB2YWxpZGF0ZXMgb25seSBzdHJpbmdzLiBNYXkgcmV0dXJuIGZhbHNlIG5lZ2F0aXZlcyBpbiBzb21lIGVkZ2UgY2FzZXNcbiAqIChsaWtlIHJlY3Vyc2l2ZSBvciB1bnJlc29sdmFibGUgcmVmcykuXG4gKlxuICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gdmFsaWRhdGUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNjaGVtYSB2YWxpZGF0ZXMgb25seSBzdHJpbmdzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlc09ubHlTdHJpbmdzKHNjaGVtYSkge1xuICAgIC8vIE51bGwsIHVuZGVmaW5lZCwgb3IgZW1wdHkgc2NoZW1hXG4gICAgaWYgKCFzY2hlbWEgfHxcbiAgICAgICAgdHlwZW9mIHNjaGVtYSAhPT0gXCJvYmplY3RcIiB8fFxuICAgICAgICBPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBWYWxpZGF0ZXMgYW55dGhpbmcsIG5vdCBqdXN0IHN0cmluZ3NcbiAgICB9XG4gICAgLy8gRXhwbGljaXQgdHlwZSBjb25zdHJhaW50XG4gICAgaWYgKFwidHlwZVwiIGluIHNjaGVtYSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnR5cGUgPT09IFwic3RyaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICAvLyBub3Qgc3VyZSB3aHkgc29tZW9uZSB3b3VsZCBkbyBgXCJ0eXBlXCI6IFtcInN0cmluZ1wiXWAgb3IgZXNwZWNpYWxseSBgXCJ0eXBlXCI6IFtcInN0cmluZ1wiLFxuICAgICAgICAgICAgLy8gXCJzdHJpbmdcIiwgXCJzdHJpbmdcIiwgLi4uXWAgYnV0IHdlJ3JlIG5vdCBoZXJlIHRvIGp1ZGdlXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnR5cGUuZXZlcnkoKHQpID0+IHQgPT09IFwic3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gSW52YWxpZCBvciBub24tc3RyaW5nIHR5cGVcbiAgICB9XG4gICAgLy8gRW51bSB3aXRoIG9ubHkgc3RyaW5nIHZhbHVlc1xuICAgIGlmIChcImVudW1cIiBpbiBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSAmJlxuICAgICAgICAgICAgc2NoZW1hLmVudW0ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgc2NoZW1hLmVudW0uZXZlcnkoKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikpO1xuICAgIH1cbiAgICAvLyBTdHJpbmcgY29uc3RhbnRcbiAgICBpZiAoXCJjb25zdFwiIGluIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgLy8gU2NoZW1hIGNvbWJpbmF0aW9uc1xuICAgIGlmIChcImFsbE9mXCIgaW4gc2NoZW1hICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSkge1xuICAgICAgICAvLyBJZiBhbnkgc3Vic2NoZW1hIHZhbGlkYXRlcyBvbmx5IHN0cmluZ3MsIHRoZW4gdGhlIG92ZXJhbGwgc2NoZW1hIHZhbGlkYXRlcyBvbmx5IHN0cmluZ3NcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5hbGxPZi5zb21lKChzdWJzY2hlbWEpID0+IHZhbGlkYXRlc09ubHlTdHJpbmdzKHN1YnNjaGVtYSkpO1xuICAgIH1cbiAgICBpZiAoKFwiYW55T2ZcIiBpbiBzY2hlbWEgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpKSB8fFxuICAgICAgICAoXCJvbmVPZlwiIGluIHNjaGVtYSAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjaGVtYXMgPSAoXCJhbnlPZlwiIGluIHNjaGVtYSA/IHNjaGVtYS5hbnlPZiA6IHNjaGVtYS5vbmVPZik7XG4gICAgICAgIC8vIEFsbCBzdWJzY2hlbWFzIG11c3QgdmFsaWRhdGUgb25seSBzdHJpbmdzXG4gICAgICAgIHJldHVybiAoc3Vic2NoZW1hcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBzdWJzY2hlbWFzLmV2ZXJ5KChzdWJzY2hlbWEpID0+IHZhbGlkYXRlc09ubHlTdHJpbmdzKHN1YnNjaGVtYSkpKTtcbiAgICB9XG4gICAgLy8gV2UncmUgbm90IGdvaW5nIHRvIHRyeSBvbiB0aGlzIG9uZSwgaXQncyB0b28gY29tcGxleCAtIHdlIGp1c3QgYXNzdW1lIGlmIGl0IGhhcyBhIFwibm90XCIga2V5IGFuZCBoYXNuJ3QgbWF0Y2hlZCBvbmUgb2YgdGhlIGFib3ZlIGNoZWNrcywgaXQncyBub3QgYSBzdHJpbmcgc2NoZW1hLlxuICAgIGlmIChcIm5vdFwiIGluIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRoZSBub3QgY2FzZSBjYW4gdmFsaWRhdGUgbm9uLXN0cmluZ3NcbiAgICB9XG4gICAgaWYgKFwiJHJlZlwiIGluIHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hLiRyZWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgcmVmID0gc2NoZW1hLiRyZWY7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gZGVyZWZlcmVuY2Uoc2NoZW1hKTtcbiAgICAgICAgaWYgKHJlc29sdmVkW3JlZl0pIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZXNPbmx5U3RyaW5ncyhyZXNvbHZlZFtyZWZdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGlnbm9yZSByZWN1cnNpdmUgcmVmcyBhbmQgb3RoZXIgY2FzZXMgd2hlcmUgdHlwZSBpcyBvbWl0dGVkIGZvciBub3dcbiAgICAvLyBpZ25vcmUgb3RoZXIgY2FzZXMgZm9yIG5vdyB3aGVyZSB0eXBlIGlzIG9taXR0ZWRcbiAgICByZXR1cm4gZmFsc2U7XG59XG4iLCAiaW1wb3J0IHsgaXNMYW5nQ2hhaW5Ub29sLCB9IGZyb20gXCIuLi90b29scy90eXBlcy5qc1wiO1xuaW1wb3J0IHsgdG9Kc29uU2NoZW1hIH0gZnJvbSBcIi4vanNvbl9zY2hlbWEuanNcIjtcbi8vIFRoZXNlIHV0aWxpdHkgZnVuY3Rpb25zIHdlcmUgbW92ZWQgdG8gYSBtb3JlIGFwcHJvcHJpYXRlIGxvY2F0aW9uLFxuLy8gYnV0IHdlIHN0aWxsIGV4cG9ydCB0aGVtIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuZXhwb3J0IHsgaXNTdHJ1Y3R1cmVkVG9vbCwgaXNTdHJ1Y3R1cmVkVG9vbFBhcmFtcywgaXNSdW5uYWJsZVRvb2xMaWtlLCBpc0xhbmdDaGFpblRvb2wsIH0gZnJvbSBcIi4uL3Rvb2xzL3R5cGVzLmpzXCI7XG4vKipcbiAqIEZvcm1hdHMgYSBgU3RydWN0dXJlZFRvb2xgIG9yIGBSdW5uYWJsZVRvb2xMaWtlYCBpbnN0YW5jZSBpbnRvIGEgZm9ybWF0XG4gKiB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBPcGVuQUkgZnVuY3Rpb24gY2FsbGluZy4gSWYgYFN0cnVjdHVyZWRUb29sYCBvclxuICogYFJ1bm5hYmxlVG9vbExpa2VgIGhhcyBhIHpvZCBzY2hlbWEsIGl0IHVzZXMgdGhlIGB6b2RUb0pzb25TY2hlbWFgXG4gKiBmdW5jdGlvbiB0byBjb252ZXJ0IHRoZSBzY2hlbWEgb2YgdGhlIGBTdHJ1Y3R1cmVkVG9vbGAgb3IgYFJ1bm5hYmxlVG9vbExpa2VgXG4gKiBpbnRvIGEgSlNPTiBzY2hlbWEsIHdoaWNoIGlzIHRoZW4gdXNlZCBhcyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIE9wZW5BSSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdHVyZWRUb29sSW50ZXJmYWNlIHwgUnVubmFibGVUb29sTGlrZX0gdG9vbCBUaGUgdG9vbCB0byBjb252ZXJ0IHRvIGFuIE9wZW5BSSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbkRlZmluaXRpb259IFRoZSBpbnB1dHRlZCB0b29sIGluIE9wZW5BSSBmdW5jdGlvbiBmb3JtYXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9PcGVuQUlGdW5jdGlvbih0b29sLCBmaWVsZHMpIHtcbiAgICAvLyBAVE9ETyAwLjMuMCBSZW1vdmUgdGhlIGBudW1iZXJgIHR5cGluZ1xuICAgIGNvbnN0IGZpZWxkc0NvcHkgPSB0eXBlb2YgZmllbGRzID09PSBcIm51bWJlclwiID8gdW5kZWZpbmVkIDogZmllbGRzO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHRvb2wubmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXG4gICAgICAgIHBhcmFtZXRlcnM6IHRvSnNvblNjaGVtYSh0b29sLnNjaGVtYSksXG4gICAgICAgIC8vIERvIG5vdCBpbmNsdWRlIHRoZSBgc3RyaWN0YCBmaWVsZCBpZiBpdCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgICAgLi4uKGZpZWxkc0NvcHk/LnN0cmljdCAhPT0gdW5kZWZpbmVkID8geyBzdHJpY3Q6IGZpZWxkc0NvcHkuc3RyaWN0IH0gOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogRm9ybWF0cyBhIGBTdHJ1Y3R1cmVkVG9vbGAgb3IgYFJ1bm5hYmxlVG9vbExpa2VgIGluc3RhbmNlIGludG8gYVxuICogZm9ybWF0IHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIE9wZW5BSSB0b29sIGNhbGxpbmcuIElmIGBTdHJ1Y3R1cmVkVG9vbGAgb3JcbiAqIGBSdW5uYWJsZVRvb2xMaWtlYCBoYXMgYSB6b2Qgc2NoZW1hLCBpdCB1c2VzIHRoZSBgem9kVG9Kc29uU2NoZW1hYFxuICogZnVuY3Rpb24gdG8gY29udmVydCB0aGUgc2NoZW1hIG9mIHRoZSBgU3RydWN0dXJlZFRvb2xgIG9yIGBSdW5uYWJsZVRvb2xMaWtlYFxuICogaW50byBhIEpTT04gc2NoZW1hLCB3aGljaCBpcyB0aGVuIHVzZWQgYXMgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBPcGVuQUkgdG9vbC5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdHVyZWRUb29sSW50ZXJmYWNlIHwgUmVjb3JkPHN0cmluZywgYW55PiB8IFJ1bm5hYmxlVG9vbExpa2V9IHRvb2wgVGhlIHRvb2wgdG8gY29udmVydCB0byBhbiBPcGVuQUkgdG9vbC5cbiAqIEByZXR1cm5zIHtUb29sRGVmaW5pdGlvbn0gVGhlIGlucHV0dGVkIHRvb2wgaW4gT3BlbkFJIHRvb2wgZm9ybWF0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvT3BlbkFJVG9vbChcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG50b29sLCBmaWVsZHMpIHtcbiAgICAvLyBAVE9ETyAwLjMuMCBSZW1vdmUgdGhlIGBudW1iZXJgIHR5cGluZ1xuICAgIGNvbnN0IGZpZWxkc0NvcHkgPSB0eXBlb2YgZmllbGRzID09PSBcIm51bWJlclwiID8gdW5kZWZpbmVkIDogZmllbGRzO1xuICAgIGxldCB0b29sRGVmO1xuICAgIGlmIChpc0xhbmdDaGFpblRvb2wodG9vbCkpIHtcbiAgICAgICAgdG9vbERlZiA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIGZ1bmN0aW9uOiBjb252ZXJ0VG9PcGVuQUlGdW5jdGlvbih0b29sKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRvb2xEZWYgPSB0b29sO1xuICAgIH1cbiAgICBpZiAoZmllbGRzQ29weT8uc3RyaWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdG9vbERlZi5mdW5jdGlvbi5zdHJpY3QgPSBmaWVsZHNDb3B5LnN0cmljdDtcbiAgICB9XG4gICAgcmV0dXJuIHRvb2xEZWY7XG59XG4iLCAiaW1wb3J0IHsgUnVubmFibGUgfSBmcm9tIFwiLi4vcnVubmFibGVzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBhZGRMYW5nQ2hhaW5FcnJvckZpZWxkcyB9IGZyb20gXCIuLi9lcnJvcnMvaW5kZXguanNcIjtcbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgcGFyc2luZyB0aGUgb3V0cHV0IG9mIGEgTGFyZ2UgTGFuZ3VhZ2UgTW9kZWxcbiAqIChMTE0pIGNhbGwuIEl0IHByb3ZpZGVzIG1ldGhvZHMgZm9yIHBhcnNpbmcgdGhlIHJlc3VsdCBvZiBhbiBMTE0gY2FsbFxuICogYW5kIGludm9raW5nIHRoZSBwYXJzZXIgd2l0aCBhIGdpdmVuIGlucHV0LlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUxMTU91dHB1dFBhcnNlciBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHJlc3VsdCBvZiBhbiBMTE0gY2FsbCB3aXRoIGEgZ2l2ZW4gcHJvbXB0LiBCeSBkZWZhdWx0LCBpdFxuICAgICAqIHNpbXBseSBjYWxscyBgcGFyc2VSZXN1bHRgLlxuICAgICAqIEBwYXJhbSBnZW5lcmF0aW9ucyBUaGUgZ2VuZXJhdGlvbnMgZnJvbSBhbiBMTE0gY2FsbC5cbiAgICAgKiBAcGFyYW0gX3Byb21wdCBUaGUgcHJvbXB0IHVzZWQgaW4gdGhlIExMTSBjYWxsLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja3MgT3B0aW9uYWwgY2FsbGJhY2tzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBwYXJzZVJlc3VsdFdpdGhQcm9tcHQoZ2VuZXJhdGlvbnMsIF9wcm9tcHQsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlc3VsdChnZW5lcmF0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgX2Jhc2VNZXNzYWdlVG9TdHJpbmcobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgPyBtZXNzYWdlLmNvbnRlbnRcbiAgICAgICAgICAgIDogdGhpcy5fYmFzZU1lc3NhZ2VDb250ZW50VG9TdHJpbmcobWVzc2FnZS5jb250ZW50KTtcbiAgICB9XG4gICAgX2Jhc2VNZXNzYWdlQ29udGVudFRvU3RyaW5nKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgcGFyc2VyIHdpdGggYSBnaXZlbiBpbnB1dCBhbmQgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIElmIHRoZSBpbnB1dCBpcyBhIHN0cmluZywgaXQgY3JlYXRlcyBhIGdlbmVyYXRpb24gd2l0aCB0aGUgaW5wdXQgYXNcbiAgICAgKiB0ZXh0IGFuZCBjYWxscyBgcGFyc2VSZXN1bHRgLiBJZiB0aGUgaW5wdXQgaXMgYSBgQmFzZU1lc3NhZ2VgLCBpdFxuICAgICAqIGNyZWF0ZXMgYSBnZW5lcmF0aW9uIHdpdGggdGhlIGlucHV0IGFzIGEgbWVzc2FnZSBhbmQgdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgICogaW5wdXQgYXMgdGV4dCwgYW5kIHRoZW4gY2FsbHMgYHBhcnNlUmVzdWx0YC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIHRoZSBwYXJzZXIsIHdoaWNoIGNhbiBiZSBhIHN0cmluZyBvciBhIGBCYXNlTWVzc2FnZWAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSBvZiB0aGUgcGFyc2VkIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKGFzeW5jIChpbnB1dCwgb3B0aW9ucykgPT4gdGhpcy5wYXJzZVJlc3VsdChbeyB0ZXh0OiBpbnB1dCB9XSwgb3B0aW9ucz8uY2FsbGJhY2tzKSwgaW5wdXQsIHsgLi4ub3B0aW9ucywgcnVuVHlwZTogXCJwYXJzZXJcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsV2l0aENvbmZpZyhhc3luYyAoaW5wdXQsIG9wdGlvbnMpID0+IHRoaXMucGFyc2VSZXN1bHQoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX2Jhc2VNZXNzYWdlVG9TdHJpbmcoaW5wdXQpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLCBvcHRpb25zPy5jYWxsYmFja3MpLCBpbnB1dCwgeyAuLi5vcHRpb25zLCBydW5UeXBlOiBcInBhcnNlclwiIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDbGFzcyB0byBwYXJzZSB0aGUgb3V0cHV0IG9mIGFuIExMTSBjYWxsLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZU91dHB1dFBhcnNlciBleHRlbmRzIEJhc2VMTE1PdXRwdXRQYXJzZXIge1xuICAgIHBhcnNlUmVzdWx0KGdlbmVyYXRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoZ2VuZXJhdGlvbnNbMF0udGV4dCwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VXaXRoUHJvbXB0KHRleHQsIF9wcm9tcHQsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSh0ZXh0LCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHN0cmluZyB0eXBlIGtleSB1bmlxdWVseSBpZGVudGlmeWluZyB0aGlzIGNsYXNzIG9mIHBhcnNlclxuICAgICAqL1xuICAgIF90eXBlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfdHlwZSBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufVxuLyoqXG4gKiBFeGNlcHRpb24gdGhhdCBvdXRwdXQgcGFyc2VycyBzaG91bGQgcmFpc2UgdG8gc2lnbmlmeSBhIHBhcnNpbmcgZXJyb3IuXG4gKlxuICogVGhpcyBleGlzdHMgdG8gZGlmZmVyZW50aWF0ZSBwYXJzaW5nIGVycm9ycyBmcm9tIG90aGVyIGNvZGUgb3IgZXhlY3V0aW9uIGVycm9yc1xuICogdGhhdCBhbHNvIG1heSBhcmlzZSBpbnNpZGUgdGhlIG91dHB1dCBwYXJzZXIuIE91dHB1dFBhcnNlckV4Y2VwdGlvbnMgd2lsbCBiZVxuICogYXZhaWxhYmxlIHRvIGNhdGNoIGFuZCBoYW5kbGUgaW4gd2F5cyB0byBmaXggdGhlIHBhcnNpbmcgZXJyb3IsIHdoaWxlIG90aGVyXG4gKiBlcnJvcnMgd2lsbCBiZSByYWlzZWQuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgdGhhdCdzIGJlaW5nIHJlLXJhaXNlZCBvciBhbiBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIGxsbU91dHB1dCAtIFN0cmluZyBtb2RlbCBvdXRwdXQgd2hpY2ggaXMgZXJyb3ItaW5nLlxuICogQHBhcmFtIG9ic2VydmF0aW9uIC0gU3RyaW5nIGV4cGxhbmF0aW9uIG9mIGVycm9yIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG8gYVxuICogICAgIG1vZGVsIHRvIHRyeSBhbmQgcmVtZWRpYXRlIHRoZSBpc3N1ZS5cbiAqIEBwYXJhbSBzZW5kVG9MTE0gLSBXaGV0aGVyIHRvIHNlbmQgdGhlIG9ic2VydmF0aW9uIGFuZCBsbG1fb3V0cHV0IGJhY2sgdG8gYW4gQWdlbnRcbiAqICAgICBhZnRlciBhbiBPdXRwdXRQYXJzZXJFeGNlcHRpb24gaGFzIGJlZW4gcmFpc2VkLiBUaGlzIGdpdmVzIHRoZSB1bmRlcmx5aW5nXG4gKiAgICAgbW9kZWwgZHJpdmluZyB0aGUgYWdlbnQgdGhlIGNvbnRleHQgdGhhdCB0aGUgcHJldmlvdXMgb3V0cHV0IHdhcyBpbXByb3Blcmx5XG4gKiAgICAgc3RydWN0dXJlZCwgaW4gdGhlIGhvcGVzIHRoYXQgaXQgd2lsbCB1cGRhdGUgdGhlIG91dHB1dCB0byB0aGUgY29ycmVjdFxuICogICAgIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGNsYXNzIE91dHB1dFBhcnNlckV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBsbG1PdXRwdXQsIG9ic2VydmF0aW9uLCBzZW5kVG9MTE0gPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGxtT3V0cHV0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9ic2VydmF0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlbmRUb0xMTVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxsbU91dHB1dCA9IGxsbU91dHB1dDtcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbiA9IG9ic2VydmF0aW9uO1xuICAgICAgICB0aGlzLnNlbmRUb0xMTSA9IHNlbmRUb0xMTTtcbiAgICAgICAgaWYgKHNlbmRUb0xMTSkge1xuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uID09PSB1bmRlZmluZWQgfHwgbGxtT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudHMgJ29ic2VydmF0aW9uJyAmICdsbG1PdXRwdXQnIGFyZSByZXF1aXJlZCBpZiAnc2VuZFRvTGxtJyBpcyB0cnVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZExhbmdDaGFpbkVycm9yRmllbGRzKHRoaXMsIFwiT1VUUFVUX1BBUlNJTkdfRkFJTFVSRVwiKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgZGVlcENvbXBhcmVTdHJpY3QgfSBmcm9tIFwiQGNmd29ya2VyL2pzb24tc2NoZW1hXCI7XG5pbXBvcnQgeyBCYXNlT3V0cHV0UGFyc2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgaXNCYXNlTWVzc2FnZSwgaXNCYXNlTWVzc2FnZUNodW5rLCB9IGZyb20gXCIuLi9tZXNzYWdlcy9iYXNlLmpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0VG9DaHVuayB9IGZyb20gXCIuLi9tZXNzYWdlcy91dGlscy5qc1wiO1xuaW1wb3J0IHsgR2VuZXJhdGlvbkNodW5rLCBDaGF0R2VuZXJhdGlvbkNodW5rLCB9IGZyb20gXCIuLi9vdXRwdXRzLmpzXCI7XG4vKipcbiAqIENsYXNzIHRvIHBhcnNlIHRoZSBvdXRwdXQgb2YgYW4gTExNIGNhbGwgdGhhdCBhbHNvIGFsbG93cyBzdHJlYW1pbmcgaW5wdXRzLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlciBleHRlbmRzIEJhc2VPdXRwdXRQYXJzZXIge1xuICAgIGFzeW5jICpfdHJhbnNmb3JtKGlucHV0R2VuZXJhdG9yKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBhcnNlUmVzdWx0KFt7IHRleHQ6IGNodW5rIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGFyc2VSZXN1bHQoW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX2Jhc2VNZXNzYWdlVG9TdHJpbmcoY2h1bmspLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gYXN5bmNocm9ub3VzIGdlbmVyYXRvciBvZiBpbnB1dCBpbnRvIGFuIGFzeW5jaHJvbm91c1xuICAgICAqIGdlbmVyYXRvciBvZiBwYXJzZWQgb3V0cHV0LlxuICAgICAqIEBwYXJhbSBpbnB1dEdlbmVyYXRvciBBbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yIG9mIGlucHV0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEEgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICogQHJldHVybnMgQW4gYXN5bmNocm9ub3VzIGdlbmVyYXRvciBvZiBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jICp0cmFuc2Zvcm0oaW5wdXRHZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQqIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoaW5wdXRHZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgcnVuVHlwZTogXCJwYXJzZXJcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGJhc2UgY2xhc3MgZm9yIG91dHB1dCBwYXJzZXJzIHRoYXQgY2FuIGhhbmRsZSBzdHJlYW1pbmcgaW5wdXQuIEl0XG4gKiBleHRlbmRzIHRoZSBgQmFzZVRyYW5zZm9ybU91dHB1dFBhcnNlcmAgY2xhc3MgYW5kIHByb3ZpZGVzIGEgbWV0aG9kIGZvclxuICogY29udmVydGluZyBwYXJzZWQgb3V0cHV0cyBpbnRvIGEgZGlmZiBmb3JtYXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlQ3VtdWxhdGl2ZVRyYW5zZm9ybU91dHB1dFBhcnNlciBleHRlbmRzIEJhc2VUcmFuc2Zvcm1PdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkaWZmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaWZmID0gZmllbGRzPy5kaWZmID8/IHRoaXMuZGlmZjtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgbGV0IHByZXZQYXJzZWQ7XG4gICAgICAgIGxldCBhY2NHZW47XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaW5wdXRHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGNodW5rLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGFuZGxlIG5vbi1zdHJpbmcgb3V0cHV0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaHVua0dlbjtcbiAgICAgICAgICAgIGlmIChpc0Jhc2VNZXNzYWdlQ2h1bmsoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYW5kbGUgbm9uLXN0cmluZyBtZXNzYWdlIG91dHB1dC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rR2VuID0gbmV3IENoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY2h1bmsuY29udGVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQmFzZU1lc3NhZ2UoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYW5kbGUgbm9uLXN0cmluZyBtZXNzYWdlIG91dHB1dC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rR2VuID0gbmV3IENoYXRHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjb252ZXJ0VG9DaHVuayhjaHVuayksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGNodW5rLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHVua0dlbiA9IG5ldyBHZW5lcmF0aW9uQ2h1bmsoeyB0ZXh0OiBjaHVuayB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY2NHZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFjY0dlbiA9IGNodW5rR2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNjR2VuID0gYWNjR2VuLmNvbmNhdChjaHVua0dlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBhd2FpdCB0aGlzLnBhcnNlUGFydGlhbFJlc3VsdChbYWNjR2VuXSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBwYXJzZWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhZGVlcENvbXBhcmVTdHJpY3QocGFyc2VkLCBwcmV2UGFyc2VkKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fZGlmZihwcmV2UGFyc2VkLCBwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgcGFyc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IHogfSBmcm9tIFwiem9kXCI7XG5pbXBvcnQgeyB6b2RUb0pzb25TY2hlbWEsIH0gZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuaW1wb3J0IHsgQmFzZU91dHB1dFBhcnNlciwgT3V0cHV0UGFyc2VyRXhjZXB0aW9uLCB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmV4cG9ydCBjbGFzcyBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyIGV4dGVuZHMgQmFzZU91dHB1dFBhcnNlciB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN0cnVjdHVyZWRPdXRwdXRQYXJzZXJcIjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTT05Ob3RJbXBsZW1lbnRlZCgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoc2NoZW1hKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBzY2hlbWFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluXCIsIFwib3V0cHV0X3BhcnNlcnNcIiwgXCJzdHJ1Y3R1cmVkXCJdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFN0cnVjdHVyZWRPdXRwdXRQYXJzZXIgZnJvbSBhIFpvZCBzY2hlbWEuXG4gICAgICogQHBhcmFtIHNjaGVtYSBUaGUgWm9kIHNjaGVtYSB3aGljaCB0aGUgb3V0cHV0IHNob3VsZCBtYXRjaFxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIFN0cnVjdHVyZWRPdXRwdXRQYXJzZXIuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21ab2RTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhzY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFN0cnVjdHVyZWRPdXRwdXRQYXJzZXIgZnJvbSBhIHNldCBvZiBuYW1lcyBhbmRcbiAgICAgKiBkZXNjcmlwdGlvbnMuXG4gICAgICogQHBhcmFtIHNjaGVtYXMgQW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGlzIGEgbmFtZSBhbmQgZWFjaCB2YWx1ZSBpcyBhIGRlc2NyaXB0aW9uXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgU3RydWN0dXJlZE91dHB1dFBhcnNlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU5hbWVzQW5kRGVzY3JpcHRpb25zKHNjaGVtYXMpIHtcbiAgICAgICAgY29uc3Qgem9kU2NoZW1hID0gei5vYmplY3QoT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNjaGVtYXMpLm1hcCgoW25hbWUsIGRlc2NyaXB0aW9uXSkgPT4gW25hbWUsIHouc3RyaW5nKCkuZGVzY3JpYmUoZGVzY3JpcHRpb24pXSkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHpvZFNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXJrZG93biBjb2RlIHNuaXBwZXQgd2l0aCBhIEpTT04gb2JqZWN0IGZvcm1hdHRlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc2NoZW1hLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsLiBUaGUgb3B0aW9ucyBmb3IgZm9ybWF0dGluZyB0aGUgaW5zdHJ1Y3Rpb25zXG4gICAgICogQHJldHVybnMgQSBtYXJrZG93biBjb2RlIHNuaXBwZXQgd2l0aCBhIEpTT04gb2JqZWN0IGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNjaGVtYS5cbiAgICAgKi9cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgZm9ybWF0IHlvdXIgb3V0cHV0IGFzIGEgSlNPTiB2YWx1ZSB0aGF0IGFkaGVyZXMgdG8gYSBnaXZlbiBcIkpTT04gU2NoZW1hXCIgaW5zdGFuY2UuXG5cblwiSlNPTiBTY2hlbWFcIiBpcyBhIGRlY2xhcmF0aXZlIGxhbmd1YWdlIHRoYXQgYWxsb3dzIHlvdSB0byBhbm5vdGF0ZSBhbmQgdmFsaWRhdGUgSlNPTiBkb2N1bWVudHMuXG5cbkZvciBleGFtcGxlLCB0aGUgZXhhbXBsZSBcIkpTT04gU2NoZW1hXCIgaW5zdGFuY2Uge3tcInByb3BlcnRpZXNcIjoge3tcImZvb1wiOiB7e1wiZGVzY3JpcHRpb25cIjogXCJhIGxpc3Qgb2YgdGVzdCB3b3Jkc1wiLCBcInR5cGVcIjogXCJhcnJheVwiLCBcIml0ZW1zXCI6IHt7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9fX19fX0sIFwicmVxdWlyZWRcIjogW1wiZm9vXCJdfX1cbndvdWxkIG1hdGNoIGFuIG9iamVjdCB3aXRoIG9uZSByZXF1aXJlZCBwcm9wZXJ0eSwgXCJmb29cIi4gVGhlIFwidHlwZVwiIHByb3BlcnR5IHNwZWNpZmllcyBcImZvb1wiIG11c3QgYmUgYW4gXCJhcnJheVwiLCBhbmQgdGhlIFwiZGVzY3JpcHRpb25cIiBwcm9wZXJ0eSBzZW1hbnRpY2FsbHkgZGVzY3JpYmVzIGl0IGFzIFwiYSBsaXN0IG9mIHRlc3Qgd29yZHNcIi4gVGhlIGl0ZW1zIHdpdGhpbiBcImZvb1wiIG11c3QgYmUgc3RyaW5ncy5cblRodXMsIHRoZSBvYmplY3Qge3tcImZvb1wiOiBbXCJiYXJcIiwgXCJiYXpcIl19fSBpcyBhIHdlbGwtZm9ybWF0dGVkIGluc3RhbmNlIG9mIHRoaXMgZXhhbXBsZSBcIkpTT04gU2NoZW1hXCIuIFRoZSBvYmplY3Qge3tcInByb3BlcnRpZXNcIjoge3tcImZvb1wiOiBbXCJiYXJcIiwgXCJiYXpcIl19fX19IGlzIG5vdCB3ZWxsLWZvcm1hdHRlZC5cblxuWW91ciBvdXRwdXQgd2lsbCBiZSBwYXJzZWQgYW5kIHR5cGUtY2hlY2tlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIHNjaGVtYSBpbnN0YW5jZSwgc28gbWFrZSBzdXJlIGFsbCBmaWVsZHMgaW4geW91ciBvdXRwdXQgbWF0Y2ggdGhlIHNjaGVtYSBleGFjdGx5IGFuZCB0aGVyZSBhcmUgbm8gdHJhaWxpbmcgY29tbWFzIVxuXG5IZXJlIGlzIHRoZSBKU09OIFNjaGVtYSBpbnN0YW5jZSB5b3VyIG91dHB1dCBtdXN0IGFkaGVyZSB0by4gSW5jbHVkZSB0aGUgZW5jbG9zaW5nIG1hcmtkb3duIGNvZGVibG9jazpcblxcYFxcYFxcYGpzb25cbiR7SlNPTi5zdHJpbmdpZnkoem9kVG9Kc29uU2NoZW1hKHRoaXMuc2NoZW1hKSl9XG5cXGBcXGBcXGBcbmA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gdGV4dCBhY2NvcmRpbmcgdG8gdGhlIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byBwYXJzZVxuICAgICAqIEByZXR1cm5zIFRoZSBwYXJzZWQgb3V0cHV0LlxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSB0ZXh0LmluY2x1ZGVzKFwiYGBgXCIpXG4gICAgICAgICAgICAgICAgPyB0ZXh0LnRyaW0oKS5zcGxpdCgvYGBgKD86anNvbik/LylbMV1cbiAgICAgICAgICAgICAgICA6IHRleHQudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgZXNjYXBlZEpzb24gPSBqc29uXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiKFteXCJcXFxcXSooXFxcXC5bXlwiXFxcXF0qKSopXCIvZywgKF9tYXRjaCwgY2FwdHVyZWRHcm91cCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRJbnNpZGVRdW90ZXMgPSBjYXB0dXJlZEdyb3VwLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgXCIke2VzY2FwZWRJbnNpZGVRdW90ZXN9XCJgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2NoZW1hLnBhcnNlQXN5bmMoSlNPTi5wYXJzZShlc2NhcGVkSnNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3V0cHV0UGFyc2VyRXhjZXB0aW9uKGBGYWlsZWQgdG8gcGFyc2UuIFRleHQ6IFwiJHt0ZXh0fVwiLiBFcnJvcjogJHtlfWAsIHRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIHNwZWNpZmljIHR5cGUgb2YgYFN0cnVjdHVyZWRPdXRwdXRQYXJzZXJgIHRoYXQgcGFyc2VzIEpTT04gZGF0YVxuICogZm9ybWF0dGVkIGFzIGEgbWFya2Rvd24gY29kZSBzbmlwcGV0LlxuICovXG5leHBvcnQgY2xhc3MgSnNvbk1hcmtkb3duU3RydWN0dXJlZE91dHB1dFBhcnNlciBleHRlbmRzIFN0cnVjdHVyZWRPdXRwdXRQYXJzZXIge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJKc29uTWFya2Rvd25TdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyXCI7XG4gICAgfVxuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRpb25EZXB0aCA9IG9wdGlvbnM/LmludGVycG9sYXRpb25EZXB0aCA/PyAxO1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkRlcHRoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZiBzdHJpbmcgaW50ZXJwb2xhdGlvbiBkZXB0aCBtdXN0IGJlIGF0IGxlYXN0IDFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBSZXR1cm4gYSBtYXJrZG93biBjb2RlIHNuaXBwZXQgd2l0aCBhIEpTT04gb2JqZWN0IGZvcm1hdHRlZCB0byBsb29rIGxpa2U6XFxuXFxgXFxgXFxganNvblxcbiR7dGhpcy5fc2NoZW1hVG9JbnN0cnVjdGlvbih6b2RUb0pzb25TY2hlbWEodGhpcy5zY2hlbWEpKVxuICAgICAgICAgICAgLnJlcGxhY2VBbGwoXCJ7XCIsIFwie1wiLnJlcGVhdChpbnRlcnBvbGF0aW9uRGVwdGgpKVxuICAgICAgICAgICAgLnJlcGxhY2VBbGwoXCJ9XCIsIFwifVwiLnJlcGVhdChpbnRlcnBvbGF0aW9uRGVwdGgpKX1cXG5cXGBcXGBcXGBgO1xuICAgIH1cbiAgICBfc2NoZW1hVG9JbnN0cnVjdGlvbihzY2hlbWFJbnB1dCwgaW5kZW50ID0gMikge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBzY2hlbWFJbnB1dDtcbiAgICAgICAgaWYgKFwidHlwZVwiIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgbGV0IG51bGxhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bGxJZHggPSBzY2hlbWEudHlwZS5maW5kSW5kZXgoKHR5cGUpID0+IHR5cGUgPT09IFwibnVsbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbElkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVsbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWEudHlwZS5zcGxpY2UobnVsbElkeCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR5cGUgPSBzY2hlbWEudHlwZS5qb2luKFwiIHwgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSBcIm9iamVjdFwiICYmIHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzY2hlbWEuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBgIC8vICR7c2NoZW1hLmRlc2NyaXB0aW9ufWBcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3QuZW50cmllcyhzY2hlbWEucHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBzY2hlbWEucmVxdWlyZWQ/LmluY2x1ZGVzKGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIiAob3B0aW9uYWwpXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtcIiBcIi5yZXBlYXQoaW5kZW50KX1cIiR7a2V5fVwiOiAke3RoaXMuX3NjaGVtYVRvSW5zdHJ1Y3Rpb24odmFsdWUsIGluZGVudCArIDIpfSR7aXNPcHRpb25hbH1gO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBge1xcbiR7cHJvcGVydGllc31cXG4ke1wiIFwiLnJlcGVhdChpbmRlbnQgLSAyKX19JHtkZXNjcmlwdGlvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSBcImFycmF5XCIgJiYgc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzY2hlbWEuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBgIC8vICR7c2NoZW1hLmRlc2NyaXB0aW9ufWBcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBgYXJyYXlbXFxuJHtcIiBcIi5yZXBlYXQoaW5kZW50KX0ke3RoaXMuX3NjaGVtYVRvSW5zdHJ1Y3Rpb24oc2NoZW1hLml0ZW1zLCBpbmRlbnQgKyAyKX1cXG4ke1wiIFwiLnJlcGVhdChpbmRlbnQgLSAyKX1dICR7ZGVzY3JpcHRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzTnVsbGFibGUgPSBudWxsYWJsZSA/IFwiIChudWxsYWJsZSlcIiA6IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHNjaGVtYS5kZXNjcmlwdGlvbiA/IGAgLy8gJHtzY2hlbWEuZGVzY3JpcHRpb259YCA6IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gYCR7dHlwZX0ke2Rlc2NyaXB0aW9ufSR7aXNOdWxsYWJsZX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImFueU9mXCIgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLmFueU9mXG4gICAgICAgICAgICAgICAgLm1hcCgocykgPT4gdGhpcy5fc2NoZW1hVG9JbnN0cnVjdGlvbihzLCBpbmRlbnQpKVxuICAgICAgICAgICAgICAgIC5qb2luKGBcXG4ke1wiIFwiLnJlcGVhdChpbmRlbnQgLSAyKX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzY2hlbWEgdHlwZVwiKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21ab2RTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhzY2hlbWEpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU5hbWVzQW5kRGVzY3JpcHRpb25zKHNjaGVtYXMpIHtcbiAgICAgICAgY29uc3Qgem9kU2NoZW1hID0gei5vYmplY3QoT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNjaGVtYXMpLm1hcCgoW25hbWUsIGRlc2NyaXB0aW9uXSkgPT4gW25hbWUsIHouc3RyaW5nKCkuZGVzY3JpYmUoZGVzY3JpcHRpb24pXSkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHpvZFNjaGVtYSk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHR5cGUgb2YgYFN0cnVjdHVyZWRPdXRwdXRQYXJzZXJgIHRoYXQgaGFuZGxlcyBhc3ltbWV0cmljIGlucHV0IGFuZFxuICogb3V0cHV0IHNjaGVtYXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3ltbWV0cmljU3RydWN0dXJlZE91dHB1dFBhcnNlciBleHRlbmRzIEJhc2VPdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgaW5wdXRTY2hlbWEgfSkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdHJ1Y3R1cmVkSW5wdXRQYXJzZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmVkSW5wdXRQYXJzZXIgPSBuZXcgSnNvbk1hcmtkb3duU3RydWN0dXJlZE91dHB1dFBhcnNlcihpbnB1dFNjaGVtYSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlKHRleHQpIHtcbiAgICAgICAgbGV0IHBhcnNlZElucHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSBhd2FpdCB0aGlzLnN0cnVjdHVyZWRJbnB1dFBhcnNlci5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE91dHB1dFBhcnNlckV4Y2VwdGlvbihgRmFpbGVkIHRvIHBhcnNlLiBUZXh0OiBcIiR7dGV4dH1cIi4gRXJyb3I6ICR7ZX1gLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRQcm9jZXNzb3IocGFyc2VkSW5wdXQpO1xuICAgIH1cbiAgICBnZXRGb3JtYXRJbnN0cnVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cnVjdHVyZWRJbnB1dFBhcnNlci5nZXRGb3JtYXRJbnN0cnVjdGlvbnMoKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQmFzZUN1bXVsYXRpdmVUcmFuc2Zvcm1PdXRwdXRQYXJzZXIgfSBmcm9tIFwiLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCB7IGNvbXBhcmUgfSBmcm9tIFwiLi4vdXRpbHMvanNvbl9wYXRjaC5qc1wiO1xuaW1wb3J0IHsgcGFyc2VKc29uTWFya2Rvd24sIHBhcnNlUGFydGlhbEpzb24gfSBmcm9tIFwiLi4vdXRpbHMvanNvbi5qc1wiO1xuLyoqXG4gKiBDbGFzcyBmb3IgcGFyc2luZyB0aGUgb3V0cHV0IG9mIGFuIExMTSBpbnRvIGEgSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uT3V0cHV0UGFyc2VyIGV4dGVuZHMgQmFzZUN1bXVsYXRpdmVUcmFuc2Zvcm1PdXRwdXRQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwib3V0cHV0X3BhcnNlcnNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkpzb25PdXRwdXRQYXJzZXJcIjtcbiAgICB9XG4gICAgX2RpZmYocHJldiwgbmV4dCkge1xuICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICByZXR1cm4gW3sgb3A6IFwicmVwbGFjZVwiLCBwYXRoOiBcIlwiLCB2YWx1ZTogbmV4dCB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGFyZShwcmV2LCBuZXh0KTtcbiAgICB9XG4gICAgLy8gVGhpcyBzaG91bGQgYWN0dWFsbHkgcmV0dXJuIFBhcnRpYWw8VD4sIGJ1dCB0aGVyZSdzIG5vIHdheVxuICAgIC8vIHRvIHNwZWNpZnkgZW1pdHRlZCBjaHVua3MgYXMgaW5zdGFuY2VzIHNlcGFyYXRlIGZyb20gdGhlIG1haW4gb3V0cHV0IHR5cGUuXG4gICAgYXN5bmMgcGFyc2VQYXJ0aWFsUmVzdWx0KGdlbmVyYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUpzb25NYXJrZG93bihnZW5lcmF0aW9uc1swXS50ZXh0KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UodGV4dCkge1xuICAgICAgICByZXR1cm4gcGFyc2VKc29uTWFya2Rvd24odGV4dCwgSlNPTi5wYXJzZSk7XG4gICAgfVxuICAgIGdldEZvcm1hdEluc3RydWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxufVxuZXhwb3J0IHsgcGFyc2VQYXJ0aWFsSnNvbiwgcGFyc2VKc29uTWFya2Rvd24gfTtcbiIsICJpbXBvcnQgeyBBSU1lc3NhZ2VDaHVuaywgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzXCI7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tIFwidXVpZFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRPbGxhbWFNZXNzYWdlc1RvTGFuZ0NoYWluKG1lc3NhZ2VzLCBleHRyYSkge1xuICAgIHJldHVybiBuZXcgQUlNZXNzYWdlQ2h1bmsoe1xuICAgICAgICBjb250ZW50OiBtZXNzYWdlcy5jb250ZW50ID8/IFwiXCIsXG4gICAgICAgIHRvb2xfY2FsbF9jaHVua3M6IG1lc3NhZ2VzLnRvb2xfY2FsbHM/Lm1hcCgodGMpID0+ICh7XG4gICAgICAgICAgICBuYW1lOiB0Yy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgYXJnczogSlNPTi5zdHJpbmdpZnkodGMuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgIHR5cGU6IFwidG9vbF9jYWxsX2NodW5rXCIsXG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgIGlkOiB1dWlkdjQoKSxcbiAgICAgICAgfSkpLFxuICAgICAgICByZXNwb25zZV9tZXRhZGF0YTogZXh0cmE/LnJlc3BvbnNlTWV0YWRhdGEsXG4gICAgICAgIHVzYWdlX21ldGFkYXRhOiBleHRyYT8udXNhZ2VNZXRhZGF0YSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RCYXNlNjRGcm9tRGF0YVVybChkYXRhVXJsKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBkYXRhVXJsLm1hdGNoKC9eZGF0YTouKj87YmFzZTY0LCguKikkLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBcIlwiO1xufVxuZnVuY3Rpb24gY29udmVydEFNZXNzYWdlc1RvT2xsYW1hKG1lc3NhZ2VzKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlcy5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlcy5jb250ZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgdGV4dEZpZWxkcyA9IG1lc3NhZ2VzLmNvbnRlbnQuZmlsdGVyKChjKSA9PiBjLnR5cGUgPT09IFwidGV4dFwiICYmIHR5cGVvZiBjLnRleHQgPT09IFwic3RyaW5nXCIpO1xuICAgIGNvbnN0IHRleHRNZXNzYWdlcyA9IHRleHRGaWVsZHMubWFwKChjKSA9PiAoe1xuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBjLnRleHQsXG4gICAgfSkpO1xuICAgIGxldCB0b29sQ2FsbE1zZ3M7XG4gICAgaWYgKG1lc3NhZ2VzLmNvbnRlbnQuZmluZCgoYykgPT4gYy50eXBlID09PSBcInRvb2xfdXNlXCIpICYmXG4gICAgICAgIG1lc3NhZ2VzLnRvb2xfY2FsbHM/Lmxlbmd0aCkge1xuICAgICAgICAvLyBgdG9vbF91c2VgIGNvbnRlbnQgdHlwZXMgYXJlIGFjY2VwdGVkIGlmIHRoZSBtZXNzYWdlIGhhcyB0b29sIGNhbGxzXG4gICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IG1lc3NhZ2VzLnRvb2xfY2FsbHM/Lm1hcCgodGMpID0+ICh7XG4gICAgICAgICAgICBpZDogdGMuaWQsXG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRjLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiB0Yy5hcmdzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAodG9vbENhbGxzKSB7XG4gICAgICAgICAgICB0b29sQ2FsbE1zZ3MgPSB7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWVzc2FnZXMuY29udGVudC5maW5kKChjKSA9PiBjLnR5cGUgPT09IFwidG9vbF91c2VcIikgJiZcbiAgICAgICAgIW1lc3NhZ2VzLnRvb2xfY2FsbHM/Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIndG9vbF91c2UnIGNvbnRlbnQgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdG9vbCBjYWxscy5cIik7XG4gICAgfVxuICAgIHJldHVybiBbLi4udGV4dE1lc3NhZ2VzLCAuLi4odG9vbENhbGxNc2dzID8gW3Rvb2xDYWxsTXNnc10gOiBbXSldO1xufVxuZnVuY3Rpb24gY29udmVydEh1bWFuR2VuZXJpY01lc3NhZ2VzVG9PbGxhbWEobWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2UuY29udGVudC5tYXAoKGMpID0+IHtcbiAgICAgICAgaWYgKGMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogYy50ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjLnR5cGUgPT09IFwiaW1hZ2VfdXJsXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYy5pbWFnZV91cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzOiBbZXh0cmFjdEJhc2U2NEZyb21EYXRhVXJsKGMuaW1hZ2VfdXJsKV0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMuaW1hZ2VfdXJsLnVybCAmJiB0eXBlb2YgYy5pbWFnZV91cmwudXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlczogW2V4dHJhY3RCYXNlNjRGcm9tRGF0YVVybChjLmltYWdlX3VybC51cmwpXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29udGVudCB0eXBlOiAke2MudHlwZX1gKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9PbGxhbWEobWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChtZXNzYWdlLmNvbnRlbnQuZXZlcnkoKGMpID0+IGMudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgdHlwZW9mIGMudGV4dCA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuY29udGVudC5tYXAoKGMpID0+ICh7XG4gICAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgICAgY29udGVudDogYy50ZXh0LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbnRlbnQgdHlwZShzKTogJHttZXNzYWdlLmNvbnRlbnRcbiAgICAgICAgICAgIC5tYXAoKGMpID0+IGMudHlwZSlcbiAgICAgICAgICAgIC5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFRvb2xNZXNzYWdlVG9PbGxhbWEobWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbiBzdHJpbmcgdG9vbCBtZXNzYWdlIGNvbnRlbnQgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIH0sXG4gICAgXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9PbGxhbWFNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIHJldHVybiBtZXNzYWdlcy5mbGF0TWFwKChtc2cpID0+IHtcbiAgICAgICAgaWYgKFtcImh1bWFuXCIsIFwiZ2VuZXJpY1wiXS5pbmNsdWRlcyhtc2cuX2dldFR5cGUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0SHVtYW5HZW5lcmljTWVzc2FnZXNUb09sbGFtYShtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZy5fZ2V0VHlwZSgpID09PSBcImFpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0QU1lc3NhZ2VzVG9PbGxhbWEobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cuX2dldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRTeXN0ZW1NZXNzYWdlVG9PbGxhbWEobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cuX2dldFR5cGUoKSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9vbE1lc3NhZ2VUb09sbGFtYShtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtZXNzYWdlIHR5cGU6ICR7bXNnLl9nZXRUeXBlKCl9YCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgeyBBSU1lc3NhZ2UsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9tZXNzYWdlc1wiO1xuaW1wb3J0IHsgQmFzZUNoYXRNb2RlbCwgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9jaGF0X21vZGVsc1wiO1xuaW1wb3J0IHsgT2xsYW1hIH0gZnJvbSBcIm9sbGFtYS9icm93c2VyXCI7XG5pbXBvcnQgeyBDaGF0R2VuZXJhdGlvbkNodW5rIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRzXCI7XG5pbXBvcnQgeyBBSU1lc3NhZ2VDaHVuayB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIjtcbmltcG9ydCB7IFJ1bm5hYmxlUGFzc3Rocm91Z2gsIFJ1bm5hYmxlU2VxdWVuY2UsIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9ydW5uYWJsZXNcIjtcbmltcG9ydCB7IGNvbnZlcnRUb09wZW5BSVRvb2wgfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL3V0aWxzL2Z1bmN0aW9uX2NhbGxpbmdcIjtcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvdXRpbHMvc3RyZWFtXCI7XG5pbXBvcnQgeyBKc29uT3V0cHV0UGFyc2VyLCBTdHJ1Y3R1cmVkT3V0cHV0UGFyc2VyLCB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvb3V0cHV0X3BhcnNlcnNcIjtcbmltcG9ydCB7IGlzWm9kU2NoZW1hIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS91dGlscy90eXBlc1wiO1xuaW1wb3J0IHsgem9kVG9Kc29uU2NoZW1hIH0gZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuaW1wb3J0IHsgY29udmVydE9sbGFtYU1lc3NhZ2VzVG9MYW5nQ2hhaW4sIGNvbnZlcnRUb09sbGFtYU1lc3NhZ2VzLCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKipcbiAqIE9sbGFtYSBjaGF0IG1vZGVsIGludGVncmF0aW9uLlxuICpcbiAqIFNldHVwOlxuICogSW5zdGFsbCBgQGxhbmdjaGFpbi9vbGxhbWFgIGFuZCB0aGUgT2xsYW1hIGFwcC5cbiAqXG4gKiBgYGBiYXNoXG4gKiBucG0gaW5zdGFsbCBAbGFuZ2NoYWluL29sbGFtYVxuICogYGBgXG4gKlxuICogIyMgW0NvbnN0cnVjdG9yIGFyZ3NdKGh0dHBzOi8vYXBpLmpzLmxhbmdjaGFpbi5jb20vY2xhc3Nlcy9fbGFuZ2NoYWluX29sbGFtYS5DaGF0T2xsYW1hLmh0bWwjY29uc3RydWN0b3IpXG4gKlxuICogIyMgW1J1bnRpbWUgYXJnc10oaHR0cHM6Ly9hcGkuanMubGFuZ2NoYWluLmNvbS9pbnRlcmZhY2VzL19sYW5nY2hhaW5fb2xsYW1hLkNoYXRPbGxhbWFDYWxsT3B0aW9ucy5odG1sKVxuICpcbiAqIFJ1bnRpbWUgYXJncyBjYW4gYmUgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYW55IG9mIHRoZSBiYXNlIHJ1bm5hYmxlIG1ldGhvZHMgYC5pbnZva2VgLiBgLnN0cmVhbWAsIGAuYmF0Y2hgLCBldGMuXG4gKiBUaGV5IGNhbiBhbHNvIGJlIHBhc3NlZCB2aWEgYC5iaW5kYCwgb3IgdGhlIHNlY29uZCBhcmcgaW4gYC5iaW5kVG9vbHNgLCBsaWtlIHNob3duIGluIHRoZSBleGFtcGxlcyBiZWxvdzpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBXaGVuIGNhbGxpbmcgYC5iaW5kYCwgY2FsbCBvcHRpb25zIHNob3VsZCBiZSBwYXNzZWQgdmlhIHRoZSBmaXJzdCBhcmd1bWVudFxuICogY29uc3QgbGxtV2l0aEFyZ3NCb3VuZCA9IGxsbS5iaW5kKHtcbiAqICAgc3RvcDogW1wiXFxuXCJdLFxuICogICB0b29sczogWy4uLl0sXG4gKiB9KTtcbiAqXG4gKiAvLyBXaGVuIGNhbGxpbmcgYC5iaW5kVG9vbHNgLCBjYWxsIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgdGhlIHNlY29uZCBhcmd1bWVudFxuICogY29uc3QgbGxtV2l0aFRvb2xzID0gbGxtLmJpbmRUb29scyhcbiAqICAgWy4uLl0sXG4gKiAgIHtcbiAqICAgICBzdG9wOiBbXCJcXG5cIl0sXG4gKiAgIH1cbiAqICk7XG4gKiBgYGBcbiAqXG4gKiAjIyBFeGFtcGxlc1xuICpcbiAqIDxkZXRhaWxzIG9wZW4+XG4gKiA8c3VtbWFyeT48c3Ryb25nPkluc3RhbnRpYXRlPC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENoYXRPbGxhbWEgfSBmcm9tICdAbGFuZ2NoYWluL29sbGFtYSc7XG4gKlxuICogY29uc3QgbGxtID0gbmV3IENoYXRPbGxhbWEoe1xuICogICBtb2RlbDogXCJsbGFtYS0zLjE6OGJcIixcbiAqICAgdGVtcGVyYXR1cmU6IDAsXG4gKiAgIC8vIG90aGVyIHBhcmFtcy4uLlxuICogfSk7XG4gKiBgYGBcbiAqIDwvZGV0YWlscz5cbiAqXG4gKiA8YnIgLz5cbiAqXG4gKiA8ZGV0YWlscz5cbiAqIDxzdW1tYXJ5PjxzdHJvbmc+SW52b2tpbmc8L3N0cm9uZz48L3N1bW1hcnk+XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgaW5wdXQgPSBgVHJhbnNsYXRlIFwiSSBsb3ZlIHByb2dyYW1taW5nXCIgaW50byBGcmVuY2guYDtcbiAqXG4gKiAvLyBNb2RlbHMgYWxzbyBhY2NlcHQgYSBsaXN0IG9mIGNoYXQgbWVzc2FnZXMgb3IgYSBmb3JtYXR0ZWQgcHJvbXB0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsbG0uaW52b2tlKGlucHV0KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiBgYGBcbiAqXG4gKiBgYGB0eHRcbiAqIEFJTWVzc2FnZSB7XG4gKiAgIFwiY29udGVudFwiOiBcIlRoZSB0cmFuc2xhdGlvbiBvZiBcXFwiSSBsb3ZlIHByb2dyYW1taW5nXFxcIiBpbnRvIEZyZW5jaCBpczpcXG5cXG5cXFwiSidhZG9yZSBwcm9ncmFtbWVyLlxcXCJcIixcbiAqICAgXCJhZGRpdGlvbmFsX2t3YXJnc1wiOiB7fSxcbiAqICAgXCJyZXNwb25zZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCJtb2RlbFwiOiBcImxsYW1hMy4xOjhiXCIsXG4gKiAgICAgXCJjcmVhdGVkX2F0XCI6IFwiMjAyNC0wOC0xMlQyMjoxMjoyMy4wOTQ2OFpcIixcbiAqICAgICBcImRvbmVfcmVhc29uXCI6IFwic3RvcFwiLFxuICogICAgIFwiZG9uZVwiOiB0cnVlLFxuICogICAgIFwidG90YWxfZHVyYXRpb25cIjogMzcxNTU3MTI5MSxcbiAqICAgICBcImxvYWRfZHVyYXRpb25cIjogMzUyNDQzNzUsXG4gKiAgICAgXCJwcm9tcHRfZXZhbF9jb3VudFwiOiAxOSxcbiAqICAgICBcInByb21wdF9ldmFsX2R1cmF0aW9uXCI6IDMwOTIxMTYwMDAsXG4gKiAgICAgXCJldmFsX2NvdW50XCI6IDIwLFxuICogICAgIFwiZXZhbF9kdXJhdGlvblwiOiA1ODU3ODkwMDBcbiAqICAgfSxcbiAqICAgXCJ0b29sX2NhbGxzXCI6IFtdLFxuICogICBcImludmFsaWRfdG9vbF9jYWxsc1wiOiBbXSxcbiAqICAgXCJ1c2FnZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCJpbnB1dF90b2tlbnNcIjogMTksXG4gKiAgICAgXCJvdXRwdXRfdG9rZW5zXCI6IDIwLFxuICogICAgIFwidG90YWxfdG9rZW5zXCI6IDM5XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICpcbiAqIDxkZXRhaWxzPlxuICogPHN1bW1hcnk+PHN0cm9uZz5TdHJlYW1pbmcgQ2h1bmtzPC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYXdhaXQgbGxtLnN0cmVhbShpbnB1dCkpIHtcbiAqICAgY29uc29sZS5sb2coY2h1bmspO1xuICogfVxuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiBBSU1lc3NhZ2VDaHVuayB7XG4gKiAgIFwiY29udGVudFwiOiBcIlRoZVwiLFxuICogICBcImFkZGl0aW9uYWxfa3dhcmdzXCI6IHt9LFxuICogICBcInJlc3BvbnNlX21ldGFkYXRhXCI6IHt9LFxuICogICBcInRvb2xfY2FsbHNcIjogW10sXG4gKiAgIFwidG9vbF9jYWxsX2NodW5rc1wiOiBbXSxcbiAqICAgXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIjogW11cbiAqIH1cbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiIHRyYW5zbGF0aW9uXCIsXG4gKiAgIFwiYWRkaXRpb25hbF9rd2FyZ3NcIjoge30sXG4gKiAgIFwicmVzcG9uc2VfbWV0YWRhdGFcIjoge30sXG4gKiAgIFwidG9vbF9jYWxsc1wiOiBbXSxcbiAqICAgXCJ0b29sX2NhbGxfY2h1bmtzXCI6IFtdLFxuICogICBcImludmFsaWRfdG9vbF9jYWxsc1wiOiBbXVxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCIgb2ZcIixcbiAqICAgXCJhZGRpdGlvbmFsX2t3YXJnc1wiOiB7fSxcbiAqICAgXCJyZXNwb25zZV9tZXRhZGF0YVwiOiB7fSxcbiAqICAgXCJ0b29sX2NhbGxzXCI6IFtdLFxuICogICBcInRvb2xfY2FsbF9jaHVua3NcIjogW10sXG4gKiAgIFwiaW52YWxpZF90b29sX2NhbGxzXCI6IFtdXG4gKiB9XG4gKiBBSU1lc3NhZ2VDaHVuayB7XG4gKiAgIFwiY29udGVudFwiOiBcIiBcXFwiXCIsXG4gKiAgIFwiYWRkaXRpb25hbF9rd2FyZ3NcIjoge30sXG4gKiAgIFwicmVzcG9uc2VfbWV0YWRhdGFcIjoge30sXG4gKiAgIFwidG9vbF9jYWxsc1wiOiBbXSxcbiAqICAgXCJ0b29sX2NhbGxfY2h1bmtzXCI6IFtdLFxuICogICBcImludmFsaWRfdG9vbF9jYWxsc1wiOiBbXVxuICogfVxuICogQUlNZXNzYWdlQ2h1bmsge1xuICogICBcImNvbnRlbnRcIjogXCJJXCIsXG4gKiAgIFwiYWRkaXRpb25hbF9rd2FyZ3NcIjoge30sXG4gKiAgIFwicmVzcG9uc2VfbWV0YWRhdGFcIjoge30sXG4gKiAgIFwidG9vbF9jYWxsc1wiOiBbXSxcbiAqICAgXCJ0b29sX2NhbGxfY2h1bmtzXCI6IFtdLFxuICogICBcImludmFsaWRfdG9vbF9jYWxsc1wiOiBbXVxuICogfVxuICogLi4uXG4gKiBBSU1lc3NhZ2VDaHVuayB7XG4gKiAgIFwiY29udGVudFwiOiBcIlwiLFxuICogICBcImFkZGl0aW9uYWxfa3dhcmdzXCI6IHt9LFxuICogICBcInJlc3BvbnNlX21ldGFkYXRhXCI6IHt9LFxuICogICBcInRvb2xfY2FsbHNcIjogW10sXG4gKiAgIFwidG9vbF9jYWxsX2NodW5rc1wiOiBbXSxcbiAqICAgXCJpbnZhbGlkX3Rvb2xfY2FsbHNcIjogW11cbiAqIH1cbiAqIEFJTWVzc2FnZUNodW5rIHtcbiAqICAgXCJjb250ZW50XCI6IFwiXCIsXG4gKiAgIFwiYWRkaXRpb25hbF9rd2FyZ3NcIjoge30sXG4gKiAgIFwicmVzcG9uc2VfbWV0YWRhdGFcIjoge1xuICogICAgIFwibW9kZWxcIjogXCJsbGFtYTMuMTo4YlwiLFxuICogICAgIFwiY3JlYXRlZF9hdFwiOiBcIjIwMjQtMDgtMTJUMjI6MTM6MjIuMjI0MjNaXCIsXG4gKiAgICAgXCJkb25lX3JlYXNvblwiOiBcInN0b3BcIixcbiAqICAgICBcImRvbmVcIjogdHJ1ZSxcbiAqICAgICBcInRvdGFsX2R1cmF0aW9uXCI6IDg1OTk4ODMyMDgsXG4gKiAgICAgXCJsb2FkX2R1cmF0aW9uXCI6IDM1OTc1ODc1LFxuICogICAgIFwicHJvbXB0X2V2YWxfY291bnRcIjogMTksXG4gKiAgICAgXCJwcm9tcHRfZXZhbF9kdXJhdGlvblwiOiA3OTE4MTk1MDAwLFxuICogICAgIFwiZXZhbF9jb3VudFwiOiAyMCxcbiAqICAgICBcImV2YWxfZHVyYXRpb25cIjogNjQzNTY5MDAwXG4gKiAgIH0sXG4gKiAgIFwidG9vbF9jYWxsc1wiOiBbXSxcbiAqICAgXCJ0b29sX2NhbGxfY2h1bmtzXCI6IFtdLFxuICogICBcImludmFsaWRfdG9vbF9jYWxsc1wiOiBbXSxcbiAqICAgXCJ1c2FnZV9tZXRhZGF0YVwiOiB7XG4gKiAgICAgXCJpbnB1dF90b2tlbnNcIjogMTksXG4gKiAgICAgXCJvdXRwdXRfdG9rZW5zXCI6IDIwLFxuICogICAgIFwidG90YWxfdG9rZW5zXCI6IDM5XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICpcbiAqIDxkZXRhaWxzPlxuICogPHN1bW1hcnk+PHN0cm9uZz5CaW5kIHRvb2xzPC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuICpcbiAqIGNvbnN0IEdldFdlYXRoZXIgPSB7XG4gKiAgIG5hbWU6IFwiR2V0V2VhdGhlclwiLFxuICogICBkZXNjcmlwdGlvbjogXCJHZXQgdGhlIGN1cnJlbnQgd2VhdGhlciBpbiBhIGdpdmVuIGxvY2F0aW9uXCIsXG4gKiAgIHNjaGVtYTogei5vYmplY3Qoe1xuICogICAgIGxvY2F0aW9uOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGNpdHkgYW5kIHN0YXRlLCBlLmcuIFNhbiBGcmFuY2lzY28sIENBXCIpXG4gKiAgIH0pLFxuICogfVxuICpcbiAqIGNvbnN0IEdldFBvcHVsYXRpb24gPSB7XG4gKiAgIG5hbWU6IFwiR2V0UG9wdWxhdGlvblwiLFxuICogICBkZXNjcmlwdGlvbjogXCJHZXQgdGhlIGN1cnJlbnQgcG9wdWxhdGlvbiBpbiBhIGdpdmVuIGxvY2F0aW9uXCIsXG4gKiAgIHNjaGVtYTogei5vYmplY3Qoe1xuICogICAgIGxvY2F0aW9uOiB6LnN0cmluZygpLmRlc2NyaWJlKFwiVGhlIGNpdHkgYW5kIHN0YXRlLCBlLmcuIFNhbiBGcmFuY2lzY28sIENBXCIpXG4gKiAgIH0pLFxuICogfVxuICpcbiAqIGNvbnN0IGxsbVdpdGhUb29scyA9IGxsbS5iaW5kVG9vbHMoW0dldFdlYXRoZXIsIEdldFBvcHVsYXRpb25dKTtcbiAqIGNvbnN0IGFpTXNnID0gYXdhaXQgbGxtV2l0aFRvb2xzLmludm9rZShcbiAqICAgXCJXaGljaCBjaXR5IGlzIGhvdHRlciB0b2RheSBhbmQgd2hpY2ggaXMgYmlnZ2VyOiBMQSBvciBOWT9cIlxuICogKTtcbiAqIGNvbnNvbGUubG9nKGFpTXNnLnRvb2xfY2FsbHMpO1xuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiBbXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnR2V0V2VhdGhlcicsXG4gKiAgICAgYXJnczogeyBsb2NhdGlvbjogJ0xvcyBBbmdlbGVzLCBDQScgfSxcbiAqICAgICBpZDogJzQ5NDEwY2FkLTIxNjMtNDE1ZS1iZGNkLWQyNjkzOGE5YzhjNScsXG4gKiAgICAgdHlwZTogJ3Rvb2xfY2FsbCdcbiAqICAgfSxcbiAqICAge1xuICogICAgIG5hbWU6ICdHZXRQb3B1bGF0aW9uJyxcbiAqICAgICBhcmdzOiB7IGxvY2F0aW9uOiAnTmV3IFlvcmssIE5ZJyB9LFxuICogICAgIGlkOiAnMzllMjMwZTQtNjNlYy00ZmFlLTlkZjAtMjFjM2FiZTczNWFkJyxcbiAqICAgICB0eXBlOiAndG9vbF9jYWxsJ1xuICogICB9XG4gKiBdXG4gKiBgYGBcbiAqIDwvZGV0YWlscz5cbiAqXG4gKiA8YnIgLz5cbiAqXG4gKiA8ZGV0YWlscz5cbiAqIDxzdW1tYXJ5PjxzdHJvbmc+U3RydWN0dXJlZCBPdXRwdXQ8L3N0cm9uZz48L3N1bW1hcnk+XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG4gKlxuICogY29uc3QgSm9rZSA9IHoub2JqZWN0KHtcbiAqICAgc2V0dXA6IHouc3RyaW5nKCkuZGVzY3JpYmUoXCJUaGUgc2V0dXAgb2YgdGhlIGpva2VcIiksXG4gKiAgIHB1bmNobGluZTogei5zdHJpbmcoKS5kZXNjcmliZShcIlRoZSBwdW5jaGxpbmUgdG8gdGhlIGpva2VcIiksXG4gKiAgIHJhdGluZzogei5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiSG93IGZ1bm55IHRoZSBqb2tlIGlzLCBmcm9tIDEgdG8gMTBcIilcbiAqIH0pLmRlc2NyaWJlKCdKb2tlIHRvIHRlbGwgdXNlci4nKTtcbiAqXG4gKiBjb25zdCBzdHJ1Y3R1cmVkTGxtID0gbGxtLndpdGhTdHJ1Y3R1cmVkT3V0cHV0KEpva2UsIHsgbmFtZTogXCJKb2tlXCIgfSk7XG4gKiBjb25zdCBqb2tlUmVzdWx0ID0gYXdhaXQgc3RydWN0dXJlZExsbS5pbnZva2UoXCJUZWxsIG1lIGEgam9rZSBhYm91dCBjYXRzXCIpO1xuICogY29uc29sZS5sb2coam9rZVJlc3VsdCk7XG4gKiBgYGBcbiAqXG4gKiBgYGB0eHRcbiAqIHtcbiAqICAgcHVuY2hsaW5lOiAnV2h5IGRpZCB0aGUgY2F0IGpvaW4gYSBiYW5kPyBCZWNhdXNlIGl0IHdhbnRlZCB0byBiZSB0aGUgcHVyci1jdXNzaW9uaXN0IScsXG4gKiAgIHJhdGluZzogOCxcbiAqICAgc2V0dXA6ICdBIGNhdCB3YWxrcyBpbnRvIGEgbXVzaWMgc3RvcmUgYW5kIGFza3MgdGhlIG93bmVyLi4uJ1xuICogfVxuICogYGBgXG4gKiA8L2RldGFpbHM+XG4gKlxuICogPGJyIC8+XG4gKlxuICogPGRldGFpbHM+XG4gKiA8c3VtbWFyeT48c3Ryb25nPlVzYWdlIE1ldGFkYXRhPC9zdHJvbmc+PC9zdW1tYXJ5PlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGFpTXNnRm9yTWV0YWRhdGEgPSBhd2FpdCBsbG0uaW52b2tlKGlucHV0KTtcbiAqIGNvbnNvbGUubG9nKGFpTXNnRm9yTWV0YWRhdGEudXNhZ2VfbWV0YWRhdGEpO1xuICogYGBgXG4gKlxuICogYGBgdHh0XG4gKiB7IGlucHV0X3Rva2VuczogMTksIG91dHB1dF90b2tlbnM6IDIwLCB0b3RhbF90b2tlbnM6IDM5IH1cbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICpcbiAqIDxkZXRhaWxzPlxuICogPHN1bW1hcnk+PHN0cm9uZz5SZXNwb25zZSBNZXRhZGF0YTwvc3Ryb25nPjwvc3VtbWFyeT5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBhaU1zZ0ZvclJlc3BvbnNlTWV0YWRhdGEgPSBhd2FpdCBsbG0uaW52b2tlKGlucHV0KTtcbiAqIGNvbnNvbGUubG9nKGFpTXNnRm9yUmVzcG9uc2VNZXRhZGF0YS5yZXNwb25zZV9tZXRhZGF0YSk7XG4gKiBgYGBcbiAqXG4gKiBgYGB0eHRcbiAqIHtcbiAqICAgbW9kZWw6ICdsbGFtYTMuMTo4YicsXG4gKiAgIGNyZWF0ZWRfYXQ6ICcyMDI0LTA4LTEyVDIyOjE3OjQyLjI3NDc5NVonLFxuICogICBkb25lX3JlYXNvbjogJ3N0b3AnLFxuICogICBkb25lOiB0cnVlLFxuICogICB0b3RhbF9kdXJhdGlvbjogNjc2NzA3MTIwOSxcbiAqICAgbG9hZF9kdXJhdGlvbjogMzE2MjgyMDksXG4gKiAgIHByb21wdF9ldmFsX2NvdW50OiAxOSxcbiAqICAgcHJvbXB0X2V2YWxfZHVyYXRpb246IDYxMjQ1MDQwMDAsXG4gKiAgIGV2YWxfY291bnQ6IDIwLFxuICogICBldmFsX2R1cmF0aW9uOiA2MDg3ODUwMDBcbiAqIH1cbiAqIGBgYFxuICogPC9kZXRhaWxzPlxuICpcbiAqIDxiciAvPlxuICovXG5leHBvcnQgY2xhc3MgQ2hhdE9sbGFtYSBleHRlbmRzIEJhc2VDaGF0TW9kZWwge1xuICAgIC8vIFVzZWQgZm9yIHRyYWNpbmcsIHJlcGxhY2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHlvdXIgY2xhc3NcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdE9sbGFtYVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzID8/IHt9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibW9kZWxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwibGxhbWEzXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm51bWFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibnVtQ3R4XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm51bUJhdGNoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm51bUdwdVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYWluR3B1XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxvd1ZyYW1cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZjE2S3ZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibG9naXRzQWxsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZvY2FiT25seVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1c2VNbWFwXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVzZU1sb2NrXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVtYmVkZGluZ09ubHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibnVtVGhyZWFkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm51bUtlZXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2VlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJudW1QcmVkaWN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvcEtcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9wUFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0ZnNaXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInR5cGljYWxQXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcGVhdExhc3ROXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRlbXBlcmF0dXJlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlcGVhdFBlbmFsdHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicHJlc2VuY2VQZW5hbHR5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZyZXF1ZW5jeVBlbmFsdHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWlyb3N0YXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWlyb3N0YXRUYXVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWlyb3N0YXRFdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGVuYWxpemVOZXdsaW5lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0cmVhbWluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3JtYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2VlcEFsaXZlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsaWVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGVja09yUHVsbE1vZGVsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmFzZVVybFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJodHRwOi8vMTI3LjAuMC4xOjExNDM0XCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IE9sbGFtYSh7XG4gICAgICAgICAgICBob3N0OiBmaWVsZHM/LmJhc2VVcmwsXG4gICAgICAgICAgICBoZWFkZXJzOiBmaWVsZHM/LmhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBmaWVsZHM/LmJhc2VVcmwgPz8gdGhpcy5iYXNlVXJsO1xuICAgICAgICB0aGlzLm1vZGVsID0gZmllbGRzPy5tb2RlbCA/PyB0aGlzLm1vZGVsO1xuICAgICAgICB0aGlzLm51bWEgPSBmaWVsZHM/Lm51bWE7XG4gICAgICAgIHRoaXMubnVtQ3R4ID0gZmllbGRzPy5udW1DdHg7XG4gICAgICAgIHRoaXMubnVtQmF0Y2ggPSBmaWVsZHM/Lm51bUJhdGNoO1xuICAgICAgICB0aGlzLm51bUdwdSA9IGZpZWxkcz8ubnVtR3B1O1xuICAgICAgICB0aGlzLm1haW5HcHUgPSBmaWVsZHM/Lm1haW5HcHU7XG4gICAgICAgIHRoaXMubG93VnJhbSA9IGZpZWxkcz8ubG93VnJhbTtcbiAgICAgICAgdGhpcy5mMTZLdiA9IGZpZWxkcz8uZjE2S3Y7XG4gICAgICAgIHRoaXMubG9naXRzQWxsID0gZmllbGRzPy5sb2dpdHNBbGw7XG4gICAgICAgIHRoaXMudm9jYWJPbmx5ID0gZmllbGRzPy52b2NhYk9ubHk7XG4gICAgICAgIHRoaXMudXNlTW1hcCA9IGZpZWxkcz8udXNlTW1hcDtcbiAgICAgICAgdGhpcy51c2VNbG9jayA9IGZpZWxkcz8udXNlTWxvY2s7XG4gICAgICAgIHRoaXMuZW1iZWRkaW5nT25seSA9IGZpZWxkcz8uZW1iZWRkaW5nT25seTtcbiAgICAgICAgdGhpcy5udW1UaHJlYWQgPSBmaWVsZHM/Lm51bVRocmVhZDtcbiAgICAgICAgdGhpcy5udW1LZWVwID0gZmllbGRzPy5udW1LZWVwO1xuICAgICAgICB0aGlzLnNlZWQgPSBmaWVsZHM/LnNlZWQ7XG4gICAgICAgIHRoaXMubnVtUHJlZGljdCA9IGZpZWxkcz8ubnVtUHJlZGljdDtcbiAgICAgICAgdGhpcy50b3BLID0gZmllbGRzPy50b3BLO1xuICAgICAgICB0aGlzLnRvcFAgPSBmaWVsZHM/LnRvcFA7XG4gICAgICAgIHRoaXMudGZzWiA9IGZpZWxkcz8udGZzWjtcbiAgICAgICAgdGhpcy50eXBpY2FsUCA9IGZpZWxkcz8udHlwaWNhbFA7XG4gICAgICAgIHRoaXMucmVwZWF0TGFzdE4gPSBmaWVsZHM/LnJlcGVhdExhc3ROO1xuICAgICAgICB0aGlzLnRlbXBlcmF0dXJlID0gZmllbGRzPy50ZW1wZXJhdHVyZTtcbiAgICAgICAgdGhpcy5yZXBlYXRQZW5hbHR5ID0gZmllbGRzPy5yZXBlYXRQZW5hbHR5O1xuICAgICAgICB0aGlzLnByZXNlbmNlUGVuYWx0eSA9IGZpZWxkcz8ucHJlc2VuY2VQZW5hbHR5O1xuICAgICAgICB0aGlzLmZyZXF1ZW5jeVBlbmFsdHkgPSBmaWVsZHM/LmZyZXF1ZW5jeVBlbmFsdHk7XG4gICAgICAgIHRoaXMubWlyb3N0YXQgPSBmaWVsZHM/Lm1pcm9zdGF0O1xuICAgICAgICB0aGlzLm1pcm9zdGF0VGF1ID0gZmllbGRzPy5taXJvc3RhdFRhdTtcbiAgICAgICAgdGhpcy5taXJvc3RhdEV0YSA9IGZpZWxkcz8ubWlyb3N0YXRFdGE7XG4gICAgICAgIHRoaXMucGVuYWxpemVOZXdsaW5lID0gZmllbGRzPy5wZW5hbGl6ZU5ld2xpbmU7XG4gICAgICAgIHRoaXMuc3RyZWFtaW5nID0gZmllbGRzPy5zdHJlYW1pbmc7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZmllbGRzPy5mb3JtYXQ7XG4gICAgICAgIHRoaXMua2VlcEFsaXZlID0gZmllbGRzPy5rZWVwQWxpdmU7XG4gICAgICAgIHRoaXMuY2hlY2tPclB1bGxNb2RlbCA9IGZpZWxkcz8uY2hlY2tPclB1bGxNb2RlbCA/PyB0aGlzLmNoZWNrT3JQdWxsTW9kZWw7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VcbiAgICBfbGxtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwib2xsYW1hXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGEgbW9kZWwgb250byB0aGUgbG9jYWwgbWFjaGluZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlbCBUaGUgbmFtZSBvZiB0aGUgbW9kZWwgdG8gZG93bmxvYWQuXG4gICAgICogQHBhcmFtIHtQdWxsTW9kZWxPcHRpb25zIHwgdW5kZWZpbmVkfSBvcHRpb25zIE9wdGlvbnMgZm9yIHB1bGxpbmcgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHB1bGwobW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzdHJlYW0sIGluc2VjdXJlLCBsb2dQcm9ncmVzcyB9ID0ge1xuICAgICAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBhd2FpdCB0aGlzLmNsaWVudC5wdWxsKHtcbiAgICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgICBpbnNlY3VyZSxcbiAgICAgICAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGlmIChsb2dQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5wdWxsKHsgbW9kZWwsIGluc2VjdXJlIH0pO1xuICAgICAgICAgICAgaWYgKGxvZ1Byb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmRUb29scyh0b29scywga3dhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmQoe1xuICAgICAgICAgICAgdG9vbHM6IHRvb2xzLm1hcCgodG9vbCkgPT4gY29udmVydFRvT3BlbkFJVG9vbCh0b29sKSksXG4gICAgICAgICAgICAuLi5rd2FyZ3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRMc1BhcmFtcyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuaW52b2NhdGlvblBhcmFtcyhvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxzX3Byb3ZpZGVyOiBcIm9sbGFtYVwiLFxuICAgICAgICAgICAgbHNfbW9kZWxfbmFtZTogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGxzX21vZGVsX3R5cGU6IFwiY2hhdFwiLFxuICAgICAgICAgICAgbHNfdGVtcGVyYXR1cmU6IHBhcmFtcy5vcHRpb25zPy50ZW1wZXJhdHVyZSA/PyB1bmRlZmluZWQsXG4gICAgICAgICAgICBsc19tYXhfdG9rZW5zOiBwYXJhbXMub3B0aW9ucz8ubnVtX3ByZWRpY3QgPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgbHNfc3RvcDogb3B0aW9ucy5zdG9wLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpbnZvY2F0aW9uUGFyYW1zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnM/LnRvb2xfY2hvaWNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb29sIGNob2ljZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBDaGF0T2xsYW1hLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBmb3JtYXQ6IG9wdGlvbnM/LmZvcm1hdCA/PyB0aGlzLmZvcm1hdCxcbiAgICAgICAgICAgIGtlZXBfYWxpdmU6IHRoaXMua2VlcEFsaXZlLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIG51bWE6IHRoaXMubnVtYSxcbiAgICAgICAgICAgICAgICBudW1fY3R4OiB0aGlzLm51bUN0eCxcbiAgICAgICAgICAgICAgICBudW1fYmF0Y2g6IHRoaXMubnVtQmF0Y2gsXG4gICAgICAgICAgICAgICAgbnVtX2dwdTogdGhpcy5udW1HcHUsXG4gICAgICAgICAgICAgICAgbWFpbl9ncHU6IHRoaXMubWFpbkdwdSxcbiAgICAgICAgICAgICAgICBsb3dfdnJhbTogdGhpcy5sb3dWcmFtLFxuICAgICAgICAgICAgICAgIGYxNl9rdjogdGhpcy5mMTZLdixcbiAgICAgICAgICAgICAgICBsb2dpdHNfYWxsOiB0aGlzLmxvZ2l0c0FsbCxcbiAgICAgICAgICAgICAgICB2b2NhYl9vbmx5OiB0aGlzLnZvY2FiT25seSxcbiAgICAgICAgICAgICAgICB1c2VfbW1hcDogdGhpcy51c2VNbWFwLFxuICAgICAgICAgICAgICAgIHVzZV9tbG9jazogdGhpcy51c2VNbG9jayxcbiAgICAgICAgICAgICAgICBlbWJlZGRpbmdfb25seTogdGhpcy5lbWJlZGRpbmdPbmx5LFxuICAgICAgICAgICAgICAgIG51bV90aHJlYWQ6IHRoaXMubnVtVGhyZWFkLFxuICAgICAgICAgICAgICAgIG51bV9rZWVwOiB0aGlzLm51bUtlZXAsXG4gICAgICAgICAgICAgICAgc2VlZDogdGhpcy5zZWVkLFxuICAgICAgICAgICAgICAgIG51bV9wcmVkaWN0OiB0aGlzLm51bVByZWRpY3QsXG4gICAgICAgICAgICAgICAgdG9wX2s6IHRoaXMudG9wSyxcbiAgICAgICAgICAgICAgICB0b3BfcDogdGhpcy50b3BQLFxuICAgICAgICAgICAgICAgIHRmc196OiB0aGlzLnRmc1osXG4gICAgICAgICAgICAgICAgdHlwaWNhbF9wOiB0aGlzLnR5cGljYWxQLFxuICAgICAgICAgICAgICAgIHJlcGVhdF9sYXN0X246IHRoaXMucmVwZWF0TGFzdE4sXG4gICAgICAgICAgICAgICAgdGVtcGVyYXR1cmU6IHRoaXMudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgcmVwZWF0X3BlbmFsdHk6IHRoaXMucmVwZWF0UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBwcmVzZW5jZV9wZW5hbHR5OiB0aGlzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3lfcGVuYWx0eTogdGhpcy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgIG1pcm9zdGF0OiB0aGlzLm1pcm9zdGF0LFxuICAgICAgICAgICAgICAgIG1pcm9zdGF0X3RhdTogdGhpcy5taXJvc3RhdFRhdSxcbiAgICAgICAgICAgICAgICBtaXJvc3RhdF9ldGE6IHRoaXMubWlyb3N0YXRFdGEsXG4gICAgICAgICAgICAgICAgcGVuYWxpemVfbmV3bGluZTogdGhpcy5wZW5hbGl6ZU5ld2xpbmUsXG4gICAgICAgICAgICAgICAgc3RvcDogb3B0aW9ucz8uc3RvcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b29sczogb3B0aW9ucz8udG9vbHM/Lmxlbmd0aFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy50b29scy5tYXAoKHRvb2wpID0+IGNvbnZlcnRUb09wZW5BSVRvb2wodG9vbCkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgbW9kZWwgZXhpc3RzIG9uIHRoZSBsb2NhbCBtYWNoaW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gV2hldGhlciBvciBub3QgdGhlIG1vZGVsIGV4aXN0cy5cbiAgICAgKi9cbiAgICBhc3luYyBjaGVja01vZGVsRXhpc3RzT25NYWNoaW5lKG1vZGVsKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZWxzIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5saXN0KCk7XG4gICAgICAgIHJldHVybiAhIW1vZGVscy5maW5kKChtKSA9PiBtLm5hbWUgPT09IG1vZGVsIHx8IG0ubmFtZSA9PT0gYCR7bW9kZWx9OmxhdGVzdGApO1xuICAgIH1cbiAgICBhc3luYyBfZ2VuZXJhdGUobWVzc2FnZXMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tPclB1bGxNb2RlbCkge1xuICAgICAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5jaGVja01vZGVsRXhpc3RzT25NYWNoaW5lKHRoaXMubW9kZWwpKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVsbCh0aGlzLm1vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ1Byb2dyZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBmaW5hbENodW5rO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHRoaXMuX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKG1lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKSkge1xuICAgICAgICAgICAgaWYgKCFmaW5hbENodW5rKSB7XG4gICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNodW5rLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY29uY2F0KGZpbmFsQ2h1bmssIGNodW5rLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgZnJvbSBBSU1lc3NhZ2VDaHVuayB0byBBSU1lc3NhZ2Ugc2luY2UgYGdlbmVyYXRlYCBleHBlY3RzIEFJTWVzc2FnZS5cbiAgICAgICAgY29uc3Qgbm9uQ2h1bmtNZXNzYWdlID0gbmV3IEFJTWVzc2FnZSh7XG4gICAgICAgICAgICBpZDogZmluYWxDaHVuaz8uaWQsXG4gICAgICAgICAgICBjb250ZW50OiBmaW5hbENodW5rPy5jb250ZW50ID8/IFwiXCIsXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBmaW5hbENodW5rPy50b29sX2NhbGxzLFxuICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IGZpbmFsQ2h1bms/LnJlc3BvbnNlX21ldGFkYXRhLFxuICAgICAgICAgICAgdXNhZ2VfbWV0YWRhdGE6IGZpbmFsQ2h1bms/LnVzYWdlX21ldGFkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0eXBlb2Ygbm9uQ2h1bmtNZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbm9uQ2h1bmtNZXNzYWdlLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbm9uQ2h1bmtNZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnQgdG8gc3VwcG9ydCBzdHJlYW1pbmcuXG4gICAgICogU2hvdWxkIHlpZWxkIGNodW5rcyBpdGVyYXRpdmVseS5cbiAgICAgKi9cbiAgICBhc3luYyAqX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKG1lc3NhZ2VzLCBvcHRpb25zLCBydW5NYW5hZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrT3JQdWxsTW9kZWwpIHtcbiAgICAgICAgICAgIGlmICghKGF3YWl0IHRoaXMuY2hlY2tNb2RlbEV4aXN0c09uTWFjaGluZSh0aGlzLm1vZGVsKSkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1bGwodGhpcy5tb2RlbCwge1xuICAgICAgICAgICAgICAgICAgICBsb2dQcm9ncmVzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmludm9jYXRpb25QYXJhbXMob3B0aW9ucyk7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBjYXN0IGFmdGVyIFNESyBhZGRzIHN1cHBvcnQgZm9yIHRvb2wgY2FsbHNcbiAgICAgICAgY29uc3Qgb2xsYW1hTWVzc2FnZXMgPSBjb252ZXJ0VG9PbGxhbWFNZXNzYWdlcyhtZXNzYWdlcyk7XG4gICAgICAgIGNvbnN0IHVzYWdlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBpbnB1dF90b2tlbnM6IDAsXG4gICAgICAgICAgICBvdXRwdXRfdG9rZW5zOiAwLFxuICAgICAgICAgICAgdG90YWxfdG9rZW5zOiAwLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocGFyYW1zLnRvb2xzICYmIHBhcmFtcy50b29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sUmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQuY2hhdCh7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBvbGxhbWFNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICBzdHJlYW06IGZhbHNlLCAvLyBPbGxhbWEgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgc3RyZWFtaW5nIHdpdGggdG9vbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBtZXNzYWdlOiByZXNwb25zZU1lc3NhZ2UsIC4uLnJlc3QgfSA9IHRvb2xSZXN1bHQ7XG4gICAgICAgICAgICB1c2FnZU1ldGFkYXRhLmlucHV0X3Rva2VucyArPSByZXN0LnByb21wdF9ldmFsX2NvdW50ID8/IDA7XG4gICAgICAgICAgICB1c2FnZU1ldGFkYXRhLm91dHB1dF90b2tlbnMgKz0gcmVzdC5ldmFsX2NvdW50ID8/IDA7XG4gICAgICAgICAgICB1c2FnZU1ldGFkYXRhLnRvdGFsX3Rva2VucyA9XG4gICAgICAgICAgICAgICAgdXNhZ2VNZXRhZGF0YS5pbnB1dF90b2tlbnMgKyB1c2FnZU1ldGFkYXRhLm91dHB1dF90b2tlbnM7XG4gICAgICAgICAgICB5aWVsZCBuZXcgQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgdGV4dDogcmVzcG9uc2VNZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogY29udmVydE9sbGFtYU1lc3NhZ2VzVG9MYW5nQ2hhaW4ocmVzcG9uc2VNZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWV0YWRhdGE6IHJlc3QsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1OZXdUb2tlbihyZXNwb25zZU1lc3NhZ2UuY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhpcy5jbGllbnQuY2hhdCh7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBtZXNzYWdlczogb2xsYW1hTWVzc2FnZXMsXG4gICAgICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGFzdE1ldGFkYXRhO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnQuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbWVzc2FnZTogcmVzcG9uc2VNZXNzYWdlLCAuLi5yZXN0IH0gPSBjaHVuaztcbiAgICAgICAgICAgIHVzYWdlTWV0YWRhdGEuaW5wdXRfdG9rZW5zICs9IHJlc3QucHJvbXB0X2V2YWxfY291bnQgPz8gMDtcbiAgICAgICAgICAgIHVzYWdlTWV0YWRhdGEub3V0cHV0X3Rva2VucyArPSByZXN0LmV2YWxfY291bnQgPz8gMDtcbiAgICAgICAgICAgIHVzYWdlTWV0YWRhdGEudG90YWxfdG9rZW5zID1cbiAgICAgICAgICAgICAgICB1c2FnZU1ldGFkYXRhLmlucHV0X3Rva2VucyArIHVzYWdlTWV0YWRhdGEub3V0cHV0X3Rva2VucztcbiAgICAgICAgICAgIGxhc3RNZXRhZGF0YSA9IHJlc3Q7XG4gICAgICAgICAgICB5aWVsZCBuZXcgQ2hhdEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICAgICAgdGV4dDogcmVzcG9uc2VNZXNzYWdlLmNvbnRlbnQgPz8gXCJcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBjb252ZXJ0T2xsYW1hTWVzc2FnZXNUb0xhbmdDaGFpbihyZXNwb25zZU1lc3NhZ2UpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVMTE1OZXdUb2tlbihyZXNwb25zZU1lc3NhZ2UuY29udGVudCA/PyBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBZaWVsZCB0aGUgYHJlc3BvbnNlX21ldGFkYXRhYCBhcyB0aGUgZmluYWwgY2h1bmsuXG4gICAgICAgIHlpZWxkIG5ldyBDaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBuZXcgQUlNZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VfbWV0YWRhdGE6IGxhc3RNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB1c2FnZV9tZXRhZGF0YTogdXNhZ2VNZXRhZGF0YSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2l0aFN0cnVjdHVyZWRPdXRwdXQob3V0cHV0U2NoZW1hLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZz8ubWV0aG9kID09PSB1bmRlZmluZWQgfHwgY29uZmlnPy5tZXRob2QgPT09IFwianNvblNjaGVtYVwiKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRTY2hlbWFJc1pvZCA9IGlzWm9kU2NoZW1hKG91dHB1dFNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCBqc29uU2NoZW1hID0gb3V0cHV0U2NoZW1hSXNab2RcbiAgICAgICAgICAgICAgICA/IHpvZFRvSnNvblNjaGVtYShvdXRwdXRTY2hlbWEpXG4gICAgICAgICAgICAgICAgOiBvdXRwdXRTY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBsbG0gPSB0aGlzLmJpbmQoe1xuICAgICAgICAgICAgICAgIGZvcm1hdDoganNvblNjaGVtYSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0UGFyc2VyID0gb3V0cHV0U2NoZW1hSXNab2RcbiAgICAgICAgICAgICAgICA/IFN0cnVjdHVyZWRPdXRwdXRQYXJzZXIuZnJvbVpvZFNjaGVtYShvdXRwdXRTY2hlbWEpXG4gICAgICAgICAgICAgICAgOiBuZXcgSnNvbk91dHB1dFBhcnNlcigpO1xuICAgICAgICAgICAgaWYgKCFjb25maWc/LmluY2x1ZGVSYXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGxtLnBpcGUob3V0cHV0UGFyc2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlckFzc2lnbiA9IFJ1bm5hYmxlUGFzc3Rocm91Z2guYXNzaWduKHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIHBhcnNlZDogKGlucHV0LCBjb25maWcpID0+IG91dHB1dFBhcnNlci5pbnZva2UoaW5wdXQucmF3LCBjb25maWcpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZXJOb25lID0gUnVubmFibGVQYXNzdGhyb3VnaC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHBhcnNlZDogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkV2l0aEZhbGxiYWNrID0gcGFyc2VyQXNzaWduLndpdGhGYWxsYmFja3Moe1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrczogW3BhcnNlck5vbmVdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUnVubmFibGVTZXF1ZW5jZS5mcm9tKFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJhdzogbGxtLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFyc2VkV2l0aEZhbGxiYWNrLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBGaXggdGhpcyB0eXBlIGluIGNvcmVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIud2l0aFN0cnVjdHVyZWRPdXRwdXQob3V0cHV0U2NoZW1hLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEh1bWFuTWVzc2FnZSwgU3lzdGVtTWVzc2FnZSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvbWVzc2FnZXNcIjtcbmltcG9ydCB7IENoYXRPbGxhbWEgfSBmcm9tIFwiQGxhbmdjaGFpbi9vbGxhbWFcIjtcblxuY29uc3QgU1lTVEVNX1BST01QVF9URU1QTEFURSA9XG4gIFwiWW91IGFyZSBhIGNhbGwtYW5kLXJlc3BvbnNlIGFzc2lzdGFudC4gS2VlcCByZXBsaWVzIGNsZWFyLCBjb25jaXNlLiBZb3VyIHJlc3BvbnNlIG11c3QgYmUgd2l0aGluIHt7VE9LRU5fTElNSVR9fSB0b2tlbnMuXCI7XG5cbmNvbnN0IERFRkFVTFRfTU9ERUwgPSBcImdlbW1hM1wiO1xuY29uc3QgREVGQVVMVF9URU1QRVJBVFVSRSA9IDAuNztcbmNvbnN0IERFRkFVTFRfTUFYX1JFVFJJRVMgPSA1O1xuXG5pbnRlcmZhY2UgQ2FsbE9sbGFtYU9wdGlvbnMge1xuICBwcm9tcHQ/OiBzdHJpbmc7XG4gIG1vZGVsPzogc3RyaW5nO1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcbiAgbWF4UmV0cmllcz86IG51bWJlcjtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBjYWxsT2xsYW1hKFxuICBpbnB1dFRleHQ6IHN0cmluZyxcbiAgb3B0aW9uczogQ2FsbE9sbGFtYU9wdGlvbnMgPSB7fVxuKSB7XG4gIGNvbnN0IHtcbiAgICBwcm9tcHQsXG4gICAgbW9kZWwgPSBERUZBVUxUX01PREVMLFxuICAgIHRlbXBlcmF0dXJlID0gREVGQVVMVF9URU1QRVJBVFVSRSxcbiAgICBtYXhSZXRyaWVzID0gREVGQVVMVF9NQVhfUkVUUklFUyxcbiAgfSA9IG9wdGlvbnM7XG5cbiAgLy8gU21hcnQgdG9rZW4gZXN0aW1hdGUgaWYgdXNlciBkaWRuJ3QgcGFzcyBudW1QcmVkaWN0XG4gIGNvbnN0IHRva2VuRXN0aW1hdGUgPSBlc3RpbWF0ZVNtYXJ0VG9rZW5MaW1pdChpbnB1dFRleHQpO1xuXG4gIGNvbnN0IGNoYXQgPSBuZXcgQ2hhdE9sbGFtYSh7XG4gICAgbW9kZWwsXG4gICAgdGVtcGVyYXR1cmUsXG4gICAgbWF4UmV0cmllcyxcbiAgICBudW1QcmVkaWN0OiB0b2tlbkVzdGltYXRlLFxuICB9KTtcblxuICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBTWVNURU1fUFJPTVBUX1RFTVBMQVRFLnJlcGxhY2UoXG4gICAgXCJ7e1RPS0VOX0xJTUlUfX1cIixcbiAgICB0b2tlbkVzdGltYXRlLnRvU3RyaW5nKClcbiAgKTtcblxuICBjb25zdCBmdWxsU3lzdGVtUHJvbXB0ID0gW3N5c3RlbVByb21wdCwgcHJvbXB0XS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuXFxuJyk7XG5cbiAgY29uc3QgbWVzc2FnZXMgPSBbXG4gICAgbmV3IFN5c3RlbU1lc3NhZ2UoZnVsbFN5c3RlbVByb21wdCksXG4gICAgbmV3IEh1bWFuTWVzc2FnZShpbnB1dFRleHQpLFxuICBdO1xuXG4gIHJldHVybiBjaGF0Lmludm9rZShtZXNzYWdlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZVNtYXJ0VG9rZW5MaW1pdChpbnB1dFRleHQ6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IHdvcmRDb3VudCA9IGlucHV0VGV4dC50cmltKCkuc3BsaXQoL1xccysvKS5sZW5ndGg7XG5cbiAgbGV0IGVzdGltYXRlZFRva2VucyA9IDA7XG5cbiAgaWYgKHdvcmRDb3VudCA8IDEwMCkge1xuICAgIGVzdGltYXRlZFRva2VucyA9IDEyODsgLy8gVGlueSBub3RlLCBzZXQgbWluIHRva2Vuc1xuICB9IGVsc2UgaWYgKHdvcmRDb3VudCA8IDUwMCkge1xuICAgIGVzdGltYXRlZFRva2VucyA9IE1hdGguY2VpbCh3b3JkQ291bnQgKiAxLjUpICsgMjAwO1xuICB9IGVsc2UgaWYgKHdvcmRDb3VudCA8IDE1MDApIHtcbiAgICBlc3RpbWF0ZWRUb2tlbnMgPSBNYXRoLmNlaWwod29yZENvdW50ICogMS4zKSArIDMwMDtcbiAgfSBlbHNlIHtcbiAgICBlc3RpbWF0ZWRUb2tlbnMgPSAyMDQ4OyAvLyBDYXAgYXQgbWF4XG4gIH1cblxuICAvLyBTYWZldHkgbmV0IG1pbi9tYXhcbiAgY29uc3QgTUlOX1RPS0VOUyA9IDEyODtcbiAgY29uc3QgTUFYX1RPS0VOUyA9IDIwNDg7XG5cbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGVzdGltYXRlZFRva2VucywgTUlOX1RPS0VOUyksIE1BWF9UT0tFTlMpO1xufVxuIiwgIi8vIDFcdUZFMEZcdTIwRTMgSW5zdHJ1Y3Rpb25zIGJsb2NrXG5jb25zdCBJTlNUUlVDVElPTlMgPSBgXG5Zb3UgYXJlIGFuIGV4cGVydCBub3RlIG9yZ2FuaXplciBhbmQgZm9ybWF0dGVyIGZvciBPYnNpZGlhbi5cblxuWW91ciBqb2I6XG4tIEFuYWx5emUgdGhlIHJhdyBpbnB1dCBub3RlIGFuZCBpbnRlbGxpZ2VudGx5IG9yZ2FuaXplIGl0IGludG8gd2VsbC1zdHJ1Y3R1cmVkIHNlY3Rpb25zLlxuLSBDbGFzc2lmeSBjb250ZW50IGludG8gdGhlIGFwcHJvcHJpYXRlIE9ic2lkaWFuIGNhbGxvdXQgdHlwZSBiYXNlZCBvbiBtZWFuaW5nLCB1c2luZyB0aGUgZm9sbG93aW5nIG1hcDpcbm5vdGUgKGJsdWUpXG5hYnN0cmFjdCwgc3VtbWFyeSwgdGxkciAoZ3JlZW4pXG5pbmZvIChibHVlKVxudG9kbyAoYmx1ZSlcbnRpcCwgaGludCwgaW1wb3J0YW50IChza3kgYmx1ZSlcbnN1Y2Nlc3MsIGNoZWNrLCBkb25lIChncmVlbilcbnF1ZXN0aW9uLCBoZWxwLCBmYXEgKHllbGxvdylcbndhcm5pbmcsIGNhdXRpb24sIGF0dGVudGlvbiAob3JhbmdlKVxuZmFpbHVyZSwgZmFpbCwgbWlzc2luZyAocmVkKVxuZGFuZ2VyLCBlcnJvciAocmVkKVxuYnVnIChyZWQpXG5leGFtcGxlIChwdXJwbGUpXG5xdW90ZSwgY2l0ZSAoZ3JleSlcbmA7XG5cbi8vIDJcdUZFMEZcdTIwRTMgRm9ybWF0dGluZyBydWxlc1xuY29uc3QgRk9STUFUVElOR19SVUxFUyA9IGBcbioqT3V0cHV0IGZvcm1hdDoqKlxuLSBTdGFydCB3aXRoIGEgKip0aXRsZSoqIGF0IHRoZSB0b3AgKGUuZy4sIFwiIyBcdUQ4M0RcdURDREQgRGFpbHkgTm90ZTogTWF5IDcsIDIwMjVcIilcbi0gQWRkIGEgKipTdW1tYXJ5IHNlY3Rpb24qKiAoYWJzdHJhY3QpIGluIGl0cyBvd24gY2FsbG91dDpcbiAgICAtIFRoZSAqKmNhbGxvdXQgaGVhZGVyKiogbXVzdCBiZTogXFxgPiBbIWFic3RyYWN0XSBTdW1tYXJ5XFxgXG4gICAgLSAqKkFmdGVyIHRoZSBjYWxsb3V0IGhlYWRlciwgaW5zZXJ0IE9ORSBibGFuayBsaW5lLioqXG4gICAgLSBUaGVuIHdyaXRlIGEgcGxhaW4gcGFyYWdyYXBoICgyXHUyMDEzNSBzZW50ZW5jZXMpIHdpdGggTk8gYmxvY2txdW90ZXMuXG4gICAgLSBUaGlzIGJsYW5rIGxpbmUgZW5zdXJlcyB0aGUgcGFyYWdyYXBoIGlzIE9VVFNJREUgdGhlIGNhbGxvdXQgYm94IGJ1dCB1bmRlciB0aGUgaGVhZGVyLlxuXG4gICAgLSBVc2UgYSAqKm5ldXRyYWwsIG9iamVjdGl2ZSB0b25lKiogKG5vIHBlcnNvbmFsIHByb25vdW5zIGxpa2UgXCJJXCIsIFwid2VcIikuXG4gICAgLSBDbGVhcmx5IGRpc3Rpbmd1aXNoIGJldHdlZW46XG4gICAgICAtIFx1MjcwNSBFdmVudHMgdGhhdCBhY3R1YWxseSBoYXBwZW5lZFxuICAgICAgLSBcdUQ4M0RcdURDREQgUGxhbm5lZCB0YXNrcyAocGVuZGluZylcbiAgICAgIC0gXHVEODNEXHVERDBEIFJlc2VhcmNoL3F1ZXN0aW9ucyAodG9waWNzIG9mIGludGVyZXN0KVxuICAgIC0gRE8gTk9UIG1pc3JlcHJlc2VudCBwbGFubmVkIHRhc2tzIGFzIGNvbXBsZXRlZC5cbiAgICAtIERPIE5PVCB1c2UgYnVsbGV0cG9pbnRzIGluIHRoZSBzdW1tYXJ5LlxuXG4tIEFmdGVyIHRoZSBzdW1tYXJ5IHNlY3Rpb24sIGFkZCBhICoqbGluZSBmb3IgdGFncyoqLCBsaWtlOiAgXG4gIFxcYHRhZ3M6ICNkaXNjb3JkICNoeXBlcmNvcmUgI3NjdXR0bGVidXR0ICN3b3JrcGxhY2VcXGBcbiAgICAtIFRhZ3MgbXVzdCBiZSAqKmR5bmFtaWNhbGx5IGdlbmVyYXRlZCBmcm9tIHRoZSBjb250ZW50LioqXG4gICAgLSBBdm9pZCBnZW5lcmljL2ZpbGxlciB0YWdzIGxpa2UgXFxgI2RhaWx5XFxgIHVubGVzcyBkaXJlY3RseSByZWxldmFudC5cbiAgICAtIFRhZ3Mgc2hvdWxkIGJlICoqdW5pcXVlIHRvIHRoZSBjb250ZW50LCBsb3dlcmNhc2UsIHByZWZpeGVkIGJ5IFxcYCNcXGAuKipcbiAgICAtIE5PIGhhcmRjb2RlZCBvciBkZWZhdWx0IHRhZ3MuXG5cbi0gVGhlbiBjcmVhdGUgc2VjdGlvbnMgZm9yIHRvZG9zLCBxdWVzdGlvbnMsIG5vdGVzLCBhbmQgb3RoZXIgcmVsZXZhbnQgY2F0ZWdvcmllczpcbiAgICAtIEVhY2ggc2VjdGlvbiBtdXN0IGJlIGluICoqT05FIGNhbGxvdXQuKipcbiAgICAtIFVzZSBidWxsZXRwb2ludHMgZm9yIGxpc3RzIGluc2lkZSB0aGUgY2FsbG91dHMuXG5gO1xuXG4vLyAzXHVGRTBGXHUyMEUzIEltcG9ydGFudCBub3RlcyBibG9ja1xuY29uc3QgSU1QT1JUQU5UX05PVEVTID0gYFxuLS0tXG5cbioqSU1QT1JUQU5UOioqXG4tIERPIE5PVCBhbnN3ZXIgYW55IHF1ZXN0aW9ucy5cbi0gVGhlICoqc3VtbWFyeSBtdXN0IGJlIGEgcGFyYWdyYXBoIHdpdGggTk8gYmxvY2txdW90ZXMqKiAoZXZlbiB0aG91Z2ggaXRcdTIwMTlzIGluc2lkZSB0aGUgY2FsbG91dCBzdHJ1Y3R1cmUpLlxuLSBJbnNlcnQgT05FIGJsYW5rIGxpbmUgYWZ0ZXIgdGhlIGNhbGxvdXQgaGVhZGVyLlxuLSBUYWdzIG11c3QgYmUgKipkeW5hbWljYWxseSBnZW5lcmF0ZWQqKiBiYXNlZCBvbiB0aGUgY29udGVudC5cbi0gRW5zdXJlIEFMTCBzZWN0aW9ucyB1c2UgKipPYnNpZGlhbiBjYWxsb3V0IGZvcm1hdHRpbmcuKipcbmA7XG5cbi8vIDRcdUZFMEZcdTIwRTMgRXhhbXBsZXMgYXJyYXlcbmNvbnN0IEVYQU1QTEVTID0gW1xuICBgKipFeGFtcGxlIDE6IERldmVsb3BlciBXb3JrIExvZyoqXG5cbiMgXHVEODNEXHVEQ0REIERhaWx5IE5vdGU6IE1heSAxMCwgMjAyNVxuXG4+IFshYWJzdHJhY3RdIFN1bW1hcnlcblxuVG9kYXkncyBmb2N1cyB3YXMgb24gcmVzb2x2aW5nIGEgcGVyc2lzdGVudCBBUEkgYXV0aGVudGljYXRpb24gYnVnIGFuZCBwbGFubmluZyBVSSBpbXByb3ZlbWVudHMgZm9yIHRoZSBkYXNoYm9hcmQgbW9kdWxlLiBQZW5kaW5nIHRhc2tzIGluY2x1ZGUgcmVmYWN0b3JpbmcgdGhlIGxvZ2luIGNvbXBvbmVudCBhbmQgd3JpdGluZyB1bml0IHRlc3RzIGZvciBuZXcgQVBJIGhhbmRsZXJzLiBSZXNlYXJjaCBpcyBvbmdvaW5nIHJlZ2FyZGluZyBPQXV0aCAyLjAgYmVzdCBwcmFjdGljZXMuXG5cbnRhZ3M6ICNhcGkgI2F1dGhlbnRpY2F0aW9uICNkYXNoYm9hcmQgI29hdXRoICNmcm9udGVuZFxuXG4+IFshdG9kb10gVG9kb1xuPiAtIFJlZmFjdG9yIGxvZ2luIGNvbXBvbmVudFxuPiAtIFdyaXRlIHVuaXQgdGVzdHMgZm9yIEFQSSBoYW5kbGVyc1xuPiAtIFByZXBhcmUgVUkgbW9ja3VwcyBmb3IgdGhlIG5ldyBkYXNoYm9hcmRcblxuPiBbIXF1ZXN0aW9uXSBRdWVzdGlvbnNcbj4gLSBXaGF0IGFyZSB0aGUgYmVzdCBwcmFjdGljZXMgZm9yIGltcGxlbWVudGluZyBPQXV0aCAyLjAgaW4gU1BBcz9cbj4gLSBIb3cgY2FuIHdlIG9wdGltaXplIGVycm9yIGhhbmRsaW5nIGZvciBmYWlsZWQgYXV0aGVudGljYXRpb24/XG5cbj4gWyFidWddIEJ1Z3Ncbj4gLSBBUEkgcmV0dXJuZWQgNDAxIGVycm9yIGRlc3BpdGUgdmFsaWQgdG9rZW5cbj4gLSBEYXNoYm9hcmQgbG9hZGluZyBzcGlubmVyIG5vdCBkaXNhcHBlYXJpbmcgYWZ0ZXIgZmV0Y2hcblxuPiBbIW5vdGVdIFJlZmxlY3Rpb25cbj4gLSBQcm9ncmVzcyB3YXMgc2xvd2VyIHRoYW4gZXhwZWN0ZWQgZHVlIHRvIG11bHRpcGxlIGRlYnVnZ2luZyBzZXNzaW9ucy5cbmAsXG5cbiAgYCoqRXhhbXBsZSAyOiBQZXJzb25hbCBQcm9kdWN0aXZpdHkgTG9nKipcblxuIyBcdUQ4M0RcdURDREQgRGFpbHkgTm90ZTogTWF5IDExLCAyMDI1XG5cbj4gWyFhYnN0cmFjdF0gU3VtbWFyeVxuXG5UaGUgZGF5IGNlbnRlcmVkIG9uIHBlcnNvbmFsIG9yZ2FuaXphdGlvbiwgaW5jbHVkaW5nIGRlY2x1dHRlcmluZyBteSB3b3Jrc3BhY2UgYW5kIHNjaGVkdWxpbmcgdXBjb21pbmcgYXBwb2ludG1lbnRzLiBQbGFubmVkIHRhc2tzIGluY2x1ZGUgdXBkYXRpbmcgbXkgY2FsZW5kYXIgYW5kIGZpbmFsaXppbmcgdGhlIGdyb2Nlcnkgc2hvcHBpbmcgbGlzdC4gQWRkaXRpb25hbCBub3RlcyBmb2N1cyBvbiByZXNlYXJjaGluZyBtaW5pbWFsaXNtIHRlY2huaXF1ZXMuXG5cbnRhZ3M6ICNvcmdhbml6YXRpb24gI21pbmltYWxpc20gI2NhbGVuZGFyICNncm9jZXJpZXMgI3dvcmtzcGFjZVxuXG4+IFshdG9kb10gVG9kb1xuPiAtIFVwZGF0ZSBjYWxlbmRhciB3aXRoIG1lZGljYWwgYW5kIHdvcmsgYXBwb2ludG1lbnRzXG4+IC0gRmluYWxpemUgZ3JvY2VyeSBzaG9wcGluZyBsaXN0XG4+IC0gU29ydCBkaWdpdGFsIGZpbGVzIG9uIGxhcHRvcFxuXG4+IFshdGlwXSBUaXBzXG4+IC0gQnJlYWsgZG93biBkZWNsdXR0ZXJpbmcgdGFza3MgaW50byAxNS1taW51dGUgc2Vzc2lvbnMuXG4+IC0gVXNlIGEgc2luZ2xlIGluYm94IHN5c3RlbSBmb3IgYm90aCBkaWdpdGFsIGFuZCBwaHlzaWNhbCBwYXBlcndvcmsuXG5cbj4gWyFxdWVzdGlvbl0gUXVlc3Rpb25zXG4+IC0gV2hhdCBhcmUgZWZmZWN0aXZlIG1pbmltYWxpc20gc3RyYXRlZ2llcyBmb3Igc21hbGwgbGl2aW5nIHNwYWNlcz9cbj4gLSBCZXN0IGFwcHMgZm9yIHRhc2sgYW5kIGNhbGVuZGFyIGludGVncmF0aW9uP1xuXG4+IFshbm90ZV0gUmVmbGVjdGlvblxuPiAtIERlY2x1dHRlcmluZyBteSB3b3Jrc3BhY2Ugbm90aWNlYWJseSBib29zdGVkIG15IGZvY3VzIHRvZGF5LlxuYCxcblxuICBgKipFeGFtcGxlIDM6IFJlc2VhcmNoICsgTGVhcm5pbmcgTm90ZSoqXG5cbiMgXHVEODNEXHVEQ0REIERhaWx5IE5vdGU6IE1heSAxMiwgMjAyNVxuXG4+IFshYWJzdHJhY3RdIFN1bW1hcnlcblxuVG9kYXlcdTIwMTlzIHN0dWR5IHNlc3Npb24gZXhwbG9yZWQgZGlzdHJpYnV0ZWQgbGVkZ2VyIHRlY2hub2xvZ2llcywgd2l0aCBhIGZvY3VzIG9uIGNvbXBhcmluZyBibG9ja2NoYWluIGFuZCBEQUcgYXJjaGl0ZWN0dXJlcy4gVXBjb21pbmcgdGFza3MgaW5jbHVkZSByZXZpZXdpbmcgdGhlIElPVEEgd2hpdGVwYXBlciBhbmQgc3VtbWFyaXppbmcga2V5IGRpZmZlcmVuY2VzLiBPcGVuIHF1ZXN0aW9ucyB0YXJnZXQgc2VjdXJpdHkgbW9kZWxzIGFuZCBzY2FsYWJpbGl0eSBjb25jZXJucy5cblxudGFnczogI2Jsb2NrY2hhaW4gI2RhZyAjaW90YSAjZGlzdHJpYnV0ZWQtc3lzdGVtcyAjc2NhbGFiaWxpdHlcblxuPiBbIXRvZG9dIFRvZG9cbj4gLSBSZXZpZXcgdGhlIElPVEEgd2hpdGVwYXBlclxuPiAtIERyYWZ0IGEgc3VtbWFyeSBjb21wYXJpbmcgYmxvY2tjaGFpbiB2cyBEQUdcbj4gLSBFeHBsb3JlIHJlYWwtd29ybGQgYXBwbGljYXRpb25zIG9mIERBR3NcblxuPiBbIXF1ZXN0aW9uXSBRdWVzdGlvbnNcbj4gLSBIb3cgZG8gREFHcyBpbXByb3ZlIHNjYWxhYmlsaXR5IG92ZXIgdHJhZGl0aW9uYWwgYmxvY2tjaGFpbnM/XG4+IC0gV2hhdCBhcmUgdGhlIHNlY3VyaXR5IHRyYWRlLW9mZnMgYmV0d2VlbiBibG9ja2NoYWluIGFuZCBEQUc/XG5cbj4gWyFleGFtcGxlXSBSZWZlcmVuY2VzXG4+IC0gSU9UQSBXaGl0ZXBhcGVyOiBodHRwczovL3d3dy5pb3RhLm9yZy9yZXNlYXJjaC93aGl0ZXBhcGVyXG4+IC0gQXJ0aWNsZTogXCJEQUcgdnMgQmxvY2tjaGFpblwiIG9uIE1lZGl1bVxuXG4+IFshbm90ZV0gUmVmbGVjdGlvblxuPiAtIERBR3Mgc2VlbSBwcm9taXNpbmcgZm9yIElvVCB1c2UgY2FzZXMgYnV0IHJhaXNlIG5ldyBzZWN1cml0eSBjaGFsbGVuZ2VzLlxuYFxuXTtcblxuLy8gNVx1RkUwRlx1MjBFMyBCdWlsZCB0aGUgZmluYWwgcHJvbXB0XG5leHBvcnQgY29uc3QgU1lTVEVNX1BST01QVF9PUkdBTklaRVIgPSBgXG4ke0lOU1RSVUNUSU9OU31cblxuJHtGT1JNQVRUSU5HX1JVTEVTfVxuXG4ke0lNUE9SVEFOVF9OT1RFU31cblxuLS0tXG5cbiR7RVhBTVBMRVMuam9pbignXFxuXFxuLS0tXFxuXFxuJyl9XG5cbi0tLVxuXG5SZXR1cm4gY2xlYW4gT2JzaWRpYW4gbWFya2Rvd24gb25seS5cbmA7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLDhDQUFBQSxTQUFBO0FBQUE7QUFDQSxJQUFBQSxRQUFPLFVBQVUsU0FBVSxLQUFLLEtBQUs7QUFDcEMsVUFBSSxPQUFPLFFBQVEsVUFBVTtBQUM1QixjQUFNLElBQUksVUFBVSxtQkFBbUI7QUFBQSxNQUN4QztBQUVBLFlBQU0sT0FBTyxRQUFRLGNBQWMsTUFBTTtBQUV6QyxhQUFPLElBQ0wsUUFBUSxxQkFBcUIsT0FBTyxNQUFNLElBQUksRUFDOUMsUUFBUSw0QkFBNEIsT0FBTyxNQUFNLElBQUksRUFDckQsWUFBWTtBQUFBLElBQ2Y7QUFBQTtBQUFBOzs7QUNaQTtBQUFBLDZDQUFBQyxTQUFBO0FBQUE7QUFFQSxRQUFNLFlBQVk7QUFDbEIsUUFBTSxZQUFZO0FBQ2xCLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sYUFBYTtBQUNuQixRQUFNLGFBQWE7QUFFbkIsUUFBTSxxQkFBcUIsSUFBSSxPQUFPLE1BQU0sV0FBVyxNQUFNO0FBQzdELFFBQU0sNEJBQTRCLElBQUksT0FBTyxXQUFXLFNBQVMsV0FBVyxRQUFRLElBQUk7QUFDeEYsUUFBTSx5QkFBeUIs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Q1IsUUFBUSxDQUFDLEdBQUcsS0FBSyxLQUFLLFFBQVEsS0FBSztBQUFBLElBQ3ZDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxNQUFNLFNBQVM7QUFDWCxXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sU0FBUyxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzNFO0FBQUEsRUFDQSxJQUFJLFNBQVM7QUFDVCxXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sT0FBTyxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQ3pFO0FBQUEsRUFDQSxNQUFNLFNBQVM7QUFDWCxXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sU0FBUyxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzNFO0FBQUEsRUFDQSxLQUFLLFNBQVM7QUFDVixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sUUFBUSxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzFFO0FBQUEsRUFDQSxPQUFPLFNBQVM7QUFDWixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sVUFBVSxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzVFO0FBQUEsRUFDQSxLQUFLLFNBQVM7QUFDVixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sUUFBUSxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzFFO0FBQUEsRUFDQSxNQUFNLFNBQVM7QUFDWCxXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sU0FBUyxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzNFO0FBQUEsRUFDQSxLQUFLLFNBQVM7QUFDVixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sUUFBUSxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzFFO0FBQUEsRUFDQSxPQUFPLFNBQVM7QUFDWixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sVUFBVSxHQUFHLFVBQVUsU0FB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QUNBLElBQUksVUFBVTtBQUNWLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxPQUFPO0FBQUEsRUFDOUQ7QUFBQSxFQUNBLElBQUksU0FBUztBQUNULFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDN0Q7QUFBQSxFQUNBLElBQUksV0FBVztBQUNYLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxRQUFRO0FBQUEsRUFDL0Q7QUFBQSxFQUNBLElBQUksU0FBUztBQUNULFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDN0Q7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxPQUFPO0FBQUEsRUFDOUQ7QUFBQSxFQUNBLElBQUksU0FBUztBQUNULFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDN0Q7QUFBQSxFQUNBLElBQUksT0FBTztBQUNQLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxJQUFJO0FBQUEsRUFDM0Q7QUFBQSxFQUNBLElBQUksU0FBUztBQUNULFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDN0Q7QUFBQSxFQUNBLElBQUksV0FBVztBQUNYLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxRQUFRO0FBQUEsRUFDL0Q7QUFBQSxFQUNBLElBQUksY0FBYztBQUVkLFdBQU8sQ0FBQyxDQUFDLEtB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TSxJQUFLLEVBQUksSUFDMUIsVUFBVSxLQUFLLEVBQUksSUFDbkIsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxJQUFLLEVBQUksSUFDMUIsVUFBVyxNQUFNLElBQUssRUFBSSxJQUMxQixVQUFVLEtBQUssRUFBSSxJQUNuQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLElBQUssRUFBSSxJQUMxQixVQUFXLE1BQU0sSUFBSyxFQUFJLElBQzFCLFVBQVUsS0FBSyxFQUFJLElBQ25CLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sSUFBSyxFQUFJLElBQzFCLFVBQVcsTUFBTSxJQUFLLEVBQUksSUFDMUIsVUFBVSxLQUFLLEVBQUksSUFDbkIsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxJQUFLLEVBQUksSUFDMUIsVUFBVyxNQUFNLElBQUssRUFBSSxJQUMxQixVQUFVLEtBQUssRUFBSTtBQUMzQjtBQUNBLEtBQUssVUFBVSxXQUFXLEtBQUssVUFBVTtBQUN6QyxLQUFLLFVBQVUsU0FB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SUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLLCtCQUErQjtBQUNsQyxhQUFPO0FBQUEsSUFDVDtBQUFBLElBQ0EsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSywwQkFBMEI7QUFDN0IsYUFBTztBQUFBLElBQ1Q7QUFBQSxJQUNBLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNM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QUFRLElBQUksUUFBUSx1Q0FBdUM7QUFDM0Q7QUFBQSxNQUNGO0FBQ0EsWUFBTSxJQUFJLE1BQU0sT0FBTyxhQUFhLGdCQUFnQjtBQUNwRCxVQUFJLHdCQUFPLG1DQUFtQyxhQUFhO0FBQUEsSUFDN0QsQ0FBQztBQUFBLEVBQ0wsQ0FBQztBQUNIOzs7QUQxQkEsSUFBTSxtQkFBcUM7QUFBQSxFQUMxQyxXQUFXO0FBQ1o7QUFFQSxJQUFxQixXQUFyQixjQUFzQyx3QkFBTztBQUFBLEVBRzVDLE1BQU0sU0FBUztBQUNkLFVBQU0sS0FBSyxhQUFhO0FBQ3hCLFNBQUssSUFBSSxVQUFVLGNBQWMsTUFBTTtBQUFBLElBRXZDLENBQUM7QUFHRCxTQUFLLFdBQVc7QUFBQSxNQUNmLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsTUFBTTtBQUNmLDhCQUFzQixLQUFLLEdBQUc7QUFBQSxNQUMvQjtBQUFBLElBQ0QsQ0FBQztBQUFBLEVBRUY7QUFBQSxFQUVBLFdBQVc7QUFBQSxFQUNYO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDcEIsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ2xDO0FBQ0Q7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJtb2R1bGUiLCAiY2FtZWxDYXNlIiwgIm1vZHVsZSIsICJzZWxmIiwgIm1ldGhvZHMiLCAib3JpZ2luYWwiLCAicmVxdWlyZV9yZXRyeSIsICJtb2R1bGUiLCAibW9kdWxlIiwgInBSZXRyeSIsICJlcnJvciIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgImNvZXJjZSIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiY2FjaGUiLCAidmVyc2lvbiIsICJ6IiwgIm1vZHVsZSIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJ2ZXJzaW9uIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJyZXF1aXJlX3ZhbGlkIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAibW9kdWxlIiwgImNvbXBhcmUiLCAidmVyc2lvbiIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJyZXF1aXJlX3NlbXZlciIsICJtb2R1bGUiLCAiY29tcGFyZSIsICJjb2VyY2UiLCAibW9kdWxlIiwgInN0eWxlcyIsICJsZW4iLCAiYXJyIiwgImkiLCAibGVuMiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInNuYWtlQ2FzZSIsICJyb290IiwgIm9iaiIsICJ0b29sQ2FsbHMiLCAidXRpbCIsICJhcnIiLCAib2JqZWN0VXRpbCIsICJlcnJvclV0aWwiLCAiZXJyb3JNYXAiLCAicmVnZXgiLCAidmVyc2lvbiIsICJiYXNlNjQiLCAiY3R4IiwgInJlc3VsdCIsICJpc3N1ZXMiLCAiZWxlbWVudHMiLCAicHJvY2Vzc2VkIiwgInIiLCAiX2EiLCAiX2IiLCAiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIiwgImltcG9ydF9wX3JldHJ5IiwgImFyciIsICJQUXVldWVNb2QiLCAicFJldHJ5IiwgImF0dGFjaG1lbnRzIiwgImRhdGFzZXRJZF8iLCAiZGF0YXNldE5hbWVfIiwgInJlc3BvbnNlIiwgImV4YW1wbGVzIiwgInZhbHVlIiwgImNsaWVudCIsICJ2YWxpZGF0ZSIsICJrZXlzIiwgImkiLCAiYXJyIiwgInZhbGlkYXRlIiwgImlzQnJvd3NlciIsICJpc1dlYldvcmtlciIsICJpc0pzRG9tIiwgImlzRGVubyIsICJpc05vZGUiLCAiZ2V0RW52IiwgInJ1bnRpbWVFbnZpcm9ubWVudCIsICJnZXRSdW50aW1lRW52aXJvbm1lbnQiLCAiZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSIsICJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwgIm1ldGhvZHMiLCAic3RyaXBOb25BbHBoYW51bWVyaWMiLCAiY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQiLCAiZWxhcHNlZCIsICJzdHlsZXMiLCAiYXJyIiwgImdldEVudmlyb25tZW50VmFyaWFibGUiLCAiY2xpZW50IiwgImdldEVudmlyb25tZW50VmFyaWFibGUiLCAiZ2V0UnVudGltZUVudmlyb25tZW50IiwgInF1ZXVlIiwgImlkIiwgImltcG9ydF9wX3F1ZXVlIiwgIlRSQUNJTkdfQUxTX0tFWSIsICJQUXVldWVNb2QiLCAiaXNUcmFjaW5nRW5hYmxlZCIsICJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwgImVyciIsICJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwgImlzVHJhY2luZ0VuYWJsZWQiLCAiTW9ja0FzeW5jTG9jYWxTdG9yYWdlIiwgIm1vY2tBc3luY0xvY2FsU3RvcmFnZSIsICJBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyIiwgIkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24iLCAiQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiIsICJidWZmZXIiLCAiQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiIsICJfYSIsICJfYSIsICJpbXBvcnRfcF9yZXRyeSIsICJpbXBvcnRfcF9xdWV1ZSIsICJTVEFUVVNfTk9fUkVUUlkiLCAiQXN5bmNDYWxsZXIiLCAiUFF1ZXVlTW9kIiwgInBSZXRyeSIsICJfYSIsICJkZWZhdWx0T3B0aW9ucyIsICJlbW9qaVJlZ2V4IiwgInJlZ2V4IiwgIl9hIiwgInR5cGVzIiwgIngiLCAiYmFzZSIsICJuYW1lIiwgInNjaGVtYSIsICJfYSIsICJzdHlsZXMiLCAiY29sb3IiLCAiZWRnZXMiLCAiZW5jb2RlciIsICJBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIiwgIl9jb2VyY2VUb0RpY3QiLCAiY2FsbGVyIiwgIkFzeW5jQ2FsbGVyIiwgIl9hIiwgInN0YXRlIiwgInBSZXRyeSIsICJyZXN1bHQiLCAiQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiIsICJfY29lcmNlVG9EaWN0IiwgIkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24iLCAiYmxvY2tzIiwgIl9fZGVmUHJvcCIsICJfX2RlZk5vcm1hbFByb3AiLCAiX19wdWJsaWNGaWVsZCIsICJiYXNlNjQiLCAiX19wdWJsaWNGaWVsZCIsICJBc3luY0NhbGxlciIsICJjYWNoZSIsICJBc3luY0NhbGxlciIsICJpbnB1dCIsICJfYSIsICJfYiIsICJjYWNoZSIsICJyZXN1bHQiLCAiY29uZmlnIiwgIkhlYWRlcnMiLCAiZmV0Y2giLCAiZmV0Y2giLCAiX19kZWZQcm9wIiwgIl9fZGVmTm9ybWFsUHJvcCIsICJfX3B1YmxpY0ZpZWxkIiwgIk91dHB1dEZvcm1hdCIsICJpbnB1dCIsICJvcHRpb25zIiwgImNvbmZpZyJdCn0K
